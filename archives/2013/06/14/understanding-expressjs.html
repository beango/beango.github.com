
<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7 ie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8 ie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9 ie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>(译)深入理解Express.js</title>
	<meta property='og:locale' content='zh_CN'/>
	<meta property='og:title' content='(译)深入理解Express.js'/>
	<meta property='og:url' content='http://www.yif1.com'/>
	<meta property='og:site_name' content='程序员 - 博客 - HuangDing'/>
	<meta property='og:type' content='article'/>
	<link href='/assets/themes/the-program/css/style.css' rel="stylesheet" media="all" />
	<link href='/assets/default.css' rel="stylesheet" media="all" />
	<link href="/assets/highlight/google-code-prettify/prettify.css" rel="stylesheet" type="text/css" media="all">
	<style type="text/css" media="all">
	@import "/assets/thickbox.css";
	</style>
</head>
<body>

<div id="page" class="hentry">
	<header class="the-header">
		<div class="unit-head">
			<div class="unit-inner unit-head-inner">
				<nav class="nav-global">
					<ul>
						<li class="logo"><a href="/">HuangDing</a></li>
						<li class="code"><a href="/code.html">code</a></li>
						<li class="archive"><a href="/archive.html">archive</a></li>
						<li class="about"><a href="/info.html">about</a></li>
					</ul>
				</nav>
				<nav id="sub-nav" class="alignright">
					<div class="social">
					<a class="rss" href="/atom.xml" title="RSS">RSS</a>
					</div>
					<form class="search" action="http://google.com/search" method="get">
						<input class="" type="text" name="q">
						<input type="hidden" name="q" value="site:http://www.yif1.com">
					</form>
				</nav>
				
				<nav id="nav-tags">
					<ul id="wordcloud-left" style="list-style: square outside none; margin: 16px 0px; padding: 0px; position: static; width: 248px; ">
					    
					  


  
     
    	<li value="2" title="浏览器"><a href="/tags.html#浏览器-ref">浏览器</a></li>
     
    	<li value="1" title="stackOverflow"><a href="/tags.html#stackOverflow-ref">stackOverflow</a></li>
     
    	<li value="2" title="架构分析"><a href="/tags.html#架构分析-ref">架构分析</a></li>
     
    	<li value="1" title="职场"><a href="/tags.html#职场-ref">职场</a></li>
     
    	<li value="11" title="mongodb"><a href="/tags.html#mongodb-ref">mongodb</a></li>
     
    	<li value="2" title="jquery"><a href="/tags.html#jquery-ref">jquery</a></li>
     
    	<li value="10" title="javascript"><a href="/tags.html#javascript-ref">javascript</a></li>
     
    	<li value="8" title="nginx"><a href="/tags.html#nginx-ref">nginx</a></li>
     
    	<li value="3" title="linux"><a href="/tags.html#linux-ref">linux</a></li>
     
    	<li value="4" title="memcached"><a href="/tags.html#memcached-ref">memcached</a></li>
     
    	<li value="1" title="markdown"><a href="/tags.html#markdown-ref">markdown</a></li>
     
    	<li value="6" title="redis"><a href="/tags.html#redis-ref">redis</a></li>
     
    	<li value="2" title="tokyo tyrant"><a href="/tags.html#tokyo tyrant-ref">tokyo tyrant</a></li>
     
    	<li value="8" title="java"><a href="/tags.html#java-ref">java</a></li>
     
    	<li value="1" title="tcrmgr"><a href="/tags.html#tcrmgr-ref">tcrmgr</a></li>
     
    	<li value="1" title="windows8"><a href="/tags.html#windows8-ref">windows8</a></li>
     
    	<li value="1" title="缓存"><a href="/tags.html#缓存-ref">缓存</a></li>
     
    	<li value="6" title=".net"><a href="/tags.html#.net-ref">.net</a></li>
     
    	<li value="1" title="json"><a href="/tags.html#json-ref">json</a></li>
     
    	<li value="1" title="jsonp"><a href="/tags.html#jsonp-ref">jsonp</a></li>
     
    	<li value="1" title="内存泄露"><a href="/tags.html#内存泄露-ref">内存泄露</a></li>
     
    	<li value="4" title="cache"><a href="/tags.html#cache-ref">cache</a></li>
     
    	<li value="2" title="集群"><a href="/tags.html#集群-ref">集群</a></li>
     
    	<li value="2" title="uml"><a href="/tags.html#uml-ref">uml</a></li>
     
    	<li value="5" title="python"><a href="/tags.html#python-ref">python</a></li>
     
    	<li value="1" title="站着编程"><a href="/tags.html#站着编程-ref">站着编程</a></li>
     
    	<li value="2" title="互联网协议"><a href="/tags.html#互联网协议-ref">互联网协议</a></li>
     
    	<li value="1" title="jekyll"><a href="/tags.html#jekyll-ref">jekyll</a></li>
     
    	<li value="3" title="nosql"><a href="/tags.html#nosql-ref">nosql</a></li>
     
    	<li value="2" title="node.js"><a href="/tags.html#node.js-ref">node.js</a></li>
     
    	<li value="2" title="rabbitmq"><a href="/tags.html#rabbitmq-ref">rabbitmq</a></li>
     
    	<li value="1" title="centos"><a href="/tags.html#centos-ref">centos</a></li>
     
    	<li value="1" title="php"><a href="/tags.html#php-ref">php</a></li>
     
    	<li value="1" title="mysql"><a href="/tags.html#mysql-ref">mysql</a></li>
     
    	<li value="1" title="框架"><a href="/tags.html#框架-ref">框架</a></li>
     
    	<li value="1" title="http状态码"><a href="/tags.html#http状态码-ref">http状态码</a></li>
     
    	<li value="1" title="bson"><a href="/tags.html#bson-ref">bson</a></li>
     
    	<li value="1" title="优化"><a href="/tags.html#优化-ref">优化</a></li>
     
    	<li value="1" title="计算机"><a href="/tags.html#计算机-ref">计算机</a></li>
     
    	<li value="5" title="程序员"><a href="/tags.html#程序员-ref">程序员</a></li>
     
    	<li value="1" title="css"><a href="/tags.html#css-ref">css</a></li>
     
    	<li value="2" title="spring"><a href="/tags.html#spring-ref">spring</a></li>
     
    	<li value="1" title="Web架构"><a href="/tags.html#Web架构-ref">Web架构</a></li>
     
    	<li value="1" title="分布式系统"><a href="/tags.html#分布式系统-ref">分布式系统</a></li>
     
    	<li value="1" title="Iperf"><a href="/tags.html#Iperf-ref">Iperf</a></li>
     
    	<li value="1" title="Siege"><a href="/tags.html#Siege-ref">Siege</a></li>
     
    	<li value="1" title="SQL"><a href="/tags.html#SQL-ref">SQL</a></li>
     
    	<li value="1" title="jvm"><a href="/tags.html#jvm-ref">jvm</a></li>
     
    	<li value="1" title="varnish"><a href="/tags.html#varnish-ref">varnish</a></li>
    
  



					</ul>
				</nav>
			</div><!-- unit-inner -->
		</div><!-- unit-head -->
	</header>
	<div class="body" role="main">
		<div class="unit-body">
			<div class="unit-inner unit-body-inner">
				<div class="entry-content">
					
<article class="unit-article layout-post">
	<div class="unit-inner unit-article-inner">
		<div class="content">
			<header>
				<div class="unit-head">
					<div class="unit-inner unit-head-inner">
						<h1 class="h2 entry-title">(译)深入理解Express.js</h1>
					</div><!-- unit-inner -->
				</div><!-- unit-head -->
			</header>

			<div class="bd">
				<div class="entry-content">
					<p>本文针对那些对<a href="http://nodejs.org">Node.js</a>有一定了解的读者。假设你已经知道如何运行Node代码，使用npm安装依赖模块。但我保证，你并不需要是这方面的专家。本文针对的是Express 3.2.5版 ​​本，以介绍相关概念为主。</p>

<p><a href="http://expressjs.org">Express.js</a>这么描述自己："轻量灵活的node.js Web应用框架"。它可以帮助你快速搭建web应用。如果你使用过Ruby里的<a href="http://www.sinatrarb.com/">Sinatra</a>,那么相信你对这个也会很快就能熟悉。</p>

<p>和其他web框架一样，Express隐藏了代码背后的秘密，然后告诉你："别担心，你不用去理解这个部分"。它来帮你解决这些问题，所以你不用去为这个而烦恼，只用将重心集中到代码上。换句话说，它有某些魔法！</p>

<p><a href="http://expressjs.com/applications.html">Express的wiki里介绍了一些它的使用者</a>，其中就有很多知名的公司:MySpace, Klout.</p>

<p>但是<a href="http://shapeshed.com/all-magic-comes-with-a-price/">拥有魔力是需要付出代价的</a>，你可能根本就不知道它的工作原理。正如驾驶一辆汽车，我可以很好的驾驭它但是可能不理解为什么汽车可以正常工作，但是我最好知道这些东西。如果车坏掉怎​​么办？如果你想最大程度的去发挥它的性能？如果你对知识有无限的渴望并想去弄清它？</p>

<p>那么我么首先从理解Express的最底层-Node开始。</p>

<h2>底层：Node HTTP服务器</h2>

<p>Node中有<a href="http://nodejs.org/api/http.html">HTTP模块</a>,它将搭建一个web服务器的过程抽象出来。你可以这样使用:</p>

<pre><code>// 引入所需模块
var http = require("http");

// 建立服务器
var app = http.createServer(function(request, response) {
    response.writeHead(200, {
        "Content-Type": "text/plain"    
    });
    response.end("Hello world!\n");
});

// 启动服务器
app.listen(1337, "localhost");
console.log("Server running at http://localhost:1337/");
</code></pre>

<p>运行这个程序(假设文件名 ​​为<code>app.js</code> ,运行<code>node app.js</code> )，你会得到"Hello world!“在浏览器访问<code>localhost:1337</code>，你会得到同样的结果。你也可以尝试访问其他地址，如<code>localhost:1337/whatever</code>，结果仍然会一样。</p>

<p>分解以上代码来看。</p>

<p>第一行使用<code>require</code>函数引入Node内置模块<code>http</code>。然后存入名为<code>http</code>的变量中。如果你要了解更多关于require函数的知识，参考<a href="http://docs.nodejitsu.com/articles/getting-started/what-is-require">Nodejitsu</a>的文档。</p>

<p>然后我们使用<code>http.createServer</code>将服务器保存至<code>app</code>变量。它将一个函数作为参数监听请求。稍后将会详细介绍它。</p>

<p>最后我们要做的就是告诉服务器监听来自1337端口的请求，之后输出结果。然后一切完成。</p>

<p>好的，回到request请求处理函数。这个函数相当重要。</p>

<p><strong>request方法</strong></p>

<p>在开始这个部分之前，我事先声明这里所涉及的HTTP相关知识与学习Express本身没有太大关系。如果你感兴趣，可以查看<a href="http://nodejs.org/api/http.html">HTTP模块文档</a>。</p>

<p>任何时候我们向服务器发起请求，request方法将会被调用。如果你不信，你可以<code>console.log</code>将结果打印出来。你会发现每次请求一个页面时它都会出来。</p>

<p><code>request</code>是来自客户端的请求。在很多应用中，你可能会看到它的缩写<code>req</code>。仔细看代码。我们修改代码如下:</p>

<pre><code>var app = http.createServer(function(request, response) {

    // 创建answer变量
    var answer = "";
    answer += "Request URL: " + request.url + "\n";
    answer += "Request type: " + request.method + "\n";
    answer += "Request headers: " + JSON.stringify(request.headers) + "\n";

    // 返回结果
    response.writeHead(200, {"Content-Type": "text/plain" });
    response.end(answer);

});
</code></pre>

<p>重启服务器并刷新<code>localhsot:1337</code>.你会发现，每次访问一个URL，就会发起一次GET请求，并会得到一堆类似用户代理或者一些其他的更加复杂的HTTP相关信息。如果你访问<code>localhost:1337/what_is_fraser</code>,你会看到request的地址发生了变化。如果你使用不同的浏览器访问，用户代理也会跟着改变，如果你使用POST请求，request的方法也很改变。</p>

<p><code>response</code>是另外一个部分。正如<code>request</code>被缩写为<code>req</code>，<code>response</code>同样被简写为<code>res</code>。每次response你都会得到对应的返回结果，之后你便可以通过调用<code>response.end</code>来结束。实际上最终你还是要执行这个方法的,甚至在<a href="http://nodejs.org/api/http.html#http_response_end_data_encoding">node</a>的文档里也是这么描述的。这个方法完成了真正的数据传输部分。你可以建立一个服务器并不调用<code>req.end</code>方法，它就会永远存在。</p>

<p>在你返回结果之前，你也可以填写一下header头​​部部分。我们的例子里是这么写的:</p>

<pre><code>response.writeHead(200, { "Content-Type": "text/plain" });
</code></pre>

<p>这个步骤主要完成两件事情。第一，发送<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">HTTP状态码</a>，表示请求成功。其次，它设置了返回的头部信息。这里表示我们要返回的是纯文本格式的内容。我们也可以返回类似JSON或者HTML格式的内容。</p>

<p>未完待续。。。</p>

<p>// 接上回</p>

<p>看了上面的之后，你可能会立马开始利用它来写api了。</p>

<pre><code>var http = require("http");

http.createServer(function(req, res) {

    // Homepage
    if(req.url == "/") {
        res.writeHead(200, { "Content-Type": "text/html" });
        res.end("Welcome to the homepage!");
    }

    // About page
    else if (req.url == "/about") {
        res.writeHead(200, { "Content-Type": "text/html" });
        res.end("Welcome to the about page!");
    }

    // 404'd!
    else {
        res.writeHead(404, { "Content-Type": "text/plain" });
        res.end("404 error! File not found.");
    }

}).listen(1337, "localhost");
</code></pre>

<p>你可以选择优化代码，让它变得更整洁。也可以向<a href="https://github.com/isaacs/npm-www#design-philosophy">npm.org</a>的那帮家伙一样用原生的Node来编写。但是你也可以选择去创建一个框架。这就是Sencha所做的，并把这个框架称为–Connect.</p>

<h2>中间件: Connect</h2>

<p><a href="http://www.senchalabs.org/connect/">Connect</a>是Nodejs的中间件。可能你现在还并不太理解什么是中间件(middleware)，别担心，我马上会进行详细解释。</p>

<p><strong>一段Connect代码</strong></p>

<p>假如我们想要编写和上面一样的代码，但是这次我们要使用Connect.别忘记安装Connect模块( <code>npm install</code> )。完成之后，代码看起来非常相似。</p>

<pre><code>// 引入所需模块
var connect = require("connect");
var http = require("http");

// 建立app
var app = connect();

// 添加中间件
app.use(function(request, response) {
    response.writeHead(200, { "Content-Type": "text/plain" });
    response.end("Hello world!\n");
});

// 启动应用
http.createServer(app).listen(1337);
</code></pre>

<p>下面分解这段代码来看。</p>

<p>首先我们分别引入了Connect和Node HTTP模块。</p>

<p>接下来和之前一样声明<code>app</code>变量，但是在创建服务器时，我们调用了<code>connect()</code>.这有是如何工作的？</p>

<p>我们添加了一个中间件，实际上就是一个函数。传入<code>app.use</code>，几乎和上面使用request方法写法一样。实际上代码是从上面粘贴过来的。</p>

<p>之后我们建立并启动服务器。<code>http.createServer</code>接收函数作为参数。没错，<code>app</code>实际上也是一个函数。这是一个Connect提供的函数，它会查找代码并自上而下执行。</p>

<p>(你可能会看见其他人使用<code>app.listen(1337)</code>,这实际上只是将<code>http.createServer</code>返回一个promise对象。再Connect和Express中都是一样的原理。)</p>

<p>接下来解释什么是中间件(middleware).</p>

<p><strong>什么是中间件?</strong></p>

<p>首先推荐阅读<a href="http://stephensugden.com/middleware_guide/">Stephen Sugden对于Connect中间件的描述</a>,比我讲的更好。如果你不喜欢我的解释，那就去看看。</p>

<p>还记得之前的request方法？每个中间件都是一个handler.依次传入request, response, next三个参数。</p>

<p>一个最基本的中间件结构如下:</p>

<pre><code>function myFunMiddleware(request, response, next) {
    // 对request和response作出相应操作
    // 操作完毕后返回next()即可转入下个中间件
    next();
}
</code></pre>

<p>当我们启动一个服务器，函数开始从顶部一直往下执行。如果你想输出函数的执行过程，添加一下代码:</p>

<pre><code>var connect = require("connect");
var http = require("http");
var app = connect();

// log中间件
app.use(function(request, response, next) {
    console.log("In comes a " + request.method + " to " + request.url);
    next();
});

// 返回"hello world"
app.use(function(request, response, next) {
    response.writeHead(200, { "Content-Type": "text/plain" });
    response.end("Hello World!\n");
});

http.createServer(app).listen(1337);
</code></pre>

<p>如果你启动应用并访问<code>localhost:1337</code>，你会看到服务器可以log出相关信息。</p>

<p>有一点值得注意，任何可以在Node.js下执行的代码都可以在中间件执行。例如上面我们所使用的<code>req.method</code>方法。</p>

<p>你当然可以编写自己的中间件，但是也不要错过Connect的一些很cool的<a href="https://github.com/senchalabs/connect/wiki">第三方中间件</a>。下面我们移除自己的log中间件，使用Connect内置方法。</p>

<pre><code>var connect = require("connect");
var http = require("http");
var app = connect();

app.use(connect.logger());
// 一个有趣的事实：connect.logger返回一个函数

app.use(function(request, response) {
    response.writeHead(200, { "Content-Type": "text/plain" });
    response.end("Hello world!\n");
});

http.createServer(app).listen(1337);
</code></pre>

<p>跳转至浏览器并访问<code>localhost:1337</code>你会得到同样的结果。</p>

<p>很快有人就会想使用上面的中间件组合起来创建一个完整应用。代码如下:</p>

<pre><code>var connect = require("connect");
var http = require("http");
var app = connect();

app.use(connect.logger());

// Homepage
app.use(function(request, response, next) {
    if (request.url == "/") {
        response.writeHead(200, { "Content-Type": "text/plain" });
        response.end("Welcome to the homepage!\n");
        // The middleware stops here.
    } else {
        next();
    }
});

// About page
app.use(function(request, response, next) {
    if (request.url == "/about") {
        response.writeHead(200, { "Content-Type": "text/plain" });
        response.end("Welcome to the about page!\n");
        // The middleware stops here.
    } else {
        next();
    }
});

// 404'd!
app.use(function(request, response) {
    response.writeHead(404, { "Content-Type": "text/plain" });
    response.end("404 error!\n");
});

http.createServer(app).listen(1337);
</code></pre>

<p>“这个看起来不太好看!我要自己写框架！”</p>

<p>某些人看了Connect的代码之后觉得，“这个代码可以更简单”。于是他们创造了Express.（事实上他们好像直接盗用了<a href="http://www.sinatrarb.com/">Sinatra</a>.）</p>

<h2>最顶层: Express</h2>

<p>文章进入第三部分，我们开始真正进入Express.</p>

<p>正如Connect拓展了Node, Express拓展Connect.代码的开始部分看起来和在Connect中非常类似：</p>

<pre><code>var express = require("express");
var http = require("http");
var app = express();
</code></pre>

<p>结尾部分也一样:</p>

<pre><code>http.createServer(app).listen(1337);
</code></pre>

<p>中间部分才是不一样的地方。Connect为我们提供了中间件，Express则为我们提供了另外三个优秀的特性：路由分发，请求处理，视图渲染。首先从如有开始看。</p>

<h3>特性一：路由</h3>

<p>路由的功能就是处理不同的请求。在上面的很多例子中，我们分别有首页，关于和404页面。我们是通过<code>if</code>来判断并处理不同请求地址。</p>

<p>但是Express却可以做的更好。Express提供了"routing"这个东西，也就是我们所说的路由。我觉得可读性甚至比纯文字还要好。</p>

<pre><code>var express = require("express");
var http = require("http");
var app = express();

app.all("*", function(request, response, next) {
    response.writeHead(404, { "Content-Type": "text/plain" });
    next();
});

app.get("/", function(request, response) {
    response.end("Welcome to the homepage!");
});

app.get("/about", function(request, response) {
    response.end("Welcome to the about page!");
});

app.get("*", function(request, response) {
    response.end("404!");
});

http.createServer(app).listen(1337);
</code></pre>

<p>简单的引入相关模块之后，我们立即调用<code>app.all</code>处理所有请求。写法看起来也非常像中间件不是吗？</p>

<p>代码中的<code>app.get</code>就是Express提供的路由系统。也可以是<code>app.post</code>来处理POST请求，或者是PUT和任何的HTTP请求方式。第一个参数是路径，例如<code>/about</code>或者<code>/</code>。第二个参数类似我们之前所见过的请求handler。引用<a href="http://expressjs.com/api.html#app.VERB">Expess文档的内容</a>:</p>

<blockquote><p>这些请求handler和中间件一样，唯一的区别是这些回调函数会调用<code>next('route')</code>从而能够继续执行剩下的路由回调函数。这种机制简单说来，它们和我们之前提过的中间件是一样，只不过是一些函数而已。</p></blockquote>

<p>这些路由也可以更加灵活，看起来是这样：</p>

<pre><code>app.get("/hello/:who", function(req, res) {
    res.end("Hello, " + req.params.who + ".");    
});
</code></pre>

<p>重启服务器并在浏览器访问<code>localhost:1337/hello/animelover69</code>你会得到如下信息：</p>

<pre><code>Hello, animelover69.
</code></pre>

<p><a href="http://expressjs.com/api.html#app.VERB">这些文档</a>演示了如何使用正则表达式，可以使得路由更加灵活。如果只是单从概念理解来讲，我说的已经足够了。</p>

<p>但是还有更加值得我们去关注的。</p>

<h3>特性二：请求处理request handling</h3>

<p>Express将你传入请求的handler传入request和response对象中。原先该有的还在，但是却加入了更多新的特性。<a href="http://expressjs.com/api.html">API文档</a>里有详细解释。下面让我们来看一些例子。</p>

<p>其中一个就是<code>redirect</code>方法。代码如下：</p>

<pre><code>response.redirect("/hello/anime");
response.redirect("http://xvfeng.me");
response.redirect(301, "http://xvfeng.me"); // HTTP 301 状态码
</code></pre>

<p>以上代码既不属于原生Node代码也不是来自与Connect,而是Express中自身添加的。它加入了一些例如<code>sendFile</code>，让你传输整个文件等功能：</p>

<pre><code>response.sendFile("/path/to/anime.mp4");
</code></pre>

<p>request对象还有一些很cool的属性，例如<code>request.ip</code>可以获取IP地址,<code>request.files</code>上传文件等。</p>

<p>理论上来讲，我们要知道的东西也不是太多，Express做的只是拓展了request和response对象而已。Express所提供的方法，请参考<a href="http://expressjs.com/api.html">API文档</a>.</p>

<h3>特性三：视图</h3>

<p>Express可以渲染视图。代码如下：</p>

<pre><code>// 启动Express
var express = require("express");
var app = express();

// 设置view目录
app.set("views", __dirname + "/views");

// 设置模板引擎
app.set("view engine", "jade");
</code></pre>

<p>开头部分的代码和前面基本一样。之后我们指定视图文件所在目录。然后告诉Express我们要使用<code>Jade</code>作为模板引擎。<a href="http://jade-lang.com/">Jade</a>是一种模板语言。稍后将会详细介绍。</p>

<p>现在我们已经设置好了view.但是如何来使用它呢？</p>

<p>首先我们建立一个名为<code>index.jade</code>的文件并把它放入<code>views</code>目录。代码如下：</p>

<pre><code>doctype 5
html
  body
    h1 Hello, world!
    p= message
</code></pre>

<p>代码只是去掉了括号的HTML代码。如果你懂HTML那肯定也看得懂上面的代码。唯一有趣的是最后一样。<code>message</code>是一个变量。它是从哪里来的呢？马上告诉你。</p>

<p>我们需要从Express中渲染这个视图。代码如下：</p>

<pre><code>app.get("/", function(request, response) {
    response.render("index", { message: "I love anime" });    
});
</code></pre>

<p>Express为<code>response</code>对象添加了一个<code>render</code>方法。这个方法可以处理很多事情，但最主要的还是加载模板引擎和对应的视图文件，之后渲染成普通的HTML文档，例如这里的<code>index.jade</code>.</p>

<p>最后一步(我觉得可能算是第一步)就是安装Jade,因为它本身并不是Express的一部分。添加至<code>package.json</code>文件并使用<code>npm install</code>进行安装。</p>

<p>如果一起设置完毕，你会看到<a href="http://evanhahn.com/wp-content/uploads/2013/05/anime.html">这个页面</a>。<a href="https://gist.github.com/EvanHahn/5673968">完整代码</a>.</p>

<h3>加分特性： 所有代码来自于Connect和Node</h3>

<p>我需要再次提醒你的是Express建立与Connect和Node之上，这意味着所有的Connect中间件均可以在Express中使用。这个对与开发来讲帮助很大。例如：</p>

<pre><code>var express = require("express");
var app = express();

app.use(express.logger()); // 继承自Connect

app.get("/", function(req, res) {
    res.send("fraser");    
});

app.listen(1337);
</code></pre>

<p>如果说你从这篇文章中学到了一点什么，就是这一点。</p>

<h2>实战</h2>

<p>本文的大部分内容都是理论，但是下面我将教你如何使用它来做一点你想做的东西。我不想说的过于具体。</p>

<p>你可以将Exp​​ress安装到系统全局，从而可以在命令行使用它。它可以帮助你迅速的完成代码组织并启动应用。使用npm安装：</p>

<pre><code># 安装时可能需要加`sudo`
npm install -g express
</code></pre>

<p>如果你需要帮助，输入<code>express --help</code>。它加入一些可选参数。例如，如果你想使用EJS模板引擎，LESS作为CSS引擎。应用的名称为"myApp".输入以下命令：</p>

<pre><code>express --ejs --css less myApp
</code></pre>

<p>这里会自动生成很多文件。进入项目目录，并使用<code>npm install</code>安装依赖包，之后便可以使用<code>node app</code>启动应用！我建议你详细的查看项目结构和代码。它可能还算不上一个真正的应用，但是我觉得它对于初学者来讲还是很有帮助的。</p>

<p><a href="https://github.com/visionmedia/express/tree/master/examples">项目Github目录下</a>也有一些很有帮助的文档。</p>

<h3>一些补充</h3>

<ul>
<li>如果你也和我一样喜欢使用CoffeeScript，好消息是Express完美支持CoffeeScript.你甚至不需要编译它。这样你只用<code>coffee app.coffee</code>即可启动应用。我在我的其他项目中也是这么做的。</li>
<li>在我看到<code>app.use(app.router)</code>的时候我很疑惑：
Express不是一直在使用router吗？简单回答是<code>app.router</code>是Express的路由中间件，在你定义路由的时候被直接添加到项目中。如果你需要在加载其他文件之前应用，也可以直接引入它。关于这么做的原因，请参考<a href="http://stackoverflow.com/a/12695813/804100">StackOverflow的这个答案</a>.</li>
<li>本文是针对Express 3，而在<a href="https://github.com/visionmedia/express/wiki/4.x-roadmap">第四版的规划中</a>又会有很多大的改动。最明显的是，Experss可能要将会分解成一些小的模块，并吸收Connect的一些特性。这个虽然还在计划中，但是也值得一看。</li>
</ul>


<p>如果这个还不能满足你？你肯定是个变态！你很快就会变成像一个瘾君子，半睁着眼，耗尽你最后一点精力，写着苦逼的代码。</p>

<p>正如Rails成为使用Ruby建立网页应用的王者一样，我觉得Express也会成为Node中的主流。但是和Rails不一样，Express更加底层。似乎还没有一个真正意义上的高级Node库。我觉得可能会发生改变。（译者注：这点我不同意，Node的很多思想来自与Unix哲学，强调的是一个Module只解决一个问题，而不是成为一个复杂的库。很多Rails的开发者转向Node，就是因为Rails正在逐渐变得臃肿，不易自定义，且效率逐渐降低。）。</p>

<p>这里我就不再多谈。已经又很多很基于Express建立了新的东西，<a href="https://github.com/visionmedia/express/wiki#frameworks-built-with-express">Expess的维基</a>里有列举。如果你觉得好可以随意使用它们，如果你喜欢从底层做起，你也可以只选择Express。不管是哪一种，好好利用它吧。</p>

<p>原文地址：<a href="http://evanhahn.com/understanding-express-js/">http://evanhahn.com/understanding-express-js/</a></p>

<p>时间仓促，翻译错误在所难免，还请指正，转载还请注明。</p>

					<div class="meta asset-footer">
						<ul class="date-publish list-linear">
							<li>Published: </li>
							<li><date class="date-pub" title="2013-06-14" datetime="2013-06-14" pubdate>
							<span class="year">2013-06-14</span>
							</date></li>
						</ul>
						<ul class="list-tag list-linear">
							<li class="list-head">tags: </li>
							
							


  
     
    	<li value="2" title="node.js"><a href="/tags.html#node.js-ref">node.js</a></li>
    
  



						</ul>
						<ul class="list-tag list-linear">
							<li class="list-head" style="display:block;">版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">Creative Commons BY-NC-ND 3.0</a></li>
							<li class="list-head" style="display:block;">原文网址：<a href="http://xvfeng.me/posts/understanding-expressjs/" target="_blank">http://xvfeng.me/posts/understanding-expressjs/</a></li>

						</ul>
					</div><!-- meta -->
				</div><!-- entry-content -->
				<div class="misc-content">
					<div class="comment">
					


  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_developer = 1;
    var disqus_shortname = 'beango'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




					</div>
				</div><!-- misc-content -->
			</div><!-- bd -->

		</div><!-- content -->
	</div><!-- unit-inner -->
</article>

				</div>
			</div><!-- unit-inner -->
		</div><!-- unit-body -->
		<p class="licence">
			Theme: <a href="http://themes.jekyllbootstrap.com/">the_program</a> based on <a href="http://jekyllbootstrap.com/">Jekyll-bootstrap</a>.<br>
			Powered by <a href="https://github.com/mojombo/jekyll">Jekyll</a>.<!--<script src="http://s21.cnzz.com/stat.php?id=4827427&web_id=4827427&show=pic" language="JavaScript"></script>-->
		</p>
	</div><!-- body -->
</div><!-- page -->
<!--
<script>
/*! A fix for the iOS orientationchange zoom bug.Script by @scottjehl, rebound by @wilto. MIT License.*/
(function(j){var i=j.document;if(!i.querySelectorAll){return}var l=i.querySelectorAll("meta[name=viewport]")[0],a=l&&l.getAttribute("content"),h=a+", maximum-scale=1.0",d=a+", maximum-scale=10.0",g=true,c=j.orientation,k=0;if(!l){return}function f(){l.setAttribute("content",d);g=true}function b(){l.setAttribute("content",h);g=false}function e(m){c=Math.abs(j.orientation);k=Math.abs(m.gamma);if(k>8&&c===0){if(g){b()}}else{if(!g){f()}}}j.addEventListener("orientationchange",f,false);j.addEventListener("deviceorientation",e,false)})(this);
</script>
-->


<script src="http://libs.baidu.com/jquery/1.5.0/jquery.min.js"></script>
<script type="text/javascript" src="/assets/highlight/google-code-prettify/prettify.js"></script>
<script src="/assets/modernizr.min.js"></script>
<script src="/assets/jquery.tagcloud.min.js"></script>
<script src='/assets/default.js'></script>
<script src="/assets/thickbox-compressed.js" type="text/javascript"></script>
</body>
</html>

