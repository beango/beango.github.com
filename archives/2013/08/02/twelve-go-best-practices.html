
<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7 ie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8 ie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9 ie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>Go 语言 12 条最佳实践</title>
	<meta property='og:locale' content='zh_CN'/>
	<meta property='og:title' content='Go 语言 12 条最佳实践'/>
	<meta property='og:url' content='http://beango.github.com'/>
	<meta property='og:site_name' content='程序员 - 博客 - HuangDing'/>
	<meta property='og:type' content='article'/>
	<link href='/assets/themes/the-program/css/style.css' rel="stylesheet" media="all" />
	<link href='/assets/default.css' rel="stylesheet" media="all" />
	<link href="/assets/highlight/google-code-prettify/prettify.css" rel="stylesheet" type="text/css" media="all">
</head>
<body>

<div id="page" class="hentry">
	<header class="the-header">
		<div class="unit-head">
			<div class="unit-inner unit-head-inner">
				<nav class="nav-global">
					<ul>
						<li class="logo"><a href="/">HuangDing</a></li>
						<li class="code"><a href="/code.html">code</a></li>
						<li class="archive"><a href="/archive.html">archive</a></li>
						<li class="archive"><a href="/category.html">category</a></li>
						<li class="about"><a href="/info.html">about</a></li>
					</ul>
				</nav>
				<nav id="sub-nav" class="alignright">
					<div class="social">
					<a class="rss" href="/atom.xml" title="RSS">RSS</a>
					</div>
					<form class="search" action="http://google.com/search" method="get">
						<input class="" type="text" name="q">
						<input type="hidden" name="q" value="site:http://beango.github.com">
					</form>
				</nav>
			</div><!-- unit-inner -->
		</div><!-- unit-head -->
	</header>
	<div class="body" role="main">
		<div class="unit-body">
			<div class="unit-inner unit-body-inner">
				<div class="entry-content">
					
<article class="unit-article layout-post">
	<div class="unit-inner unit-article-inner">
		<div class="content">
			<header>
				<div class="unit-head">
					<div class="unit-inner unit-head-inner">
						<h1 class="h2 entry-title">Go 语言 12 条最佳实践</h1>
					</div><!-- unit-inner -->
				</div><!-- unit-head -->
			</header>

			<div class="bd">
				<div class="entry-content">
					<p>本文来自 Google 工程师 Francesc Campoy Flores 分享的幻灯片。内容包括：代码组织、API、并发最佳实践和一些推荐的相关资源。</p>

<h3>最佳实践</h3>

<p>维基百科的定义是：“最佳实践是一种方法或技术，其结果始终优于其他方式。”</p>

<p>写Go代码的目标就是：</p>

<ul>
<li>简洁</li>
<li>可读性强</li>
<li>可维护性好</li>
</ul>


<h3>样例代码</h3>

<p><label /></p>

<pre><code>type Gopher struct {
    Name     string
    Age      int32
    FurColor color.Color
}

func (g *Gopher) DumpBinary(w io.Writer) error {
    err := binary.Write(w, binary.LittleEndian, int32(len(g.Name)))
    if err == nil {
        _, err := w.Write([]byte(g.Name))
        if err == nil {
            err := binary.Write(w, binary.LittleEndian, g.Age)
            if err == nil {
                return binary.Write(w, binary.LittleEndian, g.FurColor)
            }
            return err
        }
        return err
    }
    return err
}
</code></pre>

<h3>避免嵌套的处理错误</h3>

<p><label /></p>

<pre><code>func (g *Gopher) DumpBinary(w io.Writer) error {
    err := binary.Write(w, binary.LittleEndian, int32(len(g.Name)))
    if err != nil {
        return err
    }
    _, err = w.Write([]byte(g.Name))
    if err != nil {
        return err
    }
    err = binary.Write(w, binary.LittleEndian, g.Age)
    if err != nil {
        return err
    }
    return binary.Write(w, binary.LittleEndian, g.FurColor)
}
</code></pre>

<p>减少嵌套意味着提高代码的可读性</p>

<h3>尽可能避免重复</h3>

<p>功能单一，代码更简洁</p>

<pre><code>type binWriter struct {
    w   io.Writer
    err error
}

// Write writes a value into its writer using little endian.
func (w *binWriter) Write(v interface{}) {
    if w.err != nil {
        return
    }
    w.err = binary.Write(w.w, binary.LittleEndian, v)
}

func (g *Gopher) DumpBinary(w io.Writer) error {
    bw := &amp;binWriter{w: w}
    bw.Write(int32(len(g.Name)))
    bw.Write([]byte(g.Name))
    bw.Write(g.Age)
    bw.Write(g.FurColor)
    return bw.err
}
</code></pre>

<h3>使用类型推断来处理特殊情况</h3>

<p><label /></p>

<pre><code>// Write writes a value into its writer using little endian.
func (w *binWriter) Write(v interface{}) {
    if w.err != nil {
        return
    }
    switch v.(type) {
    case string:
        s := v.(string)
        w.Write(int32(len(s)))
        w.Write([]byte(s))
    default:
        w.err = binary.Write(w.w, binary.LittleEndian, v)
    }
}

func (g *Gopher) DumpBinary(w io.Writer) error {
    bw := &amp;binWriter{w: w}
    bw.Write(g.Name)
    bw.Write(g.Age)
    bw.Write(g.FurColor)
    return bw.err
}
</code></pre>

<h3>类型推断的变量声明要短</h3>

<p><label /></p>

<pre><code>// Write write the given value into the writer using little endian.
func (w *binWriter) Write(v interface{}) {
    if w.err != nil {
        return
    }
    switch v := v.(type) {
    case string:
        w.Write(int32(len(v)))
        w.Write([]byte(v))
    default:
        w.err = binary.Write(w.w, binary.LittleEndian, v)
    }
}
</code></pre>

<h3>函数适配器</h3>

<p><label /></p>

<pre><code>func init() {
    http.HandleFunc("/", handler)
}

func handler(w http.ResponseWriter, r *http.Request) {
    err := doThis()
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        log.Printf("handling %q: %v", r.RequestURI, err)
        return
    }

    err = doThat()
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        log.Printf("handling %q: %v", r.RequestURI, err)
        return
    }
}

func init() {
    http.HandleFunc("/", errorHandler(betterHandler))
}

func errorHandler(f func(http.ResponseWriter, *http.Request) error) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        err := f(w, r)
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            log.Printf("handling %q: %v", r.RequestURI, err)
        }
    }
}

func betterHandler(w http.ResponseWriter, r *http.Request) error {
    if err := doThis(); err != nil {
        return fmt.Errorf("doing this: %v", err)
    }

    if err := doThat(); err != nil {
        return fmt.Errorf("doing that: %v", err)
    }
    return nil
}
</code></pre>

<h2>如何组织代码</h2>

<h3>将重要的代码放前面</h3>

<p>版权信息，构建信息，包说明文档</p>

<p>Import 声明，相关的包连起来构成组，组与组之间用空行隔开。</p>

<pre><code>import (
    "fmt"
    "io"
    "log"

    "code.google.com/p/go.net/websocket"
)
</code></pre>

<p>接下来代码以最重要的类型开始，以工具函数和类型结束。</p>

<h3>如何编写文档</h3>

<p>包名之前要写相关文档</p>

<pre><code>// Package playground registers an HTTP handler at "/compile" that
// proxies requests to the golang.org playground service.
package playground
</code></pre>

<p>导出的标识符（译者按：大写的标识符为导出标识符）会出现在 <code>godoc</code>中，所以要正确的编写文档。</p>

<pre><code>// Author represents the person who wrote and/or is presenting the document.
type Author struct {
    Elem []Elem
}

// TextElem returns the first text elements of the author details.
// This is used to display the author' name, job title, and company
// without the contact details.
func (p *Author) TextElem() (elems []Elem) {
</code></pre>

<p><a href="http://godoc.org/code.google.com/p/go.talks/pkg/present#Author">生成的文档示例</a></p>

<p><a href="http://blog.golang.org/godoc-documenting-go-code">Gocode: 文档化Go代码</a></p>

<p> </p>

<h3>越简洁越好</h3>

<p>长代码往往不是最好的.试着使用能自解释的最短的变量名.</p>

<ul>
<li>用 <code>MarshalIndent</code> ，别用 <code>MarshalWithIndentation</code>.</li>
</ul>


<p>别忘了包名会出现在你选择的标识符前面</p>

<ul>
<li><p>In package <code>encoding/json</code> we find the type <code>Encoder</code>, not <code>JSONEncoder</code>.</p></li>
<li><p>It is referred as <code>json.Encoder</code>.</p></li>
</ul>


<p>有多个文件的包</p>

<p>需要将一个包分散到多个文件中吗?</p>

<ul>
<li>避免行数非常多的文件</li>
</ul>


<p>标准库中 <code>net/http</code> 包有47个文件，共计 15734 行.</p>

<ul>
<li>拆分代码并测试</li>
</ul>


<p><code>net/http/cookie.go</code> 和 <code>net/http/cookie_test.go</code>  都是 <code>http </code>包的一部分.</p>

<p>测试代码 只有 在测试时才会编译.</p>

<ul>
<li>多文件包的文档编写</li>
</ul>


<p>如果一个包中有多个文件, 可以很方便的创建一个 <code>doc.go </code>文件，包含包文档信息.</p>

<h3>让包可以”go get”到</h3>

<p>一些包将来可能会被复用，另外一些不会.</p>

<p>定义了一些网络协议的包可能会在开发一个可执行命令时复用.</p>

<p><a href="https://github.com/bradfitz/camlistore">github.com/bradfitz/camlistore</a></p>

<h2>接口</h2>

<h3>你需要什么</h3>

<p>让我们以之前的Gopher类型为例</p>

<pre><code>type Gopher struct {
    Name     string
    Age      int32
    FurColor color.Color
}
</code></pre>

<p>我们可以定义这个方法</p>

<pre><code>func (g *Gopher) DumpToFile(f *os.File) error {
</code></pre>

<p>但是使用一个具体的类型会让代码难以测试，因此我们使用接口.</p>

<pre><code>func (g *Gopher) DumpToReadWriter(rw io.ReadWriter) error {
</code></pre>

<p>进而，由于使用的是接口，我们可以只请求我们需要的.</p>

<pre><code>func (g *Gopher) DumpToWriter(f io.Writer) error {
</code></pre>

<h3>让独立的包彼此独立</h3>

<p><label /></p>

<pre><code>import (
    "code.google.com/p/go.talks/2013/bestpractices/funcdraw/drawer"
    "code.google.com/p/go.talks/2013/bestpractices/funcdraw/parser"
)

 // Parse the text into an executable function.
    f, err := parser.Parse(text)
    if err != nil {
        log.Fatalf("parse %q: %v", text, err)
    }

    // Create an image plotting the function.
    m := drawer.Draw(f, *width, *height, *xmin, *xmax)

    // Encode the image into the standard output.
    err = png.Encode(os.Stdout, m)
    if err != nil {
        log.Fatalf("encode image: %v", err)
    }
</code></pre>

<h3>解析</h3>

<p><label /></p>

<pre><code>type ParsedFunc struct {
    text string
    eval func(float64) float64
}

func Parse(text string) (*ParsedFunc, error) {
    f, err := parse(text)
    if err != nil {
        return nil, err
    }
    return &amp;ParsedFunc{text: text, eval: f}, nil
}

func (f *ParsedFunc) Eval(x float64) float64 { return f.eval(x) }
func (f *ParsedFunc) String() string         { return f.text }
</code></pre>

<h3>描绘</h3>

<p><label /></p>

<pre><code>import (
    "image"

    "code.google.com/p/go.talks/2013/bestpractices/funcdraw/parser"
)

// Draw draws an image showing a rendering of the passed ParsedFunc.
func DrawParsedFunc(f parser.ParsedFunc) image.Image {
</code></pre>

<p>使用接口来避免依赖.</p>

<pre><code>import "image"

// Function represent a drawable mathematical function.
type Function interface {
    Eval(float64) float64
}

// Draw draws an image showing a rendering of the passed Function.
func Draw(f Function) image.Image {
</code></pre>

<h3>测试</h3>

<p>使用接口而不是具体类型让测试更简洁.</p>

<pre><code>package drawer

import (
    "math"
    "testing"
)

type TestFunc func(float64) float64

func (f TestFunc) Eval(x float64) float64 { return f(x) }

var (
    ident = TestFunc(func(x float64) float64 { return x })
    sin   = TestFunc(math.Sin)
)

func TestDraw_Ident(t *testing.T) {
    m := Draw(ident)
    // Verify obtained image.
</code></pre>

<h3>在接口中避免并发</h3>

<p><label /></p>

<pre><code>func doConcurrently(job string, err chan error) {
    go func() {
        fmt.Println("doing job", job)
        time.Sleep(1 * time.Second)
        err &lt;- errors.New("something went wrong!")
    }()
}

func main() {
    jobs := []string{"one", "two", "three"}

    errc := make(chan error)
    for _, job := range jobs {
        doConcurrently(job, errc)
    }
    for _ = range jobs {
        if err := &lt;-errc; err != nil {
            fmt.Println(err)
        }
    }
}
</code></pre>

<p>如果我们想串行的使用它会怎样?</p>

<pre><code>func do(job string) error {
    fmt.Println("doing job", job)
    time.Sleep(1 * time.Second)
    return errors.New("something went wrong!")
}

func main() {
    jobs := []string{"one", "two", "three"}

    errc := make(chan error)
    for _, job := range jobs {
        go func(job string) {
            errc &lt;- do(job)
        }(job)
    }
    for _ = range jobs {
        if err := &lt;-errc; err != nil {
            fmt.Println(err)
        }
    }
}
</code></pre>

<p>暴露同步的接口，这样异步调用这些接口会简单.</p>

<h2>并发的最佳实践</h2>

<h3>使用goroutines管理状态</h3>

<p>使用chan或者有chan的结构体和goroutine通信</p>

<pre><code>type Server struct{ quit chan bool }

func NewServer() *Server {
    s := &amp;Server{make(chan bool)}
    go s.run()
    return s
}

func (s *Server) run() {
    for {
        select {
        case &lt;-s.quit:
            fmt.Println("finishing task")
            time.Sleep(time.Second)
            fmt.Println("task done")
            s.quit &lt;- true
            return
        case &lt;-time.After(time.Second):
            fmt.Println("running task")
        }
    }
}

func (s *Server) Stop() {
    fmt.Println("server stopping")
    s.quit &lt;- true
    &lt;-s.quit
    fmt.Println("server stopped")
}

func main() {
    s := NewServer()
    time.Sleep(2 * time.Second)
    s.Stop()
}
</code></pre>

<h3>使用带缓存的chan，来避免goroutine内存泄漏</h3>

<p><label /></p>

<pre><code>func sendMsg(msg, addr string) error {
    conn, err := net.Dial("tcp", addr)
    if err != nil {
        return err
    }
    defer conn.Close()
    _, err = fmt.Fprint(conn, msg)
    return err
}

func main() {
    addr := []string{"localhost:8080", "http://google.com"}
    err := broadcastMsg("hi", addr)

    time.Sleep(time.Second)

    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println("everything went fine")
}

func broadcastMsg(msg string, addrs []string) error {
    errc := make(chan error)
    for _, addr := range addrs {
        go func(addr string) {
            errc &lt;- sendMsg(msg, addr)
            fmt.Println("done")
        }(addr)
    }

    for _ = range addrs {
        if err := &lt;-errc; err != nil {
            return err
        }
    }
    return nil
}
</code></pre>

<ul>
<li>goroutine阻塞在chan写操作</li>
<li>goroutine保存了一个chan的引用</li>
<li><p>chan永远不会垃圾回收</p>

<p>func broadcastMsg(msg string, addrs []string) error {</p>

<pre><code>errc := make(chan error, len(addrs))
for _, addr := range addrs {
    go func(addr string) {
        errc &lt;- sendMsg(msg, addr)
        fmt.Println("done")
    }(addr)
}

for _ = range addrs {
    if err := &lt;-errc; err != nil {
        return err
    }
}
return nil
</code></pre>

<p>}</p></li>
</ul>


<p>如果我们不能预测channel的容量呢?</p>

<h3>使用quit chan避免goroutine内存泄漏</h3>

<p><label /></p>

<pre><code>func broadcastMsg(msg string, addrs []string) error {
    errc := make(chan error)
    quit := make(chan struct{})

    defer close(quit)

    for _, addr := range addrs {
        go func(addr string) {
            select {
            case errc &lt;- sendMsg(msg, addr):
                fmt.Println("done")
            case &lt;-quit:
                fmt.Println("quit")
            }
        }(addr)
    }

    for _ = range addrs {
        if err := &lt;-errc; err != nil {
            return err
        }
    }
    return nil
}
</code></pre>

<h3>12条最佳实践</h3>

<p> ​1. 避免嵌套的处理错误<br/>
 2. 尽可能避免重复<br/>
 3. 将重要的代码放前面<br/>
 4. 为代码编写文档<br/>
 5. 越简洁越好<br/>
 6. 讲包拆分到多个文件中<br/>
 7. 让包”go get”到<br/>
 8. 按需请求<br/>
 9. 让独立的包彼此独立<br/>
 10. 在接口中避免并发<br/>
 11. 使用goroutine管理状态<br/>
 12. 避免goroutine内存泄漏</p>

<h3></h3>

<h3>一些链接</h3>

<p>资源</p>

<ul>
<li>Go 首页 <a href="http://golang.org/">golang.org</a></li>
<li>Go 交互式体验 <a href="http://tour.golang.org/">tour.golang.org</a></li>
</ul>


<p>其他演讲</p>

<ul>
<li>用go做词法扫描 <a href="http://www.youtube.com/watch?v=HxaD_trXwRE">video</a></li>
<li>并发不是并行 <a href="http://vimeo.com/49718712">video</a></li>
<li>Go并发模式 <a href="http://www.youtube.com/watch?v=f6kdp27TYZs">video</a></li>
<li>Go高级并发模式 <a href="http://www.youtube.com/watch?v=QDDwwePbDtw">video</a></li>
</ul>


<h3></h3>

<h3>谢谢</h3>

<p>Francesc Campoy Flores</p>

<p>Gopher at Google</p>

<p><a href="http://twitter.com/campoy83">@campoy83</a></p>

<p><a href="http://campoy.cat/+">http://campoy.cat/+</a></p>

<p><a href="http://golang.org/">http://golang.org</a></p>

<p>原文链接： <a href="http://t.cn/zQ6eR2E">Francesc Campoy Flores</a>   
翻译：<a href="http://blog.jobbole.com">伯乐在线</a> - <a href="http://blog.jobbole.com/author/codefor/">Codefor</a><br/>
译文链接：<a href="http://blog.jobbole.com/44608/">http://blog.jobbole.com/44608/</a></p>

					<div class="meta asset-footer">
						<ul class="date-publish list-linear">
							<li>Published: </li>
							<li><date class="date-pub" title="2013-08-02" datetime="2013-08-02" pubdate>
							<span class="year">2013-08-02</span>
							</date></li>
						</ul>
						<ul class="list-tag list-linear">
							<li class="list-head">tags: </li>
							
							


  
     
    	<li value="2" title="go"><a href="/tags.html#go-ref">go</a></li>
    
  



						</ul>
						<ul class="list-tag list-linear">
							<li class="list-head" style="display:block;">版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">Creative Commons BY-NC-ND 3.0</a></li>
							<li class="list-head" style="display:block;">原文网址：<a href="http://blog.jobbole.com/44608/" target="_blank">http://blog.jobbole.com/44608/</a></li>

						</ul>
					</div><!-- meta -->
				</div><!-- entry-content -->
				<div class="misc-content">
					<div class="comment">
					


  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_developer = 1;
    var disqus_shortname = 'beango'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




					</div>
				</div><!-- misc-content -->
			</div><!-- bd -->

		</div><!-- content -->
	</div><!-- unit-inner -->
</article>

				</div>
			</div><!-- unit-inner -->
		</div><!-- unit-body -->
		<p class="licence">
			Theme: <a href="http://themes.jekyllbootstrap.com/">the_program</a> based on <a href="http://jekyllbootstrap.com/">Jekyll-bootstrap</a>.<br>
			Powered by <a href="https://github.com/mojombo/jekyll">Jekyll</a>.<!--<script src="http://s21.cnzz.com/stat.php?id=4827427&web_id=4827427&show=pic" language="JavaScript"></script>-->
		</p>
	</div><!-- body -->
</div><!-- page -->
<!--
<script>
/*! A fix for the iOS orientationchange zoom bug.Script by @scottjehl, rebound by @wilto. MIT License.*/
(function(j){var i=j.document;if(!i.querySelectorAll){return}var l=i.querySelectorAll("meta[name=viewport]")[0],a=l&&l.getAttribute("content"),h=a+", maximum-scale=1.0",d=a+", maximum-scale=10.0",g=true,c=j.orientation,k=0;if(!l){return}function f(){l.setAttribute("content",d);g=true}function b(){l.setAttribute("content",h);g=false}function e(m){c=Math.abs(j.orientation);k=Math.abs(m.gamma);if(k>8&&c===0){if(g){b()}}else{if(!g){f()}}}j.addEventListener("orientationchange",f,false);j.addEventListener("deviceorientation",e,false)})(this);
</script>
-->

<script src="http://libs.baidu.com/jquery/1.5.0/jquery.min.js"></script>
<script type="text/javascript" src="/assets/highlight/google-code-prettify/prettify.js"></script>
<script src="/assets/modernizr.min.js"></script>
<script src='/assets/default.js'></script>
</body>
</html>

