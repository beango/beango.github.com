<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="author" content="HuangDing" />
<meta name="keywords" content="python" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>程序员 - 博客 - HuangDing / 理解 Python 中的线程</title>
<link href="http://http://uwebs.tk/feed.xml" rel="alternate" title="程序员 - 博客 - HuangDing" type="application/atom+xml" />
<link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" />
<link rel="stylesheet" type="text/css" href="/assets/css/site.css" />
<link rel="stylesheet" type="text/css" href="/assets/css/code/github.css" />

</head>

<body class="page-type-post">

<div class="main">
	<div class="trace">/ <a href="/">程序员 - 博客 - HuangDing</a> / 理解 Python 中的线程</div>

<article>
	<h1><a href="/archives/2013/11/25/understanding-threads-in-python.html">理解 Python 中的线程</a></h1>
	
	<p class="meta">
	<span class="datetime">2013-11-25</span> posted in [<a href="/category/default" class="category">转载</a>]
</p>
	
<p><em>郑重声明版权属于 http://agiliq.com/blog/2013/09/understanding-threads-in-python/</em></p>

<p>我们将会看到一些在Python中使用线程的实例和如何避免线程之间的竞争。</p>

<p>你应当将下边的例子运行多次，以便可以注意到线程是不可预测的和线程每次运行出的不同结果。</p>

<p>声明：从这里开始忘掉你听到过的关于GIL的东西，因为GIL不会影响到我想要展示的东西。</p>

<h4 id="section">示例1:</h4>
<p>我们将要请求五个不同的url：</p>

<h5 id="section-1">单线程</h5>

<pre><code>import time
import urllib2

def get_responses():
    urls = [
        'http://www.google.com',
        'http://www.amazon.com',
        'http://www.ebay.com',
        'http://www.alibaba.com',
        'http://www.reddit.com'
    ]
    start = time.time()
    for url in urls:
        print url
        resp = urllib2.urlopen(url)
        print resp.getcode()
    print "Elapsed time: %s" % (time.time()-start)

get_responses()
</code></pre>

<p>输出是：</p>

<pre><code>http://www.google.com 200
http://www.amazon.com 200
http://www.ebay.com 200
http://www.alibaba.com 200
http://www.reddit.com 200
Elapsed time: 3.0814409256
</code></pre>

<p>解释：<br />
*   url顺序的被请求<br />
*   除非cpu从一个url获得了回应，否则不会去请求下一个url<br />
*   网络请求会花费较长的时间，所以cpu在等待网络请求的返回时间内一直处于闲置状态。  </p>

<h5 id="section-2">多线程</h5>

<pre><code>import urllib2
import time
from threading import Thread

class GetUrlThread(Thread):
    def __init__(self, url):
        self.url = url 
        super(GetUrlThread, self).__init__()

    def run(self):
        resp = urllib2.urlopen(self.url)
        print self.url, resp.getcode()

def get_responses():
    urls = [
        'http://www.google.com', 
        'http://www.amazon.com', 
        'http://www.ebay.com', 
        'http://www.alibaba.com', 
        'http://www.reddit.com'
    ]
    start = time.time()
    threads = []
    for url in urls:
        t = GetUrlThread(url)
        threads.append(t)
        t.start()
    for t in threads:
        t.join()
    print "Elapsed time: %s" % (time.time()-start)

get_responses()
</code></pre>

<p>输出:  </p>

<pre><code>http://www.reddit.com 200
http://www.google.com 200
http://www.amazon.com 200
http://www.alibaba.com 200
http://www.ebay.com 200
Elapsed time: 0.689890861511
</code></pre>

<p>解释：
*   意识到了程序在执行时间上的提升
*   我们写了一个多线程程序来减少cpu的等待时间，当我们在等待一个线程内的网络请求返回时，这时cpu可以切换到其他线程去进行其他线程内的网络请求。
*   我们期望一个线程处理一个url，所以实例化线程类的时候我们传了一个url。
*   线程运行意味着执行类里的<code>run()</code>方法。
*   无论如何我们想每个线程必须执行<code>run()</code>。
*   为每个url创建一个线程并且调用<code>start()</code>方法，这告诉了cpu可以执行线程中的<code>run()</code>方法了。
*   我们希望所有的线程执行完毕的时候再计算花费的时间，所以调用了<code>join()</code>方法。
*   <code>join()</code>可以通知主线程等待这个线程结束后，才可以执行下一条指令。
*   每个线程我们都调用了<code>join()</code>方法，所以我们是在所有线程执行完毕后计算的运行时间。</p>

<p>关于线程：<br />
*   cpu可能不会在调用<code>start()</code>后马上执行<code>run()</code>方法。
*   你不能确定<code>run()</code>在不同线程建间的执行顺序。
*   对于单独的一个线程，可以保证<code>run()</code>方法里的语句是按照顺序执行的。
*   这就是因为线程内的url会首先被请求，然后打印出返回的结果。</p>

<h4 id="section-3">实例2</h4>

<p>我们将会用一个程序演示一下多线程间的资源竞争，并修复这个问题。  </p>

<pre><code>from threading import Thread


#define a global variable
some_var = 0 

class IncrementThread(Thread):
    def run(self):
        #we want to read a global variable
        #and then increment it
        global some_var
        read_value = some_var
        print "some_var in %s is %d" % (self.name, read_value)
        some_var = read_value + 1 
        print "some_var in %s after increment is %d" % (self.name, some_var)

def use_increment_thread():
    threads = []
    for i in range(50):
        t = IncrementThread()
        threads.append(t)
        t.start()
    for t in threads:
        t.join()
    print "After 50 modifications, some_var should have become 50"
    print "After 50 modifications, some_var is %d" % (some_var,)

use_increment_thread()
</code></pre>

<p>多次运行这个程序，你会看到多种不同的结果。  </p>

<p>解释：
*   有一个全局变量，所有的线程都想修改它。
*   所有的线程应该在这个全局变量上加 1 。
*   有50个线程，最后这个数值应该变成50，但是它却没有。</p>

<p>为什么没有达到50？<br />
*   在<code>some_var</code>是<code>15</code>的时候，线程<code>t1</code>读取了<code>some_var</code>，这个时刻cpu将控制权给了另一个线程<code>t2</code>。
*   <code>t2</code>线程读到的<code>some_var</code>也是<code>15</code>
*   <code>t1</code>和<code>t2</code>都把<code>some_var</code>加到<code>16</code>
*   当时我们期望的是<code>t1</code> <code>t2</code>两个线程使<code>some_var + 2</code>变成<code>17</code>
*   在这里就有了资源竞争。
*   相同的情况也可能发生在其它的线程间，所以出现了最后的结果小于<code>50</code>的情况。</p>

<p>解决资源竞争</p>

<pre><code>from threading import Lock, Thread
lock = Lock()
some_var = 0 


class IncrementThread(Thread):
    def run(self):
        #we want to read a global variable
        #and then increment it
        global some_var
        lock.acquire()
        read_value = some_var
        print "some_var in %s is %d" % (self.name, read_value)
        some_var = read_value + 1 
        print "some_var in %s after increment is %d" % (self.name, some_var)
        lock.release()

def use_increment_thread():
    threads = []
    for i in range(50):
        t = IncrementThread()
        threads.append(t)
        t.start()
    for t in threads:
        t.join()
    print "After 50 modifications, some_var should have become 50"
    print "After 50 modifications, some_var is %d" % (some_var,)

use_increment_thread()
</code></pre>

<p>再次运行这个程序，达到了我们预期的结果。  </p>

<p>解释：<br />
*   Lock 用来防止竞争条件
*   如果在执行一些操作之前，线程<code>t1</code>获得了锁。其他的线程在<code>t1</code>释放Lock之前，不会执行相同的操作
*   我们想要确定的是一旦线程<code>t1</code>已经读取了<code>some_var</code>，直到<code>t1</code>完成了修改<code>some_var</code>，其他的线程才可以读取<code>some_var</code>
*   这样读取和修改<code>some_var</code>成了逻辑上的原子操作。</p>

<h4 id="section-4">实例3</h4>
<p>让我们用一个例子来证明一个线程不能影响其他线程内的变量（非全局变量）。</p>

<p>time.sleep()可以使一个线程挂起，强制线程切换发生。</p>

<pre><code>from threading import Thread
import time

class CreateListThread(Thread):
    def run(self):
        self.entries = []
        for i in range(10):
            time.sleep(1)
            self.entries.append(i)
        print self.entries

def use_create_list_thread():
    for i in range(3):
        t = CreateListThread()
        t.start()

use_create_list_thread()
</code></pre>

<p>运行几次后发现并没有打印出争取的结果。当一个线程正在打印的时候，cpu切换到了另一个线程，所以产生了不正确的结果。我们需要确保<code>print self.entries</code>是个逻辑上的原子操作，以防打印时被其他线程打断。</p>

<p>我们使用了Lock()，来看下边的例子。</p>

<pre><code>from threading import Thread, Lock
import time

lock = Lock()

class CreateListThread(Thread):
    def run(self):
        self.entries = []
        for i in range(10):
            time.sleep(1)
            self.entries.append(i)
        lock.acquire()
        print self.entries
        lock.release()

def use_create_list_thread():
    for i in range(3):
        t = CreateListThread()
        t.start()

use_create_list_thread()
</code></pre>

<p>这次我们看到了正确的结果。证明了一个线程不可以修改其他线程内部的变量（非全局变量）</p>


	
	<!--<p class="permalink">永久链接：<a href="http://http://uwebs.tk/archives/2013/11/25/understanding-threads-in-python.html">http://http://uwebs.tk/archives/2013/11/25/understanding-threads-in-python.html</a></p>-->
</article>
<div id="disqus_thread" class="comments"></div>


	<footer>
		<p>&copy; Since 2012</p>
	</footer>
</div>

<aside>
	<h2><a href="/">程序员 - 博客 - HuangDing</a><a href="/feed.xml" class="feed-link" title="Subscribe"><i class="fa fa-rss-square"></i></a></h2>
	
	<nav class="block">
		<ul>
		<li class="default"><a href="/category/default/">转载</a></li>
		<li class="code"><a href="/category/code/">笔记</a></li>
		
		</ul>
	</nav>
	
	<form action="/search/" class="block block-search">
		<h3>Search</h3>
		<p><input type="search" name="q" placeholder="Search" /></p>
	</form>
	
	<div class="block block-about">
		<h3>About</h3>
		<figure>
			
			<figcaption><strong>HuangDing</strong></figcaption>
		</figure>
		<p>dotnet, mvc, python</p>
	</div>
	
	<div class="block block-license">
		<h3>Copyright</h3>
		<p><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.5/cn/" target="_blank" class="hide-target-icon" title="Copyright declaration of site content"><img alt="知识共享许可协议" src="http://i.creativecommons.org/l/by-nc-nd/2.5/cn/88x31.png" /></a></p>
	</div>
	
	
	<div class="block block-fork">
		<a href="https://github.com/beango"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" alt="Fork me on GitHub"></a>
	</div>
	
	
	<div class="block block-thank">
		<h3>Powered by</h3>
		<p>
			<a href="http://disqus.com/" target="_blank">Disqus</a>,
			<a href="http://elfjs.com/" target="_blank">elf+js</a>,
			<a href="https://github.com/" target="_blank">GitHub</a>,
			<a href="http://www.google.com/cse/" target="_blank">Google Custom Search</a>,
			<a href="http://en.gravatar.com/" target="_blank">Gravatar</a>,
			<a href="http://softwaremaniacs.org/soft/highlight/en/">HighlightJS</a>,
			<a href="https://github.com/mojombo/jekyll" target="_blank">jekyll</a>,
			<a href="https://github.com/mytharcher/SimpleGray" target="_blank">SimpleGray</a>
		</p>
	</div>
</aside>

<script src="http://elfjs.qiniudn.com/code/elf-0.5.0.min.js"></script>
<script src="http://yandex.st/highlightjs/7.3/highlight.min.js"></script>

<script src="/assets/js/site.js"></script>

<script>
site.URL_GOOGLE_API = 'http://www.google.com/jsapi';
site.URL_DISCUS_COMMENT = 'beango' ? 'http://beango.disqus.com/embed.js' : '';

site.VAR_SITE_NAME = '程序员 - 博客 - HuangDing';
site.VAR_GOOGLE_CUSTOM_SEARCH_ID = '015845096645085761197:gh2gyye7u1m';
site.TPL_SEARCH_TITLE = '#{0} / 搜索：#{1}';
site.VAR_AUTO_LOAD_ON_SCROLL = 0;
</script>
</body>
</html>