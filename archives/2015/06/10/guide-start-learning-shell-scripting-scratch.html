<!DOCTYPE html>
<html lang="zh-CN">
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Shell脚本编程初体验</title>
  <meta name="description" content="原文出处： Petras Liumparas   译文出处：GOLinux   欢迎分享原创到伯乐头条">

  <link rel="canonical" href="http://www.uwebs.tk/archives/2015/06/10/guide-start-learning-shell-scripting-scratch.html">

  <link rel="stylesheet" href="/assets/css/bootstrap.min.css">
  <!-- <link rel="stylesheet" href="/assets/css/icard_resume.css"> -->
  <link rel="stylesheet" href="/assets/css/font-awesome.min.css">
  <link rel="stylesheet" href="/assets/css/blog.css" >
  <link rel="stylesheet" href="/assets/css/syntax.css">
  <!-- <link rel="stylesheet" href="/assets/css/prettify.css" /> --> <!-- 设置代码主题，此文件为默认主题，你可以换成其他主题-->
  <!-- <script src="/assets/css/prettify.js" type="text/javascript"></script> -->
  <link rel="icon" type="image/png" href="/assets/img/avatar.png">

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
  <script src="assets/js/html5shiv.min.js"></script>
  <script src="assets/js/respond.min.js"></script>
  <![endif]-->

</head>

    <body>
        <header class="bloghead">
    <dev class="authorheader">
        <a href="/">
            <img alt="My Avatar" src="/assets/img/avatar.png"/>
        </a>
        <dev class="blogtitle">
            <h1><a href="/">HuangDing</a></h1>
            <h5> zZZ! </h5>
        </dev>
    </dev>

    <nav class="menu" role="nav">
        <ul>
            <li><a href="/">Home</a></li>
            <li>|</li>
            <li><a href="/menu.html">Menu</a></li>
            <li>|</li>
            <li><a href="/collection.html">Collection</a></li>
            <li>|</li>
            <li><a target="_blank" href="https://github.com/beango">Github</a></li>
            <li>|</li>
            <li><a target="_blank" href="/about.html">About Me</a></li>
        </ul>
    </nav>
</header>

        <main class="blogmain">
            <header>
                <h1 class="article-title">Shell脚本编程初体验</h1>
                <p class="article-time">
                    发表于 <span>2015-06-10</span>
                </p>
                <p class="article-hint">
                    如果你对本文有任何的建议或者疑问, 可以在
                    <a href="https://github.com/beango/beango.github.com/issues" target="_blank">这里给我提 Issues</a>, 谢谢! :)
					<a href='http://blog.jobbole.com/87465/' target="_blank">查看原文</a>
                </p>
            </header>
            <p>原文出处： <a href="http://linoxide.com/linux-shell-script/guide-start-learning-shell-scripting-scratch/">Petras Liumparas</a>   译文出处：<a href="https://linux.cn/article-5591-1.html">GOLinux</a>   欢迎分享原创到<a href="http://top.jobbole.com/?utm_source=jobboleblog-article">伯乐头条</a></p>

<p><img src="/assets/files/2015-06/5e4d414cgw1esy2aafka3j20dw0afdgj.jpg" alt="" title="5e4d414cgw1esy2aafka3j20dw0afdgj" /></p>

<p>通常，当人们提到“shell脚本语言”时，浮现在他们脑海中是bash，ksh，sh或者其它相类似的linux/unix脚本语言。脚本语言是与计算机交流的另外一种途径。使用图形化窗口界面（不管是windows还是linux都无所谓）用户可以移动鼠标并点击各种对象，比如按钮、列表、选框等等。但这种方式在每次用户想要计算机/服务器完成相同任务时（比如说批量转换照片，或者下载新的电影、mp3等）却是十分不方便。要想让所有这些事情变得简单并且自动化，我们可以使用shell脚本。</p>

<p>某些编程语言，像pascal、foxpro、C、java之类，在执行前需要先进行编译。它们需要合适的编译器来让我们的代码完成某个任务。</p>

<p>而其它一些编程语言，像php、javascript、visualbasic之类，则不需要编译器，因此它们需要解释器，而我们不需要编译代码就可以运行程序。</p>

<p>shell脚本也像解释器一样，但它通常用于调用外部已编译的程序。然后，它会捕获输出结果、退出代码并根据情况进行处理。</p>

<p>Linux世界中最为流行的shell脚本语言之一，就是bash。而我认为（这是我自己的看法）原因在于，默认情况下bash shell可以让用户便捷地通过历史命令（先前执行过的）导航，与之相反的是，ksh则要求对.profile进行一些调整，或者记住一些“魔术”组合键来查阅历史并修正命令。</p>

<p>好了，我想这些介绍已经足够了，剩下来哪个环境最适合你，就留给你自己去判断吧。从现在开始，我将只讲bash及其脚本。在下面的例子中，我将使用CentOS 6.6和bash-4.1.2。请确保你有相同版本，或者更高版本。</p>

<p><strong>Shell脚本流</strong></p>

<p>shell脚本语言就跟和几个人聊天类似。你只需把所有命令想象成能帮你做事的那些人，只要你用正确的方式来请求他们去做。比如说，你想要写文档。首先，你需要纸。然后，你需要把内容说给某个人听，让他帮你写。最后，你想要把它存放到某个地方。或者说，你想要造一所房子，因而你需要请合适的人来清空场地。在他们说“事情干完了”，那么另外一些工程师就可以帮你来砌墙。最后，当这些工程师们也告诉你“事情干完了”的时候，你就可以叫油漆工来给房子粉饰了。如果你让油漆工在墙砌好前就来粉饰，会发生什么呢？我想，他们会开始发牢骚了。几乎所有这些像人一样的命令都会说话，如果它们完成了工作而没有发生什么问题，那么它们就会告诉“标准输出”。如果它们不能做你叫它们做的事——它们会告诉“标准错误”。这样，最后，所有的命令都通过“标准输入”来听你的话。</p>

<p>快速实例——当你打开linux终端并写一些文本时——你正通过“标准输入”和bash说话。那么，让我们来问问bash shell who am i（我是谁？）吧。</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># who am i                                     &lt;--- 你通过标准输入对 bash shell 说</span>
<span class="nv">root</span>  <span class="nv">pts</span><span class="o">/</span><span class="mi">0</span>  <span class="mi">2015</span><span class="o">-</span><span class="mo">04</span><span class="o">-</span><span class="mi">22</span> <span class="mi">20</span><span class="p">:</span><span class="mi">17</span> <span class="p">(</span><span class="mf">192.168.1.123</span><span class="p">)</span>  <span class="o">&lt;---</span> <span class="nv">bash</span> <span class="nv">shell</span><span class="err">通过标准输出回答你</span>
</code></pre>
</div>

<p>现在，让我们说一些bash听不懂的问题：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># blablabla           &lt;--- 哈，你又在和标准输入说话了</span>
<span class="o">-</span><span class="nv">bash:</span> <span class="nv">blablabla:</span> <span class="nv">command</span> <span class="ow">not</span> <span class="nv">found</span>     <span class="o">&lt;---</span> <span class="nv">bash</span><span class="err">通过标准错误在发牢骚了</span>
</code></pre>
</div>

<p>“:”之前的第一个单词通常是向你发牢骚的命令。实际上，这些流中的每一个都有它们自己的索引号（LCTT 译注：文件句柄号）：</p>

<ul>
  <li>标准输入（stdin） – 0</li>
  <li>标准输出（stdout） – 1</li>
  <li>标准错误（stderr） – 2</li>
</ul>

<p>如果你真的想要知道哪个输出命令说了些什么——你需要将那次发言重定向到（在命令后使用大于号“&gt;”和流索引）文件：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># blablabla 1&gt; output.txt</span>
<span class="o">-</span><span class="nv">bash:</span> <span class="nv">blablabla:</span> <span class="nv">command</span> <span class="ow">not</span> <span class="nv">found</span>
</code></pre>
</div>

<p>在本例中，我们试着重定向流1（<strong>stdout</strong>）到名为output.txt的文件。让我们来看对该文件内容所做的事情吧，使用cat命令可以做这事：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat output.txt</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>看起来似乎是空的。好吧，现在让我们来重定向流2（<strong>stderr</strong>）：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># blablabla 2&gt; error.txt</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>好吧，我们看到牢骚话没了。让我们检查一下那个文件：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat error.txt</span>
<span class="o">-</span><span class="nv">bash:</span> <span class="nv">blablabla:</span> <span class="nv">command</span> <span class="ow">not</span> <span class="nv">found</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>果然如此！我们看到，所有牢骚话都被记录到errors.txt文件里头去了。</p>

<p>有时候，命令会同时产生<strong>stdout </strong>和 <strong>stderr</strong>。要重定向它们到不同的文件，我们可以使用以下语句：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="nv">command</span> <span class="mi">1</span><span class="o">&gt;</span><span class="nv">out</span><span class="o">.</span><span class="nv">txt</span> <span class="mi">2</span><span class="o">&gt;</span><span class="nv">err</span><span class="o">.</span><span class="nv">txt</span>
</code></pre>
</div>

<p>要缩短一点语句，我们可以忽略“1”，因为默认情况下stdout会被重定向：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="nv">command</span> <span class="o">&gt;</span><span class="nv">out</span><span class="o">.</span><span class="nv">txt</span> <span class="mi">2</span><span class="o">&gt;</span><span class="nv">err</span><span class="o">.</span><span class="nv">txt</span>
</code></pre>
</div>

<p>好吧，让我们试试做些“坏事”。让我们用rm命令把file1和folder1给删了吧：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># rm -vf folder1 file1 &gt; out.txt 2&gt;err.txt</span>
</code></pre>
</div>

<p>现在来检查以下输出文件：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat out.txt</span>
<span class="nv">removed</span> <span class="sb">`file1'
[root@localhost ~]
# cat err.txt
rm: cannot remove `</span><span class="nv">folder1</span><span class="err">'</span><span class="p">:</span> <span class="nv">Is</span> <span class="nv">a</span> <span class="nv">directory</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>正如我们所看到的，不同的流被分离到了不同的文件。有时候，这也不是很方便，因为我们想要查看出现错误时，在某些操作前面或后面所连续发生的事情。要实现这一目的，我们可以重定向两个流到同一个文件：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="nv">command</span> <span class="o">&gt;&gt;</span><span class="nv">out_err</span><span class="o">.</span><span class="nv">txt</span> <span class="mi">2</span><span class="o">&gt;&gt;</span><span class="nv">out_err</span><span class="o">.</span><span class="nv">txt</span>
</code></pre>
</div>

<p>注意：请注意，我使用“&gt;&gt;”替代了“&gt;”。它允许我们附加到文件，而不是覆盖文件。</p>

<p>我们也可以重定向一个流到另一个：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="nv">command</span> <span class="o">&gt;</span><span class="nv">out_err</span><span class="o">.</span><span class="nv">txt</span> <span class="mi">2</span><span class="o">&gt;&amp;</span><span class="mi">1</span>
</code></pre>
</div>

<p>让我来解释一下吧。所有命令的标准输出将被重定向到out_err.txt，错误输出将被重定向到流1（上面已经解释过了），而该流会被重定向到同一个文件。让我们看这个实例：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># rm -fv folder2 file2 &gt;out_err.txt 2&gt;&amp;1</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat out_err.txt</span>
<span class="nv">rm:</span> <span class="nv">cannot</span> <span class="nv">remove</span> <span class="sb">`folder2': Is a directory
removed `</span><span class="nv">file2</span><span class="err">'</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>看着这些组合的输出，我们可以将其说明为：首先，rm命令试着将folder2删除，而它不会成功，因为linux要求-r键来允许rm命令删除文件夹，而第二个file2会被删除。通过为rm提供-v（详情）键，我们让rm命令告诉我们每个被删除的文件或文件夹。</p>

<p>这些就是你需要知道的，关于重定向的几乎所有内容了。我是说几乎，因为还有一个更为重要的重定向工具，它称之为“管道”。通过使用|（管道）符号，我们通常重定向stdout流。</p>

<p>比如说，我们有这样一个文本文件：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat text_file.txt</span>
<span class="nv">This</span> <span class="nv">line</span> <span class="nv">does</span> <span class="ow">not</span> <span class="nv">contain</span> <span class="nv">H</span> <span class="nv">e</span> <span class="nv">l</span> <span class="nv">l</span> <span class="nv">o</span> <span class="nv">word</span>
<span class="nv">This</span> <span class="nv">lilne</span> <span class="nv">contains</span> <span class="nv">Hello</span>
<span class="nv">This</span> <span class="nv">also</span> <span class="nv">containd</span> <span class="nv">Hello</span>
<span class="nv">This</span> <span class="nv">one</span> <span class="nb">no</span> <span class="nv">due</span> <span class="nv">to</span> <span class="nv">HELLO</span> <span class="nv">all</span> <span class="nv">capital</span>
<span class="nv">Hello</span> <span class="nv">bash</span> <span class="nv">world</span><span class="o">!</span>
</code></pre>
</div>

<p>而我们需要找到其中某些带有“Hello”的行，Linux中有个grep命令可以完成该工作：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># grep Hello text_file.txt</span>
<span class="nv">This</span> <span class="nv">lilne</span> <span class="nv">contains</span> <span class="nv">Hello</span>
<span class="nv">This</span> <span class="nv">also</span> <span class="nv">containd</span> <span class="nv">Hello</span>
<span class="nv">Hello</span> <span class="nv">bash</span> <span class="nv">world</span><span class="o">!</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>当我们有个文件，想要在里头搜索的时候，这用起来很不错。当如果我们需要在另一个命令的输出中查找某些东西，这又该怎么办呢？是的，当然，我们可以重定向输出到文件，然后再在文件里头查找：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># fdisk -l&gt;fdisk.out</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># grep "Disk /dev" fdisk.out</span>
<span class="nv">Disk</span> <span class="sr">/dev/s</span><span class="nv">da:</span> <span class="mi">8589</span> <span class="nv">MB</span><span class="p">,</span> <span class="mi">8589934592</span> <span class="nv">bytes</span>
<span class="nv">Disk</span> <span class="sr">/dev/m</span><span class="nv">apper</span><span class="o">/</span><span class="nv">VolGroup</span><span class="o">-</span><span class="nv">lv_root:</span> <span class="mi">7205</span> <span class="nv">MB</span><span class="p">,</span> <span class="mi">7205814272</span> <span class="nv">bytes</span>
<span class="nv">Disk</span> <span class="sr">/dev/m</span><span class="nv">apper</span><span class="o">/</span><span class="nv">VolGroup</span><span class="o">-</span><span class="nv">lv_swap:</span> <span class="mi">855</span> <span class="nv">MB</span><span class="p">,</span> <span class="mi">855638016</span> <span class="nv">bytes</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>如果你打算grep一些双引号引起来带有空格的内容呢！</p>

<p>注意：fdisk命令显示关于Linux操作系统磁盘驱动器的信息。</p>

<p>就像我们看到的，这种方式很不方便，因为我们不一会儿就把临时文件空间给搞乱了。要完成该任务，我们可以使用管道。它们允许我们重定向一个命令的stdout到另一个命令的stdin流：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># fdisk -l | grep "Disk /dev"</span>
<span class="nv">Disk</span> <span class="sr">/dev/s</span><span class="nv">da:</span> <span class="mi">8589</span> <span class="nv">MB</span><span class="p">,</span> <span class="mi">8589934592</span> <span class="nv">bytes</span>
<span class="nv">Disk</span> <span class="sr">/dev/m</span><span class="nv">apper</span><span class="o">/</span><span class="nv">VolGroup</span><span class="o">-</span><span class="nv">lv_root:</span> <span class="mi">7205</span> <span class="nv">MB</span><span class="p">,</span> <span class="mi">7205814272</span> <span class="nv">bytes</span>
<span class="nv">Disk</span> <span class="sr">/dev/m</span><span class="nv">apper</span><span class="o">/</span><span class="nv">VolGroup</span><span class="o">-</span><span class="nv">lv_swap:</span> <span class="mi">855</span> <span class="nv">MB</span><span class="p">,</span> <span class="mi">855638016</span> <span class="nv">bytes</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>如你所见，我们不需要任何临时文件就获得了相同的结果。我们把fdisk stdout重定向到了grep stdin。</p>

<p>注意 ： 管道重定向总是从左至右的。</p>

<p>还有几个其它重定向，但是我们将把它们放在后面讲。</p>

<p><strong>在shell中显示自定义信息</strong></p>

<p>正如我们所知道的，通常，与shell的交流以及shell内的交流是以对话的方式进行的。因此，让我们创建一些真正的脚本吧，这些脚本也会和我们讲话。这会让你学到一些简单的命令，并对脚本的概念有一个更好的理解。</p>

<p>假设我们是某个公司的总服务台经理，我们想要创建某个shell脚本来注册呼叫信息：电话号码、用户名以及问题的简要描述。我们打算把这些信息存储到普通文本文件data.txt中，以便今后统计。脚本它自己就是以对话的方式工作，这会让总服务台的工作人员的小日子过得轻松点。那么，首先我们需要显示提问。对于显示信息，我们可以用echo和printf命令。这两个都是用来显示信息的，但是printf更为强大，因为我们可以通过它很好地格式化输出，我们可以让它右对齐、左对齐或者为信息留出专门的空间。让我们从一个简单的例子开始吧。要创建文件，请使用你惯用的文本编辑器（kate，nano，vi，……），然后创建名为note.sh的文件，里面写入这些命令：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="nv">echo</span> <span class="s">"Phone number ?"</span>
</code></pre>
</div>

<p><strong>如何运行/执行脚本？</strong></p>

<p>在保存文件后，我们可以使用bash命令来运行，把我们的文件作为它的参数：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># bash note.sh</span>
<span class="nv">Phone</span> <span class="nv">number</span> <span class="p">?</span>
</code></pre>
</div>

<p>实际上，这样来执行脚本是很不方便的。如果不使用bash命令作为前缀来执行，会更舒服一些。要让脚本可执行，我们可以使用chmod命令：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># ls -la note.sh</span>
<span class="o">-</span><span class="nv">rw</span><span class="o">-</span><span class="nv">r</span><span class="o">--</span><span class="nv">r</span><span class="o">--.</span> <span class="mi">1</span> <span class="nv">root</span> <span class="nv">root</span> <span class="mi">22</span> <span class="nv">Apr</span> <span class="mi">23</span> <span class="mi">20</span><span class="p">:</span><span class="mi">52</span> <span class="nv">note</span><span class="o">.</span><span class="nv">sh</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># chmod +x note.sh</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># ls -la note.sh</span>
<span class="o">-</span><span class="nv">rwxr</span><span class="o">-</span><span class="nv">xr</span><span class="o">-</span><span class="nv">x</span><span class="o">.</span> <span class="mi">1</span> <span class="nv">root</span> <span class="nv">root</span> <span class="mi">22</span> <span class="nv">Apr</span> <span class="mi">23</span> <span class="mi">20</span><span class="p">:</span><span class="mi">52</span> <span class="nv">note</span><span class="o">.</span><span class="nv">sh</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>注意 ：ls命令显示了当前文件夹内的文件。通过添加-la键，它会显示更多文件信息。</p>

<p>如我们所见，在chmod命令执行前，脚本只有读（r）和写（w）权限。在执行chmod +x后，它就获得了执行（x）权限。（关于权限的更多细节，我会在下一篇文章中讲述。）现在，我们只需这么来运行：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># ./note.sh</span>
<span class="nv">Phone</span> <span class="nv">number</span> <span class="p">?</span>
</code></pre>
</div>

<p>在脚本名前，我添加了 ./ 组合。.(点）在unix世界中意味着当前位置（当前文件夹），/（斜线）是文件夹分隔符。（在Windows系统中，我们使用反斜线\表示同样功能）所以，这整个组合的意思是说：“从当前文件夹执行note.sh脚本”。我想，如果我用完整路径来运行这个脚本的话，你会更加清楚一些：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># /root/note.sh</span>
<span class="nv">Phone</span> <span class="nv">number</span> <span class="p">?</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>它也能工作。</p>

<p>如果所有linux用户都有相同的默认shell，那就万事OK。如果我们只是执行该脚本，默认的用户shell就会用于解析脚本内容并运行命令。不同的shell的语法、内部命令等等有着一丁点不同，所以，为了保证我们的脚本会使用bash，我们应该添加#!/bin/bash到文件首行。这样，默认的用户shell将调用/bin/bash，而只有在那时候，脚本中的命令才会被执行：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat note.sh</span>
<span class="c1">#!/bin/bash</span>
<span class="nv">echo</span> <span class="s">"Phone number ?"</span>
</code></pre>
</div>

<p>直到现在，我们才100%确信bash会用来解析我们的脚本内容。让我们继续。</p>

<p> </p>

<p><strong>读取输入</strong></p>

<p>在显示信息后，脚本会等待用户回答。有个read命令用来接收用户的回答：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="c1">#!/bin/bash</span>
<span class="nv">echo</span> <span class="s">"Phone number ?"</span>
<span class="nb">read</span> <span class="nv">phone</span>
</code></pre>
</div>

<p>在执行后，脚本会等待用户输入，直到用户按[ENTER]键结束输入：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># ./note.sh</span>
<span class="nv">Phone</span> <span class="nv">number</span> <span class="p">?</span>
<span class="mi">12345</span> <span class="o">&lt;---</span> <span class="err">这儿是我输入的内容</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>你输入的所有东西都会被存储到变量phone中，要显示变量的值，我们同样可以使用echo命令：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat note.sh</span>
<span class="c1">#!/bin/bash</span>
<span class="nv">echo</span> <span class="s">"Phone number ?"</span>
<span class="nb">read</span> <span class="nv">phone</span>
<span class="nv">echo</span> <span class="s">"You have entered $phone as a phone number"</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># ./note.sh</span>
<span class="nv">Phone</span> <span class="nv">number</span> <span class="p">?</span>
<span class="mi">123456</span>
<span class="nv">You</span> <span class="nv">have</span> <span class="nv">entered</span> <span class="mi">123456</span> <span class="nv">as</span> <span class="nv">a</span> <span class="nv">phone</span> <span class="nv">number</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>在bash shell中，一般我们使用$（美元）符号来表明这是一个变量，除了读入到变量和其它为数不多的时候才不用这个$（将在今后说明）。</p>

<p>好了，现在我们准备添加剩下的问题了：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="c1">#!/bin/bash</span>
<span class="nv">echo</span> <span class="s">"Phone number?"</span>
<span class="nb">read</span> <span class="nv">phone</span>
<span class="nv">echo</span> <span class="s">"Name?"</span>
<span class="nb">read</span> <span class="nv">name</span>
<span class="nv">echo</span> <span class="s">"Issue?"</span>
<span class="nb">read</span> <span class="nv">issue</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># ./note.sh</span>
<span class="nv">Phone</span> <span class="nv">number</span><span class="p">?</span>
<span class="mi">123</span>
<span class="nv">Name</span><span class="p">?</span>
<span class="nv">Jim</span>
<span class="nv">Issue</span><span class="p">?</span>
<span class="nv">script</span> <span class="nv">is</span> <span class="ow">not</span> <span class="nv">working</span><span class="o">.</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p><strong>使用流重定向</strong></p>

<p>太完美了！剩下来就是重定向所有东西到文件data.txt了。作为字段分隔符，我们将使用/（斜线）符号。</p>

<p>注意 ：你可以选择任何你认为是最好的分隔符，但是确保文件内容不会包含这些符号在内，否则它会导致在文本行中产生额外字段。</p>

<p>别忘了使用“&gt;&gt;”来代替“&gt;”，因为我们想要将输出内容附加到文件末！</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># tail -2 note.sh</span>
<span class="nb">read</span> <span class="nv">issue</span>
<span class="nv">echo</span> <span class="s">"$phone/$name/$issue"</span><span class="o">&gt;&gt;</span><span class="nv">data</span><span class="o">.</span><span class="nv">txt</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># ./note.sh</span>
<span class="nv">Phone</span> <span class="nv">number</span><span class="p">?</span>
<span class="mi">987</span>
<span class="nv">Name</span><span class="p">?</span>
<span class="nv">Jimmy</span>
<span class="nv">Issue</span><span class="p">?</span>
<span class="nv">Keybord</span> <span class="nv">issue</span><span class="o">.</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat data.txt</span>
<span class="mi">987</span><span class="sr">/Jimmy/</span><span class="nv">Keybord</span> <span class="nv">issue</span><span class="o">.</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>注意 ： tail命令显示了文件的最后的n行。</p>

<p>搞定。让我们再来运行一次看看：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># ./note.sh</span>
<span class="nv">Phone</span> <span class="nv">number</span><span class="p">?</span>
<span class="mi">556</span>
<span class="nv">Name</span><span class="p">?</span>
<span class="nv">Janine</span>
<span class="nv">Issue</span><span class="p">?</span>
<span class="nv">Mouse</span> <span class="nv">was</span> <span class="nv">broken</span><span class="o">.</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat data.txt</span>
<span class="mi">987</span><span class="sr">/Jimmy/</span><span class="nv">Keybord</span> <span class="nv">issue</span><span class="o">.</span>
<span class="mi">556</span><span class="sr">/Janine/</span><span class="nv">Mouse</span> <span class="nv">was</span> <span class="nv">broken</span><span class="o">.</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>我们的文件在增长，让我们在每行前面加个日期吧，这对于今后摆弄这些统计数据时会很有用。要实现这功能，我们可以使用date命令，并指定某种格式，因为我不喜欢默认格式：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># date</span>
<span class="nv">Thu</span> <span class="nv">Apr</span> <span class="mi">23</span> <span class="mi">21</span><span class="p">:</span><span class="mi">33</span><span class="p">:</span><span class="mi">14</span> <span class="nv">EEST</span> <span class="mi">2015</span> <span class="o">&lt;----</span> <span class="nv">date</span><span class="err">命令的默认输出</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># date "+%Y.%m.%d %H:%M:%S"</span>
<span class="mf">2015.04.23</span> <span class="mi">21</span><span class="p">:</span><span class="mi">33</span><span class="p">:</span><span class="mi">18</span> <span class="o">&lt;----</span> <span class="err">格式化后的输出</span>
</code></pre>
</div>

<p>有几种方式可以读取命令的输出到变量，在这种简单的情况下，我们将使用`（是反引号，不是单引号，和波浪号~在同一个键位）：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat note.sh</span>
<span class="c1">#!/bin/bash</span>
<span class="nv">now</span><span class="o">=</span><span class="sb">`date "+%Y.%m.%d %H:%M:%S"`</span>
<span class="nv">echo</span> <span class="s">"Phone number?"</span>
<span class="nb">read</span> <span class="nv">phone</span>
<span class="nv">echo</span> <span class="s">"Name?"</span>
<span class="nb">read</span> <span class="nv">name</span>
<span class="nv">echo</span> <span class="s">"Issue?"</span>
<span class="nb">read</span> <span class="nv">issue</span>
<span class="nv">echo</span> <span class="s">"$now/$phone/$name/$issue"</span><span class="o">&gt;&gt;</span><span class="nv">data</span><span class="o">.</span><span class="nv">txt</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># ./note.sh</span>
<span class="nv">Phone</span> <span class="nv">number</span><span class="p">?</span>
<span class="mi">123</span>
<span class="nv">Name</span><span class="p">?</span>
<span class="nv">Jim</span>
<span class="nv">Issue</span><span class="p">?</span>
<span class="nv">Script</span> <span class="nv">hanging</span><span class="o">.</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat data.txt</span>
<span class="mf">2015.04.23</span> <span class="mi">21</span><span class="p">:</span><span class="mi">38</span><span class="p">:</span><span class="mi">56</span><span class="sr">/123/</span><span class="nv">Jim</span><span class="o">/</span><span class="nv">Script</span> <span class="nv">hanging</span><span class="o">.</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>嗯……我们的脚本看起来有点丑啊，让我们来美化一下。如果你要手动读取read命令，你会发现read命令也可以显示一些信息。要实现该功能，我们应该使用-p键加上信息：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat note.sh</span>
<span class="c1">#!/bin/bash</span>
<span class="nv">now</span><span class="o">=</span><span class="sb">`date "+%Y.%m.%d %H:%M:%S"`</span>
<span class="nb">read</span> <span class="o">-</span><span class="nv">p</span> <span class="s">"Phone number: "</span> <span class="nv">phone</span>
<span class="nb">read</span> <span class="o">-</span><span class="nv">p</span> <span class="s">"Name: "</span> <span class="nv">name</span>
<span class="nb">read</span> <span class="o">-</span><span class="nv">p</span> <span class="s">"Issue: "</span> <span class="nv">issue</span>
<span class="nv">echo</span> <span class="s">"$now/$phone/$name/$issue"</span><span class="o">&gt;&gt;</span><span class="nv">data</span><span class="o">.</span><span class="nv">txt</span>
</code></pre>
</div>

<p>你可以直接从控制台查找到各个命令的大量有趣的信息，只需输入：man read, man echo, man date, man ……</p>

<p>同意吗？它看上去是舒服多了！</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># ./note.sh</span>
<span class="nv">Phone</span> <span class="nv">number:</span> <span class="mi">321</span>
<span class="nv">Name:</span> <span class="nv">Susane</span>
<span class="nv">Issue:</span> <span class="nv">Mouse</span> <span class="nv">was</span> <span class="nv">stolen</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat data.txt</span>
<span class="mf">2015.04.23</span> <span class="mi">21</span><span class="p">:</span><span class="mi">38</span><span class="p">:</span><span class="mi">56</span><span class="sr">/123/</span><span class="nv">Jim</span><span class="o">/</span><span class="nv">Script</span> <span class="nv">hanging</span><span class="o">.</span>
<span class="mf">2015.04.23</span> <span class="mi">21</span><span class="p">:</span><span class="mi">43</span><span class="p">:</span><span class="mi">50</span><span class="sr">/321/</span><span class="nv">Susane</span><span class="o">/</span><span class="nv">Mouse</span> <span class="nv">was</span> <span class="nv">stolen</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>光标在消息的后面（不是在新的一行中），这有点意思。（LCTT 译注：如果用 echo 命令输出显示的话，可以用 -n 参数来避免换行。）</p>

<p> </p>

<p><strong>循环</strong></p>

<p>是时候来改进我们的脚本了。如果用户一整天都在接电话，如果每次都要去运行，这岂不是很麻烦？让我们让这些活动都永无止境地循环去吧：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat note.sh</span>
<span class="c1">#!/bin/bash</span>
<span class="k">while</span> <span class="nv">true</span>
<span class="k">do</span>
<span class="nb">read</span> <span class="o">-</span><span class="nv">p</span> <span class="s">"Phone number: "</span> <span class="nv">phone</span>
<span class="nv">now</span><span class="o">=</span><span class="sb">`date "+%Y.%m.%d %H:%M:%S"`</span>
<span class="nb">read</span> <span class="o">-</span><span class="nv">p</span> <span class="s">"Name: "</span> <span class="nv">name</span>
<span class="nb">read</span> <span class="o">-</span><span class="nv">p</span> <span class="s">"Issue: "</span> <span class="nv">issue</span>
<span class="nv">echo</span> <span class="s">"$now/$phone/$name/$issue"</span><span class="o">&gt;&gt;</span><span class="nv">data</span><span class="o">.</span><span class="nv">txt</span>
<span class="nv">done</span>
</code></pre>
</div>

<p>我已经交换了read phone和now=date行的位置。这是因为我想要在输入电话号码后再获得时间。如果我把它放在循环的首行，那么循环一次后，变量 now 就会在数据存储到文件中后马上获得时间。而这并不好，因为下一次呼叫可能在20分钟后，甚至更晚。</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># ./note.sh</span>
<span class="nv">Phone</span> <span class="nv">number:</span> <span class="mi">123</span>
<span class="nv">Name:</span> <span class="nv">Jim</span>
<span class="nv">Issue:</span> <span class="nv">Script</span> <span class="nv">still</span> <span class="ow">not</span> <span class="nv">works</span><span class="o">.</span>
<span class="nv">Phone</span> <span class="nv">number:</span> <span class="mi">777</span>
<span class="nv">Name:</span> <span class="nv">Daniel</span>
<span class="nv">Issue:</span> <span class="nv">I</span> <span class="nv">broke</span> <span class="k">my</span> <span class="nv">monitor</span>
<span class="nv">Phone</span> <span class="nv">number:</span> <span class="o">^</span><span class="nv">C</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat data.txt</span>
<span class="mf">2015.04.23</span> <span class="mi">21</span><span class="p">:</span><span class="mi">38</span><span class="p">:</span><span class="mi">56</span><span class="sr">/123/</span><span class="nv">Jim</span><span class="o">/</span><span class="nv">Script</span> <span class="nv">hanging</span><span class="o">.</span>
<span class="mf">2015.04.23</span> <span class="mi">21</span><span class="p">:</span><span class="mi">43</span><span class="p">:</span><span class="mi">50</span><span class="sr">/321/</span><span class="nv">Susane</span><span class="o">/</span><span class="nv">Mouse</span> <span class="nv">was</span> <span class="nv">stolen</span>
<span class="mf">2015.04.23</span> <span class="mi">21</span><span class="p">:</span><span class="mi">47</span><span class="p">:</span><span class="mi">55</span><span class="sr">/123/</span><span class="nv">Jim</span><span class="o">/</span><span class="nv">Script</span> <span class="nv">still</span> <span class="ow">not</span> <span class="nv">works</span><span class="o">.</span>
<span class="mf">2015.04.23</span> <span class="mi">21</span><span class="p">:</span><span class="mi">48</span><span class="p">:</span><span class="mi">16</span><span class="sr">/777/</span><span class="nv">Daniel</span><span class="o">/</span><span class="nv">I</span> <span class="nv">broke</span> <span class="k">my</span> <span class="nv">monitor</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>注意： 要从无限循环中退出，你可以按[Ctrl]+[C]键。Shell会显示\^表示 CTRL 键。</p>

<p> </p>

<p><strong>使用管道重定向</strong></p>

<p>让我们添加更多功能到我们的“弗兰肯斯坦（Frankenstein）”，我想要脚本在每次呼叫后显示某个统计数据。比如说，我想要查看各个号码呼叫了我几次。对于这个，我们应该cat文件data.txt：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat data.txt</span>
<span class="mf">2015.04.23</span> <span class="mi">21</span><span class="p">:</span><span class="mi">38</span><span class="p">:</span><span class="mi">56</span><span class="sr">/123/</span><span class="nv">Jim</span><span class="o">/</span><span class="nv">Script</span> <span class="nv">hanging</span><span class="o">.</span>
<span class="mf">2015.04.23</span> <span class="mi">21</span><span class="p">:</span><span class="mi">43</span><span class="p">:</span><span class="mi">50</span><span class="sr">/321/</span><span class="nv">Susane</span><span class="o">/</span><span class="nv">Mouse</span> <span class="nv">was</span> <span class="nv">stolen</span>
<span class="mf">2015.04.23</span> <span class="mi">21</span><span class="p">:</span><span class="mi">47</span><span class="p">:</span><span class="mi">55</span><span class="sr">/123/</span><span class="nv">Jim</span><span class="o">/</span><span class="nv">Script</span> <span class="nv">still</span> <span class="ow">not</span> <span class="nv">works</span><span class="o">.</span>
<span class="mf">2015.04.23</span> <span class="mi">21</span><span class="p">:</span><span class="mi">48</span><span class="p">:</span><span class="mi">16</span><span class="sr">/777/</span><span class="nv">Daniel</span><span class="o">/</span><span class="nv">I</span> <span class="nv">broke</span> <span class="k">my</span> <span class="nv">monitor</span>
<span class="mf">2015.04.23</span> <span class="mi">22</span><span class="p">:</span><span class="mo">02</span><span class="p">:</span><span class="mi">14</span><span class="sr">/123/</span><span class="nv">Jimmy</span><span class="o">/</span><span class="nv">New</span> <span class="nv">script</span> <span class="nv">also</span> <span class="ow">not</span> <span class="nv">working</span><span class="o">!!!</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>现在，所有输出我们都可以重定向到cut命令，让cut来把每行切成一块一块（我们使用分隔符“/”），然后打印第二个字段：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat data.txt | cut -d"/" -f2</span>
<span class="mi">123</span>
<span class="mi">321</span>
<span class="mi">123</span>
<span class="mi">777</span>
<span class="mi">123</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>现在，我们可以把这个输出重定向打另外一个命令sort：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat data.txt | cut -d"/" -f2|sort</span>
<span class="mi">123</span>
<span class="mi">123</span>
<span class="mi">123</span>
<span class="mi">321</span>
<span class="mi">777</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>然后只留下唯一的行。要统计唯一条目，只需添加-c键到uniq命令：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># cat data.txt | cut -d"/" -f2 | sort | uniq -c</span>
<span class="mi">3</span> <span class="mi">123</span>
<span class="mi">1</span> <span class="mi">321</span>
<span class="mi">1</span> <span class="mi">777</span>
<span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1">#</span>
</code></pre>
</div>

<p>只要把这个添加到我们的循环的最后：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="c1">#!/bin/bash</span>
<span class="k">while</span> <span class="nv">true</span>
<span class="k">do</span>
<span class="nb">read</span> <span class="o">-</span><span class="nv">p</span> <span class="s">"Phone number: "</span> <span class="nv">phone</span>
<span class="nv">now</span><span class="o">=</span><span class="sb">`date "+%Y.%m.%d %H:%M:%S"`</span>
<span class="nb">read</span> <span class="o">-</span><span class="nv">p</span> <span class="s">"Name: "</span> <span class="nv">name</span>
<span class="nb">read</span> <span class="o">-</span><span class="nv">p</span> <span class="s">"Issue: "</span> <span class="nv">issue</span>
<span class="nv">echo</span> <span class="s">"$now/$phone/$name/$issue"</span><span class="o">&gt;&gt;</span><span class="nv">data</span><span class="o">.</span><span class="nv">txt</span>
<span class="nv">echo</span> <span class="s">"===== We got calls from ====="</span>
<span class="nv">cat</span> <span class="nv">data</span><span class="o">.</span><span class="nv">txt</span> <span class="o">|</span> <span class="nv">cut</span> <span class="o">-</span><span class="nv">d</span><span class="s">"/"</span> <span class="o">-</span><span class="nv">f2</span> <span class="o">|</span> <span class="nb">sort</span> <span class="o">|</span> <span class="nv">uniq</span> <span class="o">-</span><span class="nv">c</span>
<span class="nv">echo</span> <span class="s">"--------------------------------"</span>
<span class="nv">done</span>
</code></pre>
</div>

<p>运行：</p>

<div class="language-perl highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="nv">root@localhost</span> <span class="o">~</span><span class="p">]</span>
<span class="c1"># ./note.sh</span>
<span class="nv">Phone</span> <span class="nv">number:</span> <span class="mi">454</span>
<span class="nv">Name:</span> <span class="nv">Malini</span>
<span class="nv">Issue:</span> <span class="nv">Windows</span> <span class="nv">license</span> <span class="nv">expired</span><span class="o">.</span>
<span class="o">=====</span> <span class="nv">We</span> <span class="nv">got</span> <span class="nv">calls</span> <span class="nv">from</span> <span class="o">=====</span>
<span class="mi">3</span> <span class="mi">123</span>
<span class="mi">1</span> <span class="mi">321</span>
<span class="mi">1</span> <span class="mi">454</span>
<span class="mi">1</span> <span class="mi">777</span>
<span class="o">--------------------------------</span>
<span class="nv">Phone</span> <span class="nv">number:</span> <span class="o">^</span><span class="nv">C</span>
</code></pre>
</div>

<p>当前场景贯穿了几个熟知的步骤：</p>

<ul>
  <li>显示消息</li>
  <li>获取用户输入</li>
  <li>存储值到文件</li>
  <li>处理存储的数据</li>
</ul>

<p>但是，如果用户有点责任心，他有时候需要输入数据，有时候需要统计，或者可能要在存储的数据中查找一些东西呢？对于这些事情，我们需要使用switches/cases，并知道怎样来很好地格式化输出。这对于在shell中“画”表格的时候很有用。</p>


            <footer class="article-footer">
    <div class="authorimage">
        <img src="/assets/img/avatar.png" alt="My Avatar" class="img-circle">
    </div>
    <section class="author">
        <h4><a href="/about.html">黃丁</a></h4>
        <a href="mailto:6588617@gmail.com">6588617@gmail.com</a>
    </section>
</footer>

        </main>
        <div class="footer-copyright">
    <div class="container-fluid">
        <div class="row-fluid">
            <div class="col-md-12">
                Copyright &copy; 2016 黃丁 - All rights reserved.
            </div>
        </div>
    </div>
</div>
<script type="text/javascript" src="/assets/js/jquery.min.js"></script>
<script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
<script type="text/javascript" src="/assets/js/site.js"></script>
    </body>

</html>
