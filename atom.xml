<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>程序员 - 博客 - HuangDing</title>
 <link href="http://beango.github.com/atom.xml" rel="self"/>
 <link href="http://beango.github.com"/>
 <updated>2013-08-01T17:49:45+08:00</updated>
 <id>http://beango.github.com</id>
 <author>
   <name>HuangDing</name>
   <email>6588617@gmail.com</email>
 </author>

 
 <entry>
   <title>使用 Python 进行稳定可靠的文件操作</title>
   <link href="http://beango.github.com/archives/2013/08/01/reliable-file-updates-with-python.html"/>
   <updated>2013-08-01T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/08/01/reliable-file-updates-with-python</id>
   <content type="html">&lt;p&gt;原文出处：&lt;a href=&quot;http://blog.gocept.com/2013/07/15/reliable-file-updates-with-python/&quot;&gt;ckauhaus&lt;/a&gt;   
译文出处：&lt;a href=&quot;http://www.oschina.net/translate/reliable-file-updates-with-python&quot;&gt;oschina&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;程序需要更新文件。虽然大部分程序员知道在执行I/O的时候会发生不可预期的事情，但是我经常看到一些异常幼稚的代码。在本文中，我想要分享一些如何在Python代码中改善I/O可靠性的见解。&lt;/p&gt;

&lt;p&gt;考虑下述Python代码片段。对文件中的数据进行某些操作，然后将结果保存回文件中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with open(filename) as f:
    input = f.read()
output = do_something(input)
with open(filename, 'w') as f:
    f.write(output)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来很简单吧？可能看起来并不像乍一看这么简单。我在产品服务器中调试应用，经常会出现奇怪的行为。&lt;/p&gt;

&lt;p&gt;这是我看过的失效模式的例子：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;失控的服务器进程溢出大量日志，磁盘被填满。write()在截断文件之后抛出异常，文件将会变成空的。&lt;/li&gt;
&lt;li&gt;应用的几个实例并行执行。在各个实例结束之后，因为混合了多个实例的输出，文件内容最终变成了天书。&lt;/li&gt;
&lt;li&gt;在完成了写操作之后，应用会触发一些后续操作。几秒钟后断电。在我们重启了服务器之后，我们再一次看到了旧的文件内容。已经传递给其它应用的数据与我们在文件中看到的不再一致。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;下面没有什么新的内容。本文的目的是为在系统编程方面缺少经验的Python开发者提供常见的方法和技术。我将会提供代码例子，使得开发者可以很容易的将这些方法应用到自己的代码中。&lt;/p&gt;

&lt;h2&gt;“可靠性”意味着什么？&lt;/h2&gt;

&lt;p&gt;广义的讲，可靠性意味着在所有规定的条件下操作都能执行它所需的函数。至于文件的操作，这个函数就是创建，替换或者追加文件的内容的问题。这里可以从数据库理论上获得灵感。经典的事务模型的ACID性质作为指导来提高可靠性。&lt;/p&gt;

&lt;p&gt;开始之前，让我们先看看我们的例子怎样和ACID4个性质扯上关系：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原子性(Atomicity)&lt;/strong&gt;要求这个事务要么完全成功，要么完全失败。在上面的实例中，磁盘满了可能导致部分内容写入文件。另外，如果正当在写入内容时其它程序又在读取文件，它们可能获得是部分完成的版本，甚至会导致写错误&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性(Consistency)&lt;/strong&gt;?表示操作必须从系统的一个状态到另一个状态。一致性可以分为两部分：内部和外部一致性。内部一致性是指文件的数据结构是一致的。外部一致性是指文件的内容与它相关的数据是相符合的。在这个例子中，因为我们不了解这个应用，所以很难推断是否符合一致性。但是因为一致性需要原子性，我们至少可以说没有保证内部一致性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离性(Isolation)&lt;/strong&gt;如果在并发的执行事务中，多个相同的事务导致了不同的结果，就违反了隔离性。很明显上面的代码对操作失败或者其它&lt;a href=&quot;http://drtom.ch/posts/2011/11/12/The_Lost_Update_Problem_-_Part_1/&quot;&gt;隔离性失败&lt;/a&gt;都没有保护。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久性(Durability)&lt;/strong&gt;意味着改变是持久不变的。在我们告诉用户成功之前，我们必须确保我们的数据存储是可靠的并且不只是一个写缓存。上面的代码已经成功写入数据的前提是假设我们调用write()函数，磁盘I/O就立即执行。但是POSIX标准是不保证这个假设的。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;尽可能使用数据库系统&lt;/h2&gt;

&lt;p&gt;如果我们能够获得ACID
四个性质，那么我们增加可靠性方面取得了长远发展。但是这需要很大的编码功劳。为什么重复发明轮子？大多数数据库系统已经有ACID事务了。&lt;/p&gt;

&lt;p&gt;可靠性数据存储已经是一个已解决的问题。如果你需要可靠性存储，请使用数据库。很可能，没有几十年的功夫，你自己解决这方面的能力没有那些已经专注这方面好些年的人好。如果你不想安装一个大数据库服务器，那么你可以使用&lt;a href=&quot;http://www.sqlite.org/&quot;&gt;sqlite&lt;/a&gt;,它具有ACID事务，很小，免费的，而且它包含在Python的&lt;a href=&quot;http://docs.python.org/3/library/sqlite3.html&quot;&gt;标准库&lt;/a&gt;中。&lt;/p&gt;

&lt;p&gt;文章本该在这里就结束的，但是还有一些有根有据的原因，就是不使用数据。它们通常是文件格式或者文件位置约束。这两个在数据库系统中都不好控制。理由如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们必须处理其它应用产生的固定格式或者在固定位置的文件，&lt;/li&gt;
&lt;li&gt;我们必须为了其它应用的消耗而写文件（和应用了同样的限制条件）&lt;/li&gt;
&lt;li&gt;我们的文件必须方便人阅读或者修改。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;…等等。你懂的。&lt;/p&gt;

&lt;p&gt;如果我们自己动手实现可靠的文件更新，那么这里有一些编程技术供参考。下面我将展示四种常见的操作文件更新模式。在那之后，我会讨论采取哪些步骤在每个文件更新模式下满足ACID性质。&lt;/p&gt;

&lt;h2&gt;文件更新模式&lt;/h2&gt;

&lt;p&gt;文件可以以多种方式更新，但是我认为至少有四种常见的模式。这四种模式将做为本文剩余部分的基础。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;截断-写&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这可能是最基本的模式。在下述例子中，假设的域模型代码读数据，执行一些计算，然后以写模式重新打开存在的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with open(filename, 'r') as f:
   model.read(f)
model.process()
with open(filename, 'w') as f:
   model.write(f)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此模式的一个变种以读写模式打开文件（Python中的“加”模式），寻找到开始的位置，显式调用truncate()，重写文件内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with open(filename, 'a+') as f:
   f.seek(0)
   model.input(f.read())
   model.compute()
   f.seek(0)
   f.truncate()
   f.write(model.output())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该变种的优势是只打开文件一次，始终保持文件打开。举例来说，这样可以简化加锁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;写-替换&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外一种广泛使用的模式是将新内容写到临时文件，之后替换原始文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with tempfile.NamedTemporaryFile(
      'w', dir=os.path.dirname(filename), delete=False) as tf:
   tf.write(model.output())
   tempname = tf.name
os.rename(tempname, filename)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法与截断-写方法相比对错误更具有鲁棒性。请看下面对原子性和一致性的讨论。很多应用使用该方法。&lt;/p&gt;

&lt;p&gt;这两个模式很常见，以至于linux内核中的ext4文件系统甚至可以自动检测到这些模式，自动修复一些可靠性缺陷。但是不要依赖这一特性：你并不是总是使用ext4，而且管理员可能会关掉这一特性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;追加&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;第三种模式就是追加新数据到已存在的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with open(filename, 'a') as f:
   f.write(model.output())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个模式用来写日志文件和其它累积处理数据的任务。从技术上讲，它的显著特点就是极其简单。一个有趣的扩展应用就是常规操作中只通过追加操作更新，然后定期重新整理文件，使之更紧凑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;spooldir&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里我们将目录做为逻辑数据存储，为每条记录创建新的唯一命名的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with open(unique_filename(), 'w') as f:
   f.write(model.output())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该模式与附加模式一样具有累积的特点。一个巨大的优势是我们可以在文件名中放入少量元数据。举例来说，这可以用于传达处理状态的信息。spooldir模式的一个特别巧妙的实现是maildir格式。maildirs使用附加子目录的命名方案，以可靠的、无锁的方式执行更新操作。md和gocept.filestore库为maildir操作提供了方便的封装。&lt;/p&gt;

&lt;p&gt;如果你的文件名生成不能保证唯一的结果，甚至有可能要求文件必须实际上是新的。那么调用具有合适标志的低等级os.open()：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fd = os.open(filename, os.O_WRONLY | os.O_CREAT| os.O_EXCL, 0o666)
with os.fdopen(fd, 'w') as f:
   f.write(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在以O_EXCL方式打开文件后，我们用os.fdopen将原始的文件描述符转化为普通的Python文件对象。&lt;/p&gt;

&lt;h2&gt;应用ACID属性到文件更新&lt;/h2&gt;

&lt;p&gt;下面，我将尝试加强文件更新模式。反过来让我们看看可以做些什么来满足ACID属性。我将会尽可能保持简单，因为我们并不是要写一个完整的数据库系统。请注意本节的材料并不彻底，但是可以为你自己的实验提供一个好的起点.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原子性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;写-替换&lt;/strong&gt;模式提供了原子性，因为底层的&lt;em&gt;os.rename()&lt;/em&gt;&lt;a href=&quot;http://rcrowley.org/2010/01/06/things-unix-can-do-atomically.html&quot;&gt;是原子性的&lt;/a&gt;。这意味着在任意给定时间点，进程或者看到旧的文件，或者看到新的文件。该模式对写错误具有天然的鲁棒性：如果写操作触发异常，重命名操作就不会被执行，所有就没有用损坏的新文件覆盖正确的旧文件的风险。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;附加&lt;/strong&gt;模式并不是原子性的，因为有附加不完整记录的风险。但是有个技巧可以使更新具有原子性：为每个写操作标注校验和。之后读日志的时候，忽略所有没有有效校验和的记录。以这种方式，只有完整的记录才会被处理。在下面的例子中，应用做周期性的测量，每次在日志中附加一行JSON记录。我们计算记录的字节表示形式的CRC32校验和，然后附加到同一行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with open(logfile, 'ab') as f:
    for i in range(3):
        measure = {'timestamp': time.time(), 'value': random.random()}
        record = json.dumps(measure).encode()
        checksum = '{:8x}'.format(zlib.crc32(record)).encode()
        f.write(record + b' ' + checksum + b'\n')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该例子代码通过每次创建随机值模拟测量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat log
{&quot;timestamp&quot;: 1373396987.258189, &quot;value&quot;: 0.9360123151217828} 9495b87a
{&quot;timestamp&quot;: 1373396987.25825, &quot;value&quot;: 0.40429005476999424} 149afc22
{&quot;timestamp&quot;: 1373396987.258291, &quot;value&quot;: 0.232021160265939} d229d937
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想要处理这个日志文件，我们每次读一行记录，分离校验和，与读到的记录比较。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with open(logfile, 'rb') as f:
    for line in f:
        record, checksum = line.strip().rsplit(b' ', 1)
        if checksum.decode() == '{:8x}'.format(zlib.crc32(record)):
            print('read measure: {}'.format(json.loads(record.decode())))
        else:
            print('checksum error for record {}'.format(record))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们通过截断最后一行模拟被截断的写操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat log
{&quot;timestamp&quot;: 1373396987.258189, &quot;value&quot;: 0.9360123151217828} 9495b87a
{&quot;timestamp&quot;: 1373396987.25825, &quot;value&quot;: 0.40429005476999424} 149afc22
{&quot;timestamp&quot;: 1373396987.258291, &quot;value&quot;: 0.23202
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当读日志的时候，最后不完整的一行被拒绝：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ read_checksummed_log.py log
read measure: {'timestamp': 1373396987.258189, 'value': 0.9360123151217828}
read measure: {'timestamp': 1373396987.25825, 'value': 0.40429005476999424}
checksum error for record b'{&quot;timestamp&quot;: 1373396987.258291, &quot;value&quot;:'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加校验和到日志记录的方法被用于大量应用，包括很多数据库系统。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;spooldir&lt;/strong&gt;中的单个文件也可以在每个文件中添加校验和。另外一个可能更简单的方法是借用写-替换模式：首先将文件写到一边，然后移到最终的位置。设计一个保护正在被消费者处理的文件的命名方案。在下面的例子中，所有以.tmp结尾的文件都会被读取程序忽略，因此在写操作的时候可以安全的使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;newfile = generate_id()
with open(newfile + '.tmp', 'w') as f:
   f.write(model.output())
os.rename(newfile + '.tmp', newfile)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，&lt;strong&gt;截断-写&lt;/strong&gt;是非原子性的。很遗憾我不能提供满足原子性的变种。在执行完截取操作后，文件是空的，还没有新内容写入。如果并发的程序现在读文件或者有异常发生，程序中止，我们既看不久的版本也看不到新的版本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一致性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我谈论的关于原子性的大部分内容也可以应用到一致性。实际上，原子性更新是内部一致性的前提条件。外部一致性意味着同步更新几个文件。这不容易做到，锁文件可以用来确保读写访问互不干涉。考虑某目录下的文件需要互相保持一致。常用的模式是指定锁文件，用来控制对整个目录的访问。&lt;/p&gt;

&lt;p&gt;写程序的例子:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with open(os.path.join(dirname, '.lock'), 'a+') as lockfile:
   fcntl.flock(lockfile, fcntl.LOCK_EX)
   model.update(dirname)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读程序的例子:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with open(os.path.join(dirname, '.lock'), 'a+') as lockfile:
   fcntl.flock(lockfile, fcntl.LOCK_SH)
   model.readall(dirname)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法只有控制所有读程序才生效。因为每次只有一个写程序活动（独占锁阻塞所有共享锁），所有该方法的可扩展性有限。&lt;/p&gt;

&lt;p&gt;更进一步，我们可以对整个目录应用&lt;strong&gt;写-替换&lt;/strong&gt;模式。这涉及为每次更新创建新的目录，更新完成后改变符合链接。举例来说，镜像应用维护一个包含压缩包和列出了文件名、文件大小和校验和的索引文件的目录。当上流的镜像更新，仅仅隔离地对压缩包和索引文件进项原子性更新是不够的。相反，我们需要同时提供压缩包和索引文件以免校验和不匹配。为了解决这个问题，我们为每次生成维护一个子目录，然后改变符号链接激活该次生成。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mirror
|-- 483
|   |-- a.tgz
|   |-- b.tgz
|   `-- index.json
|-- 484
|   |-- a.tgz
|   |-- b.tgz
|   |-- c.tgz
|   `-- index.json
`-- current -&amp;gt; 483
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新的生成484正在被更新的过程中。当所有压缩包准备好，索引文件更新后，我们可以用一次原子调用os.symlink()来切换current符号链接。其它应用总是或者看到完全旧的或者完全新的生成。读程序需要使用os.chdir()进入current目录，很重要的是不要用完整路径名指定文件。否在当读程序打开current/index.json，然后打开current/a.tgz，但是同时符号链接已经改变时就会出现竞争条件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;隔离性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;隔离性意味着对同一文件的并发更新是&lt;em&gt;可串行化&lt;/em&gt;的——存在一个串行调度使得实际执行的并行调度返回相同的结果。“真实的”数据库系统使用像&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiversion_concurrency_control&quot;&gt;MVCC&lt;/a&gt;这种高级技术维护可串行性，同时允许高等级的可并行性。回到我们的场景，我们最后使用加锁来串行文件更新。&lt;/p&gt;

&lt;p&gt;对&lt;strong&gt;截断-写&lt;/strong&gt;更新进行加锁是容易的。仅仅在所有文件操作前获取一个独占锁就可以。下面的例子代码从文件中读取一个整数，然后递增，最后更新文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def update():
 with open(filename, 'r+') as f:
 fcntl.flock(f, fcntl.LOCK_EX)
 n = int(f.read())
 n += 1
 f.seek(0)
 f.truncate()
f.write('{}\n'.format(n))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;strong&gt;写-替换&lt;/strong&gt;模式加锁更新就有点儿麻烦啦。像?&lt;em&gt;截断-写&lt;/em&gt;那样使用锁可能导致更新冲突。某个幼稚的实现可能看起来像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def update():
   with open(filename) as f:
      fcntl.flock(f, fcntl.LOCK_EX)
      n = int(f.read())
      n += 1
      with tempfile.NamedTemporaryFile(
            'w', dir=os.path.dirname(filename), delete=False) as tf:
         tf.write('{}\n'.format(n))
         tempname = tf.name
      os.rename(tempname, filename)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码有什么问题呢？设想两个进程竞争更新某个文件。第一个进程运行在前面，但是第二个进程阻塞在fcntl.flock()调用。当第一个进程替换了文件，释放了锁，现在在第二个进程中打开的文件描述符指向了一个包含旧内容的“幽灵”文件（任意路径名都不可达）。想要避免这个冲突，我们必须检查打开的文件是否与fcntl.flock()返回的相同。所以我写了一个新的LockedOpen上下文管理器来替换内建的open上下文。来确保我们实际打开了正确的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class LockedOpen(object):

    def __init__(self, filename, *args, **kwargs):
        self.filename = filename
        self.open_args = args
        self.open_kwargs = kwargs
        self.fileobj = None

    def __enter__(self):
        f = open(self.filename, *self.open_args, **self.open_kwargs)
        while True:
            fcntl.flock(f, fcntl.LOCK_EX)
            fnew = open(self.filename, *self.open_args, **self.open_kwargs)
            if os.path.sameopenfile(f.fileno(), fnew.fileno()):
                fnew.close()
                break
            else:
                f.close()
                f = fnew
        self.fileobj = f
        return f

    def __exit__(self, _exc_type, _exc_value, _traceback):
        self.fileobj.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;br&gt;


&lt;pre&gt;&lt;code&gt;def update(self):
    with LockedOpen(filename, 'r+') as f:
        n = int(f.read())
        n += 1
        with tempfile.NamedTemporaryFile(
                'w', dir=os.path.dirname(filename), delete=False) as tf:
            tf.write('{}\n'.format(n))
            tempname = tf.name
        os.rename(tempname, filename)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给&lt;strong&gt;追加&lt;/strong&gt;更新上锁如同给截断-写更新上锁一样简单：需要一个排他锁，然后追加就完成了。需要长期运行的会将文件长久的打开的进程，可以在更新时释放锁，让其它进入。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;spooldir模式&lt;/strong&gt;有个很优美的性质就是它不需要任何锁。此外，你建立在使用灵活的命名模式和一个健壮的文件名分代。&lt;a href=&quot;http://cr.yp.to/proto/maildir.html&quot;&gt;邮件目录规范&lt;/a&gt;就是一个spooldir模式的好例子。它可以很容易的适应其它情况，不仅仅是处理邮件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;持久性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;持久性有点特殊，因为它不仅依赖于应用，也与OS和硬件配置有关。理论上来说，我们可以假定，如果数据没有到达持久存储，os.fsync()或os.fdatasync()调用就没有返回结果。在实际情况中，我们有可能会遇到几个问题：我们可能会面对不完整的fsync实现，或者糟糕的磁盘控制器配置，它们都无法提供任何持久化的保证。有一个来自?&lt;a href=&quot;http://www.oscon.com/oscon2008/public/schedule/detail/3172&quot;&gt;MySQL 开发者&lt;/a&gt;?的讨论对哪里会发生错误进行了详尽的讨论。有些像PostgreSQL之类的数据库系统，甚至提供了&lt;a href=&quot;http://www.postgresql.org/docs/9.2/static/runtime-config-wal.html&quot;&gt;持久化机制的选择&lt;/a&gt;?，以便管理员在运行时刻选择最佳的一个。然而不走运的人只能使用os.fsync()，并期待它可以被正确的实现。&lt;/p&gt;

&lt;p&gt;通过&lt;strong&gt;截断-写&lt;/strong&gt;模式，在结束写操作以后关闭文件以前，我们需要发送一个同步信号。注意通常这还牵涉到另一个层次的写缓存。&lt;em&gt;glibc&lt;/em&gt;?&lt;em&gt;缓存&lt;/em&gt;?甚至会在写操作传递到内核以前，在进程内部拦住它。同样为了得到空的glibc缓存，我们需要在同步以前对它flush()：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with open(filename, 'w') as f:
   model.write(f)
   f.flush()
   os.fdatasync(f)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要不，你也可以带参数&lt;strong&gt;-u&lt;/strong&gt;调用Python，以此为所有的文件I/O获得未缓冲的写。&lt;/p&gt;

&lt;p&gt;大多数时候相较os.fsync()我更喜欢os.fdatasync()，以此避免同步元数据的更新（所有权、大小、mtime…）。元数据的更新可最终导致磁盘I/O搜索操作，这会使整个过程慢不少。&lt;/p&gt;

&lt;p&gt;对&lt;strong&gt;写-替换&lt;/strong&gt;风格更新使用同样的技巧只是成功了一半。我们得确保在代替旧文件之前，新写入文件的内容已经写入了非易失性存储器上了，但是替换操作怎么办？我们不能保证那个目录更新是否执行的刚刚好。在网络上有很多关于&lt;a href=&quot;http://stackoverflow.com/questions/3764822/how-to-durably-rename-a-file-in-posix/5809073#5809073&quot;&gt;怎么让同步目录更新&lt;/a&gt;的长篇大论。但是在我们这种情况，旧文件和新文件都在同一个目录下，我们可以使用简单的解决方案来逃避这个这题。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;os.rename(tempname, filename)
dirfd = os.open(os.path.dirname(filename), os.O_DIRECTORY)
os.fsync(dirfd)
os.close(dirfd)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们调用底层的os.open()来打开目录(Python自带的open()方法不支持打开目录)，然后在目录文件描述符上执行os.fsync()。&lt;/p&gt;

&lt;p&gt;对待&lt;strong&gt;追加&lt;/strong&gt;更新和我以及说过的&lt;strong&gt;截断-写&lt;/strong&gt;是相似的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;spooldir&lt;/strong&gt;模式与写-替换模式同样的目录同步问题。幸运地是，可以使用同样的解决方案：第一步同步文件，然后同步目录。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;这使可靠的更新文件成为可能。我已经演示了满足ACID的四大性质。这些展示的实例代码充当一个工具箱。掌握这编程技术最大的满足你的需求。有时，你并不需要满足所有的ACID性质，可能仅仅需要一到两个。我希望这篇文章可以帮助你去做已充分了解的决定，什么该去实现以及什么该舍弃。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>NoSQL数据库的分布式算法</title>
   <link href="http://beango.github.com/archives/2013/07/23/distributed-algorithms-in-nosql-databases.html"/>
   <updated>2013-07-23T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/07/23/distributed-algorithms-in-nosql-databases</id>
   <content type="html">&lt;p&gt;原文出处：&lt;a href=&quot;http://highlyscalable.wordpress.com/2012/09/18/distributed-algorithms-in-nosql-databases/&quot;&gt;highlyscalable.wordpress.com&lt;/a&gt;   译文出处：&lt;a href=&quot;http://my.oschina.net/juliashine/blog/88173&quot;&gt;juliashine&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;系统的可扩展性是推动&lt;a href=&quot;http://blog.jobbole.com/1344/&quot; title=&quot;8种Nosql数据库系统对比&quot;&gt;NoSQL&lt;/a&gt;运动发展的的主要理由，包含了分布式系统协调，故障转移，资源管理和许多其他特性。这么讲使得NoSQL听起来像是一个大筐，什么都能塞进去。尽管NoSQL运动并没有给分布式数据处理带来根本性的技术变革，但是依然引发了铺天盖地的关于各种协议和算法的研究以及实践。正是通过这些尝试逐渐总结出了一些行之有效的数据库构建方法。在这篇文章里，我将针对&lt;a href=&quot;http://blog.jobbole.com/1344/&quot; title=&quot;8种Nosql数据库系统对比&quot;&gt;nosql数据库&lt;/a&gt;的分布式特点进行一些系统化的描述。&lt;/p&gt;

&lt;p&gt;接下来我们将研究一些分布式策略，比如故障检测中的复制，这些策略用黑体字标出，被分为三段：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据一致性。NoSQL需要在分布式系统的一致性，容错性和性能，低延迟及高可用之间作出权衡，一般来说，数据一致性是一个必选项，所以这一节主要是关于&lt;strong&gt;数据复制&lt;/strong&gt;和&lt;strong&gt;数据恢复&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;数据放置。一个数据库产品应该能够应对不同的数据分布，集群拓扑和硬件配置。在这一节我们将讨论如何&lt;strong&gt;分布&lt;/strong&gt;以及&lt;strong&gt;调整数据分布&lt;/strong&gt;才能够能够及时解决故障，提供持久化保证，高效查询和保证集群中的资源（如内存和硬盘空间）得到均衡使用。&lt;/li&gt;
&lt;li&gt;对等系统。像 &lt;strong&gt;leader election&lt;/strong&gt; 这样的的技术已经被用于多个数据库产品以实现容错和数据强一致性。然而，即使是分散的的数据库（无中心）也要跟踪它们的全局状态，检测故障和拓扑变化。这一节将介绍几种使系统保持一致状态的技术。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;&lt;strong&gt;数据一致性&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;众所周知，分布式系统经常会遇到网络隔离或是延迟的情况，在这种情况下隔离的部分是不可用的，因此要保持高可用性而不牺牲一致性是不可能的。这一事实通常被称作“CAP理论”。然而，一致性在分布式系统中是一个非常昂贵的东西，所以经常需要在这上面做一些让步，不只是针对可用性，还有多种权衡。为了研究这些权衡，我们注意到分布式系统的一致性问题是由数据隔离和复制引起的，所以我们将从研究复制的特点开始：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可用性。在网络隔离的情况下剩余部分仍然可以应对读写请求。&lt;/li&gt;
&lt;li&gt;读写延迟。读写请求能够在短时间内处理。&lt;/li&gt;
&lt;li&gt;读写延展性。读写的压力可由多个节点均衡分担。&lt;/li&gt;
&lt;li&gt;容错性。对于读写请求的处理不依赖于任何一个特定节点。&lt;/li&gt;
&lt;li&gt;数据持久性。特定条件下的节点故障不会造成数据丢失。&lt;/li&gt;
&lt;li&gt;一致性。一致性比前面几个特性都要复杂得多，我们需要详细讨论一下几种不同的观点。但是我们不会涉及过多的一致性理论和并发模型，因为这已经超出了本文的范畴，我只会使用一些简单特点构成的精简体系。

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;读写一致性。从读写的观点来看，数据库的基本目标是使副本趋同的时间尽可能短（即更新传递到所有副本的时间），保证最终一致性。除了这个较弱的保证，还有一些更强的一致性特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;写后读一致性。在数据项X上写操作的效果总是能够被后续的X上的读操作看见。&lt;/li&gt;
&lt;li&gt;读后读一致性。在一次对数据项X的读操作之后，后续对X的读操作应该返回与第一次的返回值相同或是更加新的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;写一致性。分区的数据库经常会发生写冲突。数据库应当能处理这种冲突并保证多个写请求不会被不同的分区所处理。这方面数据库提供了几种不同的一致性模型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;原子写。假如数据库提供了API，一次写操作只能是一个单独的原子性的赋值，避免写冲突的办法是找出每个数据的“最新版本”。这使得所有的节点都能够在更新结束时获得同一版本，而与更新的顺序无关，网络故障和延迟经常造成各节点更新顺序不一致。
数据版本可以用时间戳或是用户指定的值来表示。Cassandra用的就是这种方法。&lt;/li&gt;
&lt;li&gt;原子化的读-改-写。应用有时候需要进行 读-改-写
序列操作而非单独的原子写操作。假如有两个客户端读取了同一版本的数据，修改并且把修改后的数据写回，按照原子写模型，时间上比较靠后的那一次更新将会覆盖前一次。这种行为在某些情况下是不正确的（例如，两个客户端往同一个列表值中添加新值）。数据库提供了至少两种解决方法：

&lt;ul&gt;
&lt;li&gt;冲突预防。 读-改-写 可以被认为是一种特殊情况下的事务，所以分布式锁或是 PAXOS [20, 21]这样的一致协议都可以解决这种问题。这种技术支持原子读改写语义和任意隔离级别的事务。另一种方法是避免分布式的并发写操作，将对特定数据项的所有写操作路由到单个节点上（可以是全局主节点或者分区主节点）。为了避免冲突，数据库必须牺牲网络隔离情况下的可用性。这种方法常用于许多提供强一致性保证的系统（例如大多数关系数据库，HBase，MongoDB）。&lt;/li&gt;
&lt;li&gt;冲突检测。数据库跟踪并发更新的冲突，并选择回滚其中之一或是维持两个版本交由客户端解决。并发更新通常用向量时钟 [19]（这是一种乐观锁）来跟踪，或者维护一个完整的版本历史。这个方法用于 Riak, Voldemort, CouchDB.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;现在让我们仔细看看常用的复制技术，并按照描述的特点给他们分一下类。第一幅图描绘了不同技术之间的逻辑关系和不同技术在系统的一致性、扩展性、可用性、延迟性之间的权衡坐标。
第二张图详细描绘了每个技术。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-07/NoSQL.png&quot; title=&quot;NoSQL&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-07/NoSQL2.png&quot; title=&quot;NoSQL2&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;复本因子是4。读写协调者可以是一个外部客户端或是一个内部代理节点。&lt;/p&gt;

&lt;p&gt;我们会依据一致性从弱到强把所有的技术过一遍：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;（A, 反熵）一致性最弱，基于策略如下。写操作的时候选择任意一个节点更新，在读的时候如果新数据还没有通过后台的反熵协议传递到读的那个节点，那么读到的仍然是旧数据。（下一节会详细介绍反熵协议）。这种方法的主要特点是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;过高的传播延迟使它在数据同步方面不太好用，所以比较典型的用法是只作为辅助性的功能来检测和修复计划外的不一致。Cassandra就使用了反熵算法来在各节点之间传递数据库拓扑和其他一些元数据信息。&lt;/li&gt;
&lt;li&gt;一致性保证较弱：即使在没有发生故障的情况下，也会出现写冲突与读写不一致。&lt;/li&gt;
&lt;li&gt;在网络隔离下的高可用和健壮性。用异步的批处理替代了逐个更新，这使得性能表现优异。&lt;/li&gt;
&lt;li&gt;持久性保障较弱因为新的数据最初只有单个副本。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;（B）对上面模式的一个改进是在任意一个节点收到更新数据请求的同时异步的发送更新给所有可用节点。这也被认为是定向的反熵。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;与纯粹的反熵相比，这种做法只用一点小小的性能牺牲就极大地提高了一致性。然而，正式一致性和持久性保持不变。&lt;/li&gt;
&lt;li&gt;假如某些节点因为网络故障或是节点失效在当时是不可用的，更新最终也会通过反熵传播过程来传递到该节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;（C） 在前一个模式中，使用提示移交技术 [8] 可以更好地处理某个节点的操作失败。对于失效节点的预期更新被记录在额外的代理节点上，并且标明一旦特点节点可用就要将更新传递给该节点。这样做提高了一致性，降低了复制收敛时间。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;（D,一次性读写）因为提示移交的责任节点也有可能在将更新传递出去之前就已经失效，在这种情况下就有必要通过所谓的读修复来保证一致性。每个读操作都会启动一个异步过程，向存储这条数据的所有节点请求一份数据摘要（像签名或者hash），如果发现各节点返回的摘要不一致则统一各节点上的数据版本。我们用一次性读写来命名组合了A、B、C、D的技术-
他们都没有提供严格的一致性保证，但是作为一个自备的方法已经可以用于实践了。&lt;/li&gt;
&lt;li&gt;（E, 读若干写若干）上面的策略是降低了复制收敛时间的启发式增强。为了保证更强的一致性，必须牺牲可用性来保证一定的读写重叠。
通常的做法是同时写入W个副本而不是一个，读的时候也要读R个副本。

&lt;ul&gt;
&lt;li&gt;首先，可以配置写副本数W&gt;1。&lt;/li&gt;
&lt;li&gt;其次，因为R+W&gt;N，写入的节点和读取的节点之间必然会有重叠，所以读取的多个数据副本里至少会有一个是比较新的数据（上面的图中 W=2, R=3, N=4）。这样在读写请求依序进行的时候（写执行完再读）能够保证一致性（对于单个用户的读写一致性），但是不能保障全局的读一致性。用下面图示里的例子来看，R=2，W=2，N=3，因为写操作对于两个副本的更新是非事务的，在更新没有完成的时候读就可能读到两个都是旧值或者一新一旧：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/assets/files/2013-07/NoSQL3.png&quot; title=&quot;NoSQL3&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于某种读延迟的要求，设置R和W的不同值可以调整写延迟与持久性，反之亦然。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果W&amp;lt;=N/2，并发的多个写入会写到不同的若干节点（如，写操作A写前N/2个，B写后N/2个）。
设置 W&gt;N/2 可以保证在符合回滚模型的原子读改写时及时检测到冲突。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;严格来讲，这种模式虽然可以容忍个别节点的失效，
但是对于网络隔离的容错性并不好。在实践中，常使用”近似数量通过“这样的方法，通过牺牲一致性来提高某些情景下的可用性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;（F,读全部写若干）读一致性问题可以通过在读数据的时候访问所有副本（读数据或者检查摘要）来减轻。这确保了只要有至少一个节点上的数据更新新的数据就能被读取者看到。但是在网络隔离的情况下这种保证就不能起到作用了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;（G, 主从） 这种技术常被用来提供原子写或者
冲突检测持久级别的读改写。为了实现冲突预防级别，必须要用一种集中管理方式或者是锁。最简单的策略是用主从异步复制。对于特定数据项的写操作全部被路由到一个中心节点，并在上面顺序执行。这种情况下主节点会成为瓶颈，所以必须要将数据划分成一个个独立的片区（不同片有不同的master），这样才能提供扩展性。&lt;/li&gt;
&lt;li&gt;（H, Transactional Read Quorum Write Quorum and Read One Write All）?
更新多个副本的方法可以通过使用事务控制技术来避免写冲突。
众所周知的方法是使用两阶段提交协议。但两阶段提交并不是完全可靠的，因为协调者失效可能会造成资源阻塞。
PAXOS提交协议 [20, 21] 是更可靠的选择，但会损失一点性能。
在这个基础上再向前一小步就是读一个副本写所有副本，这种方法把所有副本的更新放在一个事务中，它提供了强容错一致性但会损失掉一些性能和可用性。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;上面分析中的一些权衡有必要再强调一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一致性与可用性。&lt;/strong&gt;?严密的权衡已经由CAP理论给出了。在网络隔离的情况下，数据库要么将数据集中，要么既要接受数据丢失的风险。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性与扩展性。&lt;/strong&gt;?看得出即使读写一致性保证降低了副本集的扩展性，只有在原子写模型中才可以以一种相对可扩展的方式处理写冲突。原子读改写模型通过给数据加上临时性的全局锁来避免冲突。这表明，
数据或操作之间的依赖，即使是很小范围内或很短时间的，也会损害扩展性。所以精心设计数据模型，将数据分片分开存放对于扩展性非常重要。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性与延迟。&lt;/strong&gt;?如上所述，当数据库需要提供强一致性或者持久性的时候应该偏向于读写所有副本技术。但是很明显一致性与请求延迟成反比，所以使用若干副本技术会是比较中允的办法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;故障转移与一致性/扩展性/延迟。&lt;/strong&gt;有趣的是容错性与一致性、扩展性、延迟的取舍冲突并不剧烈。通过合理的放弃一些性能与一致性，集群可以容忍多达 up to 的节点失效。这种折中在两阶段提交与 PAXOS
协议的区别里体现得很明显。这种折中的另一个例子是增加特定的一致性保障，比如使用严格会话进程的“读己所写”，但这又增加了故障转移的复杂性[22]。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;&lt;strong&gt;反熵协议， 谣言传播算法&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;让我们从以下场景开始：&lt;/p&gt;

&lt;p&gt;有许多节点，每条数据会在其中的若干的节点上面存有副本。每个节点都可以单独处理更新请求，每个节点定期和其他节点同步状态，如此一段时间之后所有的副本都会趋向一致。同步过程是怎样进行的？同步何时开始？怎样选择同步的对象？怎么交换数据？我们假定两个节点总是用较新版本的数据覆盖旧的数据或者两个版本都保留以待应用层处理。&lt;/p&gt;

&lt;p&gt;这个问题常见于数据一致性维护和集群状态同步（如集群成员信息传播）等场景。虽然引入一个监控数据库并制定同步计划的协调者可以解决这个问题，但是去中心化的数据库能够提供更好的容错性。去中心化的主要做法是利用精心设计的传染协议[7]，这种协议相对简单，但是提供了很好的收敛时间，而且能够容忍任何节点的失效和网络隔离。尽管有许多类型的传染算法，我们只关注反熵协议，因为NoSQL数据库都在使用它。&lt;/p&gt;

&lt;p&gt;反熵协议假定同步会按照一个固定进度表执行，每个节点定期随机或是按照某种规则选择另外一个节点交换数据，消除差异。有三种反风格的反熵协议：推，拉和混合。推协议的原理是简单选取一个随机节点然后把数据状态发送过去。在真实应用中将全部数据都推送出去显然是愚蠢的，所以节点一般按照下图所示的方式工作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-07/NoSQL4.png&quot; title=&quot;NoSQL4&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;节点A作为同步发起者准备好一份数据摘要，里面包含了A上数据的指纹。节点B接收到摘要之后将摘要中的数据与本地数据进行比较，并将数据差异做成一份摘要返回给A。最后，A发送一个更新给B，B再更新数据。拉方式和混合方式的协议与此类似，就如上图所示的。&lt;/p&gt;

&lt;p&gt;反熵协议提供了足够好的收敛时间和扩展性。下图展示了一个在100个节点的集群中传播一个更新的模拟结果。在每次迭代中，每个节点只与一个随机选取的对等节点发生联系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-07/NoSQL5.png&quot; title=&quot;NoSQL5&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，拉方式的收敛性比推方式更好，这可以从理论上得到证明[7]。而且推方式还存在一个“收敛尾巴”的问题。在多次迭代之后，尽管几乎遍历到了所有的节点，但还是有很少的一部分没受到影响。与单纯的推和拉方式相比，混合方式的效率更高，所以实际应用中通常使用这种方式。反熵是可扩展的，因为平均转换时间以集群规模的对数函数形式增长。&lt;/p&gt;

&lt;p&gt;尽管这些技术看起来很简单，仍然有许多研究关注于不同约束条件下反熵协议的性能表现。其中之一通过一种更有效的结构使用网络拓扑来取代随机选取[10]。在网络带宽有限的条件下调整传输率或使用先进的规则来选取要同步的数据[9]。摘要计算也面临挑战，数据库会维护一份最近更新的日志以有助于摘要计算。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;最终一致数据类型Eventually Consistent Data Types&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;在上一节我们假定两个节点总是合并他们的数据版本。但要解决更新冲突并不容易，让所有副本都最终达到一个语义上正确的值出乎意料的难。一个众所周知的例子是Amazon Dynamo数据库[8]中已经删除的条目可以重现。&lt;/p&gt;

&lt;p&gt;我们假设一个例子来说明这个问题：数据库维护一个逻辑上的全局计数器，每个节点可以增加或者减少计数。虽然每个节点可以在本地维护一个自己的值，但这些本地计数却不能通过简单的加减来合并。假设这样一个例子：有三个节点A、B和C，每个节点执行了一次加操作。如果A从B获得一个值，并且加到本地副本上，然后C从B获得值，然后C再从A获得值，那么C最后的值是4，而这是错误的。解决这个问题的方法是用一个类似于向量时钟[19]的数据结构为每个节点维护一对计数器[1]：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Counter {
   int[] plus
   int[] minus
   int NODE_ID

   increment() {
      plus[NODE_ID]++
   }

   decrement() {
      minus[NODE_ID]++
   }

   get() {
      return sum(plus) – sum(minus)
   }

   merge(Counter other) {
      for i in 1..MAX_ID {
         plus[i] = max(plus[i], other.plus[i])
         minus[i] = max(minus[i], other.minus[i])
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cassandra用类似的方法计数[11]。利用基于状态的或是基于操作的复制理论也可以设计出更复杂的最终一致的数据结构。例如，[1]中就提及了一系列这样的数据结构，包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;计数器（加减操作）&lt;/li&gt;
&lt;li&gt;集合（添加和移除操作）&lt;/li&gt;
&lt;li&gt;图（增加边或顶点，移除边或顶点）&lt;/li&gt;
&lt;li&gt;列表（插入某位置或者移除某位置）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;最终一致数据类型的功能通常是有限的，还会带来额外的性能开销。&lt;/p&gt;

&lt;h3&gt;数据放置&lt;/h3&gt;

&lt;p&gt;这部分主要关注控制在分布式数据库中放置数据的算法。这些算法负责把数据项映射到合适的物理节点上，在节点间迁移数据以及像内存这样的资源的全局调配。&lt;/p&gt;

&lt;h3&gt;均衡数据&lt;/h3&gt;

&lt;p&gt;我们还是从一个简单的协议开始，它可以提供集群节点间无缝的数据迁移。这常发生于像集群扩容（加入新节点），故障转移（一些节点宕机）或是均衡数据（数据在节点间的分布不均衡）这样的场景。如下图A中所描绘的场景 – 有三个节点，数据随便分布在三个节点上（假设数据都是key-value型）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-07/NoSQL6.png&quot; title=&quot;NoSQL6&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果数据库不支持数据内部均衡，就要在每个节点上发布数据库实例，如上面图B所示。这需要手动进行集群扩展，停掉要迁移的数据库实例，把它转移到新节点上，再在新节点上启动，如图C所示。尽管数据库能够监控到每一条记录，包括MongoDB, Oracle Coherence, 和还在开发中的 Redis Cluster 在内的许多系统仍然使用的是自动均衡技术。也即，将数据分片并把每个数据分片作为迁移的最小单位，这是基于效率的考虑。很明显分片数会比节点数多，数据分片可以在各节点间平均分布。按照一种简单的协议即可实现无缝数据迁移，这个协议可以在迁移数据分片的时候重定向客户的数据迁出节点和迁入节点。下图描绘了一个Redis Cluster中实现的get（key）逻辑的状态机。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-07/NoSQL7.png&quot; title=&quot;NoSQL7&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假定每个节点都知道集群拓扑，能够把任意key映射到相应的数据分片，把数据分片映射到节点。如果节点判断被请求的key属于本地分片，就会在本地查找（上图中上面的方框）。假如节点判断请求的key属于另一个节点X，他会发送一个永久重定向命令给客户端（上图中下方的方框）。永久重定向意味着客户端可以缓存分片和节点间的映射关系。如果分片迁移正在进行，迁出节点和迁入节点会标记相应的分片并且将分片的数据加锁逐条加锁然后开始移动。迁出节点首先会在本地查找key，如果没有找到，重定向客户端到迁入节点，假如key已经迁移完毕的话。这种重定向是一次性的，并且不能被缓存。迁入节点在本地处理重定向，但定期查询在迁移还没完成前被永久重定向。&lt;/p&gt;

&lt;h3&gt;动态环境中的数据分片和复制&lt;/h3&gt;

&lt;p&gt;我们关注的另一个问题是怎么把记录映射到物理节点。比较直接的方法是用一张表来记录每个范围的key与节点的映射关系，一个范围的key对应到一个节点，或者用key的hash值与节点数取模得到的值作为节点ID。但是hash取模的方法在集群发生更改的情况下就不是很好用，因为增加或者减少节点都会引起集群内的数据彻底重排。导致很难进行复制和故障恢复。&lt;/p&gt;

&lt;p&gt;有许多方法在复制和故障恢复的角度进行了增强。最著名的就是一致性hash。网上已经有很多关于一致性hash的介绍了，所以在这里我只提供一个基本介绍，仅仅为了文章内容的完整性。下图描绘了一致性hash的基本原理：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-07/NoSQL8.png&quot; title=&quot;NoSQL8&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一致性hash从根本上来讲是一个键值映射结构 – 它把键（通常是hash过的）映射到物理节点。键经过hash之后的取值空间是一个有序的定长二进制字符串，很显然每个在此范围内的键都会被映射到图A中A、B、C三个节点中的某一个。为了副本复制，将取值空间闭合成一个环，沿环顺时针前行直到所有副本都被映射到合适的节点上，如图B所示。换句话说，Y将被定位在节点B上，因为它在B的范围内，第一个副本应该放置在C，第二个副本放置在A，以此类推。&lt;/p&gt;

&lt;p&gt;这种结构的好处体现在增加或减少一个节点的时候，因为它只会引起临接区域的数据重新均衡。如图C所示，节点D的加入只会对数据项X产生影响而对Y无影响。同样，移除节点B（或者B失效）只会影响Y和X的副本，而不会对X自身造成影响。但是，正如参考资料[8]中所提到的，这种做法在带来好处的同时也有弱点，那就是重新均衡的负担都由邻节点承受了，它们将移动大量的数据。通过将每个节点映射到多个范围而不是一个范围可以一定程度上减轻这个问题带来的不利影响，如图D所示。这是一个折中，它避免了重新均衡数据时负载过于集中，但是与基于模块的映射相比，保持了总均衡数量适当降低。&lt;/p&gt;

&lt;p&gt;给大规模的集群维护一个完整连贯的hash环很不容易。对于相对小一点的数据库集群就不会有问题，研究如何在对等网络中将数据放置与网络路由结合起来很有意思。一个比较好的例子是Chord算法，它使环的完整性让步于单个节点的查找效率。Chord算法也使用了环映射键到节点的理念，在这方面和一致性hash很相似。不同的是，一个特定节点维护一个短列表，列表中的节点在环上的逻辑位置是指数增长的（如下图）。这使得可以使用二分搜索只需要几次网络跳跃就可以定位一个键。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-07/NoSQL9.png&quot; title=&quot;NoSQL9&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这张图画的是一个由16个节点组成的集群，描绘了节点A是如何查找放在节点D上的key的。(A) 描绘了路由，(B)描绘了环针对节点A、B、C的局部图像。在参考资料[15]中有更多关于分散式系统中的数据复制的内容。&lt;/p&gt;

&lt;h3&gt;按照多个属性的数据分片&lt;/h3&gt;

&lt;p&gt;当只需要通过主键来访问数据的时候，一致性hash的数据放置策略很有效，但是当需要按照多个属性来查询的时候事情就会复杂得多。一种简单的做法（MongoDB使用的）是用主键来分布数据而不考虑其他属性。这样做的结果是依据主键的查询可以被路由到接个合适的节点上，但是对其他查询的处理就要遍历集群的所有节点。查询效率的不均衡造成下面的问题：&lt;/p&gt;

&lt;p&gt;有一个数据集，其中的每条数据都有若干属性和相应的值。是否有一种数据分布策略能够使得限定了任意多个属性的查询会被交予尽量少的几个节点执行？&lt;/p&gt;

&lt;p&gt;HyperDex数据库提供了一种解决方案。基本思想是把每个属性视作多维空间中的一个轴，将空间中的区域映射到物理节点上。一次查询会被对应到一个由空间中多个相邻区域组成的超平面，所以只有这些区域与该查询有关。让我们看看参考资料[6]中的一个例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-07/NoSQL10.png&quot; title=&quot;NoSQL10&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每一条数据都是一条用户信息，有三个属性First Name 、Last Name 和Phone Number。这些属性被视作一个三维空间，可行的数据分布策略是将每个象限映射到一个物理节点。像“First Name = John”这样的查询对应到一个贯穿4个象限的平面，也即只有4个节点会参与处理此次查询。有两个属性限制的查询对应于一条贯穿两个象限的直线，如上图所示，因此只有2个节点会参与处理。&lt;/p&gt;

&lt;p&gt;这个方法的问题是空间象限会呈属性数的指数函数增长。结果就会是，只有几个属性限制的查询会投射到许多个空间区域，也即许多台服务器。将一个属性较多的数据项拆分成几个属性相对较少的子项，并将每个子项都映射到一个独立的子空间，而不是将整条数据映射到一个多维空间，这样可以一定程度上缓解这个问题：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-07/NoSQL11.png&quot; title=&quot;NoSQL11&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样能够提供更好的查询到节点的映射，但是增加了集群协调的复杂度，因为这种情况下一条数据会散布在多个独立的子空间，而每个子空间都对应各自的若干个物理节点，数据更新时就必须考虑事务问题。参考资料[6]有这种技术的更多介绍和实现细节。&lt;/p&gt;

&lt;h3&gt;钝化副本&lt;/h3&gt;

&lt;p&gt;有的应用有很强的随机读取要求，这就需要把所有数据放在内存里。在这种情况下，将数据分片并把每个分片主从复制通常需要两倍以上的内存，因为每个数据都要在主节点和从节点上各有一份。为了在主节点失效的时候起到代替作用，从节点上的内存大小应该和主节点一样。如果系统能够容忍节点失效的时候出现短暂中断或性能下降，也可以不要分片。&lt;/p&gt;

&lt;p&gt;下面的图描绘了4个节点上的16个分片，每个分片都有一份在内存里，副本存在硬盘上：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-07/NoSQL12.png&quot; title=&quot;NoSQL12&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;灰色箭头突出了节点2上的分片复制。其他节点上的分片也是同样复制的。红色箭头描绘了在节点2失效的情况下副本怎样加载进内存。集群内副本的均匀分布使得只需要预留很少的内存就可以存放节点失效情况下激活的副本。在上面的图里，集群只预留了1/3的内存就可以承受单个节点的失效。特别要指出的是副本的激活（从硬盘加载入内存）会花费一些时间，这会造成短时间的性能下降或者正在恢复中的那部分数据服务中断。&lt;/p&gt;

&lt;h3&gt;系统协调&lt;/h3&gt;

&lt;p&gt;在这部分我们将讨论与系统协调相关的两种技术。分布式协调是一个比较大的领域，数十年以来有很多人对此进行了深入的研究。这篇文章里只涉及两种已经投入实用的技术。关于分布式锁，consensus协议以及其他一些基础技术的内容可以在很多书或者网络资源中找到，也可以去看参考资料[17, 18, 21]。&lt;/p&gt;

&lt;h3&gt;故障检测&lt;/h3&gt;

&lt;p&gt;故障检测是任何一个拥有容错性的分布式系统的基本功能。实际上所有的故障检测协议都基于心跳通讯机制，原理很简单，被监控的组件定期发送心跳信息给监控进程（或者由监控进程轮询被监控组件），如果有一段时间没有收到心跳信息就被认为失效了。除此之外，真正的分布式系统还要有另外一些功能要求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自适应。故障检测应该能够应对暂时的网络故障和延迟，以及集群拓扑、负载和带宽的变化。但这有很大难度，因为没有办法去分辨一个长时间没有响应的进程到底是不是真的失效了，因此，故障检测需要权衡故障识别时间（花多长时间才能识别一个真正的故障，也即一个进程失去响应多久之后会被认为是失效）和虚假警报率之间的轻重。这个权衡因子应该能够动态自动调整。&lt;/li&gt;
&lt;li&gt;灵活性。乍看上去，故障检测只需要输出一个表明被监控进程是否处于工作状态的布尔值，但在实际应用中这是不够的。我们来看参考资料[12]中的一个类似MapReduce的例子。有一个由一个主节点和若干工作节点组成的分布式应用，主节点维护一个作业列表，并将列表中的作业分配给工作节点。主节点能够区分不同程度的失败。如果主节点怀疑某个工作节点挂了，他就不会再给这个节点分配作业。其次，随着时间推移，如果没有收到该节点的心跳信息，主节点就会把运行在这个节点上的作业重新分配给别的节点。最后，主节点确认这个节点已经失效，并释放所有相关资源。&lt;/li&gt;
&lt;li&gt;可扩展性和健壮性。失败检测作为一个系统功能应该能够随着系统的扩大而扩展。他应该是健壮和一致的，也即，即使在发生通讯故障的情况下，系统中的所有节点都应该有一个一致的看法（即所有节点都应该知道哪些节点是不可用的，那些节点是可用的，各节点对此的认知不能发生冲突，不能出现一部分节点知道某节点A不可用，而另一部分节点不知道的情况）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;所谓的累计失效检测器[12]可以解决前两个问题，Cassandra[16]对它进行了一些修改并应用在产品中。其基本工作流程如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于每一个被监控资源，检测器记录心跳信息到达时间Ti。&lt;/li&gt;
&lt;li&gt;计算在统计预测范围内的到达时间的均值和方差。&lt;/li&gt;
&lt;li&gt;假定到达时间的分布已知（下图包括一个正态分布的公式），我们可以计算心跳延迟（当前时间t_now和上一次到达时间Tc之间的差值）的概率，用这个概率来判断是否发生故障。如参考资料[12]中所建议的，可以使用对数函数来调整它以提高可用性。在这种情况下，输出1意味着判断错误（认为节点失效）的概率是10%，2意味着1%，以此类推。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/assets/files/2013-07/NoSQL13.png&quot; title=&quot;NoSQL13&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据重要程度不同来分层次组织监控区，各区域之间通过谣言传播协议或者中央容错库同步，这样可以满足扩展性的要求，又可以防止心跳信息在网络中泛滥[14]。如下图所示（6个故障检测器组成了两个区域，互相之间通过谣言传播协议或者像ZooKeeper这样的健壮性库来联系）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-07/NoSQL14.png&quot; title=&quot;NoSQL14&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;协调者竞选&lt;/h3&gt;

&lt;p&gt;协调者竞选是用于强一致性数据库的一个重要技术。首先，它可以组织主从结构的系统中主节点的故障恢复。其次，在网络隔离的情况下，它可以断开处于少数的那部分节点，以避免写冲突。&lt;/p&gt;

&lt;p&gt;Bully 算法是一种相对简单的协调者竞选算法。MongoDB 用了这个算法来决定副本集中主要的那一个。Bully 算法的主要思想是集群的每个成员都可以声明它是协调者并通知其他节点。别的节点可以选择接受这个声称或是拒绝并进入协调者竞争。被其他所有节点接受的节点才能成为协调者。节点按照一些属性来判断谁应该胜出。这个属性可以是一个静态ID，也可以是更新的度量像最近一次事务ID（最新的节点会胜出）。&lt;/p&gt;

&lt;p&gt;下图的例子展示了bully算法的执行过程。使用静态ID作为度量，ID值更大的节点会胜出：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;最初集群有5个节点，节点5是一个公认的协调者。&lt;/li&gt;
&lt;li&gt;假设节点5挂了，并且节点2和节点3同时发现了这一情况。两个节点开始竞选并发送竞选消息给ID更大的节点。&lt;/li&gt;
&lt;li&gt;节点4淘汰了节点2和3，节点3淘汰了节点2。&lt;/li&gt;
&lt;li&gt;这时候节点1察觉了节点5失效并向所有ID更大的节点发送了竞选信息。&lt;/li&gt;
&lt;li&gt;节点2、3和4都淘汰了节点1。&lt;/li&gt;
&lt;li&gt;节点4发送竞选信息给节点5。&lt;/li&gt;
&lt;li&gt;节点5没有响应，所以节点4宣布自己当选并向其他节点通告了这一消息。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;img src=&quot;/assets/files/2013-07/NoSQL15.png&quot; title=&quot;NoSQL15&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;协调者竞选过程会统计参与的节点数目并确保集群中至少一半的节点参与了竞选。这确保了在网络隔离的情况下只有一部分节点能选出协调者（假设网络中网络会被分割成多块区域，之间互不联通，协调者竞选的结果必然会在节点数相对比较多的那个区域中选出协调者，当然前提是那个区域中的可用节点多于集群原有节点数的半数。如果集群被隔离成几个区块，而没有一个区块的节点数多于原有节点总数的一半，那就无法选举出协调者，当然这样的情况下也别指望集群能够继续提供服务了）。&lt;/p&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://hal.inria.fr/docs/00/55/55/88/PDF/techreport.pdf&quot;&gt;M. Shapiro et al. A Comprehensive Study of Convergent and Commutative Replicated Data Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pdos.csail.mit.edu/papers/chord:sigcomm01/chord_sigcomm.pdf&quot;&gt;I. Stoica et al. Chord: A Scalable Peer-to-peer Lookup Service for Internet Applications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ssrc.ucsc.edu/Papers/honicky-ipdps04.pdf&quot;&gt;R. J. Honicky, E.L.Miller. Replication Under Scalable Hashing: A Family of Algorithms for Scalable Decentralized Data Distribution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://cs-www.cs.yale.edu/homes/shah/pubs/thesis.pdf&quot;&gt;G. Shah. Distributed Data Structures for Peer-to-Peer Systems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sbrc2010.inf.ufrgs.br/resources/presentations/tutorial/tutorial-montresor.pdf&quot;&gt;A. Montresor, Gossip Protocols for Large-Scale Distributed Systems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hyperdex.org/papers/hyperdex.pdf&quot;&gt;R. Escriva, B. Wong, E.G. Sirer. HyperDex: A Distributed, Searchable Key-Value Store&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://net.pku.edu.cn/~course/cs501/2009/reading/1987-SPDC-Epidemic%20algorithms%20for%20replicated%20database%20maintenance.pdf&quot;&gt;A. Demers et al. Epidemic Algorithms for Replicated Database Maintenance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf&quot;&gt;G. DeCandia, et al. Dynamo: Amazon’s Highly Available Key-value Store&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf&quot;&gt;R. van Resesse et al. Efficient Reconciliation and Flow Control for Anti-Entropy Protocols&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.hcs.ufl.edu/pubs/CC2000.pdf&quot;&gt;S. Ranganathan et al. Gossip-Style Failure Detection and Distributed Consensus for Scalable Heterogeneous
Clusters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.slideshare.net/kakugawa/distributed-counters-in-cassandra-cassandra-summit-2010&quot;&gt;http://www.slideshare.net/kakugawa/distributed-counters-in-cassandra-cassandra-summit-2010&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://cassandra-shawn.googlecode.com/files/The%20Phi%20Accrual%20Failure%20Detector.pdf&quot;&gt;N. Hayashibara, X. Defago, R. Yared, T. Katayama. The Phi Accrual Failure Detector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cs.mcgill.ca/~carl/impossible.pdf&quot;&gt;M.J. Fischer, N.A. Lynch, and M.S. Paterson. Impossibility of Distributed Consensus with One Faulty Process&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ddg.jaist.ac.jp/pub/HCK02.pdf&quot;&gt;N. Hayashibara, A. Cherif, T. Katayama. Failure Detectors for Large-Scale Distributed Systems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;M. Leslie, J. Davies, and T. Huffman. A Comparison Of Replication Strategies for Reliable Decentralised Storage&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cs.cornell.edu/projects/ladis2009/papers/lakshman-ladis2009.pdf&quot;&gt;A. Lakshman, P.Malik. Cassandra – A Decentralized Structured Storage System&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;N. A. Lynch. Distributed Algorithms&lt;/li&gt;
&lt;li&gt;G. Tel. Introduction to Distributed Algorithms&lt;/li&gt;
&lt;li&gt;http://basho.com/blog/technical/2010/04/05/why-vector-clocks-are-hard/](http://basho.com/blog/technical/2010/04/05/why-vector-clocks-are-hard/)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf&quot;&gt;L. Lamport. Paxos Made Simple&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cs.duke.edu/courses/fall07/cps212/consensus.pdf&quot;&gt;J. Chase. Distributed Systems, Failures, and Consensus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.allthingsdistributed.com/2008/12/eventually_consistent.html&quot;&gt;W. Vogels. Eventualy Consistent – Revisited&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/archive/spanner-osdi2012.pdf&quot;&gt;J. C. Corbett et al. Spanner: Google’s Globally-Distributed Database&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Go语言内存模型</title>
   <link href="http://beango.github.com/archives/2013/07/20/golang-memory-model.html"/>
   <updated>2013-07-20T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/07/20/golang-memory-model</id>
   <content type="html">&lt;h1&gt;目录：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#toc_0&quot;&gt;名词定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#toc_1&quot;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#toc_2&quot;&gt;Happens Before&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#toc_3&quot;&gt;Happens-before 定义&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#toc_4&quot;&gt;同步方法&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#toc_5&quot;&gt;初始化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#toc_6&quot;&gt;创建Goroutine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#toc_7&quot;&gt;销毁Goroutine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#toc_8&quot;&gt;Channel通信&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#toc_9&quot;&gt;锁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#toc_10&quot;&gt;Once&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#toc_11&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h1 id=&quot;toc_0&quot;&gt;名词定义&lt;/h1&gt;


&lt;p&gt;执行体 - Go里的Goroutine或Java中的Thread&lt;/p&gt;

&lt;h1 id=&quot;toc_1&quot;&gt;背景介绍&lt;/h1&gt;


&lt;p&gt;内存模型的目的是为了定义清楚变量的读写在不同执行体里的可见性。理解内存模型在并发编程中非常重要，因为代码的执行顺序和书写的逻辑顺序并不会完全一致，甚至在编译期间编译器也有可能重排代码以最优化CPU执行,另外还因为有CPU缓存的存在，内存的数据不一定会及时更新，这样对内存中的同一个变量读和写也不一定和期望一样。&lt;/p&gt;

&lt;p&gt;和&lt;a href=&quot;http://ifeve.com/java-memory-model-1/&quot;&gt;Java的内存模型规范&lt;/a&gt;类似，Go语言也有一个内存模型，相对JMM来说，Go的内存模型比较简单，Go的并发模型是基于CSP（&lt;a href=&quot;http://en.wikipedia.org/wiki/Communicating_sequential_processes&quot;&gt;Communicating Sequential Process&lt;/a&gt;）的，不同的Goroutine通过一种叫Channel的数据结构来通信；Java的并发模型则基于多线程和共享内存，有较多的概念（violatie, lock, final, construct, thread, atomic等）和场景，当然java.util.concurrent并发工具包大大简化了Java并发编程。&lt;/p&gt;

&lt;p&gt;Go内存模型规范了在什么条件下一个Goroutine对某个变量的修改一定对其它Goroutine可见。&lt;/p&gt;

&lt;h1 id=&quot;toc_2&quot;&gt;Happens Before&lt;/h1&gt;


&lt;p&gt;在一个单独的Goroutine里，对变量的读写和代码的书写顺序一致。比如以下的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main
import (
    &quot;log&quot;
)
var a, b, c int
func main() {
    a = 1
    b = 2
    c = a + 2
    log.Println(a, b, c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尽管在编译期和执行期，编译器和CPU都有可能重排代码，比如，先执行b=2，再执行a=1，但c=a+2是保证在a=1后执行的。这样最后的执行结果一定是&lt;code&gt;1 2 3&lt;/code&gt;，不会是&lt;code&gt;1 2 2&lt;/code&gt;。但下面的代码则可能会输出&lt;code&gt;0 0 0&lt;/code&gt;，&lt;code&gt;1 2 2&lt;/code&gt;, &lt;code&gt;0 2 3&lt;/code&gt; (b=2比a=1先执行), &lt;code&gt;1 2 3&lt;/code&gt;等各种可能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main
import (
    &quot;log&quot;
)
var a, b, c int
func main() {
    go func() {
        a = 1
        b = 2
    }()
    go func() {
        c = a + 2
    }()
    log.Println(a, b, c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;Happens-before 定义&lt;/h2&gt;


&lt;p&gt;Happens-before用来指明Go程序里的内存操作的局部顺序。如果一个内存操作事件e1 happens-before e2，则e2 happens-after e1也成立；如果e1不是happens-before e2,也不是happens-after e2，则e1和e2是并发的。&lt;/p&gt;

&lt;p&gt;在这个定义之下，如果以下情况满足，则对变量（v）的内存写操作（w）对一个内存读操作（r）来说&lt;strong&gt;允许&lt;/strong&gt;可见的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;r不在w开始之前发生（可以是之后或并发）；&lt;/li&gt;
&lt;li&gt;w和r之间没有另一个写操作(w’)发生；&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;为了保证对变量（v）的一个特定写操作（w）对一个读操作（r）可见，就需要确保w是r&lt;strong&gt;唯一&lt;/strong&gt;&lt;strong&gt;允许&lt;/strong&gt;的写操作，于是如果以下情况满足，则对变量（v）的内存写操作（w）对一个内存读操作（r）来说&lt;strong&gt;保证&lt;/strong&gt;可见的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;w在r开始之前发生；&lt;/li&gt;
&lt;li&gt;所有其它对v的写操作只在w之前或r之后发生；&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;可以看出后一种约定情况比前一种更严格，这种情况要求没有w或r没有其他的并发写操作。&lt;/p&gt;

&lt;p&gt;在单个Goroutine里，因为肯定没有并发，上面两种情况是等价的。对变量v的读操作可以读到最近一次写操作的值（这个应该很容易理解）。但在多个Goroutine里如果要访问一个共享变量，我们就必须使用同步工具来建立happens-before条件，来保证对该变量的读操作能读到期望的修改值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要保证并行执行体对共享变量的顺序访问方法就是用锁&lt;/strong&gt;。Java和Go在这点上是一致的。&lt;/p&gt;

&lt;p&gt;以下是具体的可被利用的Go语言的happens-before规则，从本质上来讲，happens-before规则确定了CPU缓冲和主存的同步时间点（通过&lt;a href=&quot;http://hugozhu.myalert.info/2013/03/28/22-memory-barriers-or-fences.html&quot;&gt;内存屏障&lt;/a&gt;等指令），从而使得对变量的读写顺序可被确定–也就是我们通常说的“同步”。&lt;/p&gt;

&lt;h1 id=&quot;toc_4&quot;&gt;同步方法&lt;/h1&gt;




&lt;h2 id=&quot;toc_5&quot;&gt;初始化&lt;/h2&gt;


&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;如果package p 引用了package q，q的init()方法 happens-before p&lt;/strong&gt;（Java工程师可以对比一下&lt;a href=&quot;http://www.infoq.com/cn/articles/java-memory-model-6?utm_source=infoq&amp;amp;utm_medium=related_content_link&amp;amp;utm_campaign=relatedContent_articles_clk&quot;&gt;final变量的happens-before规则&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;main.main()方法 happens-after所有package的init()方法结束。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h2 id=&quot;toc_6&quot;&gt;创建Goroutine&lt;/h2&gt;


&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;go语句创建新的goroutine happens-before 该goroutine执行&lt;/strong&gt;（这个应该很容易理解）&lt;/li&gt;
&lt;/ol&gt;


&lt;br&gt;


&lt;pre&gt;&lt;code&gt;package main
import (
    &quot;log&quot;
    &quot;time&quot;
)
var a, b, c int
func main() {
    a = 1
    b = 2
    go func() {
        c = a + 2
        log.Println(a, b, c)
    }()
    time.Sleep(1 * time.Second)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用这条happens-before，我们可以确定&lt;code&gt;c=a+2&lt;/code&gt;是happens-after&lt;code&gt;a=1和b=2&lt;/code&gt;，所以结果输出是可以确定的&lt;code&gt;1 2 3&lt;/code&gt;，但如果是下面这样的代码，输出就不确定了，有可能是&lt;code&gt;1 2 3&lt;/code&gt;或&lt;code&gt;0 0 2&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    go func() {
        c = a + 2
        log.Println(a, b, c)
    }()
    a = 1
    b = 2
    time.Sleep(1 * time.Second)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;toc_7&quot;&gt;销毁Goroutine&lt;/h2&gt;


&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Goroutine的退出并不保证happens-before任何事件&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;


&lt;br&gt;


&lt;pre&gt;&lt;code&gt;var a string
func hello() {
    go func() { a = &quot;hello&quot; }()
    print(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码因为&lt;code&gt;a=&quot;hello&quot;&lt;/code&gt;没有使用同步事件，并不能保证这个赋值被主goroutine可见。事实上，极度优化的Go编译器甚至可以完全删除这行代码&lt;code&gt;go func() { a = &quot;hello&quot; }()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Goroutine对变量的修改需要让对其它Goroutine可见，除了使用锁来同步外还可以用Channel。&lt;/p&gt;

&lt;h2 id=&quot;toc_8&quot;&gt;Channel通信&lt;/h2&gt;


&lt;p&gt;在Go编程中，Channel是被推荐的执行体间通信的方法，Go的编译器和运行态都会尽力对其优化。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;对一个Channel的发送操作(send) happens-before 相应Channel的接收操作完成&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关闭一个Channel happens-before 从该Channel接收到最后的返回值0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不带缓冲的Channel的接收操作（receive） happens-before 相应Channel的发送操作完成&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;br&gt;


&lt;pre&gt;&lt;code&gt;var c = make(chan int, 10)
var a string
func f() {
    a = &quot;hello, world&quot;
    c &amp;lt;- 0
}
func main() {
    go f()
    &amp;lt;-c
    print(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码可以确保输出&lt;code&gt;hello, world&lt;/code&gt;，因为&lt;code&gt;a = &quot;hello, world&quot;&lt;/code&gt; happens-before &lt;code&gt;c &amp;lt;- 0&lt;/code&gt;，&lt;code&gt;print(a)&lt;/code&gt; happens-after &lt;code&gt;&amp;lt;-c&lt;/code&gt;， 根据上面的规则1）以及happens-before的可传递性，&lt;code&gt;a = &quot;hello, world&quot;&lt;/code&gt; happens-before&lt;code&gt;print(a)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;根据规则2）把&lt;code&gt;c&amp;lt;-0&lt;/code&gt;替换成&lt;code&gt;close(c)&lt;/code&gt;也能保证输出&lt;code&gt;hello,world&lt;/code&gt;，因为关闭操作在&lt;code&gt;&amp;lt;-c&lt;/code&gt;接收到0之前发送。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var c = make(chan int)
var a string
func f() {
    a = &quot;hello, world&quot;
    &amp;lt;-c
}
func main() {
    go f()
    c &amp;lt;- 0
    print(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据规则3），因为c是不带缓冲的Channel，&lt;code&gt;a = &quot;hello, world&quot;&lt;/code&gt; happens-before &lt;code&gt;&amp;lt;-c&lt;/code&gt; happens-before &lt;code&gt;c &amp;lt;- 0&lt;/code&gt; happens-before &lt;code&gt;print(a)&lt;/code&gt;，但如果c是缓冲队列，如定义&lt;code&gt;c = make(chan int, 1)&lt;/code&gt;, 那结果就不确定了。&lt;/p&gt;

&lt;h2 id=&quot;toc_9&quot;&gt;锁&lt;/h2&gt;


&lt;p&gt;&lt;code&gt;sync&lt;/code&gt; 包实现了两种锁数据结构:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;sync.Mutex -&gt; java.util.concurrent.ReentrantLock&lt;/li&gt;
&lt;li&gt;sync.RWMutex -&gt; java.util.concurrent.locks.ReadWriteLock&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;其happens-before规则和Java的也类似：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;任何sync.Mutex或sync.RWMutex 变量（l），定义 n &amp;lt; m， 第n次&lt;code&gt;l.Unlock()&lt;/code&gt; happens-before 第m次&lt;code&gt;l.lock()&lt;/code&gt;调用返回。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;br&gt;


&lt;pre&gt;&lt;code&gt;var l sync.Mutex
var a string
func f() {
    a = &quot;hello, world&quot;
    l.Unlock()
}
func main() {
    l.Lock()
    go f()
    l.Lock()
    print(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;a = &quot;hello, world&quot;&lt;/code&gt; happens-before &lt;code&gt;l.Unlock()&lt;/code&gt; happens-before 第二个 &lt;code&gt;l.Lock()&lt;/code&gt; happens-before &lt;code&gt;print(a)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;toc_10&quot;&gt;Once&lt;/h2&gt;


&lt;p&gt;&lt;code&gt;sync&lt;/code&gt;包还提供了一个安全的初始化工具Once。还记得Java的Singleton设计模式，double-check，甚至triple-check的各种单例初始化方法吗？Go则提供了一个标准的方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;once.Do(f)&lt;/code&gt;中的&lt;code&gt;f()&lt;/code&gt; happens-before 任何多个once.Do(f)调用的返回，且f()有且只有一次调用。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;br&gt;


&lt;pre&gt;&lt;code&gt;var a string
var once sync.Once
func setup() {
    a = &quot;hello, world&quot;
}
func doprint() {
    once.Do(setup)
    print(a)
}
func twoprint() {
    go doprint()
    go doprint()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码虽然调用两次&lt;code&gt;doprint()&lt;/code&gt;，但实际上&lt;code&gt;setup&lt;/code&gt;只会执行一次，并且并发的&lt;code&gt;once.Do(setup)&lt;/code&gt;都会等待&lt;code&gt;setup&lt;/code&gt;返回后再继续执行。&lt;/p&gt;

&lt;h1 id=&quot;toc_11&quot;&gt;参考链接&lt;/h1&gt;


&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://golang.org/ref/mem&quot;&gt;http://golang.org/ref/mem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Java_Memory_Model&quot;&gt;http://en.wikipedia.org/wiki/Java_Memory_Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ifeve.com/java-memory-model-1/&quot;&gt;http://ifeve.com/java-memory-model-1/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://code.google.com/p/golang-china/wiki/go_mem&quot;&gt;http://code.google.com/p/golang-china/wiki/go_mem&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Javascript 常见陷阱及特殊用法</title>
   <link href="http://beango.github.com/archives/2013/07/01/javascript-common-traps-and-special-usage.html"/>
   <updated>2013-07-01T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/07/01/javascript-common-traps-and-special-usage</id>
   <content type="html">&lt;h2&gt;对象使用和属性&lt;/h2&gt;

&lt;p&gt;JavaScript 中所有变量都是对象，除了两个例外 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;false.toString() // 'false'
[1, 2, 3].toString(); // '1,2,3'

function Foo(){}
Foo.bar = 1;
Foo.bar; // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个常见的误解是数字的字面值（literal）不是对象。这是因为 JavaScript 解析器的一个错误， 它试图将点操作符解析为浮点数字面值的一部分。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2.toString(); // 出错：SyntaxError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有很多变通方法可以让数字的字面值看起来像对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2..toString(); // 第二个点号可以正常解析
2 .toString(); // 注意点号前面的空格
(2).toString(); // 2先被计算
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;对象作为数据类型&lt;/h2&gt;

&lt;p&gt;JavaScript 的对象可以作为哈希表使用，主要用来保存命名的键与值的对应关系。&lt;/p&gt;

&lt;p&gt;使用对象的字面语法 - &lt;code&gt;{}&lt;/code&gt; - 可以创建一个简单对象。这个新创建的对象从 &lt;code&gt;Object.prototype&lt;/code&gt; 继承下面，没有任何自定义属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var foo = {}; // 一个空对象

// 一个新对象，拥有一个值为12的自定义属性'test'
var bar = {test: 12}; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;访问对象属性&lt;/h2&gt;

&lt;p&gt;有两种方式来访问对象的属性，点操作符或者中括号操作符。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var foo = {name: 'Kitten'}
foo.name; // kitten
foo['name']; // kitten

var get = 'name';
foo[get]; // kitten

foo.1234; // SyntaxError
foo['1234']; // works
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两种语法是等价的，但是中括号操作符在下面两种情况下依然有效 - 动态设置属性 - 属性名不是一个有效的变量名（译者注：比如属性名中包含空格，或者属性名是 JS 的关键词）&lt;/p&gt;

&lt;h2&gt;删除对象属性&lt;/h2&gt;

&lt;p&gt;删除属性的唯一方法是使用 &lt;code&gt;delete&lt;/code&gt; 操作符；设置属性为 &lt;code&gt;undefined&lt;/code&gt; 或者 &lt;code&gt;null&lt;/code&gt; 并不能真正的删除属性， 而仅仅是移除了属性和值的关联。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
    bar: 1,
    foo: 2,
    baz: 3
};
obj.bar = undefined;
obj.foo = null;
delete obj.baz;

for(var i in obj) {
    if (obj.hasOwnProperty(i)) {
        console.log(i, '' + obj[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的输出结果有 &lt;code&gt;bar undefined&lt;/code&gt; 和 &lt;code&gt;foo null&lt;/code&gt; - 只有 &lt;code&gt;baz&lt;/code&gt; 被真正的删除了，所以从输出结果中消失。&lt;/p&gt;

&lt;h2&gt;对象属性名的语法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var test = {
    'case': 'I am a keyword so I must be notated as a string',
    delete: 'I am a keyword too so me' // 出错：SyntaxError
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对象的属性名可以使用字符串或者普通字符声明。但是由于 JavaScript 解析器的另一个错误设计， 上面的第二种声明方式在 ECMAScript 5 之前会抛出 &lt;code&gt;SyntaxError&lt;/code&gt; 的错误。&lt;/p&gt;

&lt;p&gt;这个错误的原因是 &lt;code&gt;delete&lt;/code&gt; 是 JavaScript 语言的一个关键词；因此为了在更低版本的 JavaScript 引擎下也能正常运行，必须使用字符串字面值声明方式。&lt;/p&gt;

&lt;h2&gt;﻿原型&lt;/h2&gt;

&lt;p&gt;JavaScript 不包含传统的类继承模型，而是使用prototypal原型模型。&lt;/p&gt;

&lt;p&gt;虽然这经常被当作是 JavaScript 的缺点被提及，其实基于原型的继承模型比传统的类继承还要强大。实现传统的类继承模型是很简单，但是实现 JavaScript 中的原型继承则要困难的多。 (It is for example fairly trivial to build a classic model on top of it, while the other way around is a far more difficult task.)&lt;/p&gt;

&lt;p&gt;由于 JavaScript 是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的。&lt;/p&gt;

&lt;p&gt;第一个不同之处在于 JavaScript 使用原型链的继承方式。&lt;/p&gt;

&lt;p&gt;注意:简单的使用 &lt;code&gt;Bar.prototype = Foo.prototype&lt;/code&gt; 将会导致两个对象共享相同的原型。因此，改变任意一个对象的原型都会影响到另一个对象的原型，在大多数情况下这不是希望的结果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Foo() {
    this.value = 42;
}
Foo.prototype = {
    method: function() {}
};

function Bar() {}

// 设置Bar的prototype属性为Foo的实例对象
Bar.prototype = new Foo();
Bar.prototype.foo = 'Hello World';

// 修正Bar.prototype.constructor为Bar本身
Bar.prototype.constructor = Bar;

var test = new Bar() // 创建Bar的一个新实例

// 原型链
test [Bar的实例]
    Bar.prototype [Foo的实例] 
        { foo: 'Hello World' }
        Foo.prototype
            {method: ...};
            Object.prototype
                {toString: ... /* etc. */};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子中，&lt;code&gt;test&lt;/code&gt; 对象从 &lt;code&gt;Bar.prototype&lt;/code&gt; 和 &lt;code&gt;Foo.prototype&lt;/code&gt; 继承下来；因此， 它能访问 &lt;code&gt;Foo&lt;/code&gt; 的原型方法&lt;code&gt;method&lt;/code&gt;。同时，它也能够访问那个定义在原型上的 &lt;code&gt;Foo&lt;/code&gt; 实例属性 &lt;code&gt;value&lt;/code&gt;。需要注意的是 &lt;code&gt;new Bar()&lt;/code&gt; 不会创造出一个新的 &lt;code&gt;Foo&lt;/code&gt; 实例，而是重复使用它原型上的那个实例；因此，所有的 &lt;code&gt;Bar&lt;/code&gt; 实例都会共享相同的 &lt;code&gt;value&lt;/code&gt; 属性。&lt;/p&gt;

&lt;p&gt;注意:不要使用 &lt;code&gt;Bar.prototype = Foo&lt;/code&gt;，因为这不会执行 &lt;code&gt;Foo&lt;/code&gt; 的原型，而是指向函数 &lt;code&gt;Foo&lt;/code&gt;。 因此原型链将会回溯到 &lt;code&gt;Function.prototype&lt;/code&gt; 而不是 &lt;code&gt;Foo.prototype&lt;/code&gt;，因此 &lt;code&gt;method&lt;/code&gt; 将不会在 Bar 的原型链上。&lt;/p&gt;

&lt;h2&gt;属性查找&lt;/h2&gt;

&lt;p&gt;当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止。&lt;/p&gt;

&lt;p&gt;到查找到达原型链的顶部 - 也就是 &lt;code&gt;Object.prototype&lt;/code&gt; - 但是仍然没有找到指定的属性，就会返回 undefined。&lt;/p&gt;

&lt;h3&gt;原型属性&lt;/h3&gt;

&lt;p&gt;当原型属性用来创建原型链时，可以把任何类型的值赋给它（prototype）。然而将原子类型赋给 prototype 的操作将会被忽略。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Foo() {}
Foo.prototype = 1; // 无效
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而将对象赋值给 prototype，正如上面的例子所示，将会动态的创建原型链。&lt;/p&gt;

&lt;h3&gt;性能&lt;/h3&gt;

&lt;p&gt;如果一个属性在原型链的上端，则对于查找时间将带来不利影响。特别的，试图获取一个不存在的属性将会遍历整个原型链。&lt;/p&gt;

&lt;p&gt;并且，当使用 &lt;code&gt;for in&lt;/code&gt; 循环遍历对象的属性时，原型链上的所有属性都将被访问。&lt;/p&gt;

&lt;h3&gt;扩展内置类型的原型&lt;/h3&gt;

&lt;p&gt;一个错误特性被经常使用，那就是扩展 &lt;code&gt;Object.prototype&lt;/code&gt; 或者其他内置类型的原型对象。&lt;/p&gt;

&lt;p&gt;这种技术被称之为 monkey patching 并且会破坏封装。虽然它被广泛的应用到一些 JavaScript 类库中比如 Prototype, 但是我仍然不认为为内置类型添加一些非标准的函数是个好主意。&lt;/p&gt;

&lt;p&gt;扩展内置类型的唯一理由是为了和新的 JavaScript 保持一致，比如&lt;code&gt;Array.forEach&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;译者注：这是编程领域常用的一种方式，称之为Backport，也就是将新的补丁添加到老版本中。&lt;/p&gt;

&lt;h2&gt;﻿&lt;code&gt;hasOwnProperty&lt;/code&gt; 函数&lt;/h2&gt;

&lt;p&gt;为了判断一个对象是否包含自定义属性而不是原型链上的属性，我们需要使用继承自 &lt;code&gt;Object.prototype&lt;/code&gt; 的 &lt;code&gt;hasOwnProperty&lt;/code&gt; 方法。&lt;/p&gt;

&lt;p&gt;注意:通过判断一个属性是否 &lt;code&gt;undefined&lt;/code&gt; 是不够的。因为一个属性可能确实存在，只不过它的值被设置为 &lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hasOwnProperty&lt;/code&gt; 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 修改Object.prototype
Object.prototype.bar = 1; 
var foo = {goo: undefined};

foo.bar; // 1
'bar' in foo; // true

foo.hasOwnProperty('bar'); // false
foo.hasOwnProperty('goo'); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只有 &lt;code&gt;hasOwnProperty&lt;/code&gt; 可以给出正确和期望的结果，这在遍历对象的属性时会很有用。没有其它方法可以用来排除原型链上的属性，而不是定义在对象自身上的属性。&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;hasOwnProperty&lt;/code&gt; 作为属性&lt;/h3&gt;

&lt;p&gt;JavaScript不会保护 &lt;code&gt;hasOwnProperty&lt;/code&gt; 被非法占用，因此如果一个对象碰巧存在这个属性， 就需要使用外部的 &lt;code&gt;hasOwnProperty&lt;/code&gt; 函数来获取正确的结果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var foo = {
    hasOwnProperty: function() {
        return false;
    },
    bar: 'Here be dragons'
};

foo.hasOwnProperty('bar'); // 总是返回 false

// 使用其它对象的 hasOwnProperty，并将其上下为设置为foo
{}.hasOwnProperty.call(foo, 'bar'); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;结论&lt;/h3&gt;

&lt;p&gt;当检查对象上某个属性是否存在时，&lt;code&gt;hasOwnProperty&lt;/code&gt; 是唯一可用的方法。同时在使用 &lt;code&gt;for in&lt;/code&gt; loop 遍历对象时，推荐总是使用 &lt;code&gt;hasOwnProperty&lt;/code&gt; 方法，这将会避免原型对象扩展带来的干扰。&lt;/p&gt;

&lt;h2&gt;﻿&lt;code&gt;for in&lt;/code&gt; 循环&lt;/h2&gt;

&lt;p&gt;和 &lt;code&gt;in&lt;/code&gt; 操作符一样，&lt;code&gt;for in&lt;/code&gt; 循环同样在查找对象属性时遍历原型链上的所有属性。&lt;/p&gt;

&lt;p&gt;注意:&lt;code&gt;for in&lt;/code&gt; 循环不会遍历那些 &lt;code&gt;enumerable&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; 的属性；比如数组的 &lt;code&gt;length&lt;/code&gt; 属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 修改 Object.prototype
Object.prototype.bar = 1;

var foo = {moo: 2};
for(var i in foo) {
    console.log(i); // 输出两个属性：bar 和 moo
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于不可能改变 &lt;code&gt;for in&lt;/code&gt; 自身的行为，因此有必要过滤出那些不希望出现在循环体中的属性， 这可以通过 &lt;code&gt;Object.prototype&lt;/code&gt; 原型上的 &lt;code&gt;hasOwnProperty&lt;/code&gt; 函数来完成。&lt;/p&gt;

&lt;p&gt;注意:由于 &lt;code&gt;for in&lt;/code&gt; 总是要遍历整个原型链，因此如果一个对象的继承层次太深的话会影响性能。&lt;/p&gt;

&lt;h3&gt;使用 &lt;code&gt;hasOwnProperty&lt;/code&gt; 过滤&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// foo 变量是上例中的
for(var i in foo) {
    if (foo.hasOwnProperty(i)) {
        console.log(i);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个版本的代码是唯一正确的写法。由于我们使用了&lt;code&gt;hasOwnProperty&lt;/code&gt;，所以这次只输出 &lt;code&gt;moo&lt;/code&gt;。 如果不使用 &lt;code&gt;hasOwnProperty&lt;/code&gt;，则这段代码在原生对象原型（比如&lt;code&gt;Object.prototype&lt;/code&gt;）被扩展时可能会出错。&lt;/p&gt;

&lt;p&gt;一个广泛使用的类库 Prototype 就扩展了原生的 JavaScript 对象。因此，但这个类库被包含在页面中时，不使用 &lt;code&gt;hasOwnProperty&lt;/code&gt; 过滤的 &lt;code&gt;for in&lt;/code&gt; 循环难免会出问题。&lt;/p&gt;

&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;推荐总是使用&lt;code&gt;hasOwnProperty&lt;/code&gt;。不要对代码运行的环境做任何假设，不要假设原生对象是否已经被扩展了。&lt;/p&gt;

&lt;h2&gt;﻿函数声明与表达式&lt;/h2&gt;

&lt;p&gt;函数是JavaScript中的一等对象，这意味着可以把函数像其它值一样传递。一个常见的用法是把匿名函数作为回调函数传递对异步函数中。&lt;/p&gt;

&lt;h3&gt;函数声明&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function foo() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的方法会在执行前被解析(hoisted)，因此它存在于当前上下文的任意一个地方，即使在函数定义体的上面被调用也是对的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo(); // 正常运行，因为foo在代码运行前已经被创建
function foo() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;函数赋值表达式&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var foo = function() {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子把一个匿名的函数赋值给变量 &lt;code&gt;foo&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo; // 'undefined'
foo(); // 出错：TypeError
var foo = function() {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于 &lt;code&gt;var&lt;/code&gt; 定义了一个声明语句，对变量 &lt;code&gt;foo&lt;/code&gt; 的解析是在代码运行之前，因此 &lt;code&gt;foo&lt;/code&gt; 变量在代码运行时已经被定义过了。&lt;/p&gt;

&lt;p&gt;但是由于赋值语句只在运行时执行，因此在相应代码执行之前， &lt;code&gt;foo&lt;/code&gt; 的值缺省为 undefined。&lt;/p&gt;

&lt;h3&gt;命名函数的赋值表达式&lt;/h3&gt;

&lt;p&gt;另外一个特殊的情况是将命名函数赋值给一个变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var foo = function bar() {
    bar(); // 正常运行
}
bar(); // 出错：ReferenceError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;bar&lt;/code&gt; 函数声明外是不可见的，这是因为我们已经把函数赋值给了 &lt;code&gt;foo&lt;/code&gt;； 然而在 &lt;code&gt;bar&lt;/code&gt; 内部依然可见。这是由于 JavaScript 的 命名处理 所致，函数名在函数内总是可见的。&lt;/p&gt;

&lt;h2&gt;﻿&lt;code&gt;this&lt;/code&gt; 的工作原理&lt;/h2&gt;

&lt;p&gt;JavaScript 有一套完全不同于其它语言的对 &lt;code&gt;this&lt;/code&gt; 的处理机制。在五种不同的情况下 ，&lt;code&gt;this&lt;/code&gt; 指向的各不相同。&lt;/p&gt;

&lt;h3&gt;全局范围内&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;this;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当在全部范围内使用 &lt;code&gt;this&lt;/code&gt;，它将会指向全局对象。&lt;/p&gt;

&lt;p&gt;译者注：浏览器中运行的 JavaScript 脚本，这个全局对象是 &lt;code&gt;window&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;函数调用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;foo();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 &lt;code&gt;this&lt;/code&gt; 也会指向全局对象。&lt;/p&gt;

&lt;p&gt;ES5 注意:在严格模式下（strict mode），不存在全局变量。 这种情况下 &lt;code&gt;this&lt;/code&gt; 将会是 &lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;方法调用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;test.foo(); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子中，&lt;code&gt;this&lt;/code&gt; 指向 &lt;code&gt;test&lt;/code&gt; 对象。&lt;/p&gt;

&lt;h3&gt;调用构造函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;new foo(); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果函数倾向于和 &lt;code&gt;new&lt;/code&gt; 关键词一块使用，则我们称这个函数是 构造函数。在函数内部，&lt;code&gt;this&lt;/code&gt; 指向新创建的对象。&lt;/p&gt;

&lt;h3&gt;显式的设置 &lt;code&gt;this&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function foo(a, b, c) {}

var bar = {};
foo.apply(bar, [1, 2, 3]); // 数组将会被扩展，如下所示
foo.call(bar, 1, 2, 3); // 传递到foo的参数是：a = 1, b = 2, c = 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当使用 &lt;code&gt;Function.prototype&lt;/code&gt; 上的 &lt;code&gt;call&lt;/code&gt; 或者 &lt;code&gt;apply&lt;/code&gt; 方法时，函数内的 &lt;code&gt;this&lt;/code&gt; 将会被显式设置为函数调用的第一个参数。&lt;/p&gt;

&lt;p&gt;因此函数调用的规则在上例中已经不适用了，在&lt;code&gt;foo&lt;/code&gt; 函数内 &lt;code&gt;this&lt;/code&gt; 被设置成了 &lt;code&gt;bar&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;注意:在对象的字面声明语法中，&lt;code&gt;this&lt;/code&gt; 不能用来指向对象本身。 因此 &lt;code&gt;var obj = {me: this}&lt;/code&gt; 中的 &lt;code&gt;me&lt;/code&gt; 不会指向 &lt;code&gt;obj&lt;/code&gt;，因为 &lt;code&gt;this&lt;/code&gt; 只可能出现在上述的五种情况中。译者注：这个例子中，如果是在浏览器中运行，&lt;code&gt;obj.me&lt;/code&gt; 等于 &lt;code&gt;window&lt;/code&gt; 对象。&lt;/p&gt;

&lt;h3&gt;常见误解&lt;/h3&gt;

&lt;p&gt;尽管大部分的情况都说的过去，不过第一个规则（译者注：这里指的应该是第二个规则，也就是直接调用函数时，&lt;code&gt;this&lt;/code&gt; 指向全局对象）被认为是JavaScript语言另一个错误设计的地方，因为它从来就没有实际的用途。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Foo.method = function() {
    function test() {
        // this 将会被设置为全局对象（译者注：浏览器环境中也就是 window 对象）
    }
    test();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个常见的误解是 &lt;code&gt;test&lt;/code&gt; 中的 &lt;code&gt;this&lt;/code&gt; 将会指向 &lt;code&gt;Foo&lt;/code&gt; 对象，实际上不是这样子的。&lt;/p&gt;

&lt;p&gt;为了在 &lt;code&gt;test&lt;/code&gt; 中获取对 &lt;code&gt;Foo&lt;/code&gt; 对象的引用，我们需要在 &lt;code&gt;method&lt;/code&gt; 函数内部创建一个局部变量指向 &lt;code&gt;Foo&lt;/code&gt; 对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Foo.method = function() {
    var that = this;
    function test() {
        // 使用 that 来指向 Foo 对象
    }
    test();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;that&lt;/code&gt; 只是我们随意起的名字，不过这个名字被广泛的用来指向外部的 &lt;code&gt;this&lt;/code&gt; 对象。 在 闭包 一节，我们可以看到 &lt;code&gt;that&lt;/code&gt; 可以作为参数传递。&lt;/p&gt;

&lt;h3&gt;方法的赋值表达式&lt;/h3&gt;

&lt;p&gt;另一个看起来奇怪的地方是函数别名，也就是将一个方法赋值给一个变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var test = someObject.methodTest;
test();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上例中，&lt;code&gt;test&lt;/code&gt; 就像一个普通的函数被调用；因此，函数内的 &lt;code&gt;this&lt;/code&gt; 将不再被指向到 &lt;code&gt;someObject&lt;/code&gt; 对象。&lt;/p&gt;

&lt;p&gt;虽然 &lt;code&gt;this&lt;/code&gt; 的晚绑定特性似乎并不友好，但是这确实基于原型继承赖以生存的土壤。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Foo() {}
Foo.prototype.method = function() {};

function Bar() {}
Bar.prototype = Foo.prototype;

new Bar().method();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当 &lt;code&gt;method&lt;/code&gt; 被调用时，&lt;code&gt;this&lt;/code&gt; 将会指向 &lt;code&gt;Bar&lt;/code&gt; 的实例对象。&lt;/p&gt;

&lt;h2&gt;﻿闭包和引用&lt;/h2&gt;

&lt;p&gt;闭包是 JavaScript 一个非常重要的特性，这意味着当前作用域总是能够访问外部作用域中的变量。因为 函数 是 JavaScript 中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数。&lt;/p&gt;

&lt;h3&gt;模拟私有变量&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function Counter(start) {
    var count = start;
    return {
        increment: function() {
            count++;
        },

        get: function() {
            return count;
        }
    }
}

var foo = Counter(4);
foo.increment();
foo.get(); // 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，&lt;code&gt;Counter&lt;/code&gt; 函数返回两个闭包，函数 &lt;code&gt;increment&lt;/code&gt; 和函数 &lt;code&gt;get&lt;/code&gt;。这两个函数都维持着 对外部作用域 &lt;code&gt;Counter&lt;/code&gt; 的引用，因此总可以访问此作用域内定义的变量 &lt;code&gt;count&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;为什么不可以在外部访问私有变量&lt;/h3&gt;

&lt;p&gt;因为 JavaScript 中不可以对作用域进行引用或赋值，因此没有办法在外部访问 &lt;code&gt;count&lt;/code&gt; 变量。 唯一的途径就是通过那两个闭包。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var foo = new Counter(4);
foo.hack = function() {
    count = 1337;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码不会改变定义在 &lt;code&gt;Counter&lt;/code&gt; 作用域中的 &lt;code&gt;count&lt;/code&gt; 变量的值，因为 &lt;code&gt;foo.hack&lt;/code&gt; 没有 定义在那个作用域内。它将会创建或者覆盖全局变量 &lt;code&gt;count&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;循环中的闭包&lt;/h3&gt;

&lt;p&gt;一个常见的错误出现在循环中使用闭包，假设我们需要在每次循环中调用循环序号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(var i = 0; i &amp;lt; 10; i++) {
    setTimeout(function() {
        console.log(i);  
    }, 1000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码不会输出数字 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;9&lt;/code&gt;，而是会输出数字 &lt;code&gt;10&lt;/code&gt; 十次。&lt;/p&gt;

&lt;p&gt;当 &lt;code&gt;console.log&lt;/code&gt; 被调用的时候，匿名函数保持对外部变量 &lt;code&gt;i&lt;/code&gt; 的引用，此时&lt;code&gt;for&lt;/code&gt;循环已经结束， &lt;code&gt;i&lt;/code&gt; 的值被修改成了 &lt;code&gt;10&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;为了得到想要的结果，需要在每次循环中创建变量 &lt;code&gt;i&lt;/code&gt; 的拷贝。&lt;/p&gt;

&lt;h3&gt;避免引用错误&lt;/h3&gt;

&lt;p&gt;为了正确的获得循环序号，最好使用匿名包裹器（译者注：其实就是我们通常说的自执行匿名函数）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(var i = 0; i &amp;lt; 10; i++) {
    (function(e) {
        setTimeout(function() {
            console.log(e);  
        }, 1000);
    })(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;外部的匿名函数会立即执行，并把 &lt;code&gt;i&lt;/code&gt; 作为它的参数，此时函数内 &lt;code&gt;e&lt;/code&gt; 变量就拥有了 &lt;code&gt;i&lt;/code&gt; 的一个拷贝。&lt;/p&gt;

&lt;p&gt;当传递给 &lt;code&gt;setTimeout&lt;/code&gt; 的匿名函数执行时，它就拥有了对 &lt;code&gt;e&lt;/code&gt; 的引用，而这个值是不会被循环改变的。&lt;/p&gt;

&lt;p&gt;有另一个方法完成同样的工作；那就是从匿名包装器中返回一个函数。这和上面的代码效果一样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(var i = 0; i &amp;lt; 10; i++) {
    setTimeout((function(e) {
        return function() {
            console.log(e);
        }
    })(i), 1000)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;﻿&lt;code&gt;arguments&lt;/code&gt; 对象&lt;/h2&gt;

&lt;p&gt;JavaScript 中每个函数内都能访问一个特别变量&lt;code&gt;arguments&lt;/code&gt;。这个变量维护着所有传递到这个函数中的参数列表。&lt;/p&gt;

&lt;p&gt;注意:由于 &lt;code&gt;arguments&lt;/code&gt; 已经被定义为函数内的一个变量。 因此通过 &lt;code&gt;var&lt;/code&gt; 关键字定义 &lt;code&gt;arguments&lt;/code&gt; 或者将 &lt;code&gt;arguments&lt;/code&gt; 声明为一个形式参数，都将导致原生的 &lt;code&gt;arguments&lt;/code&gt; 不会被创建。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;arguments&lt;/code&gt; 变量不是一个数组（&lt;code&gt;Array&lt;/code&gt;）。 尽管在语法上它有数组相关的属性&lt;code&gt;length&lt;/code&gt;，但它不从 &lt;code&gt;Array.prototype&lt;/code&gt; 继承，实际上它是一个对象（&lt;code&gt;Object&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;因此，无法对 &lt;code&gt;arguments&lt;/code&gt; 变量使用标准的数组方法，比如 &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt; 或者&lt;code&gt;slice&lt;/code&gt;。 虽然使用 &lt;code&gt;for&lt;/code&gt; 循环遍历也是可以的，但是为了更好的使用数组方法，最好把它转化为一个真正的数组。&lt;/p&gt;

&lt;h3&gt;转化为数组&lt;/h3&gt;

&lt;p&gt;下面的代码将会创建一个新的数组，包含所有 &lt;code&gt;arguments&lt;/code&gt; 对象中的元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Array.prototype.slice.call(arguments);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个转化比较慢，在性能不好的代码中不推荐这种做法。&lt;/p&gt;

&lt;h3&gt;传递参数&lt;/h3&gt;

&lt;p&gt;下面将参数从一个函数传递到另一个函数，是推荐的做法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
    bar.apply(null, arguments);
}
function bar(a, b, c) {
    // do stuff here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个技巧是同时使用 &lt;code&gt;call&lt;/code&gt; 和 &lt;code&gt;apply&lt;/code&gt;，创建一个快速的解绑定包装器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Foo() {}

Foo.prototype.method = function(a, b, c) {
    console.log(this, a, b, c);
};

// Create an unbound version of &quot;method&quot; 
// 输入参数为: this, arg1, arg2...argN
Foo.method = function() {

    // 结果: Foo.prototype.method.call(this, arg1, arg2... argN)
    Function.call.apply(Foo.prototype.method, arguments);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;译者注：上面的 &lt;code&gt;Foo.method&lt;/code&gt; 函数和下面代码的效果是一样的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Foo.method = function() {
    var args = Array.prototype.slice.call(arguments);
    Foo.prototype.method.apply(args[0], args.slice(1));
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;自动更新&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;arguments&lt;/code&gt; 对象为其内部属性以及函数形式参数创建getter和setter方法。&lt;/p&gt;

&lt;p&gt;因此，改变形参的值会影响到 &lt;code&gt;arguments&lt;/code&gt; 对象的值，反之亦然。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo(a, b, c) {
    arguments[0] = 2;
    a; // 2

    b = 4;
    arguments[1]; // 4

    var d = c;
    d = 9;
    c; // 3
}
foo(1, 2, 3);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;性能真相&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;arguments&lt;/code&gt; 对象总会被创建，除了两个特殊情况 -作为局部变量声明和作为形式参数。 而不管它是否有被使用。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;arguments&lt;/code&gt; 的getters和setters方法总会被创佳；因此使用 &lt;code&gt;arguments&lt;/code&gt; 对性能不会有什么影响。 除非是需要对 &lt;code&gt;arguments&lt;/code&gt; 对象的属性进行多次访问。&lt;/p&gt;

&lt;p&gt;ES5 提示:这些getters和setters在严格模式下（strict mode）不会被创建。&lt;/p&gt;

&lt;p&gt;译者注：在 MDC 中对 &lt;code&gt;strict mode&lt;/code&gt; 模式下 &lt;code&gt;arguments&lt;/code&gt; 的描述有助于我们的理解，请看下面代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 阐述在 ES5 的严格模式下 `arguments` 的特性
function f(a) {
  &quot;use strict&quot;;
  a = 42;
  return [a, arguments[0]];
}
var pair = f(17);
assert(pair[0] === 42);
assert(pair[1] === 17);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，的确有一种情况会显著的影响现代 JavaScript 引擎的性能。这就是使用 &lt;code&gt;arguments.callee&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
    arguments.callee; // do something with this function object
    arguments.callee.caller; // and the calling function object
}

function bigLoop() {
    for(var i = 0; i &amp;lt; 100000; i++) {
        foo(); // Would normally be inlined...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;foo&lt;/code&gt; 不再是一个单纯的内联函数 inlining（译者注：这里指的是解析器可以做内联处理），因为它需要知道它自己和它的调用者。这不仅抵消了内联函数带来的性能提升，而且破坏了封装，因此现在函数可能要依赖于特定的上下文。&lt;/p&gt;

&lt;p&gt;因此强烈建议大家不要使用 &lt;code&gt;arguments.callee&lt;/code&gt; 和它的属性。&lt;/p&gt;

&lt;p&gt;ES5 提示:在严格模式下，&lt;code&gt;arguments.callee&lt;/code&gt; 会报错&lt;code&gt;TypeError&lt;/code&gt;，因为它已经被废除了。&lt;/p&gt;

&lt;h2&gt;﻿构造函数&lt;/h2&gt;

&lt;p&gt;JavaScript 中的构造函数和其它语言中的构造函数是不同的。 通过 &lt;code&gt;new&lt;/code&gt; 关键字方式调用的函数都被认为是构造函数。&lt;/p&gt;

&lt;p&gt;在构造函数内部 - 也就是被调用的函数内 - &lt;code&gt;this&lt;/code&gt; 指向新创建的对象&lt;code&gt;Object&lt;/code&gt;。 这个新创建的对象的 &lt;code&gt;prototype&lt;/code&gt; 被指向到构造函数的&lt;code&gt;prototype&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果被调用的函数没有显式的 &lt;code&gt;return&lt;/code&gt; 表达式，则隐式的会返回 &lt;code&gt;this&lt;/code&gt; 对象 - 也就是新创建的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Foo() {
    this.bla = 1;
}

Foo.prototype.test = function() {
    console.log(this.bla);
};

var test = new Foo();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码把 &lt;code&gt;Foo&lt;/code&gt; 作为构造函数调用，并设置新创建对象的 &lt;code&gt;prototype&lt;/code&gt; 为 &lt;code&gt;Foo.prototype&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;显式的 &lt;code&gt;return&lt;/code&gt; 表达式将会影响返回结果，但仅限于返回的是一个对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Bar() {
    return 2;
}
new Bar(); // 返回新创建的对象

function Test() {
    this.value = 2;

    return {
        foo: 1
    };
}
new Test(); // 返回的对象
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;译者注：&lt;code&gt;new Bar()&lt;/code&gt; 返回的是新创建的对象，而不是数字的字面值 2。 因此&lt;code&gt;new Bar().constructor === Bar&lt;/code&gt;，但是如果返回的是数字对象，结果就不同了，如下所示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Bar() {
    return new Number(2);
}
new Bar().constructor === Number
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;译者注：这里得到的&lt;code&gt;new Test()&lt;/code&gt;是函数返回的对象，而不是通过&lt;code&gt;new&lt;/code&gt;关键字新创建的对象，因此：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(new Test()).value === undefined
(new Test()).foo === 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 &lt;code&gt;new&lt;/code&gt; 被遗漏了，则函数不会返回新创建的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Foo() {
    this.bla = 1; // 获取设置全局参数
}
Foo(); // undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然上例在有些情况下也能正常运行，但是由于 JavaScript 中 &lt;code&gt;this&lt;/code&gt; 的工作原理， 这里的 &lt;code&gt;this&lt;/code&gt; 指向全局对象。&lt;/p&gt;

&lt;h3&gt;工厂模式&lt;/h3&gt;

&lt;p&gt;为了不使用 &lt;code&gt;new&lt;/code&gt; 关键字，构造函数必须显式的返回一个值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Bar() {
    var value = 1;
    return {
        method: function() {
            return value;
        }
    }
}
Bar.prototype = {
    foo: function() {}
};

new Bar();
Bar();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面两种对 &lt;code&gt;Bar&lt;/code&gt; 函数的调用返回的值完全相同，一个新创建的拥有 &lt;code&gt;method&lt;/code&gt; 属性的对象被返回， 其实这里创建了一个闭包。&lt;/p&gt;

&lt;p&gt;还需要注意， &lt;code&gt;new Bar()&lt;/code&gt; 并不会改变返回对象的原型（译者注：也就是返回对象的原型不会指向&lt;code&gt;Bar.prototype&lt;/code&gt;）。 因为构造函数的原型会被指向到刚刚创建的新对象，而这里的 &lt;code&gt;Bar&lt;/code&gt; 没有把这个新对象返回（译者注：而是返回了一个包含 &lt;code&gt;method&lt;/code&gt; 属性的自定义对象）。&lt;/p&gt;

&lt;p&gt;在上面的例子中，使用或者不使用 &lt;code&gt;new&lt;/code&gt; 关键字没有功能性的区别。&lt;/p&gt;

&lt;p&gt;译者注：上面两种方式创建的对象不能访问 &lt;code&gt;Bar&lt;/code&gt; 原型链上的属性，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var bar1 = new Bar();
typeof(bar1.method); // &quot;function&quot;
typeof(bar1.foo); // &quot;undefined&quot;

var bar2 = Bar();
typeof(bar2.method); // &quot;function&quot;
typeof(bar2.foo); // &quot;undefined&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;通过工厂模式创建新对象&lt;/h3&gt;

&lt;p&gt;我们常听到的一条忠告是不要使用 &lt;code&gt;new&lt;/code&gt; 关键字来调用函数，因为如果忘记使用它就会导致错误。&lt;/p&gt;

&lt;p&gt;为了创建新对象，我们可以创建一个工厂方法，并且在方法内构造一个新对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Foo() {
    var obj = {};
    obj.value = 'blub';

    var private = 2;
    obj.someMethod = function(value) {
        this.value = value;
    }

    obj.getPrivate = function() {
        return private;
    }
    return obj;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然上面的方式比起 &lt;code&gt;new&lt;/code&gt; 的调用方式不容易出错，并且可以充分利用私有变量带来的便利，
但是随之而来的是一些不好的地方。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;会占用更多的内存，因为新创建的对象不能共享原型上的方法。&lt;/li&gt;
&lt;li&gt;为了实现继承，工厂方法需要从另外一个对象拷贝所有属性，或者把一个对象作为新创建对象的原型。&lt;/li&gt;
&lt;li&gt;放弃原型链仅仅是因为防止遗漏 &lt;code&gt;new&lt;/code&gt;
带来的问题，这似乎和语言本身的思想相违背。&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;虽然遗漏 &lt;code&gt;new&lt;/code&gt; 关键字可能会导致问题，但这并不是放弃使用原型链的借口。最终使用哪种方式取决于应用程序的需求，选择一种代码书写风格并坚持下去才是最重要的。&lt;/p&gt;

&lt;h2&gt;﻿作用域与命名空间&lt;/h2&gt;

&lt;p&gt;尽管 JavaScript 支持一对花括号创建的代码段，但是并不支持块级作用域；而仅仅支持函数作用域。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function test() { // 一个作用域
    for(var i = 0; i &amp;lt; 10; i++) { // 不是一个作用域
        // count
    }
    console.log(i); // 10
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:如果不是在赋值语句中，而是在 return 表达式或者函数参数中，&lt;code&gt;{...}&lt;/code&gt; 将会作为代码段解析， 而不是作为对象的字面语法解析。如果考虑到自动分号插入，这可能会导致一些不易察觉的错误。&lt;/p&gt;

&lt;p&gt;译者注：如果 &lt;code&gt;return&lt;/code&gt; 对象的左括号和 &lt;code&gt;return&lt;/code&gt; 不在一行上就会出错。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 译者注：下面输出 undefined
function add(a, b) {
    return 
        a + b;
}
console.log(add(1, 2));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript中没有显式的命名空间定义，这就意味着所有对象都定义在一个全局共享的命名空间下面。&lt;/p&gt;

&lt;p&gt;每次引用一个变量，JavaScript 会向上遍历整个作用域直到找到这个变量为止。如果到达全局作用域但是这个变量仍未找到，则会抛出 &lt;code&gt;ReferenceError&lt;/code&gt; 异常。&lt;/p&gt;

&lt;h3&gt;隐式的全局变量&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// 脚本 A
foo = '42';

// 脚本 B
var foo = '42'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面两段脚本效果不同。脚本 A 在全局作用域内定义了变量 &lt;code&gt;foo&lt;/code&gt;，而脚本 B 在当前作用域内定义变量 &lt;code&gt;foo&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;再次强调，上面的效果完全不同，不使用 &lt;code&gt;var&lt;/code&gt; 声明变量将会导致隐式的全局变量产生。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 全局作用域
var foo = 42;
function test() {
    // 局部作用域
    foo = 21;
}
test();
foo; // 21
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在函数 &lt;code&gt;test&lt;/code&gt; 内不使用 &lt;code&gt;var&lt;/code&gt; 关键字声明 &lt;code&gt;foo&lt;/code&gt; 变量将会覆盖外部的同名变量。起初这看起来并不是大问题，但是当有成千上万行代码时，不使用 &lt;code&gt;var&lt;/code&gt; 声明变量将会带来难以跟踪的 BUG。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 全局作用域
var items = [/* 数组 */];
for(var i = 0; i &amp;lt; 10; i++) {
    subLoop();
}

function subLoop() {
    // subLoop 函数作用域
    for(i = 0; i &amp;lt; 10; i++) { // 没有使用 var 声明变量
        // 干活
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;外部循环在第一次调用 &lt;code&gt;subLoop&lt;/code&gt; 之后就会终止，因为 &lt;code&gt;subLoop&lt;/code&gt; 覆盖了全局变量 &lt;code&gt;i&lt;/code&gt;。 在第二个 &lt;code&gt;for&lt;/code&gt; 循环中使用 &lt;code&gt;var&lt;/code&gt; 声明变量可以避免这种错误。 声明变量时绝对不要遗漏 &lt;code&gt;var&lt;/code&gt; 关键字，除非这就是期望的影响外部作用域的行为。&lt;/p&gt;

&lt;h3&gt;局部变量&lt;/h3&gt;

&lt;p&gt;JavaScript中局部变量只可能通过两种方式声明，一个是作为函数参数，另一个是通过 &lt;code&gt;var&lt;/code&gt; 关键字声明。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 全局变量
var foo = 1;
var bar = 2;
var i = 2;

function test(i) {
    // 函数 test 内的局部作用域
    i = 5;

    var foo = 3;
    bar = 4;
}
test(10);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;i&lt;/code&gt; 是函数 &lt;code&gt;test&lt;/code&gt; 内的局部变量，而对 &lt;code&gt;bar&lt;/code&gt; 的赋值将会覆盖全局作用域内的同名变量。&lt;/p&gt;

&lt;h3&gt;变量声明提升（Hoisting）&lt;/h3&gt;

&lt;p&gt;JavaScript 会提升变量声明。这意味着 &lt;code&gt;var&lt;/code&gt; 表达式和 &lt;code&gt;function&lt;/code&gt; 声明都将会被提升到当前作用域的顶部。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bar();
var bar = function() {};
var someValue = 42;

test();
function test(data) {
    if (false) {
        goo = 1;

    } else {
        var goo = 2;
    }
    for(var i = 0; i &amp;lt; 100; i++) {
        var e = data[i];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码在运行之前将会被转化。JavaScript 将会把 &lt;code&gt;var&lt;/code&gt; 表达式和 &lt;code&gt;function&lt;/code&gt; 声明提升到当前作用域的顶部。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// var 表达式被移动到这里
var bar, someValue; // 缺省值是 'undefined'

// 函数声明也会提升
function test(data) {
    var goo, i, e; // 没有块级作用域，这些变量被移动到函数顶部
    if (false) {
        goo = 1;

    } else {
        goo = 2;
    }
    for(i = 0; i &amp;lt; 100; i++) {
        e = data[i];
    }
}

bar(); // 出错：TypeError，因为 bar 依然是 'undefined'
someValue = 42; // 赋值语句不会被提升规则（hoisting）影响
bar = function() {};

test();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有块级作用域不仅导致 &lt;code&gt;var&lt;/code&gt; 表达式被从循环内移到外部，而且使一些 &lt;code&gt;if&lt;/code&gt; 表达式更难看懂。&lt;/p&gt;

&lt;p&gt;在原来代码中，&lt;code&gt;if&lt;/code&gt; 表达式看起来修改了全部变量&lt;code&gt;goo&lt;/code&gt;，实际上在提升规则被应用后，却是在修改局部变量。&lt;/p&gt;

&lt;p&gt;如果没有提升规则（hoisting）的知识，下面的代码看起来会抛出异常 &lt;code&gt;ReferenceError&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 检查 SomeImportantThing 是否已经被初始化
if (!SomeImportantThing) {
    var SomeImportantThing = {};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上，上面的代码正常运行，因为 &lt;code&gt;var&lt;/code&gt; 表达式会被提升到全局作用域的顶部。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var SomeImportantThing;

// 其它一些代码，可能会初始化 SomeImportantThing，也可能不会

// 检查是否已经被初始化
if (!SomeImportantThing) {
    SomeImportantThing = {};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;译者注：在 Nettuts+ 网站有一篇介绍 hoisting 的&lt;a href=&quot;http://net.tutsplus.com/tutorials/javascript-ajax/quick-tip-javascript-hoisting-explained/&quot;&gt;文章&lt;/a&gt;，其中的代码很有启发性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 译者注：来自 Nettuts+ 的一段代码，生动的阐述了 JavaScript 中变量声明提升规则
var myvar = 'my value';  

(function() {  
    alert(myvar); // undefined  
    var myvar = 'local value';  
})();  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;名称解析顺序&lt;/h3&gt;

&lt;p&gt;JavaScript 中的所有作用域，包括全局作用域，都有一个特别的名称 &lt;code&gt;this&lt;/code&gt; 指向当前对象。&lt;/p&gt;

&lt;p&gt;函数作用域内也有默认的变量 &lt;code&gt;arguments&lt;/code&gt;，其中包含了传递到函数中的参数。&lt;/p&gt;

&lt;p&gt;比如，当访问函数内的 &lt;code&gt;foo&lt;/code&gt; 变量时，JavaScript 会按照下面顺序查找：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当前作用域内是否有 &lt;code&gt;var foo&lt;/code&gt; 的定义。&lt;/li&gt;
&lt;li&gt;函数形式参数是否有使用 &lt;code&gt;foo&lt;/code&gt; 名称的。&lt;/li&gt;
&lt;li&gt;函数自身是否叫做 &lt;code&gt;foo&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;回溯到上一级作用域，然后从#1重新开始。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;注意:自定义 &lt;code&gt;arguments&lt;/code&gt; 参数将会阻止原生的 &lt;code&gt;arguments&lt;/code&gt; 对象的创建。&lt;/p&gt;

&lt;h3&gt;命名空间&lt;/h3&gt;

&lt;p&gt;只有一个全局作用域导致的常见错误是命名冲突。在JavaScript中，这可以通过匿名包装器轻松解决。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function() {
    // 函数创建一个命名空间

    window.foo = function() {
        // 对外公开的函数，创建了闭包
    };

})(); // 立即执行此匿名函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匿名函数被认为是 表达式；因此为了可调用性，它们首先会被执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;( // 小括号内的函数首先被执行
function() {}
) // 并且返回函数对象
() // 调用上面的执行结果，也就是函数对象
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有一些其他的调用函数表达式的方法，比如下面的两种方式语法不同，但是效果一模一样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 另外两种方式
+function(){}();
(function(){}());
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;结论&lt;/h3&gt;

&lt;p&gt;推荐使用匿名包装器（译者注：也就是自执行的匿名函数）来创建命名空间。这样不仅可以防止命名冲突，而且有利于程序的模块化。&lt;/p&gt;

&lt;p&gt;另外，使用全局变量被认为是不好的习惯。这样的代码倾向于产生错误和带来高的维护成本。&lt;/p&gt;

&lt;h2&gt;﻿数组遍历与属性&lt;/h2&gt;

&lt;p&gt;虽然在 JavaScript 中数组是是对象，但是没有好的理由去使用 &lt;code&gt;for in&lt;/code&gt; 循环遍历数组。 相反，有一些好的理由不去使用 &lt;code&gt;for in&lt;/code&gt; 遍历数组。&lt;/p&gt;

&lt;p&gt;注意:JavaScript 中数组不是关联数组。 JavaScript 中只有对象来管理键值的对应关系。但是关联数组是保持顺序的，而对象不是。&lt;/p&gt;

&lt;p&gt;由于 &lt;code&gt;for in&lt;/code&gt; 循环会枚举原型链上的所有属性，唯一过滤这些属性的方式是使用 &lt;code&gt;hasOwnProperty&lt;/code&gt; 函数， 因此会比普通的 &lt;code&gt;for&lt;/code&gt; 循环慢上好多倍。&lt;/p&gt;

&lt;h3&gt;遍历&lt;/h3&gt;

&lt;p&gt;为了达到遍历数组的最佳性能，推荐使用经典的 &lt;code&gt;for&lt;/code&gt; 循环。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var list = [1, 2, 3, 4, 5, ...... 100000000];
for(var i = 0, l = list.length; i &amp;lt; l; i++) {
    console.log(list[i]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码有一个处理，就是通过 &lt;code&gt;l = list.length&lt;/code&gt; 来缓存数组的长度。&lt;/p&gt;

&lt;p&gt;虽然 &lt;code&gt;length&lt;/code&gt;　是数组的一个属性，但是在每次循环中访问它还是有性能开销。可能最新的　JavaScript　引擎在这点上做了优化，但是我们没法保证自己的代码是否运行在这些最近的引擎之上。&lt;/p&gt;

&lt;p&gt;实际上，不使用缓存数组长度的方式比缓存版本要慢很多。&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;length&lt;/code&gt; 属性&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;length&lt;/code&gt; 属性的getter方式会简单的返回数组的长度，而setter方式会截断数组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var foo = [1, 2, 3, 4, 5, 6];
foo.length = 3;
foo; // [1, 2, 3]

foo.length = 6;
foo; // [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;译者注：在 Firebug 中查看此时 &lt;code&gt;foo&lt;/code&gt; 的值是：&lt;code&gt;[1, 2, 3, undefined, undefined, undefined]&lt;/code&gt;,但是这个结果并不准确，如果你在 Chrome 的控制台查看 &lt;code&gt;foo&lt;/code&gt; 的结果，你会发现是这样的： &lt;code&gt;[1, 2, 3]&lt;/code&gt; 因为在 JavaScript 中 &lt;code&gt;undefined&lt;/code&gt; 是一个变量，注意是变量不是关键字，因此上面两个结果的意义是完全不相同的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 译者注：为了验证，我们来执行下面代码，看序号 5 是否存在于 foo 中。
5 in foo; // 不管在 Firebug 或者 Chrome 都返回 false
foo[5] = undefined;
5 in foo; // 不管在 Firebug 或者 Chrome 都返回 true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为 &lt;code&gt;length&lt;/code&gt; 设置一个更小的值会截断数组，但是增大 &lt;code&gt;length&lt;/code&gt; 属性值不会对数组产生影响。&lt;/p&gt;

&lt;h3&gt;结论&lt;/h3&gt;

&lt;p&gt;为了更好的性能，推荐使用普通的 &lt;code&gt;for&lt;/code&gt; 循环并缓存数组的 &lt;code&gt;length&lt;/code&gt; 属性。使用 &lt;code&gt;for in&lt;/code&gt; 遍历数组被认为是不好的代码习惯并倾向于产生错误和导致性能问题。&lt;/p&gt;

&lt;h2&gt;﻿&lt;code&gt;Array&lt;/code&gt; 构造函数&lt;/h2&gt;

&lt;p&gt;由于 &lt;code&gt;Array&lt;/code&gt; 的构造函数在如何处理参数时有点模棱两可，因此总是推荐使用数组的字面语法 -
&lt;code&gt;[]&lt;/code&gt; - 来创建数组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1, 2, 3]; // 结果: [1, 2, 3]
new Array(1, 2, 3); // 结果: [1, 2, 3]

[3]; // 结果: [3]
new Array(3); // 结果: [] 
new Array('3') // 结果: ['3']

// 译者注：因此下面的代码将会使人很迷惑
new Array(3, 4, 5); // 结果: [3, 4, 5] 
new Array(3) // 结果: []，此数组长度为 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;译者注：这里的模棱两可指的是数组的&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array&quot;&gt;两种构造函数语法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由于只有一个参数传递到构造函数中（译者注：指的是 &lt;code&gt;new Array(3);&lt;/code&gt; 这种调用方式），并且这个参数是数字，构造函数会返回一个 &lt;code&gt;length&lt;/code&gt; 属性被设置为此参数的空数组。 需要特别注意的是，此时只有 &lt;code&gt;length&lt;/code&gt; 属性被设置，真正的数组并没有生成。&lt;/p&gt;

&lt;p&gt;译者注：在 Firebug 中，你会看到&lt;code&gt;[undefined, undefined, undefined]&lt;/code&gt;，这其实是不对的。在上一节有详细的分析。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = new Array(3);
arr[1]; // undefined
1 in arr; // false, 数组还没有生成
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种优先于设置数组长度属性的做法只在少数几种情况下有用，比如需要循环字符串，可以避免 &lt;code&gt;for&lt;/code&gt; 循环的麻烦。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new Array(count + 1).join(stringToRepeat);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;译者注：&lt;code&gt;new Array(3).join('#')&lt;/code&gt; 将会返回 &lt;code&gt;##&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;结论&lt;/h3&gt;

&lt;p&gt;应该尽量避免使用数组构造函数创建新数组。推荐使用数组的字面语法。它们更加短小和简洁，因此增加了代码的可读性。&lt;/p&gt;

&lt;h2&gt;﻿相等与比较&lt;/h2&gt;

&lt;p&gt;JavaScript 有两种方式判断两个值是否相等。&lt;/p&gt;

&lt;h3&gt;等于操作符&lt;/h3&gt;

&lt;p&gt;等于操作符由两个等号组成：&lt;code&gt;==&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;JavaScript是弱类型语言，这就意味着，等于操作符会为了比较两个值而进行强制类型转换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;&quot;           ==   &quot;0&quot;           // false
0            ==   &quot;&quot;            // true
0            ==   &quot;0&quot;           // true
false        ==   &quot;false&quot;       // false
false        ==   &quot;0&quot;           // true
false        ==   undefined     // false
false        ==   null          // false
null         ==   undefined     // true
&quot; \t\r\n&quot;    ==   0             // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的表格展示了强类型转换，这也是使用 &lt;code&gt;==&lt;/code&gt; 被广泛认为是不好编程习惯的主要原因，由于它的复杂转换规则，会导致难以跟踪的问题。&lt;/p&gt;

&lt;p&gt;此外，强制类型转换也会带来性能消耗，比如一个字符串为了和一个数组进行比较，必须事先被强制转换为数字。&lt;/p&gt;

&lt;h3&gt;严格等于操作符&lt;/h3&gt;

&lt;p&gt;严格等于操作符由三个等号组成：&lt;code&gt;===&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;不想普通的等于操作符，严格等于操作符不会进行强制类型转换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;&quot;           ===   &quot;0&quot;           // false
0            ===   &quot;&quot;            // false
0            ===   &quot;0&quot;           // false
false        ===   &quot;false&quot;       // false
false        ===   &quot;0&quot;           // false
false        ===   undefined     // false
false        ===   null          // false
null         ===   undefined     // false
&quot; \t\r\n&quot;    ===   0             // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的结果更加清晰并有利于代码的分析。如果两个操作数类型不同就肯定不相等也有助于性能的提升。&lt;/p&gt;

&lt;h3&gt;比较对象&lt;/h3&gt;

&lt;p&gt;虽然 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;===&lt;/code&gt; 操作符都是等于操作符，但是当其中有一个操作数为对象时，行为就不同了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{} === {};                   // false
new String('foo') === 'foo'; // false
new Number(10) === 10;       // false
var foo = {};
foo === foo;                 // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里等于操作符比较的不是值是否相等，而是是否属于同一个身份；也就是说，只有对象的同一个实例才被认为是相等的。这有点像 Python 中的 &lt;code&gt;is&lt;/code&gt; 和 C 中的指针比较。&lt;/p&gt;

&lt;h3&gt;结论&lt;/h3&gt;

&lt;p&gt;强烈推荐使用严格等于操作符。如果类型需要转换，应该在比较之前显式的转换，而不是使用语言本身复杂的强制转换规则。&lt;/p&gt;

&lt;h2&gt;﻿&lt;code&gt;typeof&lt;/code&gt; 操作符&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;typeof&lt;/code&gt; 操作符（和 &lt;code&gt;instanceof&lt;/code&gt; 一起）或许是 JavaScript 中最大的设计缺陷，因为几乎不可能从它们那里得到想要的结果。&lt;/p&gt;

&lt;p&gt;尽管 &lt;code&gt;instanceof&lt;/code&gt; 还有一些极少数的应用场景，&lt;code&gt;typeof&lt;/code&gt; 只有一个实际的应用（译者注：这个实际应用是用来检测一个对象是否已经定义或者是否已经赋值），而这个应用却不是用来检查对象的类型。&lt;/p&gt;

&lt;p&gt;注意:由于 &lt;code&gt;typeof&lt;/code&gt; 也可以像函数的语法被调用，比如&lt;code&gt;typeof(obj)&lt;/code&gt;，但这并是一个函数调用。那两个小括号只是用来计算一个表达式的值，这个返回值会作为 &lt;code&gt;typeof&lt;/code&gt; 操作符的一个操作数。 实际上不存在名为 &lt;code&gt;typeof&lt;/code&gt; 的函数。&lt;/p&gt;

&lt;h3&gt;JavaScript 类型表格&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Value               Class      Type
-------------------------------------
&quot;foo&quot;               String     string
new String(&quot;foo&quot;)   String     object
1.2                 Number     number
new Number(1.2)     Number     object
true                Boolean    boolean
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
new Function(&quot;&quot;)    Function   function
/abc/g              RegExp     object (function in Nitro/V8)
new RegExp(&quot;meow&quot;)  RegExp     object (function in Nitro/V8)
{}                  Object     object
new Object()        Object     object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面表格中，Type一列表示 &lt;code&gt;typeof&lt;/code&gt; 操作符的运算结果。可以看到，这个值在大多数情况下都返回 &quot;object&quot;。&lt;/p&gt;

&lt;p&gt;Class一列表示对象的内部属性 &lt;code&gt;[[Class]]&lt;/code&gt; 的值。&lt;/p&gt;

&lt;p&gt;JavaScript 标准文档中定义:&lt;code&gt;[[Class]]&lt;/code&gt; 的值只可能是下面字符串中的一个：&lt;code&gt;Arguments&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt;, &lt;code&gt;JSON&lt;/code&gt;,&lt;code&gt;Math&lt;/code&gt;, &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;RegExp&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;为了获取对象的 &lt;code&gt;[[Class]]&lt;/code&gt;，我们需要使用定义在 &lt;code&gt;Object.prototype&lt;/code&gt; 上的方法 &lt;code&gt;toString&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;对象的类定义&lt;/h3&gt;

&lt;p&gt;JavaScript 标准文档只给出了一种获取 &lt;code&gt;[[Class]]&lt;/code&gt; 值的方法，那就是使用 &lt;code&gt;Object.prototype.toString&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function is(type, obj) {
    var clas = Object.prototype.toString.call(obj).slice(8, -1);
    return obj !== undefined &amp;amp;&amp;amp; obj !== null &amp;amp;&amp;amp; clas === type;
}

is('String', 'test'); // true
is('String', new String('test')); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面例子中，&lt;code&gt;Object.prototype.toString&lt;/code&gt; 方法被调用，this 被设置为了需要获取 &lt;code&gt;[[Class]]&lt;/code&gt; 值的对象。&lt;/p&gt;

&lt;p&gt;译者注：&lt;code&gt;Object.prototype.toString&lt;/code&gt; 返回一种标准格式字符串，所以上例可以通过 &lt;code&gt;slice&lt;/code&gt; 截取指定位置的字符串，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Object.prototype.toString.call([])  // &quot;[object Array]&quot;
Object.prototype.toString.call({})  // &quot;[object Object]&quot;
Object.prototype.toString.call(2)   // &quot;[object Number]&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ES5 提示:在 ECMAScript 5 中，为了方便，对 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 调用 &lt;code&gt;Object.prototype.toString&lt;/code&gt; 方法， 其返回值由 &lt;code&gt;Object&lt;/code&gt; 变成了 &lt;code&gt;Null&lt;/code&gt; 和 &lt;code&gt;Undefined&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;译者注：这种变化可以从 IE8 和 Firefox 4 中看出区别，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// IE8
Object.prototype.toString.call(null)    // &quot;[object Object]&quot;
Object.prototype.toString.call(undefined)   // &quot;[object Object]&quot;

// Firefox 4
Object.prototype.toString.call(null)    // &quot;[object Null]&quot;
Object.prototype.toString.call(undefined)   // &quot;[object Undefined]&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;测试为定义变量&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;typeof foo !== 'undefined'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码会检测 &lt;code&gt;foo&lt;/code&gt; 是否已经定义；如果没有定义而直接使用会导致 &lt;code&gt;ReferenceError&lt;/code&gt; 的异常。 这是 &lt;code&gt;typeof&lt;/code&gt; 唯一有用的地方。&lt;/p&gt;

&lt;h3&gt;结论&lt;/h3&gt;

&lt;p&gt;为了检测一个对象的类型，强烈推荐使用 &lt;code&gt;Object.prototype.toString&lt;/code&gt; 方法；因为这是唯一一个可依赖的方式。正如上面表格所示，&lt;code&gt;typeof&lt;/code&gt;的一些返回值在标准文档中并未定义， 因此不同的引擎实现可能不同。&lt;/p&gt;

&lt;p&gt;除非为了检测一个变量是否已经定义，我们应尽量避免使用 &lt;code&gt;typeof&lt;/code&gt; 操作符。&lt;/p&gt;

&lt;h2&gt;﻿&lt;code&gt;instanceof&lt;/code&gt; 操作符&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt;操作符用来比较两个操作数的构造函数。只有在比较自定义的对象时才有意义。如果用来比较内置类型，将会和 &lt;code&gt;typeof&lt;/code&gt; 操作符 一样用处不大。&lt;/p&gt;

&lt;h3&gt;比较自定义对象&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function Foo() {}
function Bar() {}
Bar.prototype = new Foo();

new Bar() instanceof Bar; // true
new Bar() instanceof Foo; // true

// 如果仅仅设置 Bar.prototype 为函数 Foo 本省，而不是 Foo 构造函数的一个实例
Bar.prototype = Foo;
new Bar() instanceof Foo; // false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;code&gt;instanceof&lt;/code&gt; 比较内置类型&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;new String('foo') instanceof String; // true
new String('foo') instanceof Object; // true

'foo' instanceof String; // false
'foo' instanceof Object; // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有一点需要注意，&lt;code&gt;instanceof&lt;/code&gt; 用来比较属于不同 JavaScript 上下文的对象（比如，浏览器中不同的文档结构）时将会出错，因为它们的构造函数不会是同一个对象。&lt;/p&gt;

&lt;h3&gt;结论&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt; 操作符应该仅仅用来比较来自同一个 JavaScript 上下文的自定义对象。 正如 &lt;code&gt;typeof&lt;/code&gt; 操作符一样，任何其它的用法都应该是避免的。&lt;/p&gt;

&lt;h2&gt;﻿类型转换&lt;/h2&gt;

&lt;p&gt;JavaScript 是弱类型语言，所以会在任何可能的情况下应用强制类型转换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 下面的比较结果是：true
new Number(10) == 10; // Number.toString() 返回的字符串被再次转换为数字

10 == '10';           // 字符串被转换为数字
10 == '+10 ';         // 同上
10 == '010';          // 同上 
isNaN(null) == false; // null 被转换为数字 0
                      // 0 当然不是一个 NaN（译者注：否定之否定）

// 下面的比较结果是：false
10 == 010;
10 == '-10';
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ES5 提示:以 &lt;code&gt;0&lt;/code&gt; 开头的数字字面值会被作为八进制数字解析。 而在 ECMAScript 5 严格模式下，这个特性被移除了。&lt;/p&gt;

&lt;p&gt;为了避免上面复杂的强制类型转换，强烈推荐使用严格的等于操作符。虽然这可以避免大部分的问题，但 JavaScript 的弱类型系统仍然会导致一些其它问题。&lt;/p&gt;

&lt;h3&gt;内置类型的构造函数&lt;/h3&gt;

&lt;p&gt;内置类型（比如 &lt;code&gt;Number&lt;/code&gt; 和 &lt;code&gt;String&lt;/code&gt;）的构造函数在被调用时，使用或者不使用 &lt;code&gt;new&lt;/code&gt; 的结果完全不同。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new Number(10) === 10;     // False, 对象与数字的比较
Number(10) === 10;         // True, 数字与数字的比较
new Number(10) + 0 === 10; // True, 由于隐式的类型转换
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用内置类型 &lt;code&gt;Number&lt;/code&gt; 作为构造函数将会创建一个新的 &lt;code&gt;Number&lt;/code&gt; 对象，而在不使用 &lt;code&gt;new&lt;/code&gt; 关键字的 &lt;code&gt;Number&lt;/code&gt; 函数更像是一个数字转换器。&lt;/p&gt;

&lt;p&gt;另外，在比较中引入对象的字面值将会导致更加复杂的强制类型转换。&lt;/p&gt;

&lt;p&gt;最好的选择是把要比较的值显式的转换为三种可能的类型之一。&lt;/p&gt;

&lt;h3&gt;转换为字符串&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;'' + 10 === '10'; // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将一个值加上空字符串可以轻松转换为字符串类型。&lt;/p&gt;

&lt;h3&gt;转换为数字&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;+'10' === 10; // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用一元的加号操作符，可以把字符串转换为数字。&lt;/p&gt;

&lt;p&gt;译者注：字符串转换为数字的常用方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+'010' === 10
Number('010') === 10
parseInt('010', 10) === 10  // 用来转换为整数

+'010.2' === 10.2
Number('010.2') === 10.2
parseInt('010.2', 10) === 10
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;转换为布尔型&lt;/h3&gt;

&lt;p&gt;通过使用否操作符两次，可以把一个值转换为布尔型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;!!'foo';   // true
!!'';      // false
!!'0';     // true
!!'1';     // true
!!'-1'     // true
!!{};      // true
!!true;    // true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;﻿&lt;code&gt;setTimeout&lt;/code&gt; 和 &lt;code&gt;setInterval&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;由于 JavaScript 是异步的，可以使用 &lt;code&gt;setTimeout&lt;/code&gt; 和 &lt;code&gt;setInterval&lt;/code&gt; 来计划执行函数。&lt;/p&gt;

&lt;p&gt;注意:定时处理不是ECMAScript 的标准，它们在 &lt;a href=&quot;http://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM(文档对象模型)&lt;/a&gt;被实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo() {}
var id = setTimeout(foo, 1000); // 返回一个大于零的数字
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当 &lt;code&gt;setTimeout&lt;/code&gt; 被调用时，它会返回一个 ID 标识并且计划在将来大约1000毫秒后调用 &lt;code&gt;foo&lt;/code&gt; 函数。 &lt;code&gt;foo&lt;/code&gt; 函数只会被执行一次。&lt;/p&gt;

&lt;p&gt;基于 JavaScript 引擎的计时策略，以及本质上的单线程运行方式，所以其它代码的运行可能会阻塞此线程。因此没法确保函数会在 &lt;code&gt;setTimeout&lt;/code&gt; 指定的时刻被调用。&lt;/p&gt;

&lt;p&gt;作为第一个参数的函数将会在全局作用域中执行，因此函数内的 &lt;code&gt;this&lt;/code&gt; 将会指向这个全局对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Foo() {
    this.value = 42;
    this.method = function() {
        // this 指向全局对象
        console.log(this.value); // 输出：undefined
    };
    setTimeout(this.method, 500);
}
new Foo();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:&lt;code&gt;setTimeout&lt;/code&gt; 的第一个参数是函数对象，一个常犯的错误是这样的&lt;code&gt;setTimeout(foo(), 1000)&lt;/code&gt;， 这里回调函数是 &lt;code&gt;foo&lt;/code&gt;的返回值，而不是&lt;code&gt;foo&lt;/code&gt;本身。大部分情况下，这是一个潜在的错误，因为如果函数返回&lt;code&gt;undefined&lt;/code&gt;，&lt;code&gt;setTimeout&lt;/code&gt; 也不会报错。&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;setInterval&lt;/code&gt; 的堆调用&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;setTimeout&lt;/code&gt; 只会执行回调函数一次，不过 &lt;code&gt;setInterval&lt;/code&gt; - 正如名字建议的 - 会每隔 &lt;code&gt;X&lt;/code&gt; 毫秒执行函数一次。 但是却不鼓励使用这个函数。&lt;/p&gt;

&lt;p&gt;当回调函数的执行被阻塞时，&lt;code&gt;setInterval&lt;/code&gt; 仍然会发布更多的毁掉指令。在很小的定时间隔情况下，这会导致回调函数被堆积起来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo(){
    // 阻塞执行 1 秒
}
setInterval(foo, 1000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;foo&lt;/code&gt; 会执行一次随后被阻塞了一分钟。&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;foo&lt;/code&gt; 被阻塞的时候，&lt;code&gt;setInterval&lt;/code&gt; 仍然在组织将来对回调函数的调用。因此，当第一次 &lt;code&gt;foo&lt;/code&gt; 函数调用结束时，已经有10次函数调用在等待执行。&lt;/p&gt;

&lt;h3&gt;处理可能的阻塞调用&lt;/h3&gt;

&lt;p&gt;最简单也是最容易控制的方案，是在回调函数内部使用 &lt;code&gt;setTimeout&lt;/code&gt; 函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo(){
    // 阻塞执行 1 秒
    setTimeout(foo, 1000);
}
foo();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样不仅封装了 &lt;code&gt;setTimeout&lt;/code&gt; 回调函数，而且阻止了调用指令的堆积，可以有更多的控制。 &lt;code&gt;foo&lt;/code&gt;函数现在可以控制是否继续执行还是终止执行。&lt;/p&gt;

&lt;h3&gt;手工清空定时器&lt;/h3&gt;

&lt;p&gt;可以通过将定时时产生的 ID 标识传递给 &lt;code&gt;clearTimeout&lt;/code&gt; 或者 &lt;code&gt;clearInterval&lt;/code&gt; 函数来清除定时， 至于使用哪个函数取决于调用的时候使用的是 &lt;code&gt;setTimeout&lt;/code&gt; 还是 &lt;code&gt;setInterval&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var id = setTimeout(foo, 1000);
clearTimeout(id);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;清除所有定时器&lt;/h3&gt;

&lt;p&gt;由于没有内置的清除所有定时器的方法，可以采用一种暴力的方式来达到这一目的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 清空&quot;所有&quot;的定时器
for(var i = 1; i &amp;lt; 1000; i++) {
    clearTimeout(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能还有些定时器不会在上面代码中被清除（译者注：如果定时器调用时返回的 ID 值大于 1000）， 因此我们可以事先保存所有的定时器 ID，然后一把清除。&lt;/p&gt;

&lt;h3&gt;隐藏使用 &lt;code&gt;eval&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;setTimeout&lt;/code&gt; 和 &lt;code&gt;setInterval&lt;/code&gt; 也接受第一个参数为字符串的情况。这个特性绝对不要使用，因为它在内部使用了 &lt;code&gt;eval&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;注意:由于定时器函数不是 ECMAScript 的标准，如何解析字符串参数在不同的 JavaScript 引擎实现中可能不同。 事实上，微软的 JScript 会使用 &lt;code&gt;Function&lt;/code&gt; 构造函数来代替 &lt;code&gt;eval&lt;/code&gt; 的使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
    // 将会被调用
}

function bar() {
    function foo() {
        // 不会被调用
    }
    setTimeout('foo()', 1000);
}
bar();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于 &lt;code&gt;eval&lt;/code&gt; 在这种情况下不是被直接调用，因此传递到 &lt;code&gt;setTimeout&lt;/code&gt; 的字符串会自全局作用域中执行； 因此，上面的回调函数使用的不是定义在 &lt;code&gt;bar&lt;/code&gt; 作用域中的局部变量 &lt;code&gt;foo&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;建议不要在调用定时器函数时，为了向回调函数传递参数而使用字符串的形式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo(a, b, c) {}

// 不要这样做
setTimeout('foo(1,2, 3)', 1000)

// 可以使用匿名函数完成相同功能
setTimeout(function() {
    foo(a, b, c);
}, 1000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:虽然也可以使用这样的语法 &lt;code&gt;setTimeout(foo, 1000, a, b, c)&lt;/code&gt;，但是不推荐这么做，因为在使用对象的属性方法时可能会出错。（译者注：这里说的是属性方法内，&lt;code&gt;this&lt;/code&gt; 的指向错误）&lt;/p&gt;

&lt;h3&gt;结论&lt;/h3&gt;

&lt;p&gt;绝对不要使用字符串作为 &lt;code&gt;setTimeout&lt;/code&gt; 或者 &lt;code&gt;setInterval&lt;/code&gt; 的第一个参数，这么写的代码明显质量很差。当需要向回调函数传递参数时，可以创建一个匿名函数，在函数内执行真实的回调函数。&lt;/p&gt;

&lt;p&gt;另外，应该避免使用 &lt;code&gt;setInterval&lt;/code&gt;，因为它的定时执行不会被 JavaScript 阻塞。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>使用面向对象技术创建高级Web应用程序</title>
   <link href="http://beango.github.com/archives/2013/06/22/create-advanced-web-applications-with-object-oriented-techniques.html"/>
   <updated>2013-06-22T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/06/22/create-advanced-web-applications-with-object-oriented-techniques</id>
   <content type="html">&lt;p&gt;&lt;em&gt;英文原文：&lt;a href=&quot;http://msdn.microsoft.com/en-us/magazine/cc163419.aspx&quot;&gt;Create Advanced Web Applications With Object-Oriented Techniques&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;最近，我面试了一位具有5年Web应用开发经验的软件开发人员。她有4年半的JavaScript编程经验，自认为自己具有非常优秀的JavaScript技能，可是，随后我很快发现，实际上她对JavaScript却知之甚少。然而，我并不是要为此而责怪她。JavaScript就是这么不可思议。有很多人（也包括我自己，这种情况直到最近才有所改观）都自以为是，觉得因为他们懂C/C++/C#或者具有编程经验，便以为他们非常擅长JavaScript这门语言。&lt;/p&gt;

&lt;p&gt;从某个角度讲，这种自以为是也并非毫无道理。用JavaScript做一些简单的事情是非常容易的。其入门的门槛非常低；这个语言待人宽厚，并不苛求你必须懂它很多才能开始用它编写代码。甚至对于非程序员来说，也可以仅花个把小时就能够上手用它为他的网站编写几段或多或少都有些用的脚本。&lt;/p&gt;

&lt;p&gt;实际上直到最近，无论懂的JavaScript有多么少，仅仅在MSDN® DHTML参考资料以及我在C++/C#方面编程经验的帮助下，我都能够凑合过下去。直到我在工作中真正开始编写AJAX应用时，我才发现我对JavaScript的了解有多么欠缺。这种新一代的Web应用复杂的交互特性要求使用一种完全不同的方式来编写JavaScript代码。这些都是非常严肃的JavaScript应用！我们以往那种漫不经心编写脚本的方法不灵了。&lt;/p&gt;

&lt;p&gt;面向对象的编程(OOP)这种方法广泛用于多种JavaScript库，采用这种方法可使代码库更加易于管理和维护。JavaScript支持OOP，但它的支持方式同流行的Microsoft®.NET框架下的C++、C#、Visual Basic®等语言完全不同，所以，大量使用这些语言的开发者起初可能会发现，JavaScript中的OOP比较怪异，同直觉不符。我写这篇文章就是要对JavaScript到底是如何支持面向对象编程的以及如何高效利用这种支进行面向对象的JavaScript开发进行深入讨论。接下来让我们开始谈谈对象（除了对象还能有别的吗？）吧。&lt;/p&gt;

&lt;h2&gt;JavaScript对象是字典&lt;/h2&gt;

&lt;p&gt;在C++或C#中，当谈及对象时，我们指的是类或者结构的实例。对象根据实例化出它的模版（也即，类）的不同而具有不同的属性和方法。JavaScript对象不是这样的。在JavaScript中，对象仅仅是name/value对的集合，我们可以把JavaScript对象看作字典，字典中的键为字符串。我们可以用我们熟悉的&quot;.&quot;(点)操作符或者一般用于字典的&quot;[]&quot;操作符，来获取或者设置对象的属性。下面的代码片段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var userObject = new Object();
userObject.lastLoginTime = new Date();
alert(userObject.lastLoginTime);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同这段代码所做的完全是同样的事情：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var userObject = {}; // equivalent to new Object()
userObject[&quot;lastLoginTime&quot;] = new Date();
alert(userObject[&quot;lastLoginTime&quot;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还可以用这样的方式，直接在userObject的定义中定义lastLoginTime属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var userObject = { &quot;lastLoginTime&quot;: new Date() };
alert(userObject.lastLoginTime);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请注意这同C#3.0的对象初始化表达式是多么的相似。另外，熟悉Python的读者会发现，在第二段和第三段代码中，我们实例化userObject的方式就是Python中指定字典的方式。这里唯一的区别的就是，JavaScript中的对象/字典只接受字符串作为键，而Python中字典则无此限制。&lt;/p&gt;

&lt;p&gt;这些例子也表明，同C++或者C#对象相比，JavaScript对象是多么地更加具有可塑性。属性lastLoginTime不必事先声明，如果在使用这个属性的时候userObject还不具有以此为名的属性，就会在userObject中把这个属性添加进来。如果记住了JavaScript对象就是字典的话，你就不会对此大惊小怪了 —— 毕竟我们随时都可以把新键（及其对应的值）添加到字典中去。&lt;/p&gt;

&lt;p&gt;JavaScript对象的属性就是这个样子的。那么，JavaScript对象的方法呢？和属性一样，JavaScript仍然和C++/C#不同。为了理解对象的方法，就需要首先仔细看看JavaScript函数。&lt;/p&gt;

&lt;h2&gt;JavaScript中的函数具有首要地位&lt;/h2&gt;

&lt;p&gt;在许多编程语言中，函数和对象一般都认为是两种不同的东西。可在JavaScript中，它们之间的区别就没有那么明显了 —— JavaScript中的函数实际上就是对象，只不过这个对象具有同其相关联的一段可执行代码。请看下面这段再普通不过的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function func(x) {
    alert(x);
}
func(&quot;blah&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是JavaScript中定义函数最常用的方式了。但是，你还可以先创建一个匿名函数对象再将该对象赋值给变量func，也即，象下面那样，定义出完全相同的函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var func = function(x) {
    alert(x);
};
func(&quot;blah2&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者甚至通过使用Function构造器，向下面这样来定义它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var func = new Function(&quot;x&quot;, &quot;alert(x);&quot;);
func(&quot;blah3&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这表明，函数实际上就是一个支持函数调用操作的对象。最后这种使用Function构造器来定义函数的方式并不常用，但却为我们带来很多很有趣的可能，其原因可能你也已经发现了，在这种函数定义的方式中，函数体只是Function构造器的一个字符串型的参数。这就意味着，你可以在JavaScript运行的时候构造出任意的函数。&lt;/p&gt;

&lt;p&gt;要进一步证明函数是对象，你可以就象为任何其它JavaScript对象一样，为函数设置或添加属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function sayHi(x) {
    alert(&quot;Hi, &quot; + x + &quot;!&quot;);
}

sayHi.text = &quot;Hello World!&quot;;
sayHi[&quot;text2&quot;] = &quot;Hello World... again.&quot;;

alert(sayHi[&quot;text&quot;]); // displays &quot;Hello World!&quot;
alert(sayHi.text2); // displays &quot;Hello World... again.&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作为对象，函数还可以赋值给变量、作为参数传递给其它函数、作为其它函数的返回值、保存为对象的属性或数组中的一员等等。&lt;strong&gt;图1&lt;/strong&gt;所示为其中一例。&lt;/p&gt;

&lt;p&gt;图1 &lt;strong&gt;函数在JavaScript具有首要地位&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// assign an anonymous function to a variable
var greet = function(x) {
    alert(&quot;Hello, &quot; + x);
};

greet(&quot;MSDN readers&quot;);

// passing a function as an argument to another
function square(x) {
    return x * x;
}

function operateOn(num, func) {
    return func(num);
}

// displays 256
alert(operateOn(16, square));

// functions as return values
function makeIncrementer() {
    return function(x) { return x + 1; };
}

var inc = makeIncrementer();
// displays 8
alert(inc(7));

// functions stored as array elements
var arr = [];
arr[0] = function(x) { return x * x; };
arr[1] = arr[0](2);
arr[2] = arr[0](arr[1]);
arr[3] = arr[0](arr[2]);

// displays 256
alert(arr[3]);

// functions as object properties
var obj = { &quot;toString&quot; : function() { return &quot;This is an object.&quot;; } };

// calls obj.toString()
alert(obj);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;记住这一点后，为对象添加方法就简单了，只要选择一个函数名并把一个函数赋值为这个函数名即可。接下来我通过将三个匿名函数分别赋值给各自相应的方法名，为一个对象定义了三个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myDog = {
    &quot;name&quot; : &quot;Spot&quot;,
    &quot;bark&quot; : function() { alert(&quot;Woof!&quot;); },
    &quot;displayFullName&quot; : function() {
        alert(this.name + &quot; The Alpha Dog&quot;);
    },

    &quot;chaseMrPostman&quot; : function() { 
        // implementation beyond the scope of this article 
    }    
};

myDog.displayFullName(); 
myDog.bark(); // Woof!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数displayFullName中&quot;this&quot;关键字的用法对C++/C#开发者来说并不陌生 —— 该方法是通过哪个对象调用的，它指的就是哪个对象（使用Visual Basic的开发者也应该熟悉这种用法 —— 只不过&quot;this&quot;在Visual Basic称作&quot;Me&quot;）。因此在上面的例子中，displayFullName中&quot;this&quot;的值指的就是myDog对象。但是，&quot;this&quot;的值不是静态的。如果通过别的对象对函数进行调用，&quot;this&quot;的值也会随之指向这个别的对象，如&lt;strong&gt;图2&lt;/strong&gt;所示。&lt;/p&gt;

&lt;p&gt;图2 &lt;strong&gt;“this”随着对象的改变而改变&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function displayQuote() {
    // the value of &quot;this&quot; will change; depends on 
    // which object it is called through
    alert(this.memorableQuote);    
}

var williamShakespeare = {
    &quot;memorableQuote&quot;: &quot;It is a wise father that knows his own child.&quot;, 
    &quot;sayIt&quot; : displayQuote
};

var markTwain = {
    &quot;memorableQuote&quot;: &quot;Golf is a good walk spoiled.&quot;, 
    &quot;sayIt&quot; : displayQuote
};

var oscarWilde = {
    &quot;memorableQuote&quot;: &quot;True friends stab you in the front.&quot; 
    // we can call the function displayQuote
    // as a method of oscarWilde without assigning it 
    // as oscarWilde’s method. 
    //&quot;sayIt&quot; : displayQuote
};

williamShakespeare.sayIt(); // true, true
markTwain.sayIt(); // he didn’t know where to play golf

// watch this, each function has a method call()
// that allows the function to be called as a 
// method of the object passed to call() as an
// argument. 
// this line below is equivalent to assigning
// displayQuote to sayIt, and calling oscarWilde.sayIt().

displayQuote.call(oscarWilde); // ouch!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;图2&lt;/strong&gt;最后一行的代码是将函数作为一个对象的方法进行调用的另外一种方式。别忘了，JavaScript中的函数是对象。每个函数对象都有一个叫做call的方法，这个方法会将函数作为该方法的第一个参数的方法进行调用。也就是说，无论将哪个对象作为第一个参数传递给call方法，它都会成为此次函数调用中&quot;this&quot;的值。后面我们就会看到，这个技术在调用基类构造器时会非常有用。&lt;/p&gt;

&lt;p&gt;有一点要记住，那就是永远不要调用不属于任意对象却包含有&quot;this&quot;的函数。如果调用了的话，就会搅乱全局命名空间。这是因为在这种调用中，&quot;this&quot;将指向Global对象，此举将严重损害你的应用。例如，下面的脚本将会改变JavaScript的全局函数isNaN的行为。我们不推荐这么干。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alert(&quot;NaN is NaN: &quot; + isNaN(NaN));

function x() {
    this.isNaN = function() { 
        return &quot;not anymore!&quot;;
    };
}

// alert!!! trampling the Global object!!!
x();

alert(&quot;NaN is NaN: &quot; + isNaN(NaN));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到此我们已经看过了创建对象并为其添加熟悉和方法的几种方式。但是，如果你仔细看了以上所举的所以代码片段就会发现，所有的熟悉和方法都是在对象的定义之中通过硬性编码定义的。要是你需要对对象的创建进行更加严格的控制，那该怎么办？例如，你可能会需要根据某些参数对对象属性中的值进行计算，或者你可能需要将对象的属性初始化为只有到代码运行时才会得到的值，你还有可能需要创建一个对象的多个实例，这些要求也是非常常见的。&lt;/p&gt;

&lt;p&gt;在C#中，我们使用类类实例化出对象实例。但是JavaScript不一样，它并没有类的概念。相反， 在下一小节你将看到，你可以利用这一点：将函数同&quot;new&quot;操作符一起使用就可以把函数当着构造器来用。&lt;/p&gt;

&lt;h2&gt;有构造函数但没有类&lt;/h2&gt;

&lt;p&gt;JavaScript中的OOP最奇怪的事，如前所述，就是JavaScript没有C#和C++中所具有的类。在C#中，通过如下这样的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dog spot = new Dog();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;能够得到一个对象，这个对象就是Dog类的一个实例。但在JavaScript中根本就没有类。要想得到同类最近似的效果，可以象下面这样定义一个构造器函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function DogConstructor(name) {
    this.name = name;
    this.respondTo = function(name) {
        if(this.name == name) {
            alert(&quot;Woof&quot;);        
        }
    };
}

var spot = new DogConstructor(&quot;Spot&quot;);
spot.respondTo(&quot;Rover&quot;); // nope
spot.respondTo(&quot;Spot&quot;); // yeah!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好吧，这里都发生了什么？先请不要管DogConstructor函数的定义，仔细看看这行代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var spot = new DogConstructor(&quot;Spot&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&quot;new&quot;操作符所做的事情很简单。首先，它会创建出一个新的空对象。然后，紧跟其后的函数调用就会得到执行，并且会将那个新建的空对象设置为该函数中&quot;this&quot;的值。换句话说，这行带有&quot;new&quot;操作符的代码可以看作等价于下面这两行代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// create an empty object
var spot = {}; 
// call the function as a method of the empty object
DogConstructor.call(spot, &quot;Spot&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在DogConstructor的函数体中可以看出，调用该函数就会对调用中关键字&quot;this&quot;所指的对象进行初始化。采用这种方式，你就可以为对象创建模版了！无论何时当你需要创建类似的对象时，你就可以用&quot;new&quot;来调用该构造器函数，然后你就能够得到一个完全初始化好的对象。这和类看上去非常相似，不是吗？实际上，JavaScript中构造器函数的名字往往就是你想模拟的类的名字，所以上面例子中的构造函数你就可以直接命名为Dog：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Think of this as class Dog
function Dog(name) {
    // instance variable 
    this.name = name;

    // instance method? Hmmm...
    this.respondTo = function(name) {
        if(this.name == name) {
            alert(&quot;Woof&quot;);        
        }
    };
}

var spot = new Dog(&quot;Spot&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面在Dog的定义中，我定义了一个叫做name的实例变量。将Dog作为构造器函数使用而创建的每个对象都有自己的一份叫做name的实例变量（如前所述，name就是该对象的字典入口）。这符合我们的期望；毕竟每个对象都需属于自己的一份实例变量，只有这样才能保存它自己的状态。但是如果你再看接下来的那行代码，就会发现Dog的每个实例都有自己的一份respondTo方法，这可是个浪费；respondTo的实例你只需要一个，只有将这一个实例在所有的Dog实例间共享即可！你可以把respondTo的定义从Dog中拿出来，这样就可以克服此问题了，就向下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function respondTo() {
    // respondTo definition
}

function Dog(name) {
    this.name = name;
    // attached this function as a method of the object
    this.respondTo = respondTo;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一来，Dog的所有实例（也即，用构造器函数Dog创建的所有实例）都可以共享respondTo方法的同一个实例了。但是，随着方法数量的增加，这种方式维护起来会越来越困难。最后你的代码库中会堆积大量的全局函数，而且，随着“类”的数量不断增加，特别是这些类的方法具有类似的方法名时，情况会变得更加糟糕。这里还有一个更好的办法，就是使用原型对象，这就是下一个小节要讨论的内容。&lt;/p&gt;

&lt;h2&gt;原型（Prototype）&lt;/h2&gt;

&lt;p&gt;原型对象是JavaScript面向对象编程中的一个核心概念。原型这个名称来自于这样一个概念：在JavaScript中，所有对象都是通过对已有的样本（也即，原型）对象进行拷贝而创建的。该原型对象的所有属性和方法都会成为通过使用该原型的构造函数生成的对象的属性和方法。你可以认为，这些对象从它们的原型中继承了相应的属性和方法。当你象这样来创建一个新的Dog对象时&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var buddy = new Dog(&quot;Buddy&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;buddy所引用的对象将从它的原型中继承到相应的属性和方法，虽然仅从上面这一行代码可能会很难看出来其原型来自哪里。buddy对象的原型来自来自构造器函数（在此例中指的就是函数Dog）的一个属性。&lt;/p&gt;

&lt;p&gt;在JavaScript中，每个函数都有一个叫做“prototype”的属性，该属性指向一个原型对象。发过来，该原型对象据有一个叫做&quot;constructor&quot;的属性，该属性又指回了这个函数本身。这是一种循环引用；&lt;strong&gt;图3&lt;/strong&gt; 更好地揭示出了这种环形关系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-06/20151040_gQ9A.gif&quot; alt=&quot;&quot; /&gt; 图3&lt;strong&gt; 每个函数的原型都具有一个叫做Constructor的属性 &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;好了，当一个函数（比如上例中的Dog）和&quot;new&quot;操作符一起使用，创建出一个对象时，该对象将从Dog.prototype中继承所有的属性。在图&lt;strong&gt;3&lt;/strong&gt;中，你可以看出，Dog.prototype对象具有一个指会Dog函数的construtor属性，每个Dog对象（它们继承自Dog.prototype)将同样也具有一个指会Dog函数的constructor属性。&lt;strong&gt;图4&lt;/strong&gt;中的代码证明了这一点。构造器函数、原型对象以及用它们创建出来的对象这三者之间的关系如&lt;strong&gt;图5&lt;/strong&gt;所示。&lt;/p&gt;

&lt;p&gt;图4 &lt;strong&gt;对象同样也具有它们原型的属性&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var spot = new Dog(&quot;Spot&quot;);

// Dog.prototype is the prototype of spot
alert(Dog.prototype.isPrototypeOf(spot));

// spot inherits the constructor property
// from Dog.prototype
alert(spot.constructor == Dog.prototype.constructor);
alert(spot.constructor == Dog);

// But constructor property doesn’t belong
// to spot. The line below displays &quot;false&quot;
alert(spot.hasOwnProperty(&quot;constructor&quot;));

// The constructor property belongs to Dog.prototype
// The line below displays &quot;true&quot;
alert(Dog.prototype.hasOwnProperty(&quot;constructor&quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-06/20151041_UD0W.gif&quot; alt=&quot;&quot; /&gt; 图5&lt;strong&gt; 继承自它们的原型的实例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有些读者可能已经注意到了&lt;strong&gt;图4&lt;/strong&gt;中对hasOwnProperty方法和isPrototypeOf方法的调用。这些方法又来自哪里呢？它们并不是来自Dog.prototype。实际上，JavaScript中还有其它一些类似于toString、toLocaleString和valueOf等等我们可以直接对Dog.prototype以及Dog的实例进行调用的方法，但它们统统都不是来自于Dog.prototype的。其实就象.NET框架具有System.Object一样，JavaScript中也有Object.prototype，它是所有类的最顶级的基类。（Object.prototype的原型为null。）&lt;/p&gt;

&lt;p&gt;在这个例子中，请记住Dog.prototype也是一个对象。它也是通过对Object的构造函数进行调用后生成的，虽然这一点在代码中并不直接出现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dog.prototype = new Object();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，就如同Dog的实例继承自Dog.prototype一样，Dog.prototype继承自Object.prototype。这就使得Dog的所有实例也都会继承Object.prototype的方法和实例。&lt;/p&gt;

&lt;p&gt;每个JavaScript对象都会继承一个原型链，该链的最末端都是Object.prototype。请注意，到此为止你在这里所见到的继承都是活生生的对象间的继承。这同你通常所认识的类在定义时形成的继承的概念不同。因此，JavaScript中的继承要来得更加的动态化。继承的算法非常简单，就是这样的：当你要访问一个对象的属性/方法时，JavaScript会首先对该属性/方法是否定义于该对象之中。如果不是，接下来就要对该对象的原型进行检查。如果还没有发现相应的定义，然后就会对该对象的原型的原型进行检查，并以此类推，直到碰到Object.prototype。&lt;strong&gt;图6&lt;/strong&gt;所示即为这个解析过程。&lt;/p&gt;

&lt;p&gt;JavaScript这种动态解析属性访问和方法调用的方式将对JavaScript带来一些影响。对原型对象的修改会马上在继承它的对象中得以体现，即使这种修改是在对象创建后才进行的也无关紧要。如果你在对象中定义了一个叫做X的属性/方法，那么该对象原型中同名的属性/方法就会无法访问到。例如，你可以通过在Dog.prototype中定义一个toString方法来对Object.prototype中的toString方法进行重载。所有修改指挥在一个方向上产生作用，即慈宁宫原型到继承它的对象这个方向，相反则不然。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图7&lt;/strong&gt;所示即为这种影响。&lt;strong&gt;图7&lt;/strong&gt;还演示了如何解决前文碰到的避免不必要的方法实例问题。不用让每个对象都具有一个单独的方法对象的实例，你可以通过将方法放到其原型之中来让所有对象共享同一个方法。此例中，getBreed方法由rover和spot共享
——
至少直到在spot中重载了getBreed（译者注：原文为toString，应为笔误）方法之前。spot在重载之后就具有自己版本的getBreed方法，但是rover对象以及随后使用new和GreatDane创建的对象仍将继承的是定义于GreatDane.prototype对象的getBreed方法。&lt;/p&gt;

&lt;p&gt;图7  &lt;strong&gt;从原型中进行继承&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function GreatDane() { }

var rover = new GreatDane();
var spot = new GreatDane();

GreatDane.prototype.getBreed = function() {
    return &quot;Great Dane&quot;;
};

// Works, even though at this point
// rover and spot are already created.
alert(rover.getBreed());

// this hides getBreed() in GreatDane.prototype
spot.getBreed = function() {
    return &quot;Little Great Dane&quot;;
};

alert(spot.getBreed()); 

// but of course, the change to getBreed 
// doesn’t propagate back to GreatDane.prototype
// and other objects inheriting from it,
// it only happens in the spot object
alert(rover.getBreed());
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;静态属性和方法&lt;/h2&gt;

&lt;p&gt;有些时候你会需要同类而不是实例捆绑到一起的属性或方法 ——
也即，静态属性和静态方法。在JavaScript中这很容易就能做到，因为函数就是对象，所以可以随心所欲为其设置属性和方法。既然构造器函数在JavaScript代表了类这个概念，所以你可以通过在构造器函数中设置属性和昂奋来为一个类添加静态方法和属性，就象这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function DateTime() { }

// set static method now()
DateTime.now = function() {
    return new Date();
};

alert(DateTime.now());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在JavaScript调用静态方法的语法实际上和C#完全相同。既然构造器函数就是类的名字，所以这也不应该有什么奇怪的。这样你就有了类、共有属性/方法以及静态属性/方法。你还需要什么呢？当然，还需要私有成员。但是，JavaScript并不直接支持私有成员（这方面它也不支持protected成员）。对象的所以属性和方法所有人都可以访问得到。这里有一种在类中定义出私有成员的方法，但要完成这个任务就需要首先对闭包有所了解。 &lt;/p&gt;

&lt;h2&gt;闭包&lt;/h2&gt;

&lt;p&gt;我学JavaScript完全是迫不得已。因为我意识到，不学习JavaScript，就无法为在工作中参加编写真正的AJAX应用做好准备。起初，我有种在程序员的级别中下降了不少等级的感觉。（我要学JavaScript了！我那些使用C++的朋友该会怎么说我啊？）但是一旦我克服了起初的抗拒心理之后，我很快发现，JavaScript实际上是一门功能强大、表达能力极强而且很小巧的语言。它甚至拥有一些其它更加流行的语言才刚刚开始支持的特性。&lt;/p&gt;

&lt;p&gt;JavaScript中更加高级的一个特性便是它对闭包的支持，在C# 2.0中是通过匿名方法对闭包提供支持的。闭包是一种运行时的现象，它产生于内部函数（在C#中成为内部匿名方法）本绑定到了其外部函数的局部变量之上的时候。显然，除非内部函数可以通过某种方式在外部函数之外也可以让其可以访问得到，否则这也没有多大意义。举个例子就可以把这个现象说得更清楚了。&lt;/p&gt;

&lt;p&gt;假如你需要基于一个简单评判标准对一个数字序列进行过滤，该标准就是大于100的数字可以留下，但要把其它的所以数字都过滤掉。你可以编写写一个如&lt;strong&gt;图8&lt;/strong&gt;所示的函数。&lt;/p&gt;

&lt;p&gt;图8 &lt;strong&gt;基于谓词（Predicate）对元素进行过滤&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function filter(pred, arr) {

    var len = arr.length;
    var filtered = []; // shorter version of new Array();

    // iterate through every element in the array...
    for(var i = 0; i &amp;amp;lt; len; i++) {
        var val = arr[i];
        // if the element satisfies the predicate let it through
        if(pred(val)) {
            filtered.push(val);
        }
    }
    return filtered;
}

var someRandomNumbers = [12, 32, 1, 3, 2, 2, 234, 236, 632,7, 8];
var numbersGreaterThan100 = filter(
    function(x) { return (x &amp;amp;gt; 100) ? true : false; }, 
    someRandomNumbers);


// displays 234, 236, 632
alert(numbersGreaterThan100);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是现在你想新建一个不同的过滤标准，比方说，这次只有大于300的数字才能留下。你可以这么做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var greaterThan300 = filter(
    function(x) { return (x &amp;amp;gt; 300) ? true : false; }, 
    someRandomNumbers);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能还需要留下大于50、25、10、600等等的数字，然而，你是如此聪明，很快就会发现它们使用的都是“大于”这同一个谓词，所不同的只是其中的数字。所以，你可以把具体的数字拿掉，编写出这么一个函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function makeGreaterThanPredicate(lowerBound) {
    return function(numberToCheck) {
        return (numberToCheck &amp;amp;gt; lowerBound) ? true : false;
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这个函数你就可以象下面这样做了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var greaterThan10 = makeGreaterThanPredicate(10);
var greaterThan100 = makeGreaterThanPredicate(100);
alert(filter(greaterThan10, someRandomNumbers));
alert(filter(greaterThan100, someRandomNumbers));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请注意makeGreaterThanPredicate函数所返回的内部匿名函数。该匿名内部函数使用了lowerBound，它是传递给makeGreaterThanPredicate的一个参数。根据通常的变量范围规则，当makeGreater­ThanPredicate函数退出后，lowerBound就离开了它的作用范围！但是在此种情况下，内部匿名函数仍然还携带着它，即使make­GreaterThanPredicate早就退出了也还是这样。这就是我们称之为闭包的东西 ——— 因为内部函数关闭着它的定义所在的环境（也即，外部函数的参数和局部变量）。&lt;/p&gt;

&lt;p&gt;乍一看，闭包也许没什么大不了的。但是如果使用得当，使用它可以在将你的点子转变为代码时，为你打开很多非常有意思的新思路。在JavaScript中闭包最值得关注的用途之一就是用它来模拟出类的私有变量。&lt;/p&gt;

&lt;h2&gt;模拟私有属性&lt;/h2&gt;

&lt;p&gt;好的，现在让我们来看看在闭包的帮助下怎样才能模拟出私有成员。函数中的私有变量通常在函数之外是访问不到的。在函数执行结束后，实际上局部变量就会永远消失。然而，如果内部函数捕获了局部变量的话，这样的局部变量就会继续存活下去。 这个实情就是在JavaScript中模拟出私有属性的关键所在。请看下面的Person类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Person(name, age) {
    this.getName = function() { return name; };
    this.setName = function(newName) { name = newName; };
    this.getAge = function() { return age; };
    this.setAge = function(newAge) { age = newAge; };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数name和age对构造器函数Person来说就是局部变量。一旦Person函数返回之后，name和age就应该被认为永远消失了。然而，这两个参数被4个内部函数捕获，这些内部函数被赋值为Person实例的方法了，因此这样一来就使得name和age能够继续存活下去，但却被很严格地限制为只有通过这4个方法才能访问到它们。所以，你可以这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var ray = new Person(&quot;Ray&quot;, 31);
alert(ray.getName());
alert(ray.getAge());
ray.setName(&quot;Younger Ray&quot;);
// Instant rejuvenation!
ray.setAge(22);

alert(ray.getName() + &quot; is now &quot; + ray.getAge() + 
      &quot; years old.&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不必在构造器中进行初始化的私有成员可以声明为构造器函数的局部变量，就象这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Person(name, age) {
    var occupation;
    this.getOccupation = function() { return occupation; };
    this.setOccupation = function(newOcc) { occupation = 
                         newOcc; };
    // accessors for name and age    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要注意的是，这样的私有成员同我们所认为的C#中的私有成员稍有不同。在C#中，类的公开方法可以直接访问类的私有成员。但是在JavaScript中，私有成员只有通过在闭包中包含有这些私有成员的方法来访问（这样的方法通常称为特权方法，因为它们不同于普通的公开方法）。因此，在Person的公开方法中，你依然可以通过Person的特权方法方法来访问私有成员：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Person.prototype.somePublicMethod = function() {
    // doesn’t work!
    // alert(this.name);
    // this one below works
    alert(this.getName());
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大家广泛认为，Douglas Crockford是第一个发现（或者可能说发表更合适）使用闭包来模拟私有成员的人。他的网站，&lt;a href=&quot;http://javascript.crockford.com/&quot;&gt;javascript.crockford.com&lt;/a&gt;，包含了JavaScript方面的大量信息 —— 对JavaScript感兴趣的开发人员都应该去他的网站看看。&lt;/p&gt;

&lt;h2&gt;类的继承&lt;/h2&gt;

&lt;p&gt;好的，现在你已经看到了如何通过构造器函数和原型对象在JavaScript中模拟类。你也已经了解原型链可以确保所有的对象都能具有Object.prototype中的通用方法。你还看到了如何使用闭包来模拟出私有成员。但是，这里好像还是缺点什么东西。你还没看到在JavaScript中如何实现类的继承；这在C#中可是司空见惯的事情。很不幸，在JavaScript进行类的继承无法象在C#中那样键入一个冒号而实现；在JavaScript中还需要做更多的事情。但从另一方面讲，因为JavaScript非常灵活，我们有多种途径实现类的继承。&lt;/p&gt;

&lt;p&gt;比方说，如&lt;strong&gt;图9&lt;/strong&gt;所示，你有一个基类叫Pet，它有一个派生类叫做Dog。怎样在JavaScript中实现这个继承关系呢？Pet类就很简单了，你已经看到过怎么实现它了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-06/20151043_zqob.gif&quot; alt=&quot;&quot; /&gt; 图9&lt;strong&gt; 类 &lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// class Pet
function Pet(name) {
    this.getName = function() { return name; };
    this.setName = function(newName) { name = newName; };
}

Pet.prototype.toString = function() {
    return &quot;This pet’s name is: &quot; + this.getName();
};

// end of class Pet
var parrotty = new Pet(&quot;Parrotty the Parrot&quot;);
alert(parrotty);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那该如何定义派生自Pet类的Dog类呢？从&lt;strong&gt;图9&lt;/strong&gt;中可看出，Dog类具有一个额外的属性，breed,，并且它还重载了Pet的toString方法（请注意，avaScript中的方法和属性命名惯例采用的是驼峰式大小写方式，即camel case；而C#推荐使用的是Pascal大小写方式）。&lt;strong&gt;图10&lt;/strong&gt;所示即为Pet类的定义实现方法：&lt;/p&gt;

&lt;p&gt;图10 &lt;strong&gt;继承Pet类&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// class Dog : Pet 
// public Dog(string name, string breed)
function Dog(name, breed) {
    // think Dog : base(name) 
    Pet.call(this, name);
    this.getBreed = function() { return breed; };
    // Breed doesn’t change, obviously! It’s read only.
    // this.setBreed = function(newBreed) { name = newName; };
}

// this makes Dog.prototype inherits
// from Pet.prototype
Dog.prototype = new Pet();

// remember that Pet.prototype.constructor
// points to Pet. We want our Dog instances’
// constructor to point to Dog.
Dog.prototype.constructor = Dog;

// Now we override Pet.prototype.toString
Dog.prototype.toString = function() {
    return &quot;This dog’s name is: &quot; + this.getName() + 
        &quot;, and its breed is: &quot; + this.getBreed();

};

// end of class Dog

var dog = new Dog(&quot;Buddy&quot;, &quot;Great Dane&quot;);

// test the new toString()
alert(dog);

// Testing instanceof (similar to the is operator)

// (dog is Dog)? yes
alert(dog instanceof Dog);

// (dog is Pet)? yes
alert(dog instanceof Pet);

// (dog is Object)? yes
alert(dog instanceof Object);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过正确设置原型链这个小把戏，就可以同在C#中所期望的那样，使得instanceof测试在JavaScript中也能够正常进行。而且如你所愿，特权方法也能够正常得以运行。&lt;/p&gt;

&lt;h2&gt;模拟命名空间&lt;/h2&gt;

&lt;p&gt;在C++和C#中，命名空间用来将命名冲突的可能性减小到最小的程度。例如，在.NET框架中，命名空间可以帮助我们区分出Microsoft.Build.Task.Message和Sys­tem.Messaging.Message这两个类。JavaScript并没有明确的语言特性来支持命名空间，但使用对象可以非常容易的模拟出命名空间。比如说你想创建一个JavaScript代码库。不想在全局中定义函数和类，你就可以将你的函数和类封装到如下这样的命名空间之中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MSDNMagNS = {};

MSDNMagNS.Pet = function(name) { // code here };
MSDNMagNS.Pet.prototype.toString = function() { // code };

var pet = new MSDNMagNS.Pet(&quot;Yammer&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只有一层命名空间可能会出现不唯一的请看，所以你可以创建嵌套的命名空间：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MSDNMagNS = {};

// nested namespace &quot;Examples&quot;
MSDNMagNS.Examples = {}; 

MSDNMagNS.Examples.Pet = function(name) { // code };
MSDNMagNS.Examples.Pet.prototype.toString = function() { // code };

var pet = new MSDNMagNS.Examples.Pet(&quot;Yammer&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不难想象，每次都键入这些很长的嵌套命名空间很快就会让人厌烦。幸运的是，你的代码库的用户可以很容易地为你的命名空间起一个比较简洁的别名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// MSDNMagNS.Examples and Pet definition...
// think &quot;using Eg = MSDNMagNS.Examples;&quot; 
var Eg = MSDNMagNS.Examples;
var pet = new Eg.Pet(&quot;Yammer&quot;);

alert(pet);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你要是看一眼Microsoft AJAX代码库的源代码的话，就会发现该库的编写者也使用了类似的技巧来实现命名空间（请看静态方法Type.registerNamespace的实现代码)。这方面更详细的信息可参见&quot;OOP and ASP.NET AJAX&quot;的侧边栏。&lt;/p&gt;

&lt;h2&gt;你应该用这种方式来进行JavaScript编程吗？&lt;/h2&gt;

&lt;p&gt;如你所见，JavaScript对面向对象的支持非常好。虽然设计为基于原型的语言，但是它足够灵活也足够强大，允许你拿它来进行通常是出现在其它常用语言中的基于类的编程风格。但是问题在于：你是否应该以这种方式来进行JavaScript编码吗？你是否应该采用C#或C++的编程方式，采用比较聪明的方式模拟出本来不存在的特性来进行JavaScript编程？每种编程语言都互不相同，一种语言的最佳实践对另外一种编程语言来讲可能就不实最佳的了。&lt;/p&gt;

&lt;p&gt;你已经了解在JavaScript中是对象继承自对象（而非类继承自类）。所以，让大量的类使用静态的继承层次结构可能不是JavaScript之道。可能就象Douglas Crockford在他的这篇文章&quot;&lt;a href=&quot;http://javascript.crockford.com/prototypal.html&quot;&gt;Prototypal Inheritance in JavaScript&lt;/a&gt;&quot;中所说的那样，JavaScript的编程之道就是创建原型对象，并使用下面这样的简单的对象函数来创建继承自原对象的新对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function object(o) {
    function F() {}
    F.prototype = o;
    return new F();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，既然JavaScript对象可塑性很强，你就可以在对象生成之后，通过为它添加必要的新字段和新方法来增强对象。&lt;/p&gt;

&lt;p&gt;这种做法都很不错，但不可否认的是，全世界大多数开发者都更加属性基于类的编程。实际上，基于类的编程还会继续流行下去。根据即将发布的ECMA-262规范（ECMA-262是JavaScript的官方规范）的第4个版本，JavaScript 2.0将具有真正的类。所以说，JavaScript正在逼近基于类的编程语言。然而，JavaScript 2.0要得到广泛使用可能还需要几年的时间。同时还有一点也很重要，就是要全面掌握当前版本的JavaScript，只有这样才能读懂和编写出基于原型和基于类的这两种风格的JavaScript代码。&lt;/p&gt;

&lt;h2&gt;大局观&lt;/h2&gt;

&lt;p&gt;随着交互式、重客户端AJAX应用的普及，JavaScript很快就成为了.NET开发者工具箱中最有用的工具之一。然而，对于更加适应C++、C#或者Visual Basic等语言的开发者来讲，JavaScript的原型本性一开始会让它们感到很不适应。我觉得我的JavaScript之旅收获颇丰，但一直以来也不乏挫折打击。如果这篇文章能够帮助你更加顺利地进步，那么我将倍感欣慰，因为这就是我写这篇文章的目的所在。&lt;/p&gt;

&lt;h2&gt;OOP 和 ASP.NET AJAX&lt;/h2&gt;

&lt;p&gt;ASP.NET AJAX中实现的OOP同我在这篇文章里讨论的规范的实现方法稍有不同。这里面主要有两个方面的原因：ASP.NET AJAX版的实现为反射（对于象xml-scrip这样的声明式语法并且为了参数验证，反射是很有必要的手段）提供了更多的可能，而且ASP.NET AJAX旨在将.NET开发者所熟悉的其它一些语法结构，比如属性、事件、枚举以及接口等翻译为JavaScript代码。&lt;/p&gt;

&lt;p&gt;在当前广泛可用的版本中，JavaScript缺乏.NET开发者所熟知的大量OOP方面的概念，ASP.NET AJAX模拟出了其中的大部分概念。&lt;/p&gt;

&lt;p&gt;类可用具有基于命名规范的属性访问器（下文中有例子），还可用完全按照.NET所提供的模式进行事件多播。私有变量的命名遵从以下划线打头的成员就是私有成员这样的规范。很少有必要使用真正私有的变量，这个策略使得我们可用从调试器中直接查看这种变量。引入接口也是为了进行类型检查，而不是通常的duck-typing（一种类型方案，其基于的概念是，如果有一种东西象鸭子那样走路并且象鸭子那样嘎嘎叫，我们就认为这种东西是鸭子，或者说可用把这种东西看作鸭子）。&lt;/p&gt;

&lt;h3&gt;类和反射&lt;/h3&gt;

&lt;p&gt;在JavaScript中，我们无法得知函数的名字。即使有可能可以得知，多数情况下这对我们来说也没有什么帮助，因为类构造器通常就是将一个匿名函数赋值为一个命名空间变量。真正的类型名的是由该变量的全限定名组成的，但却同样无法取得，构造器函数对此名也一无所知。为了克服此局限并在JavaScript类之中具有丰富的反射机制，ASP.NET AJAX要求要将类型的名字进行注册。&lt;/p&gt;

&lt;p&gt;ASP.NET AJAX中的反射API可用于任何类型，无论该类型是内建的类、接口、命名空间、甚至是枚举都没有问题，而且其中还包含有和.NET框架中相同的isInstanceOfType和inheritsFrom函数，这两个函数用来在程序运行时对类的层次结构进行检视。ASP.NET AJAX在调试模式还做了类型检查，其意义在于能够帮助开发者尽早地找出程序中的bug。&lt;/p&gt;

&lt;h3&gt;注册类的层次结构和基类的调用&lt;/h3&gt;

&lt;p&gt;要在ASP.NET AJAX中定义一个类，你需要将该类的构造器函数赋值给一个变量（要注意构造器函数是如何调用基类的方法的）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyNamespace.MyClass = function() {
    MyNamespace.MyClass.initializeBase(this);
    this._myProperty = null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，你需要在它的原型中定义该类的成员：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyNamespace.MyClass.prototype = {
    get_myProperty: function() { return this._myProperty;},
    set_myProperty: function(value) { this._myProperty = value; },
    doSomething: function() {
        MyNamespace.MyClass.callBaseMethod(this, &quot;doSomething&quot;);
        /* do something more */
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，你要对这个类进行注册：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyNamespace.MyClass.registerClass(
    &quot;MyNamespace.MyClass &quot;, MyNamespace.BaseClass);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构造器和原型的继承层次结构就不需要你管了，因为registerClass函数会为你完成此项任务。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>使用 Varnish 加速你的 Web 网站</title>
   <link href="http://beango.github.com/archives/2013/06/20/speed-your-web-site-varnish.html"/>
   <updated>2013-06-20T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/06/20/speed-your-web-site-varnish</id>
   <content type="html">&lt;p&gt;Varnish可以有效降低web服务器的负载，提升访问速度。根据官方的说法，Varnish是一个cache型的HTTP反向代理。&lt;/p&gt;

&lt;p&gt;按照HTTP协议的处理过程，web服务器接受请求并且返回处理结果，理想情况下服务器要在不做额外处理的情况下，立即返回结果，但实际情况并非如此。本文将分析在web服务器处理请求的过程中，Varnish能起到什么作用。&lt;/p&gt;

&lt;p&gt;web服务器的实现千差万别，但典型的处理过程是相同的，都要经过一系列的步骤来处理接收到的每个请求。有可能需要启动一个进程来处理请求，有可能需要从磁盘上载入文件，或者启动内部线程来编译执行一些脚本。在执行脚本的过程中，还会有进行很多别的动作，比如进行数据库查询，读取文件等等。当成百上千个请求并发访问时，服务器的负载会很快上升，出现系统资源不够的情况。一种更糟的情况是，很多请求是重复的，但web服务器无法记住曾经作出的响应，还会重复上面复杂的处理过程。&lt;/p&gt;

&lt;p&gt;当把Varnish部署上之后，web请求的处理过程会有一些变化。客户端的请求将首先被Varnish接受。Varnish将分析接收的请求，并将其转发到后端的web服务器上。后端的web服务器对请求进行常规的处理，并将依次将处理结果返回给Varnish。&lt;/p&gt;

&lt;p&gt;但Varnish的功能并非仅限于此。Varnish的核心功能是能能将后端web服务器返回的结果缓存起来，如果发现后续有相同的请求，Varnish将不会将这个请求转发到web服务器，而是返回缓存中的结果。这将有效的降低web服务器的负载，提升响应速度，并且每秒可以响应更多的请求。Varnish速度很快的另一个主要原因是其缓存全部都是放在内存里的，这比放在磁盘上要快的多。诸如此类的优化措施使得Varnish的相应速度超乎想象。但考虑到实际的系统中内存一般是有限的，所以需要手工配置一下缓存的空间限额，同时避免缓存重复的内容。&lt;/p&gt;

&lt;p&gt;下面来看一下Varnish的安装过程。可以从源码进行安装，也可以直接使用一些发行版中的预编译包。当期Varnish的版本是3.0.3（译者注：目前最新是2013年6月17日发布的3.0.4版），本文将基于3.0.3进行源码安装。需要注意的是，2.X版的Varnish和3.X的配置文件格式发生了变化。可以从Varnish的&lt;a href=&quot;https://www.varnish-cache.org/docs/3.0/installation/upgrade.html&quot;&gt;官方网站&lt;/a&gt;上找到2.x到3.x升级的细节。&lt;/p&gt;

&lt;p&gt;从源码进行安装经常遇到的问题是系统缺少某些依赖的文件。可以从Varnish的&lt;a href=&quot;https://www.varnish-cache.org/docs/3.0/installation/install.html#compiling-varnish-from-source&quot;&gt;安装文档&lt;/a&gt;里找到编译所需的所有依赖的文件。&lt;/p&gt;

&lt;p&gt;以root身份运行如下命令来下载和安装Varnish。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /var/tmp
wget http://repo.varnish-cache.org/source/varnish-3.0.3.tar.gz
tar xzf varnish-3.0.3.tar.gz
cd varnish-3.0.3
sh autogen.sh
sh configure
make
make test
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vanish将安装在/usr/local目录下。主程序的完整路径为：/usr/local/sbin/varnishd，默认的配置文件为：/usr/local/etc/varnish/default.vcl&lt;/p&gt;

&lt;p&gt;在运行varnishd之前，需要先配置后端的web服务器，参照如下格式编辑default.vcl文件，更改为你自己web服务器配置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;backend default {
    .host = &quot;127.0.0.1&quot;;
    .port = &quot;80&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用如下命令启动Varnishd：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/sbin/varnishd -f /usr/local/etc/varnish/default.vcl -a :6081 -P /var/run/varnish.pid -s malloc,256m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完毕后，Varnish将进入后台运行，同时返回命令行状态。需要注意的是，Varnish运行时会同时启动两个进程，一个主进程，一个是子进程，如果子进程出现问题，主进程将重新生成一个子进程。&lt;/p&gt;

&lt;h3&gt;Varnishd 的启动选项&lt;/h3&gt;

&lt;p&gt;-f : 指定配置文件位置&lt;/p&gt;

&lt;p&gt;-a : varnish监听的本地地址和端口。&lt;/p&gt;

&lt;p&gt;-P :PID文件位置，用来关闭Varnish&lt;/p&gt;

&lt;p&gt;-s :cache配置。默认使用256M内存&lt;/p&gt;

&lt;p&gt;如果从一些包管理器来安装varnish，可能安装完毕后就会自动运行。这种情况下需要先停掉它。并使用上述命令选项来运行。否则一些配置可能和本文例子中的不同了。可以用下面的命令来检查varnish的运行情况和配置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/bin/pgrep -lf varnish
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动完毕之后，Varnish就可以处理并转发请求了。在转发过程中，varnish会尽可能的缓存结果。我们通过下面几个简单的GET请求，来看看varnish是如何工作的。首先，运行如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/bin/varnishlog
/usr/local/bin/varnishstat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的GET命令是perl的libwww-perl中的。使用这个命令可以看到varnish返回的HTTP响应的细节。如果你的系统里没有安装libwww-perl，也可以使用Firefox中live HTTP Headers扩展，或者使用其他类似工具也可以。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET -Used http://localhost:6081/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-06/20080236_hM8L.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这里GET命令的选项无所谓。需要注意的是varnish返回的响应，varnish会增加三个相应头信息，分别是“X-Varnish”、“Via”和“Age”。这些头信息在Varnish的处理过程中非常有用。X-Varnish头信息的后面会有一个或两个数字，如果是一个数字，就表明varnish在缓存中没有发现这个请求，这个数字的含义是varnish为这个请求所做的标记ID。如果X-Varnish后是两个数字，就表明varnish在缓存中命中了这个请求，第一个数字是请求的标识ID，第二个数字是缓存的标识ID。“Via”头信息表明这个请求将经过一个代理。“Age”头信息标识出这个请求将被缓存多长时间（单位：秒）。首次请求的“Age”为0，后续的重复请求将会使Age值增大。如果后续的请求没有是“Age”增加，那就说明varnish没有缓存这个响应的结果。&lt;/p&gt;

&lt;p&gt;现在来看看 varnishstat 命令启动执行的情况，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-06/20080237_w5ic.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图2. varnishstat 命令&lt;/p&gt;

&lt;p&gt;最重要的是 cache_hit 和 cache_miss这两行。如果没有任何命中，cache_hits不会显示。当越来越多的请求进来，计数器会不断更新以反应新的命中数和未命中数。&lt;/p&gt;

&lt;p&gt;接下来看看 varnishlog 命令：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-06/20080238_inKm.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图3. varnishlog 命令&lt;/p&gt;

&lt;p&gt;上图显示varnish接受请求并作出响应的内部细节，下面是varnish官方文档中的解释：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;第一列是一个乱数，用来标识当前请求。第一列数字相同的行属于一HTTP请求序列。第二列是日志信息的标签，所有的日志信息会分类标记，以“Rx”开头的为接收的数据，以“Tx”开头的为发送的数据。第三列表示数据在客户端，vainish和web服务器之间的传输状态。第四列是被日志记录的数据。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;varnishlog命令有很多的选项可以在查询时使用。强烈推荐在排错或测试时使用varnishlog。可以阅读varnish的man page来查看这个命令的详细使用情况。下面是一些使用的例子。&lt;/p&gt;

&lt;p&gt;显示varnish和客户端之间的通信（忽略后端web服务器）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/bin/varnishlog -b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示varnish接收到的HTTP头信息（既有客户端请求的，也有web服务器响应的）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/bin/varnishlog -c -i RxHeader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只显示web服务器响应的头信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/bin/varnishlog -Dw /var/log/varnish.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从/var/log/varnish.log中读取所有日志信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kill `cat /var/run/varnish.pid`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令会从/var/run/varnish.pid中读取varnish的主进程的PID，并给这个进程发送TERM信号，从而关闭varnish。&lt;/p&gt;

&lt;p&gt;现在通过上述命令，我们可以控制varnish的启动和关闭，可以检查缓存的命中情况，下一个问题是varnish到底缓存了什么，会存多久？&lt;/p&gt;

&lt;p&gt;varnish的默认缓存策略是偏向保守的（可以通过配置改变）。它默认只缓存get请求和HEAD请求。不会缓存带有Cookie和认证信息的请求，也不会缓存带有Set-Cookie或者有变化的头信息的响应。varnish也会检查请求和响应中的Cache-Control头信息，这个头信息中会包含一些选项来控制缓存行为。当Cache-control中Max-age的控制和默认策略冲突时，varnish不会单纯的根据Cache-control信息就改变自己的缓存行为。例如：Cache-Control: max-age=n，n为数字，如果varnish收到web服务器的响应中包含max-age，varnish会以此值设定缓存的过期时间（单位：秒），否则varnish将会设置为参数配置的时间，默认为120秒。&lt;/p&gt;

&lt;h3&gt;注意:&lt;/h3&gt;

&lt;p&gt;varnish的默认配置可以适应多数情况。例如，默认的default_ttl缓存过期时间是120秒。配置文件的详细解释可以阅读varnishd的man page。如果你想改变某些默认设置，一种方式是通过命令行varnishd加上-p参数，这将重启varnishd，并清空缓存。另外一种方式是使用varnish的管理接口，要使用varnish的管理接口需要以-T参数启动varnish，这个参数指定了，varnish管理接口的监听端口。然后使用varnishadm命令连接到varnish的管理接口上，然后实时的查询varnish的运行参数，或者更改新的参数，这些都不需要重启varnish。&lt;/p&gt;

&lt;p&gt;想要了解详细的情况，可以参阅varnishd、varnishadm和varnish-cli的man page。&lt;/p&gt;

&lt;p&gt;一般情况下我们会改变varnish的缓存行为，定制自己的缓存策略。可以将配置写入默认的default.vcl文件，VCL是varnish的配置文件的格式，像一种简单的脚本语言。可以通过vcl的man page来了解详细的格式，推荐阅读。&lt;/p&gt;

&lt;p&gt;在修改default.vcl配置之前，我们先来看一下varnish处理http请求的一个完整过程。我们将之成为一个请求／响应周期（request/response cycle）。这个过程始于varnish收到客户端的请求，varnish将检查这个请求，并将其标记存储，接下来varnish将根据一定的策略决定是将这个请求直接转发，还是检查缓存。如果是第一种情况，varnish会将请求直接转发到后端的服务器上，并且将服务器的响应返回给你客户端。如果是第二种情况，varnish会进行一个缓存查询的过程，如果缓存命中，varnish会将缓存中结果返回给客户端，如果缓存中没有，varnish会将此请求转发给后端的服务器，并将服务器的响应先进行缓存，然后再转发给客户端。&lt;/p&gt;

&lt;p&gt;了解完varnish对请求和响应处理的过程之后，我们来讨论一下如何改变varnish的缓存策略。varnish有一系列的子功能来完成上述处理过程，每一个子功能完成处理过程的一个部分。每一个子功能的执行结果传递给下一个子功能。所以我们可以通过改变子功能的返回值来改变varnish的处理动作。每一个子功能都在default.vcl中有一个默认定义，可以通过改变这些值来定制varnish的功能。&lt;/p&gt;

&lt;h3&gt;Varnish 子程序&lt;/h3&gt;

&lt;p&gt;varnish的子程序在default.vcl中有默认的配置，如果你重新配置了某一个功能，并不意味着默认的动作一定不会执行。一般情况下，如果你重新配置了某一个功能，但是没有返回值，varnish将会执行默认的动，因为所有的varnish子程序都会有一个返回值。这可以看作varnish的一种容错机制。&lt;/p&gt;

&lt;p&gt;第一个子程序是“vcl_recv”，在姐收到完整的客户端请求后开始执行这个子程序，可以通过修改req对象来改变默认的请求处理，varnish根据返回值决定处理方式。比如，返回：pass，将使varnish直接转发请求到web服务器，返回：lookup，将使varnish检查缓存。&lt;/p&gt;

&lt;p&gt;下一个子程序是vcl_pass。如果在vcl_recv中返回了“pass”，将执行vcl_pass。vcl_pass有两种返回值，pass：继续转发请求到后端web服务器。restart:将请求重新返回给vcl_recv。&lt;/p&gt;

&lt;p&gt;vcl_miss和vcl_hit将会根据varnish的缓存命中情况来执行。vcl_miss的执行有两种情况,一是从后端服务器获取响应结果，并且在本地缓存（fetch），二是从后端获取到响应，但本地不缓存（pass）。如果varnish缓存命中，将会执行vcl_hit，会有两个选择，一个直接将缓存的结果返回给客户端（deliver），二是丢弃缓存，重新从后端服务器获取数据（pass）。&lt;/p&gt;

&lt;p&gt;当从后端服务器获取到数据之后，将会执行vcl_fetch过程，在这里可以通过beresp对象来访问响应数据，返回两种处理结果；deliver:按计划将数据发送给客户端，restart，退回这个请求。&lt;/p&gt;

&lt;p&gt;在vcl_deliver子程序中，可以将响应结果发送给客户端（deliver），结束这个请求，同时根据不同情况决定是否缓存结果。也可以返回“restart”值，来重新开始这个请求。&lt;/p&gt;

&lt;p&gt;如前所述，通过default.vcl来控制varnish的缓存策略，通过子程序的返回值来控制varnish的动作。子程序的返回值可以基于req和resp对象，也可以基于客户端对象，服务端对象或者后端服务器对象。但在子程序处理过程中，上述数据对象并非一直都可用。另外要注意子程序的返回值会有一定的限制范围，一个难点就是记住在什么时候，哪个子程序中什么数据对象是可用的，合法的返回值有哪些。为了让这个问题更清晰一些，下面是一张表格，可以在修改配置的时候快速参考：&lt;/p&gt;

&lt;h3&gt;表1. 各子程序中各数据对象的可用情况.&lt;/h3&gt;

&lt;table border=&quot;1&quot;&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; client &lt;/td&gt; 
   &lt;td&gt; server &lt;/td&gt; 
   &lt;td&gt; req &lt;/td&gt; 
   &lt;td&gt; bereq &lt;/td&gt; 
   &lt;td&gt; beresp &lt;/td&gt; 
   &lt;td&gt; resp &lt;/td&gt; 
   &lt;td&gt; obj &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;em&gt;vcl_recv&lt;/em&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;em&gt;vcl_pass&lt;/em&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;em&gt;vcl_miss&lt;/em&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;em&gt;vcl_hit&lt;/em&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;em&gt;vcl_fetch&lt;/em&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;em&gt;vcl_deliver&lt;/em&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt;


&lt;h3&gt;表2. 各子程序的合法返回值.&lt;/h3&gt;

&lt;table border=&quot;1&quot;&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; pass &lt;/td&gt; 
   &lt;td&gt; lookup &lt;/td&gt; 
   &lt;td&gt; error &lt;/td&gt; 
   &lt;td&gt; restart &lt;/td&gt; 
   &lt;td&gt; deliver &lt;/td&gt; 
   &lt;td&gt; fetch &lt;/td&gt; 
   &lt;td&gt; pipe &lt;/td&gt; 
   &lt;td&gt; hit_for_pass &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;em&gt;vcl_recv&lt;/em&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;em&gt;vcl_pass&lt;/em&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;em&gt;vcl_lookup&lt;/em&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;em&gt;vcl_miss&lt;/em&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;em&gt;vcl_hit&lt;/em&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;em&gt;vcl_fetch&lt;/em&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;em&gt;vcl_deliver&lt;/em&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; X &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;br&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt;


&lt;h3&gt;注意:&lt;/h3&gt;

&lt;p&gt;请仔细阅读vcl的文档来了解相关子程序，返回值以及可用的数据对象。&lt;/p&gt;

&lt;p&gt;下面是一些实际的例子：&lt;/p&gt;

&lt;p&gt;修改HTTP请求的 Host 头信息:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub vcl_recv {
    if (req.http.host ~ &quot;^www.example.com&quot;) {
        set req.http.host = &quot;example.com&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以通过 req.http.host来访问请求的HTTP host头信息，类似的，你可以通过req.http访问所有的HTTP头信息。“\~”符表示相等的意思，后面是一个正则表达式. 如果匹配上，会通过set关键字和“=”赋值操作，将hostname改为&quot;example.com&quot;.修改hostname的一个作用是防止重复的缓存。 因为varnish会通过hostname和URL来判断缓存匹配情况，所以hostname应该被修改为统一的形式。&lt;/p&gt;

&lt;p&gt;下面是默认 vcl_recv 子程序的一个片段:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub vcl_recv {
    if (req.request != &quot;GET&quot; &amp;amp;&amp;amp; req.request != &quot;HEAD&quot;) {
        return (pass);
    }
    return (lookup);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是默认的vcl_recv配置文件的片段，在这个配置中如果发现请求不是GET或者HEAD，varnish将会直接pass这个请求，并且不会缓存这个请求的响应，如果是GET或HEAD，将会到缓存中进行查找。&lt;/p&gt;

&lt;p&gt;匹配特定的URL，移除请求中的Cookie信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub vcl_recv {
    if (req.url ~ &quot;^/images&quot;) {
        unset req.http.cookie;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是varnish网站上的例子，如果发现请求的URL以&quot;/images&quot;开始，varnish会将其中的Cookie信息移除。当在cookie中设置不缓存当前响应时，varnish可以通过移除Cookie，来缓存这个响应。&lt;/p&gt;

&lt;p&gt;在对图片文件的响应头中中移除set-Cookie：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub vcl_fetch {
    if (req.url ~ &quot;\.(png|gif|jpg)$&quot;) {
        unset beresp.http.set-cookie;
        set beresp.ttl = 1h;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是varnish网站上的另一个例子。接收到web服务器的返回结果后会触发vcl_fetch处理过程。当从web服务器接收到新的数据后，beresp中保存web服务器返回的响应信息，req中是本次请求的信息。如果本次请求的文件是图像文件，varnish会将响应头信息中的“Set-Cookie”移除，并且将缓存的时间设置为1小时（带有Set-Cookie的响应，varnish不会缓存）。&lt;/p&gt;

&lt;p&gt;现在我们想朝响应信息中增加一个&quot;X-Hit&quot;的头信息，当缓存命中的时候，这个值为1，未命中的时候为0。根据上文，判断缓存命中的最简单的办法是在vcl_hit中。当缓存命中是会调用vcl_hit，因此可以考虑在vcl_hit中设置这个头信息，但从上文表1中我们看到，vcl_hit里beresp和resp都是不可用的。一个可行的办法就是在请求中设置里一个临时头信息，然后在后续的处理过程中真正进行设置。下面我们看一下这个问题是如何解决的：&lt;/p&gt;

&lt;p&gt;在响应头信息中增加“x-hit”：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub vcl_hit {
    set req.http.tempheader = &quot;1&quot;;
}

sub vcl_miss {
    set req.http.tempheader = &quot;0&quot;;
}

sub vcl_deliver {
    set resp.http.X-Hit = &quot;0&quot;;
    if (req.http.tempheader) {
        set resp.http.X-Hit = req.http.tempheader;
        unset req.http.tempheader;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述vcl_hit和vcl_miss中设置了一个临时的请求头信息，来标识出缓存的命中情况。真正的处理过程在vcl_deliver里，首先默认设置x-hit为0，然后根据请求里的临时头信息判断缓存的命中情况，并且依此更新刚才设置的x-hit默认值，最后删除此临时头信息。之所以选择在vcl_deliver里来进行处理，是因为在响应信息返回给客户端之前，只有在vcl_deliver中才可以访问resp对象。&lt;/p&gt;

&lt;p&gt;下面我们看一个针对此问题错误的解决办法：&lt;/p&gt;

&lt;p&gt;增加“x-hit”头信息（错误的方法）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub vcl_hit {
    set req.http.tempheader = &quot;1&quot;;
}

sub vcl_miss {
    set req.http.tempheader = &quot;0&quot;;
}

sub vcl_fetch {
    set beresp.http.X-Hit = &quot;0&quot;;
    if (req.http.tempheader) {
        set beresp.http.X-Hit = req.http.tempheader;
        unset req.http.tempheader;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在vcl_fetch里修改服务器返回的信息（beresp），但这并不是最终发送给客户端的数据。上述配置貌似正确，其实隐含了一个大BUG。首次请求当缓存未命中时，web服务器的响应被标上'x-hit'为0，然后送到vcl_fetch处理，并被缓存在本地。但当后续请求缓存命中时，vcl_fetch过程不会被执行，结果就导致所有的缓存命中的响应都带有x-hit=0的标记。这是在配置varnish时需要特别注意的一类问题。&lt;/p&gt;

&lt;p&gt;避免这些问题的办法是熟练掌握上述的表1的内容，并且在实际工作中多做测试。&lt;/p&gt;

&lt;p&gt;下面的配置可以让varnish将所有的数据缓存一个小时（不建议在真实环境中使用）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub vcl_recv {
    return (lookup);
}

sub vcl_fetch {
    set beresp.ttl = 1h;
    return (deliver);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上述配置中重写了vcl_recv和vcl_fetch两个过程。需要注意的是：如果vcl_fetch不返回“deliver”，varnish将会继续执行默认的处理过程，就不会有想要的效果了。&lt;/p&gt;

&lt;p&gt;一旦varnish运行生效之后，你可以通过一些负载测试工具来测试性能的改善。我通常使用的测试工具是apache自带的ab，可以从apache的安装包里找到，或者通过一些第三方的包管理器进行安装。可以在&lt;a href=&quot;http://httpd.apache.org/docs/2.4/programs/ab.html&quot;&gt;apache的网站&lt;/a&gt;上找到ab的使用文档。&lt;/p&gt;

&lt;p&gt;在下面的测试例子中，apache2.2监听在80端口，varnish监听在6081端口。用来做测试的页面是一个非常简单的perl
CGI脚本，只输出一个单行的HTML文件。通过访问相同的URL来测试apache和varnish的不同表现。为避免网络因素的影响，所有的测试都在本机执行。测试中使用的ab选项非常简单，也可以试着去改变这些选项，看看是什么结果。&lt;/p&gt;

&lt;p&gt;首先进行一个1000次的请求（n=1000），并发数量1个（c=1）.&lt;/p&gt;

&lt;p&gt;先测试apache：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ab -c 1 -n 1000 http://localhost/cgi-bin/test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图 4. Apache测试结果&lt;/p&gt;

&lt;p&gt;再测试varnish：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ab -c 1 -n 1000 http://localhost:6081/cgi-bin/test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图 5. varnish测试结果&lt;/p&gt;

&lt;p&gt;ab的测试输出里包含很多信息，最基本的性能指标有“Time per request”和“Requests per second（rps）”。&lt;/p&gt;

&lt;p&gt;从上述测试结果来看，apache的每个请求在1ms以上（780rps），而varnish在0.1ms（7336rps）比apache高了10倍。&lt;/p&gt;

&lt;p&gt;从这个测试结果说明varnish的速度比apache快，至少在当前环境下是这样。可以尝试改变ab的选项来进行不同的测试，例如改变并发访问数量。&lt;/p&gt;

&lt;h3&gt;系统负载和磁盘IO（ %iowait）&lt;/h3&gt;

&lt;p&gt;系统负载是反映CPU运行状况的指标，通常情况下系统中每个CPU核心的负载应该在1.0以下。如果你的系统中有4个CPU核心，理想的系统负载应该在4.0以下。&lt;/p&gt;

&lt;p&gt;磁盘的%iowait反映每个CPU时间片内系统的输入输出（I／O）状况。%iowait指标较高表示磁盘IO成为了系统瓶颈会拖慢整体的速度。比如，如果收到的每个请求都需要读取100个文件或者更多，这将会导致%iowait迅速升高然后成为系统性能的瓶颈。&lt;/p&gt;

&lt;p&gt;测试的时候除了关注系统的响应时间之外，还要看系统资源的使用情况。当测试请求持续很长时间时，我们比较一下两者的系统资源使用情况。监控的指标就是系统的负载（system
load）和磁盘IO（%iowait）。系统负载可以从top命令里查看，%iowait可以从iostat命令看到。在测试过程中需要同时关注这两个指标，我们打开两个终端分别运行top和iostat。&lt;/p&gt;

&lt;p&gt;运行iostat，2秒更新一次：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iostat -c 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行top:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/bin/top
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在就可以做测试了。因为要看长时间持续请求的状况下服务器的性能表现（至少要在1到10分钟），所以需要在ab的选项里加大请求次数和并发数量。&lt;/p&gt;

&lt;p&gt;使用ab对Apache进行测试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ab -c 50 -n 100000 http://localhost/cgi-bin/test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-06/20080239_FhrH.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图 6. Apache 下系统压力测试流量记录&lt;/p&gt;

&lt;p&gt;使用ab测试Varnish:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ab -c 50 -n 1000000 http://localhost:6081/cgi-bin/test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-06/20080239_P03y.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图 7. Varnish下系统压力测试流量记录&lt;/p&gt;

&lt;p&gt;首先对比响应时间，虽然截图上没有直接显示时间，但是我们可以从ab结束的时间计算出来，apache是23ms每次请求（2097rps），varnish是4ms每次请求（12099rps）。最大的差异是平均负载，Apache使系统的负载达到了12，使用varnish时则一直保持在0～0.4。在从apache切换到varnish做测试时，甚至要等上几分钟，系统负载才能回复正常。最好在非生产环境下用比较空闲的机器做这些测试。&lt;/p&gt;

&lt;p&gt;尽管真实环境中的web服务器有很多个性化的配置和需求，但是vanish一般都可以帮助你的web服务器提高性能并且降低负载。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>(译)深入理解Express.js</title>
   <link href="http://beango.github.com/archives/2013/06/14/understanding-expressjs.html"/>
   <updated>2013-06-14T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/06/14/understanding-expressjs</id>
   <content type="html">&lt;p&gt;本文针对那些对&lt;a href=&quot;http://nodejs.org&quot;&gt;Node.js&lt;/a&gt;有一定了解的读者。假设你已经知道如何运行Node代码，使用npm安装依赖模块。但我保证，你并不需要是这方面的专家。本文针对的是Express 3.2.5版 ​​本，以介绍相关概念为主。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://expressjs.org&quot;&gt;Express.js&lt;/a&gt;这么描述自己：&quot;轻量灵活的node.js Web应用框架&quot;。它可以帮助你快速搭建web应用。如果你使用过Ruby里的&lt;a href=&quot;http://www.sinatrarb.com/&quot;&gt;Sinatra&lt;/a&gt;,那么相信你对这个也会很快就能熟悉。&lt;/p&gt;

&lt;p&gt;和其他web框架一样，Express隐藏了代码背后的秘密，然后告诉你：&quot;别担心，你不用去理解这个部分&quot;。它来帮你解决这些问题，所以你不用去为这个而烦恼，只用将重心集中到代码上。换句话说，它有某些魔法！&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://expressjs.com/applications.html&quot;&gt;Express的wiki里介绍了一些它的使用者&lt;/a&gt;，其中就有很多知名的公司:MySpace, Klout.&lt;/p&gt;

&lt;p&gt;但是&lt;a href=&quot;http://shapeshed.com/all-magic-comes-with-a-price/&quot;&gt;拥有魔力是需要付出代价的&lt;/a&gt;，你可能根本就不知道它的工作原理。正如驾驶一辆汽车，我可以很好的驾驭它但是可能不理解为什么汽车可以正常工作，但是我最好知道这些东西。如果车坏掉怎​​么办？如果你想最大程度的去发挥它的性能？如果你对知识有无限的渴望并想去弄清它？&lt;/p&gt;

&lt;p&gt;那么我么首先从理解Express的最底层-Node开始。&lt;/p&gt;

&lt;h2&gt;底层：Node HTTP服务器&lt;/h2&gt;

&lt;p&gt;Node中有&lt;a href=&quot;http://nodejs.org/api/http.html&quot;&gt;HTTP模块&lt;/a&gt;,它将搭建一个web服务器的过程抽象出来。你可以这样使用:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 引入所需模块
var http = require(&quot;http&quot;);

// 建立服务器
var app = http.createServer(function(request, response) {
    response.writeHead(200, {
        &quot;Content-Type&quot;: &quot;text/plain&quot;    
    });
    response.end(&quot;Hello world!\n&quot;);
});

// 启动服务器
app.listen(1337, &quot;localhost&quot;);
console.log(&quot;Server running at http://localhost:1337/&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行这个程序(假设文件名 ​​为&lt;code&gt;app.js&lt;/code&gt; ,运行&lt;code&gt;node app.js&lt;/code&gt; )，你会得到&quot;Hello world!“在浏览器访问&lt;code&gt;localhost:1337&lt;/code&gt;，你会得到同样的结果。你也可以尝试访问其他地址，如&lt;code&gt;localhost:1337/whatever&lt;/code&gt;，结果仍然会一样。&lt;/p&gt;

&lt;p&gt;分解以上代码来看。&lt;/p&gt;

&lt;p&gt;第一行使用&lt;code&gt;require&lt;/code&gt;函数引入Node内置模块&lt;code&gt;http&lt;/code&gt;。然后存入名为&lt;code&gt;http&lt;/code&gt;的变量中。如果你要了解更多关于require函数的知识，参考&lt;a href=&quot;http://docs.nodejitsu.com/articles/getting-started/what-is-require&quot;&gt;Nodejitsu&lt;/a&gt;的文档。&lt;/p&gt;

&lt;p&gt;然后我们使用&lt;code&gt;http.createServer&lt;/code&gt;将服务器保存至&lt;code&gt;app&lt;/code&gt;变量。它将一个函数作为参数监听请求。稍后将会详细介绍它。&lt;/p&gt;

&lt;p&gt;最后我们要做的就是告诉服务器监听来自1337端口的请求，之后输出结果。然后一切完成。&lt;/p&gt;

&lt;p&gt;好的，回到request请求处理函数。这个函数相当重要。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;request方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在开始这个部分之前，我事先声明这里所涉及的HTTP相关知识与学习Express本身没有太大关系。如果你感兴趣，可以查看&lt;a href=&quot;http://nodejs.org/api/http.html&quot;&gt;HTTP模块文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;任何时候我们向服务器发起请求，request方法将会被调用。如果你不信，你可以&lt;code&gt;console.log&lt;/code&gt;将结果打印出来。你会发现每次请求一个页面时它都会出来。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;request&lt;/code&gt;是来自客户端的请求。在很多应用中，你可能会看到它的缩写&lt;code&gt;req&lt;/code&gt;。仔细看代码。我们修改代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var app = http.createServer(function(request, response) {

    // 创建answer变量
    var answer = &quot;&quot;;
    answer += &quot;Request URL: &quot; + request.url + &quot;\n&quot;;
    answer += &quot;Request type: &quot; + request.method + &quot;\n&quot;;
    answer += &quot;Request headers: &quot; + JSON.stringify(request.headers) + &quot;\n&quot;;

    // 返回结果
    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot; });
    response.end(answer);

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启服务器并刷新&lt;code&gt;localhsot:1337&lt;/code&gt;.你会发现，每次访问一个URL，就会发起一次GET请求，并会得到一堆类似用户代理或者一些其他的更加复杂的HTTP相关信息。如果你访问&lt;code&gt;localhost:1337/what_is_fraser&lt;/code&gt;,你会看到request的地址发生了变化。如果你使用不同的浏览器访问，用户代理也会跟着改变，如果你使用POST请求，request的方法也很改变。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;response&lt;/code&gt;是另外一个部分。正如&lt;code&gt;request&lt;/code&gt;被缩写为&lt;code&gt;req&lt;/code&gt;，&lt;code&gt;response&lt;/code&gt;同样被简写为&lt;code&gt;res&lt;/code&gt;。每次response你都会得到对应的返回结果，之后你便可以通过调用&lt;code&gt;response.end&lt;/code&gt;来结束。实际上最终你还是要执行这个方法的,甚至在&lt;a href=&quot;http://nodejs.org/api/http.html#http_response_end_data_encoding&quot;&gt;node&lt;/a&gt;的文档里也是这么描述的。这个方法完成了真正的数据传输部分。你可以建立一个服务器并不调用&lt;code&gt;req.end&lt;/code&gt;方法，它就会永远存在。&lt;/p&gt;

&lt;p&gt;在你返回结果之前，你也可以填写一下header头​​部部分。我们的例子里是这么写的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个步骤主要完成两件事情。第一，发送&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_HTTP_status_codes&quot;&gt;HTTP状态码&lt;/a&gt;，表示请求成功。其次，它设置了返回的头部信息。这里表示我们要返回的是纯文本格式的内容。我们也可以返回类似JSON或者HTML格式的内容。&lt;/p&gt;

&lt;p&gt;未完待续。。。&lt;/p&gt;

&lt;p&gt;// 接上回&lt;/p&gt;

&lt;p&gt;看了上面的之后，你可能会立马开始利用它来写api了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var http = require(&quot;http&quot;);

http.createServer(function(req, res) {

    // Homepage
    if(req.url == &quot;/&quot;) {
        res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/html&quot; });
        res.end(&quot;Welcome to the homepage!&quot;);
    }

    // About page
    else if (req.url == &quot;/about&quot;) {
        res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/html&quot; });
        res.end(&quot;Welcome to the about page!&quot;);
    }

    // 404'd!
    else {
        res.writeHead(404, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
        res.end(&quot;404 error! File not found.&quot;);
    }

}).listen(1337, &quot;localhost&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以选择优化代码，让它变得更整洁。也可以向&lt;a href=&quot;https://github.com/isaacs/npm-www#design-philosophy&quot;&gt;npm.org&lt;/a&gt;的那帮家伙一样用原生的Node来编写。但是你也可以选择去创建一个框架。这就是Sencha所做的，并把这个框架称为–Connect.&lt;/p&gt;

&lt;h2&gt;中间件: Connect&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.senchalabs.org/connect/&quot;&gt;Connect&lt;/a&gt;是Nodejs的中间件。可能你现在还并不太理解什么是中间件(middleware)，别担心，我马上会进行详细解释。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一段Connect代码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假如我们想要编写和上面一样的代码，但是这次我们要使用Connect.别忘记安装Connect模块( &lt;code&gt;npm install&lt;/code&gt; )。完成之后，代码看起来非常相似。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 引入所需模块
var connect = require(&quot;connect&quot;);
var http = require(&quot;http&quot;);

// 建立app
var app = connect();

// 添加中间件
app.use(function(request, response) {
    response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
    response.end(&quot;Hello world!\n&quot;);
});

// 启动应用
http.createServer(app).listen(1337);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面分解这段代码来看。&lt;/p&gt;

&lt;p&gt;首先我们分别引入了Connect和Node HTTP模块。&lt;/p&gt;

&lt;p&gt;接下来和之前一样声明&lt;code&gt;app&lt;/code&gt;变量，但是在创建服务器时，我们调用了&lt;code&gt;connect()&lt;/code&gt;.这有是如何工作的？&lt;/p&gt;

&lt;p&gt;我们添加了一个中间件，实际上就是一个函数。传入&lt;code&gt;app.use&lt;/code&gt;，几乎和上面使用request方法写法一样。实际上代码是从上面粘贴过来的。&lt;/p&gt;

&lt;p&gt;之后我们建立并启动服务器。&lt;code&gt;http.createServer&lt;/code&gt;接收函数作为参数。没错，&lt;code&gt;app&lt;/code&gt;实际上也是一个函数。这是一个Connect提供的函数，它会查找代码并自上而下执行。&lt;/p&gt;

&lt;p&gt;(你可能会看见其他人使用&lt;code&gt;app.listen(1337)&lt;/code&gt;,这实际上只是将&lt;code&gt;http.createServer&lt;/code&gt;返回一个promise对象。再Connect和Express中都是一样的原理。)&lt;/p&gt;

&lt;p&gt;接下来解释什么是中间件(middleware).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;什么是中间件?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先推荐阅读&lt;a href=&quot;http://stephensugden.com/middleware_guide/&quot;&gt;Stephen Sugden对于Connect中间件的描述&lt;/a&gt;,比我讲的更好。如果你不喜欢我的解释，那就去看看。&lt;/p&gt;

&lt;p&gt;还记得之前的request方法？每个中间件都是一个handler.依次传入request, response, next三个参数。&lt;/p&gt;

&lt;p&gt;一个最基本的中间件结构如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function myFunMiddleware(request, response, next) {
    // 对request和response作出相应操作
    // 操作完毕后返回next()即可转入下个中间件
    next();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们启动一个服务器，函数开始从顶部一直往下执行。如果你想输出函数的执行过程，添加一下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var connect = require(&quot;connect&quot;);
var http = require(&quot;http&quot;);
var app = connect();

// log中间件
app.use(function(request, response, next) {
    console.log(&quot;In comes a &quot; + request.method + &quot; to &quot; + request.url);
    next();
});

// 返回&quot;hello world&quot;
app.use(function(request, response, next) {
    response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
    response.end(&quot;Hello World!\n&quot;);
});

http.createServer(app).listen(1337);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你启动应用并访问&lt;code&gt;localhost:1337&lt;/code&gt;，你会看到服务器可以log出相关信息。&lt;/p&gt;

&lt;p&gt;有一点值得注意，任何可以在Node.js下执行的代码都可以在中间件执行。例如上面我们所使用的&lt;code&gt;req.method&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;你当然可以编写自己的中间件，但是也不要错过Connect的一些很cool的&lt;a href=&quot;https://github.com/senchalabs/connect/wiki&quot;&gt;第三方中间件&lt;/a&gt;。下面我们移除自己的log中间件，使用Connect内置方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var connect = require(&quot;connect&quot;);
var http = require(&quot;http&quot;);
var app = connect();

app.use(connect.logger());
// 一个有趣的事实：connect.logger返回一个函数

app.use(function(request, response) {
    response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
    response.end(&quot;Hello world!\n&quot;);
});

http.createServer(app).listen(1337);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跳转至浏览器并访问&lt;code&gt;localhost:1337&lt;/code&gt;你会得到同样的结果。&lt;/p&gt;

&lt;p&gt;很快有人就会想使用上面的中间件组合起来创建一个完整应用。代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var connect = require(&quot;connect&quot;);
var http = require(&quot;http&quot;);
var app = connect();

app.use(connect.logger());

// Homepage
app.use(function(request, response, next) {
    if (request.url == &quot;/&quot;) {
        response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
        response.end(&quot;Welcome to the homepage!\n&quot;);
        // The middleware stops here.
    } else {
        next();
    }
});

// About page
app.use(function(request, response, next) {
    if (request.url == &quot;/about&quot;) {
        response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
        response.end(&quot;Welcome to the about page!\n&quot;);
        // The middleware stops here.
    } else {
        next();
    }
});

// 404'd!
app.use(function(request, response) {
    response.writeHead(404, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
    response.end(&quot;404 error!\n&quot;);
});

http.createServer(app).listen(1337);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;“这个看起来不太好看!我要自己写框架！”&lt;/p&gt;

&lt;p&gt;某些人看了Connect的代码之后觉得，“这个代码可以更简单”。于是他们创造了Express.（事实上他们好像直接盗用了&lt;a href=&quot;http://www.sinatrarb.com/&quot;&gt;Sinatra&lt;/a&gt;.）&lt;/p&gt;

&lt;h2&gt;最顶层: Express&lt;/h2&gt;

&lt;p&gt;文章进入第三部分，我们开始真正进入Express.&lt;/p&gt;

&lt;p&gt;正如Connect拓展了Node, Express拓展Connect.代码的开始部分看起来和在Connect中非常类似：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require(&quot;express&quot;);
var http = require(&quot;http&quot;);
var app = express();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结尾部分也一样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http.createServer(app).listen(1337);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中间部分才是不一样的地方。Connect为我们提供了中间件，Express则为我们提供了另外三个优秀的特性：路由分发，请求处理，视图渲染。首先从如有开始看。&lt;/p&gt;

&lt;h3&gt;特性一：路由&lt;/h3&gt;

&lt;p&gt;路由的功能就是处理不同的请求。在上面的很多例子中，我们分别有首页，关于和404页面。我们是通过&lt;code&gt;if&lt;/code&gt;来判断并处理不同请求地址。&lt;/p&gt;

&lt;p&gt;但是Express却可以做的更好。Express提供了&quot;routing&quot;这个东西，也就是我们所说的路由。我觉得可读性甚至比纯文字还要好。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require(&quot;express&quot;);
var http = require(&quot;http&quot;);
var app = express();

app.all(&quot;*&quot;, function(request, response, next) {
    response.writeHead(404, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
    next();
});

app.get(&quot;/&quot;, function(request, response) {
    response.end(&quot;Welcome to the homepage!&quot;);
});

app.get(&quot;/about&quot;, function(request, response) {
    response.end(&quot;Welcome to the about page!&quot;);
});

app.get(&quot;*&quot;, function(request, response) {
    response.end(&quot;404!&quot;);
});

http.createServer(app).listen(1337);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单的引入相关模块之后，我们立即调用&lt;code&gt;app.all&lt;/code&gt;处理所有请求。写法看起来也非常像中间件不是吗？&lt;/p&gt;

&lt;p&gt;代码中的&lt;code&gt;app.get&lt;/code&gt;就是Express提供的路由系统。也可以是&lt;code&gt;app.post&lt;/code&gt;来处理POST请求，或者是PUT和任何的HTTP请求方式。第一个参数是路径，例如&lt;code&gt;/about&lt;/code&gt;或者&lt;code&gt;/&lt;/code&gt;。第二个参数类似我们之前所见过的请求handler。引用&lt;a href=&quot;http://expressjs.com/api.html#app.VERB&quot;&gt;Expess文档的内容&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;这些请求handler和中间件一样，唯一的区别是这些回调函数会调用&lt;code&gt;next('route')&lt;/code&gt;从而能够继续执行剩下的路由回调函数。这种机制简单说来，它们和我们之前提过的中间件是一样，只不过是一些函数而已。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;这些路由也可以更加灵活，看起来是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.get(&quot;/hello/:who&quot;, function(req, res) {
    res.end(&quot;Hello, &quot; + req.params.who + &quot;.&quot;);    
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启服务器并在浏览器访问&lt;code&gt;localhost:1337/hello/animelover69&lt;/code&gt;你会得到如下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello, animelover69.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://expressjs.com/api.html#app.VERB&quot;&gt;这些文档&lt;/a&gt;演示了如何使用正则表达式，可以使得路由更加灵活。如果只是单从概念理解来讲，我说的已经足够了。&lt;/p&gt;

&lt;p&gt;但是还有更加值得我们去关注的。&lt;/p&gt;

&lt;h3&gt;特性二：请求处理request handling&lt;/h3&gt;

&lt;p&gt;Express将你传入请求的handler传入request和response对象中。原先该有的还在，但是却加入了更多新的特性。&lt;a href=&quot;http://expressjs.com/api.html&quot;&gt;API文档&lt;/a&gt;里有详细解释。下面让我们来看一些例子。&lt;/p&gt;

&lt;p&gt;其中一个就是&lt;code&gt;redirect&lt;/code&gt;方法。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;response.redirect(&quot;/hello/anime&quot;);
response.redirect(&quot;http://xvfeng.me&quot;);
response.redirect(301, &quot;http://xvfeng.me&quot;); // HTTP 301 状态码
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码既不属于原生Node代码也不是来自与Connect,而是Express中自身添加的。它加入了一些例如&lt;code&gt;sendFile&lt;/code&gt;，让你传输整个文件等功能：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;response.sendFile(&quot;/path/to/anime.mp4&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;request对象还有一些很cool的属性，例如&lt;code&gt;request.ip&lt;/code&gt;可以获取IP地址,&lt;code&gt;request.files&lt;/code&gt;上传文件等。&lt;/p&gt;

&lt;p&gt;理论上来讲，我们要知道的东西也不是太多，Express做的只是拓展了request和response对象而已。Express所提供的方法，请参考&lt;a href=&quot;http://expressjs.com/api.html&quot;&gt;API文档&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;特性三：视图&lt;/h3&gt;

&lt;p&gt;Express可以渲染视图。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 启动Express
var express = require(&quot;express&quot;);
var app = express();

// 设置view目录
app.set(&quot;views&quot;, __dirname + &quot;/views&quot;);

// 设置模板引擎
app.set(&quot;view engine&quot;, &quot;jade&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开头部分的代码和前面基本一样。之后我们指定视图文件所在目录。然后告诉Express我们要使用&lt;code&gt;Jade&lt;/code&gt;作为模板引擎。&lt;a href=&quot;http://jade-lang.com/&quot;&gt;Jade&lt;/a&gt;是一种模板语言。稍后将会详细介绍。&lt;/p&gt;

&lt;p&gt;现在我们已经设置好了view.但是如何来使用它呢？&lt;/p&gt;

&lt;p&gt;首先我们建立一个名为&lt;code&gt;index.jade&lt;/code&gt;的文件并把它放入&lt;code&gt;views&lt;/code&gt;目录。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;doctype 5
html
  body
    h1 Hello, world!
    p= message
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码只是去掉了括号的HTML代码。如果你懂HTML那肯定也看得懂上面的代码。唯一有趣的是最后一样。&lt;code&gt;message&lt;/code&gt;是一个变量。它是从哪里来的呢？马上告诉你。&lt;/p&gt;

&lt;p&gt;我们需要从Express中渲染这个视图。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.get(&quot;/&quot;, function(request, response) {
    response.render(&quot;index&quot;, { message: &quot;I love anime&quot; });    
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Express为&lt;code&gt;response&lt;/code&gt;对象添加了一个&lt;code&gt;render&lt;/code&gt;方法。这个方法可以处理很多事情，但最主要的还是加载模板引擎和对应的视图文件，之后渲染成普通的HTML文档，例如这里的&lt;code&gt;index.jade&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;最后一步(我觉得可能算是第一步)就是安装Jade,因为它本身并不是Express的一部分。添加至&lt;code&gt;package.json&lt;/code&gt;文件并使用&lt;code&gt;npm install&lt;/code&gt;进行安装。&lt;/p&gt;

&lt;p&gt;如果一起设置完毕，你会看到&lt;a href=&quot;http://evanhahn.com/wp-content/uploads/2013/05/anime.html&quot;&gt;这个页面&lt;/a&gt;。&lt;a href=&quot;https://gist.github.com/EvanHahn/5673968&quot;&gt;完整代码&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;加分特性： 所有代码来自于Connect和Node&lt;/h3&gt;

&lt;p&gt;我需要再次提醒你的是Express建立与Connect和Node之上，这意味着所有的Connect中间件均可以在Express中使用。这个对与开发来讲帮助很大。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require(&quot;express&quot;);
var app = express();

app.use(express.logger()); // 继承自Connect

app.get(&quot;/&quot;, function(req, res) {
    res.send(&quot;fraser&quot;);    
});

app.listen(1337);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果说你从这篇文章中学到了一点什么，就是这一点。&lt;/p&gt;

&lt;h2&gt;实战&lt;/h2&gt;

&lt;p&gt;本文的大部分内容都是理论，但是下面我将教你如何使用它来做一点你想做的东西。我不想说的过于具体。&lt;/p&gt;

&lt;p&gt;你可以将Exp​​ress安装到系统全局，从而可以在命令行使用它。它可以帮助你迅速的完成代码组织并启动应用。使用npm安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 安装时可能需要加`sudo`
npm install -g express
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你需要帮助，输入&lt;code&gt;express --help&lt;/code&gt;。它加入一些可选参数。例如，如果你想使用EJS模板引擎，LESS作为CSS引擎。应用的名称为&quot;myApp&quot;.输入以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;express --ejs --css less myApp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里会自动生成很多文件。进入项目目录，并使用&lt;code&gt;npm install&lt;/code&gt;安装依赖包，之后便可以使用&lt;code&gt;node app&lt;/code&gt;启动应用！我建议你详细的查看项目结构和代码。它可能还算不上一个真正的应用，但是我觉得它对于初学者来讲还是很有帮助的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/visionmedia/express/tree/master/examples&quot;&gt;项目Github目录下&lt;/a&gt;也有一些很有帮助的文档。&lt;/p&gt;

&lt;h3&gt;一些补充&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果你也和我一样喜欢使用CoffeeScript，好消息是Express完美支持CoffeeScript.你甚至不需要编译它。这样你只用&lt;code&gt;coffee app.coffee&lt;/code&gt;即可启动应用。我在我的其他项目中也是这么做的。&lt;/li&gt;
&lt;li&gt;在我看到&lt;code&gt;app.use(app.router)&lt;/code&gt;的时候我很疑惑：
Express不是一直在使用router吗？简单回答是&lt;code&gt;app.router&lt;/code&gt;是Express的路由中间件，在你定义路由的时候被直接添加到项目中。如果你需要在加载其他文件之前应用，也可以直接引入它。关于这么做的原因，请参考&lt;a href=&quot;http://stackoverflow.com/a/12695813/804100&quot;&gt;StackOverflow的这个答案&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;本文是针对Express 3，而在&lt;a href=&quot;https://github.com/visionmedia/express/wiki/4.x-roadmap&quot;&gt;第四版的规划中&lt;/a&gt;又会有很多大的改动。最明显的是，Experss可能要将会分解成一些小的模块，并吸收Connect的一些特性。这个虽然还在计划中，但是也值得一看。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;如果这个还不能满足你？你肯定是个变态！你很快就会变成像一个瘾君子，半睁着眼，耗尽你最后一点精力，写着苦逼的代码。&lt;/p&gt;

&lt;p&gt;正如Rails成为使用Ruby建立网页应用的王者一样，我觉得Express也会成为Node中的主流。但是和Rails不一样，Express更加底层。似乎还没有一个真正意义上的高级Node库。我觉得可能会发生改变。（译者注：这点我不同意，Node的很多思想来自与Unix哲学，强调的是一个Module只解决一个问题，而不是成为一个复杂的库。很多Rails的开发者转向Node，就是因为Rails正在逐渐变得臃肿，不易自定义，且效率逐渐降低。）。&lt;/p&gt;

&lt;p&gt;这里我就不再多谈。已经又很多很基于Express建立了新的东西，&lt;a href=&quot;https://github.com/visionmedia/express/wiki#frameworks-built-with-express&quot;&gt;Expess的维基&lt;/a&gt;里有列举。如果你觉得好可以随意使用它们，如果你喜欢从底层做起，你也可以只选择Express。不管是哪一种，好好利用它吧。&lt;/p&gt;

&lt;p&gt;原文地址：&lt;a href=&quot;http://evanhahn.com/understanding-express-js/&quot;&gt;http://evanhahn.com/understanding-express-js/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;时间仓促，翻译错误在所难免，还请指正，转载还请注明。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>优化技巧分享：把内存消耗降低至原来的1/20</title>
   <link href="http://beango.github.com/archives/2013/06/01/reducing-memory-consumption-by-20x.html"/>
   <updated>2013-06-01T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/06/01/reducing-memory-consumption-by-20x</id>
   <content type="html">&lt;p&gt;这是最近发生的又一起内存相关的事件了。这个案例是从一个最近的客户报告中提取出来，一个异常运行的应用在其产品中反复报告内存耗尽。&lt;/p&gt;

&lt;p&gt;这个症状是由我们的一个实验性功能发现，它主要用来监测某一类数据结构的使用情况。它提供了一个信号探针，结果会指向问题源代码的某一位置。为了保护客户的隐私，我们人为重建了该例子并保持它同原真实场景在技术层面的一致性。你可以免费在此处&lt;a href=&quot;http://www.plumbr.eu/files/plumbr-optimization-sample.zip&quot;&gt;下载到源码&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;故事开始于一组从外界源加载进来的对象。同外部的信息交互是基于XML的接口，这本身并没什么大不了的，但事实上“基于XML的格式进行通讯”的实现细节被分散到了系统的每一个角落。传入系统的文档是首先被转换成XMLBean实例，然后在整个系统范围内被使用，这中做法听起来有点傻。&lt;/p&gt;

&lt;p&gt;整个问题中最核心的部分是一个延迟加载的缓冲方案。缓存的对象是“Person”的实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Imports and methods removed to improve readability 
public class Person { 
    private String id;
    private Date dateOfBirth;
    private String forename;
    private String surname;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也许会说这才能消耗多少内存呢。但当我们揭开进一步的细节时，发现事情就变了味了。表面上根据设计，声称实现只用到的诸如上文提到的那样一些简单的类，但真实的情形是使用了基于模型生成的数据结构。使用的模型是诸如下面的这个简化的XSD片段。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xs:schema targetNamespace=&quot;http://plumbr.eu&quot;
    xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
    elementFormDefault=&quot;qualified&quot;&amp;gt;
    &amp;lt;xs:element name=&quot;person&quot;&amp;gt;
        &amp;lt;xs:complexType&amp;gt;
            &amp;lt;xs:sequence&amp;gt;
                &amp;lt;xs:element name=&quot;id&quot; type=&quot;xs:string&quot;/&amp;gt;
                &amp;lt;xs:element name=&quot;dateOfBirth&quot; type=&quot;xs:dateTime&quot;/&amp;gt;
                &amp;lt;xs:element name=&quot;forename&quot; type=&quot;xs:string&quot;/&amp;gt;
                &amp;lt;xs:element name=&quot;surname&quot; type=&quot;xs:string&quot;/&amp;gt;
            &amp;lt;/xs:sequence&amp;gt;
        &amp;lt;/xs:complexType&amp;gt;
    &amp;lt;/xs:element&amp;gt;
&amp;lt;/xs:schema&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;a href=&quot;http://xmlbeans.apache.org/&quot;&gt;XMLBeans&lt;/a&gt;，开发者生成了该模型，并在真实的场景中使用。现在我们回到开始的这个缓存的方案上来，假设它设计初衷是为了支持最多1.3M Person类的实例，而我们实际却要塞进去同等数量的大家伙，这从根上就注定了失败。&lt;/p&gt;

&lt;p&gt;跑一组测试用例后，发现1.3M个基于XMLBean的生成的实例需要消耗大概1.5GB的堆空间。我们当时想这肯定可以做的更好。&lt;/p&gt;

&lt;p&gt;第一个改进是显而易见的，外部同系统内部集成的实现细节是不应该把影响传递给系统的每一个角落的。所以我们把缓存改成了使用简单的&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;java.util.HashMap&amp;lt;Long,Person&gt;&lt;/a&gt;。ID是键，Person是值。我们发现内存的消耗立即降低到了214MB。但这还不能令我们满意。&lt;/p&gt;

&lt;p&gt;由于Map中的键是一个数，我们有十足的理由使用&lt;a href=&quot;http://trove.starlight-systems.com/&quot;&gt;Trove Collections&lt;/a&gt;来进一步降低它的内存消耗。这在实现上的改动很快，我们只需把&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt;改成&lt;a href=&quot;http://trove4j.sourceforge.net/javadocs/gnu/trove/map/hash/TLongObjectHashMap.html&quot;&gt;TLongObjectHashMap&amp;lt;Person&gt;&lt;/a&gt;，堆的消耗进一步降低到了143MB。&lt;/p&gt;

&lt;p&gt;活干到这个程度我们已经可以收工了，但是工程师的好奇心驱使我们要更进一步。不由自主的我们发现了系统的数据存在着大量的重复信息。例如Date Of Birth其实已经在ID中编码了，所以Date Of Birth可以直接从ID中得到，而不必使用额外的空间去它。&lt;/p&gt;

&lt;p&gt;经过改良，Person类现在变成了这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Imports and methods removed to improve readability
public class Person {
    private String id;
    private String forename;
    private String surname;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新跑一边测试证实我们的改进的确有效，堆消耗降低到了93MB。但是我们还未满足。&lt;/p&gt;

&lt;p&gt;该应用在64位的机器上使用老的JDK6。默认情况下，这么做不能&lt;a href=&quot;https://wikis.oracle.com/display/HotSpotInternals/CompressedOops&quot;&gt;压缩普通对象&lt;/a&gt;的指针的。通过参数”&lt;a href=&quot;https://wikis.oracle.com/display/HotSpotInternals/CompressedOops&quot;&gt;-XX:UseCompressedOops&lt;/a&gt;“切换到压缩模式使我们获得了额外的收获，现在我们的内存消耗降低到了73MB。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-06/comparing-heap-consumption.png&quot; title=&quot;comparing-heap-consumption&quot;&gt;&lt;img src=&quot;/assets/files/2013-06/comparing-heap-consumption.png&quot; title=&quot;comparing-heap-consumption&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然，我们还能走的更远。比如基于键值建立B-tree，但这已经开始影响到了代码的可读性，所以我们决定到此为止。降低21.5倍的堆内存应该已经是一个足够好的结果了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;让我们在重复一下学到了什么&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;别把同外部模块的整合影响到系统的每一个角落&lt;/li&gt;
&lt;li&gt;冗余的数据可能带来开销。在可能的情况下尽量消除它&lt;/li&gt;
&lt;li&gt;基本数据类型是你最经常打交道的朋友，务必知道些关于它们的工具，如果还没玩过&lt;a href=&quot;http://trove.starlight-systems.com/&quot;&gt;Trove&lt;/a&gt;请立刻开始吧&lt;/li&gt;
&lt;li&gt;JVM自带的优化技术不可忽视&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;如果你对这个实验很好奇，请在此处&lt;a href=&quot;http://www.plumbr.eu/files/plumbr-optimization-sample.zip&quot;&gt;下载相关的代码&lt;/a&gt;。使用到的的测量工具和其具体描述可以在这篇&lt;a href=&quot;http://plumbr.eu/blog/how-much-memory-do-i-need-part-3-measure-dont-guess&quot;&gt;博文&lt;/a&gt;找到。&lt;/p&gt;

&lt;p&gt;原文链接： &lt;a href=&quot;http://plumbr.eu/blog/reducing-memory-consumption-by-20x&quot;&gt;Nikita Salnikov-Tarnovski&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>深入研究JavaScript的Module模式</title>
   <link href="http://beango.github.com/archives/2013/05/31/javascript-module-pattern-in-depth.html"/>
   <updated>2013-05-31T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/05/31/javascript-module-pattern-in-depth</id>
   <content type="html">&lt;p&gt;Module模式是常见的JavaScript编程模式，一般来说这种模式是很好理解的，但是依然有一些高级的用法没有得到太多的注意。在这篇文章中我会提到Module模式的基础知识和一些真正重要的话题，包括一个可能是我原创的。&lt;/p&gt;

&lt;h2&gt;基础知识&lt;/h2&gt;

&lt;p&gt;首先我们要大概了解一下Module模式（2007年由YUI的EricMiraglia在博客中提出），如果你已熟悉 Module 模式，可以跳过本部分，直接阅读“高级模式”。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3&gt;匿名函数闭包&lt;/h3&gt;

&lt;p&gt;匿名函数闭包是JavaScript最棒的特征，没有之一，是它让一切都成为了可能。现在我们来创建一个匿名函数然后立即执行。函数中所有的代码都是在一个闭包中执行的，闭包决定了在整个执行过程中这些代码的私有性和状态。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function () {
    // ... all vars and functions are in this scope only
    // still maintains access to all globals
}());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意在匿名函数外面的括号。这是由于在JavaScript中以function开头的语句通常被认为是函数声明。加上了外面的括号之后则创建的是函数表达式。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3&gt;全局导入&lt;/h3&gt;

&lt;p&gt;JavaScript有一个特征叫做隐藏的全局变量。当一个变量名被使用，编译器会向上级查询用var来声明这个变量的语句。如果没有找到的话这个变量就被认为是全局的。如果在赋值的时候这样使用，就会创建一个全局的作用域。这意味着在一个匿名的闭包中创建一个全局变量是十分容易的。不幸的是，这将会导致代码的难以管理，因为对于程序员来说，如果全局的变量不是在一个文件中声明会很不清晰。幸运的是，匿名函数给我我们另一个选择。我们可以将全局变量通过匿名函数的参数来导入到我们的代码中，这样更加的快速和整洁。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function ($, YAHOO) {
    // now have access to globals jQuery (as $) and YAHOO in this code
}(jQuery, YAHOO));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;/h3&gt;

&lt;h3&gt;Module导出&lt;/h3&gt;

&lt;p&gt;有时你并不想要使用全局变量，但是你想要声明他们。我们可以很容易通过匿名函数的返回值来导出他们。关于Module模式的基本内容就这么多，这里有一个复杂一点的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MODULE = (function () {
    var my = {},
        privateVariable = 1;

    function privateMethod() {
        // ...
    }

    my.moduleProperty = 1;
    my.moduleMethod = function () {
        // ...
    };

    return my;
}());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们声明了一个全局的module叫做MODULE，有两个公有属性：一个叫做MODULE.moduleMethod的方法和一个叫做MODULE.moduleProperty的变量。另外他通过匿名函数的闭包来维持私有的内部状态，当然我们也可使用前面提到的模式，轻松导入所需的全局变量&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h2&gt;高级模式&lt;/h2&gt;

&lt;p&gt;之前提到的内容已经可以满足很多需求了，但我们可以更深入地研究这种模式来创造一些强力的可拓展的结构。让我们一点一点，继续通过这个叫做MODULE的module来学习。&lt;/p&gt;

&lt;h3&gt;拓展&lt;/h3&gt;

&lt;p&gt;目前，module模式的一个局限性就是整个module必须是写在一个文件里面的。每个进行过大规模代码开发的人都知道将一个文件分离成多个文件的重要性。幸运的是我们有一个很好的方式来拓展modules。首先我们导入一个module，然后加属性，最后将它导出。这里的这个例子，就是用上面所说的方法来拓展MODULE。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MODULE = (function (my) {
    my.anotherMethod = function () {
        // added method...
    };

    return my;
}(MODULE));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然不必要，但是为了一致性，我们再次使用var关键字。然后代码执行，module会增加一个叫做MODULE.anotherMethod的公有方法。这个拓展文件同样也维持着它私有的内部状态和导入。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3&gt;松拓展&lt;/h3&gt;

&lt;p&gt;我们上面的那个例子需要我们先创建module，然后在对module进行拓展，这并不是必须的。异步加载脚本是提升Javascript应用性能的最佳方式之一。。通过松拓展，我们创建灵活的，可以以任意顺序加载的，分成多个文件的module。每个文件的结构大致如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MODULE = (function (my) {
    // add capabilities...

    return my;
}(MODULE || {}));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这种模式下，var语句是必须。如果导入的module并不存在就会被创建。这意味着你可以用类似于LABjs的工具来并行加载这些module的文件。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3&gt;紧拓展&lt;/h3&gt;

&lt;p&gt;虽然松拓展已经很棒了，但是它也给你的module增添了一些局限。最重要的一点是，你没有办法安全的重写module的属性，在初始化的时候你也不能使用其他文件中的module属性（但是你可以在初始化之后运行中使用）。紧拓展包含了一定的载入顺序，但是支持重写，下面是一个例子（拓展了我们最初的MODULE）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MODULE = (function (my) {
    var old_moduleMethod = my.moduleMethod;

    my.moduleMethod = function () {
        // method override, has access to old through old_moduleMethod...
    };

    return my;
}(MODULE));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们已经重写了MODULE.moduleMethod，还按照需求保留了对原始方法的引用。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3&gt;复制和继承&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var MODULE_TWO = (function (old) {
    var my = {},
        key;

    for (key in old) {
        if (old.hasOwnProperty(key)) {
            my[key] = old[key];
        }
    }

    var super_moduleMethod = old.moduleMethod;
    my.moduleMethod = function () {
        // override method on the clone, access to super through super_moduleMethod
    };

    return my;
}(MODULE));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种模式可能是最不灵活的选择。虽然它支持了一些优雅的合并，但是代价是牺牲了灵巧性。在我们写的代码中，那些类型是对象或者函数的属性不会被复制，只会以一个对象的两份引用的形式存在。一个改变，另外一个也改变。对于对象来说&lt;a href=&quot;http://blog.jobbole.com/40409/#_msocom_5&quot;&gt;[g5]&lt;/a&gt; ，我们可以通过一个递归的克隆操作来解决，但是对于函数是没有办法的，除了eval。然而，为了完整性我还是包含了它。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3&gt;跨文件的私有状态&lt;/h3&gt;

&lt;p&gt;把一个module分成多个文件有一很大的局限，就是每一个文件都在维持自身的私有状态，而且没有办法来获得其他文件的私有状态。这个是可以解决的，下面这个松拓展的例子，可以在不同文件中维持私有状态。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MODULE = (function (my) {
    var _private = my._private = my._private || {},
        _seal = my._seal = my._seal || function () {
            delete my._private;
            delete my._seal;
            delete my._unseal;
        },
        _unseal = my._unseal = my._unseal || function () {
            my._private = _private;
            my._seal = _seal;
            my._unseal = _unseal;
        };

    // permanent access to _private, _seal, and _unseal

    return my;
}(MODULE || {}));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一个文件可以为它的私有变量_private设置属性，其他文件可以立即调用。当module加载完毕，程序会调用MODULE._seal(),让外部没有办法接触到内部的  _.private。如果之后module要再次拓展，某一个属性要改变。在载入新文件前,每一个文件都可以调用_.unsea(),，在代码执行之后再调用_.seal。&lt;/p&gt;

&lt;p&gt;这个模式在我今天的工作中想到的，我从没有在其他地方见到过。但是我认为这是一个很有用的模式，值得单独写出来。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h3&gt;Sub-modules&lt;/h3&gt;

&lt;p&gt;最后一个高级模式实际上是最简单的，有很多创建子module的例子，就像创建一般的module一样的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MODULE.sub = (function () {
    var my = {};
    // ...

    return my;
}());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然这可能是很简单的，但是我决定这值得被写进来。子module有一般的module所有优质的特性，包括拓展和私有状态。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;大多数高级模式都可以互相组合来创建更有用的新模式。如果一定要让我提出一个设计复杂应用的方法的话，我会结合松拓展，私有状态，和子module。&lt;/p&gt;

&lt;p&gt;在这里我没有提到性能相关的事情，但是我可以说，module模式对于性能的提升有好处。它可以减少代码量，这就使得代码的载入更迅速。松拓展使得并行加载成为可能，这同样提升的载入速度。初始化的时间可能比其他的方法时间长，但是这多花的时间是值得的。只要全局变量被正确导入了运行的时候就不会出问题，在子module中由于对变量的引用链变短了可能也会提升速度。&lt;/p&gt;

&lt;p&gt;最后，这是一个子module自身动态加载的例子（如果不存在就创建），为了简介我没有考虑内部状态，但是即便考虑它也很简单。这个模式可以让复杂，多层次的代码并行的加载，包括子module和其他所有的东西。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var UTIL = (function (parent, $) {
    var my = parent.ajax = parent.ajax || {};

    my.get = function (url, params, callback) {
        // ok, so I'm cheating a bit :)
        return $.getJSON(url, params, callback);
    };

    // etc...

    return parent;
}(UTIL || {}, jQuery));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我希望这些内容是有用的，请在下面留言来分享你的想法。少年们，努力吧，写出更好的，更模块化的JavaScript。&lt;/p&gt;

&lt;p&gt;英文原文；&lt;a href=&quot;http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html&quot;&gt;ben cherry&lt;/a&gt;，编译：&lt;a href=&quot;http://www.jobbole.com&quot; title=&quot;伯乐在线&quot;&gt;伯乐&lt;/a&gt;在线 – &lt;a href=&quot;http://blog.jobbole.com/author/%e7%8e%8b%e7%ad%b1/&quot;&gt;王筱&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译文链接：&lt;a href=&quot;http://blog.jobbole.com/40409/&quot;&gt;http://blog.jobbole.com/40409/&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>使用 Spring 进行单元测试</title>
   <link href="http://beango.github.com/archives/2013/05/30/j-lo-springunitest.html"/>
   <updated>2013-05-30T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/05/30/j-lo-springunitest</id>
   <content type="html">&lt;p&gt;原文出处： &lt;a href=&quot;http://www.ibm.com/developerworks/cn/java/j-lo-springunitest/index.html&quot;&gt;IBM developerworks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/java/j-lo-springunitest/index.html#author1&quot;&gt;赵才文&lt;/a&gt;,技术经理&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;简介：&lt;/strong&gt; 通过本文，您能够在较短的时间内掌握使用 Spring 单元测试框架测试基于 Spring 的应用程序的方法，这套方法主要涵盖如何使用 Spring 测试注释来进行常见的 Junit4 或者 TestNG 的单元测试，同时支持访问 Spring 的 beanFactory 和进行自动化的事务管理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;单元测试和集成测试在我们的软件开发整个流程中占有举足轻重的地位，一方面，程序员通过编写单元测试来验证自己程序的有效性，另外一方面，管理者通过持续自动的执行单元测试和分析单元测试的覆盖率等来确保软件本身的质量。这里，我们先不谈单元测试本身的重要性，对于目前大多数的基于 Java 的企业应用软件来说，Spring 已经成为了标准配置，一方面它实现了程序之间的低耦合度，另外也通过一些配置减少了企业软件集成的工作量，例如和 Hibernate、Struts 等的集成。那么，有个问题，在普遍使用 Spring 的应用程序中，我们如何去做单元测试？或者说，我们怎么样能高效的在 Spring 生态系统中实现各种单元测试手段？这就是本文章要告诉大家的事情。&lt;/p&gt;

&lt;p&gt;单元测试目前主要的框架包括 Junit、TestNG，还有些 MOCK 框架，例如 Jmock、Easymock、PowerMock 等，这些都是单元测试的利器，但是当把他们用在 Spring 的开发环境中，还是那么高效么？还好，Spring 提供了单元测试的强大支持，主要特性包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;支持主流的测试框架 Junit 和 TestNG&lt;/li&gt;
&lt;li&gt;支持在测试类中使用依赖注入 Denpendency Injection&lt;/li&gt;
&lt;li&gt;支持测试类的自动化事务管理&lt;/li&gt;
&lt;li&gt;支持使用各种注释标签，提高开发效率和代码简洁性&lt;/li&gt;
&lt;li&gt;Spring 3.1 更是支持在测试类中使用非 XML 配置方法和基于 Profile 的 bean 配置模式&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;通过阅读本文，您能够快速的掌握基于 Spring TestContext 框架的测试方法，并了解基本的实现原理。本文将提供大量测试标签的使用方法，通过这些标签，开发人员能够极大的减少编码工作量。OK，现在让我们开始 Spring 的测试之旅吧！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原来我们是怎么做的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里先展示一个基于 Junit 的单元测试，这个单元测试运行在基于 Spring 的应用程序中，需要使用 Spring 的相关配置文件来进行测试。相关类图如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据库表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设有一个员工账号表，保存了员工的基本账号信息，表结构如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ID：整数类型，唯一标识&lt;/li&gt;
&lt;li&gt;NAME：字符串，登录账号&lt;/li&gt;
&lt;li&gt;SEX：字符串，性别&lt;/li&gt;
&lt;li&gt;AGE：字符串，年龄&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;假设表已经建好，且内容为空。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;测试工程目录结构和依赖 jar 包&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在 Eclipse 中，我们可以展开工程目录结构，看到如下图所示的工程目录结构和依赖的 jar 包列表：&lt;/p&gt;

&lt;p&gt;您需要引入的 jar 包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cglib-nodep-2.2.3.jar&lt;/li&gt;
&lt;li&gt;commons-logging.jar&lt;/li&gt;
&lt;li&gt;hsqldb.jar&lt;/li&gt;
&lt;li&gt;Junit-4.5.jar&lt;/li&gt;
&lt;li&gt;log4j-1.2.14.jar&lt;/li&gt;
&lt;li&gt;Spring-asm-3.2.0.M1.jar&lt;/li&gt;
&lt;li&gt;Spring-beans-3.2.0.M1.jar&lt;/li&gt;
&lt;li&gt;Spring-context-3.2.0.M1.jar&lt;/li&gt;
&lt;li&gt;Spring-core-3.2.0.M1.jar&lt;/li&gt;
&lt;li&gt;Spring-expression-3.2.0.M1.jar&lt;/li&gt;
&lt;li&gt;Spring-jdbc-3.2.0.M1.jar&lt;/li&gt;
&lt;li&gt;Spring-test-3.2.0.M1.jar&lt;/li&gt;
&lt;li&gt;Spring-tx-3.2.0.M1.jar&lt;/li&gt;
&lt;li&gt;testng-6.8.jar&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;其中的 hsqldb 是我们测试用数据库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 1. 工程目录结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-05/spring-unit-test-01.png&quot; title=&quot;使用 Spring 进行单元测试&quot;&gt;&lt;img src=&quot;/assets/files/2013-05/spring-unit-test-01.png&quot; title=&quot;使用 Spring 进行单元测试&quot; alt=&quot;使用 Spring 进行单元测试&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类总体介绍&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设我们现在有一个基于 Spring 的应用程序，除了 MVC 层，还包括业务层和数据访问层，业务层有一个类 AccountService，负责处理账号类的业务，其依赖于数据访问层 AccountDao 类，此类提供了基于 Spring Jdbc Template 实现的数据库访问方法，AccountService 和 AccountDao 以及他们之间的依赖关系都是通过 Spring 配置文件进行管理的。&lt;/p&gt;

&lt;p&gt;现在我们要对 AccountService 类进行测试，在不使用 Spring 测试方法之前，我们需要这样做：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 1. Account.Java&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此类代表账号的基本信息，提供 getter 和 setter 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package domain; 

public class Account { 
    public static final String SEX_MALE = &quot;male&quot;; 
    public static final String SEX_FEMALE = &quot;female&quot;; 

    private int id; 
    private String name; 
    private int age; 
    private String sex; 
    public String toString() { 
       return String.format(&quot;Account[id=%d,name=%s,age:%d,sex:%s]&quot;,id,name,age,sex); 
    } 
    public int getId() { 
        return id; 
    } 
    public void setId(int id) { 
        this.id = id; 
    } 
    public String getName() { 
        return name; 
    } 
    public void setName(String name) { 
        this.name = name; 
    } 
    public int getAge() { 
        return age; 
    } 
    public void setAge(int age) { 
        this.age = age; 
    } 
    public String getSex() { 
        return sex; 
    } 
    public void setSex(String sex) { 
        this.sex = sex; 
    } 

    public static Account getAccount(int id,String name,int age,String sex) { 
        Account acct = new Account(); 
        acct.setId(id); 
        acct.setName(name); 
        acct.setAge(age); 
        acct.setSex(sex); 
        return acct; 
    } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上面的 Account 类有一个 toString() 方法和一个静态的 getAccount 方法，getAccount 方法用于快速获取 Account 测试对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 2. AccountDao.Java&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个 DAO 我们这里为了简单起见，采用 Spring Jdbc Template 来实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package DAO; 

import Java.sql.ResultSet; 
import Java.sql.SQLException; 
import Java.util.HashMap; 
import Java.util.List; 
import Java.util.Map; 

import org.Springframework.context.ApplicationContext; 
import org.Springframework.context.support.ClassPathXmlApplicationContext; 
import org.Springframework.jdbc.core.RowMapper; 
import org.Springframework.jdbc.core.namedparam.NamedParameterJdbcDaoSupport; 
import org.Springframework.jdbc.core.simple.ParameterizedRowMapper; 

import domain.Account; 

public class AccountDao extends NamedParameterJdbcDaoSupport { 
    public void saveAccount(Account account) { 
        String sql = &quot;insert into tbl_account(id,name,age,sex) &quot; + 
               &quot;values(:id,:name,:age,:sex)&quot;; 
        Map paramMap = new HashMap(); 
        paramMap.put(&quot;id&quot;, account.getId()); 
        paramMap.put(&quot;name&quot;, account.getName()); 
        paramMap.put(&quot;age&quot;, account.getAge()); 
        paramMap.put(&quot;sex&quot;,account.getSex()); 
        getNamedParameterJdbcTemplate().update(sql, paramMap); 
    } 

    public Account getAccountById(int id) { 
        String sql = &quot;select id,name,age,sex from tbl_account where id=:id&quot;; 
        Map paramMap = new HashMap(); 
        paramMap.put(&quot;id&quot;, id); 
        List&amp;lt;Account&amp;gt; matches = getNamedParameterJdbcTemplate().query(sql, 
        paramMap,new ParameterizedRowMapper&amp;lt;Account&amp;gt;() { 
                    @Override
                    public Account mapRow(ResultSet rs, int rowNum) 
                            throws SQLException { 
                        Account a = new Account(); 
                        a.setId(rs.getInt(1)); 
                        a.setName(rs.getString(2)); 
                        a.setAge(rs.getInt(3)); 
                        a.setSex(rs.getString(4)); 
                        return a; 
                    } 

        }); 
        return matches.size()&amp;gt;0?matches.get(0):null; 
    } 

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AccountDao 定义了几个账号对象的数据库访问方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;saveAccount：负责把传入的账号对象入库&lt;/li&gt;
&lt;li&gt;getAccountById：负责根据 Id 查询账号&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;清单 3. AccountService.Java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package service; 

import org.apache.commons.logging.Log; 
import org.apache.commons.logging.LogFactory; 
import org.Springframework.beans.factory.annotation.Autowired; 

import DAO.AccountDao; 
import domain.Account; 

public class AccountService { 
    private static final Log log = LogFactory.getLog(AccountService.class); 

    @Autowired
    private AccountDao accountDao; 

    public Account getAccountById(int id) { 
        return accountDao.getAccountById(id); 
    } 

    public void insertIfNotExist(Account account) { 
        Account acct = accountDao.getAccountById(account.getId()); 
        if(acct==null) { 
            log.debug(&quot;No &quot;+account+&quot; found,would insert it.&quot;); 
            accountDao.saveAccount(account); 
        } 
        acct = null; 
    } 

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AccountService 包括下列方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;getAccountById：根据 Id 查询账号信息&lt;/li&gt;
&lt;li&gt;insertIfNotExist：根据传入的对象插入数据库&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;其依赖的 DAO 对象 accountDao 是通过 Spring 注释标签 @Autowired 自动注入的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 4. Spring 配置文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上述几个类的依赖关系是通过 Spring 进行管理的，配置文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;beans xmlns=&quot;http://www.Springframework.org/schema/beans&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
     xmlns:context=&quot;http://www.Springframework.org/schema/context&quot;
     xsi:schemaLocation=&quot;http://www.Springframework.org/schema/beans 
     http://www.Springframework.org/schema/beans/Spring-beans-3.0.xsd
     http://www.Springframework.org/schema/context
     http://www.Springframework.org/schema/context/Spring-context-3.0.xsd &quot;&amp;gt; 

 &amp;lt;context:annotation-config/&amp;gt; 
 &amp;lt;bean id=&quot;datasource&quot;&amp;gt; 
         &amp;lt;property name=&quot;driverClassName&quot; value=&quot;org.hsqldb.jdbcDriver&quot; /&amp;gt; 
         &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:hsqldb:hsql://localhost&quot; /&amp;gt; 
         &amp;lt;property name=&quot;username&quot; value=&quot;sa&quot; /&amp;gt; 
         &amp;lt;property name=&quot;password&quot; value=&quot;&quot; /&amp;gt; 
     &amp;lt;/bean&amp;gt; 
     &amp;lt;bean id=&quot;initer&quot; init-method=&quot;init&quot;&amp;gt; 
     &amp;lt;/bean&amp;gt; 
 &amp;lt;bean id=&quot;accountDao&quot; depends-on=&quot;initer&quot;&amp;gt; 
         &amp;lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot; /&amp;gt; 
     &amp;lt;/bean&amp;gt; 
 &amp;lt;bean id=&quot;accountService&quot;&amp;gt; 
     &amp;lt;/bean&amp;gt; 
 &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意其中的“&amp;lt;context:annotation-config/&gt;”的作用，这个配置启用了 Spring 对 Annotation 的支持，这样在我们的测试类中 @Autowired 注释才会起作用（如果用了 Spring 测试框架，则不需要这样的配置项，稍后会演示）。另外还有一个 accountDao 依赖的 initer bean, 这个 bean 的作用是加载 log4j 日志环境，不是必须的。&lt;/p&gt;

&lt;p&gt;另外还有一个要注意的地方，就是 datasource 的定义，由于我们使用的是 Spring Jdbc Template，所以只要定义一个 org.Springframework.jdbc.datasource.DriverManagerDataSource 类型的 datasource 即可。这里我们使用了简单的数据库 HSQL、Single Server 运行模式，通过 JDBC 进行访问。实际测试中，大家可以选择 Oracle 或者 DB2、Mysql 等。&lt;/p&gt;

&lt;p&gt;好，万事具备，下面我们来用 Junit4 框架测试 accountService 类。代码如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 5. AccountServiceOldTest.Java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package service; 

import static org.Junit.Assert.assertEquals; 

import org.Junit.BeforeClass; 
import org.Junit.Test; 
import org.Springframework.context.ApplicationContext; 
import org.Springframework.context.support.ClassPathXmlApplicationContext; 

import domain.Account; 

public class AccountServiceOldTest { 
    private static AccountService service; 

    @BeforeClass
    public static void init() { 
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;config/Spring-db-old.xml&quot;); 
        service = (AccountService)context.getBean(&quot;accountService&quot;); 
    }  

    @Test
    public void testGetAcccountById() { 
        Account acct = Account.getAccount(1, &quot;user01&quot;, 18, &quot;M&quot;); 
        Account acct2 = null; 
        try { 
            service.insertIfNotExist(acct); 
            acct2 = service.getAccountById(1); 
            assertEquals(acct, acct2); 
        } catch (Exception ex) { 
            fail(ex.getMessage()); 
        } finally { 
            service.removeAccount(acct); 
        } 
    } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上面的 Junit4 注释标签，第一个注释标签 @BeforeClass，用来执行整个测试类需要一次性初始化的环境，这里我们用 Spring 的 ClassPathXmlApplicationContext 从 XML 文件中加载了上面定义的 Spring 配置文件，并从中获得了 accountService 的实例。第二个注释标签 @Test 用来进行实际的测试。&lt;/p&gt;

&lt;p&gt;测试过程：我们先获取一个 Account 实例对象，然后通过 service bean 插入数据库中，然后通过 getAccountById 方法从数据库再查询这个记录，如果能获取，则判断两者的相等性；如果相同，则表示测试成功。成功后，我们尝试删除这个记录，以利于下一个测试的进行，这里我们用了 try-catch-finally 来保证账号信息会被清除。&lt;/p&gt;

&lt;p&gt;执行测试：（在 Eclipse 中，右键选择 AccountServiceOldTest 类，点击 Run as Junit test 选项），得到的结果如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;执行测试的结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在 Eclipse 的 Junit 视图中，我们可以看到如下的结果：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 2. 测试的结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-05/spring-unit-test-02.png&quot; title=&quot;使用 Spring 进行单元测试&quot;&gt;&lt;img src=&quot;/assets/files/2013-05/spring-unit-test-02.png&quot; title=&quot;使用 Spring 进行单元测试&quot; alt=&quot;使用 Spring 进行单元测试&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于这种不使用 Spring test 框架进行的单元测试，我们注意到，需要做这些工作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在测试开始之前，需要手工加载 Spring 的配置文件，并获取需要的 bean 实例&lt;/li&gt;
&lt;li&gt;在测试结束的时候，需要手工清空搭建的数据库环境，比如清除您插入或者更新的数据，以保证对下一个测试没有影响&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;另外，在这个测试类中，我们还不能使用 Spring 的依赖注入特性。一切都靠手工编码实现。好，那么我们看看 Spring test 框架能做到什么。&lt;/p&gt;

&lt;p&gt;首先我们修改一下 Spring 的 XML 配置文件，删除 &amp;lt;context:annotation-config/&gt; 行，其他不变。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 6. Spring-db1.xml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;beans xmlns=&quot;http://www.Springframework.org/schema/beans&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
     xsi:schemaLocation=&quot;http://www.Springframework.org/schema/beans 
     http://www.Springframework.org/schema/beans/Spring-beans-3.2.xsd&quot;&amp;gt;

     &amp;lt;bean id=&quot;datasource&quot;&amp;gt; 
             &amp;lt;property name=&quot;driverClassName&quot; value=&quot;org.hsqldb.jdbcDriver&quot; /&amp;gt; 
             &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:hsqldb:hsql://localhost&quot; /&amp;gt; 
             &amp;lt;property name=&quot;username&quot; value=&quot;sa&quot;/&amp;gt; 
             &amp;lt;property name=&quot;password&quot; value=&quot;&quot;/&amp;gt; 
     &amp;lt;/bean&amp;gt; 
     &amp;lt;bean id=&quot;transactionManager&quot;&amp;gt; 
             &amp;lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot;&amp;gt;&amp;lt;/property&amp;gt; 
     &amp;lt;/bean&amp;gt; 
     &amp;lt;bean id=&quot;initer&quot; init-method=&quot;init&quot;&amp;gt; 
     &amp;lt;/bean&amp;gt; 
     &amp;lt;bean id=&quot;accountDao&quot; depends-on=&quot;initer&quot;&amp;gt; 
         &amp;lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot;/&amp;gt; 
     &amp;lt;/bean&amp;gt; 
     &amp;lt;bean id=&quot;accountService&quot;&amp;gt; 
     &amp;lt;/bean&amp;gt; 
 &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的 transactionManager 是 Spring test 框架用来做事务管理的管理器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 7. AccountServiceTest1.Java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package service; 
import static org.Junit.Assert.assertEquals; 

import org.Junit.Test; 
import org.Junit.runner.RunWith; 
import org.Springframework.beans.factory.annotation.Autowired; 
import org.Springframework.test.context.ContextConfiguration; 
import org.Springframework.test.context.Junit4.SpringJUnit4ClassRunner; 
import org.Springframework.transaction.annotation.Transactional; 

import domain.Account; 

@RunWith(SpringJUnit4ClassRunner.class) 
@ContextConfiguration(&quot;/config/Spring-db1.xml&quot;) 
@Transactional
public class AccountServiceTest1 { 
    @Autowired
    private AccountService service; 

    @Test
    public void testGetAcccountById() { 
Account acct = Account.getAccount(1, &quot;user01&quot;, 18, &quot;M&quot;); 
        service.insertIfNotExist(acct); 
        Account acct2 = service.getAccountById(1); 
        assertEquals(acct,acct2); 
    } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对这个类解释一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@RunWith 注释标签是 Junit 提供的，用来说明此测试类的运行者，这里用了 SpringJUnit4ClassRunner，这个类是一个针对 Junit 运行环境的自定义扩展，用来标准化在 Spring 环境中 Junit4.5 的测试用例，例如支持的注释标签的标准化&lt;/li&gt;
&lt;li&gt;@ContextConfiguration 注释标签是 Spring test context 提供的，用来指定 Spring 配置信息的来源，支持指定 XML 文件位置或者 Spring 配置类名，这里我们指定 classpath 下的 /config/Spring-db1.xml 为配置文件的位置&lt;/li&gt;
&lt;li&gt;@Transactional 注释标签是表明此测试类的事务启用，这样所有的测试方案都会自动的 rollback，即您不用自己清除自己所做的任何对数据库的变更了&lt;/li&gt;
&lt;li&gt;@Autowired 体现了我们的测试类也是在 Spring 的容器中管理的，他可以获取容器的 bean 的注入，您不用自己手工获取要测试的 bean 实例了&lt;/li&gt;
&lt;li&gt;testGetAccountById 是我们的测试用例：注意和上面的 AccountServiceOldTest 中相同的测试方法的对比，这里我们不用再 try-catch-finally 了，事务管理自动运行，当我们执行完成后，所有相关变更会被自动清除&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;执行结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在 Eclipse 的 Junit 视图中，我们可以看到如下的结果：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 3. 执行结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-05/spring-unit-test-03.png&quot; title=&quot;使用 Spring 进行单元测试&quot;&gt;&lt;img src=&quot;/assets/files/2013-05/spring-unit-test-03.png&quot; title=&quot;使用 Spring 进行单元测试&quot; alt=&quot;使用 Spring 进行单元测试&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果您希望在 Spring 环境中进行单元测试，那么可以做如下配置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;继续使用 Junit4 测试框架，包括其 @Test 注释标签和相关的类和方法的定义，这些都不用变&lt;/li&gt;
&lt;li&gt;您需要通过 @RunWith(SpringJUnit4ClassRunner.class) 来启动 Spring 对测试类的支持&lt;/li&gt;
&lt;li&gt;您需要通过 @ContextConfiguration 注释标签来指定 Spring 配置文件或者配置类的位置&lt;/li&gt;
&lt;li&gt;您需要通过 @Transactional 来启用自动的事务管理&lt;/li&gt;
&lt;li&gt;您可以使用 @Autowired 自动织入 Spring 的 bean 用来测试&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;另外您不再需要：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;手工加载 Spring 的配置文件&lt;/li&gt;
&lt;li&gt;手工清理数据库的每次变更&lt;/li&gt;
&lt;li&gt;手工获取 application context 然后获取 bean 实例&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;Spring 测试注释标签&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们已经看到利用 Spring test framework 来进行基于 Junit4 的单元测试是多么的简单，下面我们来看一下前面遇到的各种注释标签的一些可选用法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@ContextConfiguration 和 @Configuration 的使用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;刚才已经介绍过，可以输入 Spring xml 文件的位置，Spring test framework 会自动加载 XML 文件，得到 application context，当然也可以使用 Spring 3.0 新提供的特性 @Configuration，这个注释标签允许您用 Java 语言来定义 bean 实例，举个例子：&lt;/p&gt;

&lt;p&gt;现在我们将前面定义的 Spring-db1.xml 进行修改，我们希望其中的三个 bean：initer、accountDao、accountService 通过配置类来定义，而不是 XML，则我们需要定义如下配置类：&lt;/p&gt;

&lt;p&gt;注意：如果您想使用 @Configuration，请在 classpath 中加入 cglib 的 jar 包（cglib-nodep-2.2.3.jar），否则会报错。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 8. SpringDb2Config.Java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package config; 

import org.Springframework.beans.factory.annotation.Autowired; 
import org.Springframework.context.annotation.Bean; 
import org.Springframework.context.annotation.Configuration; 
import org.Springframework.jdbc.datasource.DriverManagerDataSource; 

import service.AccountService; 
import service.Initializer; 
import DAO.AccountDao; 

@Configuration
public class SpringDb2Config { 
    private @Autowired DriverManagerDataSource datasource; 
    @Bean
    public Initializer initer() { 
        return new Initializer(); 
    } 

    @Bean
    public AccountDao accountDao() { 
AccountDao DAO = new AccountDao(); 
DAO.setDataSource(datasource); 
return DAO; 
    } 

    @Bean
    public AccountService accountService() { 
return new AccountService(); 
    } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上面的注释标签：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@Configuration：表明这个类是一个 Spring 配置类，提供 Spring 的 bean 定义，实际效果等同于 XML 配置方法&lt;/li&gt;
&lt;li&gt;@Bean：表明这个方法是一个 bean 的定义，缺省情况下，方法名称就是 bean 的 Id&lt;/li&gt;
&lt;li&gt;@Autowired：这个 datasource 采用自动注入的方式获取&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;注意，我们采用的是 XML+config bean 的方式进行配置，这种方式比较符合实际项目的情况。相关的 Spring 配置文件也要做变化，如下清单所示：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 9. Spring-db2.xml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;beans xmlns=&quot;http://www.Springframework.org/schema/beans&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
     xmlns:context=&quot;http://www.Springframework.org/schema/context&quot;
     xsi:schemaLocation=&quot;http://www.Springframework.org/schema/beans 
     http://www.Springframework.org/schema/beans/Spring-beans-3.0.xsd     
     http://www.Springframework.org/schema/context     
     http://www.Springframework.org/schema/context/Spring-context-3.0.xsd&quot;&amp;gt;

 &amp;lt;context:annotation-config/&amp;gt; 
 &amp;lt;bean id=&quot;datasource&quot;&amp;gt; 
         &amp;lt;property name=&quot;driverClassName&quot; value=&quot;org.hsqldb.jdbcDriver&quot; /&amp;gt; 
         &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:hsqldb:hsql://localhost&quot; /&amp;gt; 
         &amp;lt;property name=&quot;username&quot; value=&quot;sa&quot;/&amp;gt; 
         &amp;lt;property name=&quot;password&quot; value=&quot;&quot;/&amp;gt; 
 &amp;lt;/bean&amp;gt; 
 &amp;lt;bean id=&quot;transactionManager&quot;&amp;gt; 
         &amp;lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot;&amp;gt;&amp;lt;/property&amp;gt; 
 &amp;lt;/bean&amp;gt; 

 &amp;lt;bean/&amp;gt; 
 &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意里面的 context 命名空间的定义，如代码中黑体字所示。另外还必须有 &amp;lt;context:annotaiton-config/&gt; 的定义，这个定义允许采用注释标签的方式来控制 Spring 的容器，最后我们看到 beans 已经没有 initer、accountDao 和 accountService 这些 bean 的定义，取而代之的是一个 SpringDb2Config bean 的定义，注意这个 bean 没有名称，因为不需要被引用。&lt;/p&gt;

&lt;p&gt;现在有了这些配置，我们的测试类只要稍稍修改一下，即可实现加载配置类的效果，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@ContextConfiguration(&quot;/config/Spring-db2.xml&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面的配置，测试用例就可以实现加载 Spring 配置类，运行结果也是成功的 green bar。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@DirtiesContext&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;缺省情况下，Spring 测试框架一旦加载 applicationContext 后，将一直缓存，不会改变，但是，&lt;/p&gt;

&lt;p&gt;由于 Spring 允许在运行期修改 applicationContext 的定义，例如在运行期获取 applicationContext，然后调用 registerSingleton 方法来动态的注册新的 bean，这样的情况下，如果我们还使用 Spring 测试框架的被修改过 applicationContext，则会带来测试问题，我们必须能够在运行期重新加载 applicationContext，这个时候，我们可以在测试类或者方法上注释：@DirtiesContext，作用如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果定义在类上（缺省），则在此测试类运行完成后，重新加载 applicationContext&lt;/li&gt;
&lt;li&gt;如果定义在方法上，即表示测试方法运行完成后，重新加载 applicationContext&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;@TransactionConfiguration 和 @Rollback&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;缺省情况下，Spring 测试框架将事务管理委托到名为 transactionManager 的 bean 上，如果您的事务管理器不是这个名字，那需要指定 transactionManager 属性名称，还可以指定 defaultRollback 属性，缺省为 true，即所有的方法都 rollback，您可以指定为 false，这样，在一些需要 rollback 的方法，指定注释标签 @Rollback（true）即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对 Junit4 的注释标签支持&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;看了上面 Spring 测试框架的注释标签，我们来看看一些常见的基于 Junit4 的注释标签在 Spring 测试环境中的使用方法。&lt;/p&gt;

&lt;p&gt;@Test(expected=…)&lt;/p&gt;

&lt;p&gt;此注释标签的含义是，这是一个测试，期待一个异常的发生，期待的异常通过 xxx.class 标识。例如，我们修改 AccountService.Java 的 insertIfNotExist 方法，对于传入的参数如果为空，则抛出 IllegalArgumentException，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void insertIfNotExist(Account account) { 
    if(account==null) 
        throw new IllegalArgumentException(&quot;account is null&quot;); 
    Account acct = accountDao.getAccountById(account.getId()); 
    if(acct==null) { 
        log.debug(&quot;No &quot;+account+&quot; found,would insert it.&quot;); 
        accountDao.saveAccount(account); 
    } 
    acct = null; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，在测试类中增加一个测试异常的方法，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test(expected=IllegalArgumentException.class) 
public void testInsertException() { 
    service.insertIfNotExist(null); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果是 green bar。&lt;/p&gt;

&lt;p&gt;@Test(timeout=…)&lt;/p&gt;

&lt;p&gt;可以给测试方法指定超时时间（毫秒级别），当测试方法的执行时间超过此值，则失败。&lt;/p&gt;

&lt;p&gt;比如在 AccountService 中增加如下方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void doSomeHugeJob() { 
    try { 
        Thread.sleep(2*1000); 
    } catch (InterruptedException e) { 
    } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述方法模拟任务执行时间 2 秒，则测试方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test(timeout=3000) 
public void testHugeJob() { 
    service.doSomeHugeJob(); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述测试方法期待 service.doSomeHugeJob 方法能在 3 秒内结束，执行测试结果是 green bar。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@Repeat&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过 @Repeat，您可以轻松的多次执行测试用例，而不用自己写 for 循环，使用方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Repeat(3) 
@Test(expected=IllegalArgumentException.class) 
public void testInsertException() { 
    service.insertIfNotExist(null); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，testInsertException 就能被执行 3 次。&lt;/p&gt;

&lt;p&gt;在测试类中基于 profile 加载测试 bean&lt;/p&gt;

&lt;p&gt;从 Spring 3.2 以后，Spring 开始支持使用 @ActiveProfiles 来指定测试类加载的配置包，比如您的配置文件只有一个，但是需要兼容生产环境的配置和单元测试的配置，那么您可以使用 profile 的方式来定义 beans，如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 10. Spring-db.xml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;beans xmlns=&quot;http://www.Springframework.org/schema/beans&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
     xsi:schemaLocation=&quot;http://www.Springframework.org/schema/beans 
     http://www.Springframework.org/schema/beans/Spring-beans-3.2.xsd&quot;&amp;gt;

       &amp;lt;beans profile=&quot;test&quot;&amp;gt; 
         &amp;lt;bean id=&quot;datasource&quot;&amp;gt; 
             &amp;lt;property name=&quot;driverClassName&quot; value=&quot;org.hsqldb.jdbcDriver&quot; /&amp;gt; 
             &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:hsqldb:hsql://localhost&quot; /&amp;gt; 
             &amp;lt;property name=&quot;username&quot; value=&quot;sa&quot;/&amp;gt; 
             &amp;lt;property name=&quot;password&quot; value=&quot;&quot;/&amp;gt; 
         &amp;lt;/bean&amp;gt; 
      &amp;lt;/beans&amp;gt; 

      &amp;lt;beans profile=&quot;production&quot;&amp;gt; 
         &amp;lt;bean id=&quot;datasource&quot;&amp;gt; 
             &amp;lt;property name=&quot;driverClassName&quot; value=&quot;org.hsqldb.jdbcDriver&quot; /&amp;gt; 
             &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:hsqldb:hsql://localhost/prod&quot; /&amp;gt; 
             &amp;lt;property name=&quot;username&quot; value=&quot;sa&quot;/&amp;gt; 
             &amp;lt;property name=&quot;password&quot; value=&quot;&quot;/&amp;gt; 
         &amp;lt;/bean&amp;gt; 
     &amp;lt;/beans&amp;gt; 

     &amp;lt;beans profile=&quot;test,production&quot;&amp;gt; 
        &amp;lt;bean id=&quot;transactionManager&quot;&amp;gt; 
            &amp;lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot;&amp;gt;&amp;lt;/property&amp;gt; 
        &amp;lt;/bean&amp;gt; 
        &amp;lt;bean id=&quot;initer&quot; init-method=&quot;init&quot;&amp;gt; 
        &amp;lt;/bean&amp;gt; 
        &amp;lt;bean id=&quot;accountDao&quot; depends-on=&quot;initer&quot;&amp;gt; 
            &amp;lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot;/&amp;gt; 
        &amp;lt;/bean&amp;gt; 

        &amp;lt;bean id=&quot;accountService&quot;&amp;gt; 
        &amp;lt;/bean&amp;gt; 
        &amp;lt;bean id=&quot;envSetter&quot;/&amp;gt; 
    &amp;lt;/beans&amp;gt; 
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的定义，我们看到：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在 XML 头中我们引用了 Spring 3.2 的 beans 定义，因为只有 Spring 3.2+ 才支持基于 profile 的定义&lt;/li&gt;
&lt;li&gt;在 &amp;lt;beans&gt; 根节点下可以嵌套 &amp;lt;beans&gt; 定义，要指定 profile 属性，这个配置中，我们定义了两个 datasource，一个属于 test profile，一个输入 production profile，这样，我们就能在测试程序中加载 test profile，不影响 production 数据库了&lt;/li&gt;
&lt;li&gt;在下面定义了一些属于两个 profile 的 beans，即 &amp;lt;beans profile=”test,production”&gt; 这样方便重用一些 bean 的定义，因为这些 bean 在两个 profile 中都是一样的&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;清单 11. AccountServiceTest.Java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@RunWith(SpringJUnit4ClassRunner.class) 
@ContextConfiguration(&quot;/config/Spring-db.xml&quot;) 
@Transactional
@ActiveProfiles(&quot;test&quot;) 
public class AccountServiceTest { 
... 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上面的 @ActiveProfiles，可以指定一个或者多个 profile，这样我们的测试类就仅仅加载这些名字的 profile 中定义的 bean 实例。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对 TestNG 的支持&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Spring 2.5 以后，就开始支持 TestNG 了，支持的方法包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将您的 TestNG 测试类继承 Spring 的测试父类：AbstractTransactionalTestNGSpringContextTests 或者 AbstractTestNGSpringContextTests，这样您的 TestNG 测试类内部就可以访问 applicationContext 成员变量了&lt;/li&gt;
&lt;li&gt;不继承 Spring 父类，在测试类上使用 @TestExecutionListeners 注释标签，可以引入的监听器包括

&lt;ul&gt;
&lt;li&gt;DependencyInjectionTestExecutionListener：使得测试类拥有依赖注入特性&lt;/li&gt;
&lt;li&gt;DirtiesContextTestExecutionListener：使得测试类拥有更新 applicationContext 能力&lt;/li&gt;
&lt;li&gt;TransactionalTestExecutionListener：使得测试类拥有自动的事务管理能力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这里我们演示一下如何使用 Spring 提供的 TestNG 父类来进行测试。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 12. AccountServiceTestNGTest.Java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package testng; 

import static org.Junit.Assert.assertEquals; 

import org.Springframework.beans.factory.annotation.Autowired; 
import org.Springframework.test.context.ActiveProfiles; 
import org.Springframework.test.context.ContextConfiguration; 
import org.Springframework.test.context.testng. 
AbstractTransactionalTestNGSpringContextTests; 
import org.Springframework.transaction.annotation.Transactional; 

import service.AccountService; 
import domain.Account; 

@ContextConfiguration(&quot;/config/Spring-db.xml&quot;) 
@Transactional
@ActiveProfiles(&quot;test&quot;) 
public class AccountServiceTestNGTest extends
AbstractTransactionalTestNGSpringContextTests { 
    @Autowired
    private AccountService service; 

    @org.testng.annotations.Test 
    public void testGetAcccountById() { 
        Account acct = Account.getAccount(1, &quot;user01&quot;, 18, &quot;M&quot;); 
        service.insertIfNotExist(acct); 
        Account acct2 = service.getAccountById(1); 
        assertEquals(acct,acct2); 
    } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行测试，我们将看到测试成功。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 4. 测试成功&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-05/spring-unit-test-04.png&quot; title=&quot;使用 Spring 进行单元测试&quot;&gt;&lt;img src=&quot;/assets/files/2013-05/spring-unit-test-04.png&quot; title=&quot;使用 Spring 进行单元测试&quot; alt=&quot;使用 Spring 进行单元测试&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;搜索数据库对应的表，我们看到里面没有数据，说明自动事务起作用了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基本原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Spring test framework 主要位于 org.Springframework.test.context 包中，主要包括下面几个类：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 5. Spring 测试框架类图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-05/spring-unit-test-05.png&quot; title=&quot;使用 Spring 进行单元测试&quot;&gt;&lt;img src=&quot;/assets/files/2013-05/spring-unit-test-05.png&quot; title=&quot;使用 Spring 进行单元测试&quot; alt=&quot;使用 Spring 进行单元测试&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TestContextManager：主要的入口类，提供 TestContext 实例的管理，负责根据各种事件来通知测试监听器&lt;/li&gt;
&lt;li&gt;TestContext：实体类，提供访问 Spring applicatoin context 的能力，并负责缓存 applicationContext&lt;/li&gt;
&lt;li&gt;TestExecutionListener：测试监听器，提供依赖注入、applicationContext 缓存和事务管理等能力&lt;/li&gt;
&lt;li&gt;ContextLoader：负责根据配置加载 Spring 的 bean 定义，以构建 applicationContext 实例对象&lt;/li&gt;
&lt;li&gt;SmartContextLoader：Spring 3.1 引入的新加载方法，支持按照 profile 加载&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Spring 通过 AOP hook 了测试类的实例创建、beforeClass、before、after、afterClass 等事件入口，执行顺序主要如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 6. Spring 测试框架执行序列图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-05/spring-unit-test-06.png&quot; title=&quot;使用 Spring 进行单元测试&quot;&gt;&lt;img src=&quot;/assets/files/2013-05/spring-unit-test-06.png&quot; title=&quot;使用 Spring 进行单元测试&quot; alt=&quot;使用 Spring 进行单元测试&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;测试执行者开始执行测试类，这个时候 Spring 获取消息，自动创建 TestContextManager 实例&lt;/li&gt;
&lt;li&gt;TestContextManager 会创建 TestContext，以记录当前测试的上下文信息，TestContext 则通过 ContextLoader 来获取 Spring ApplicationContext 实例&lt;/li&gt;
&lt;li&gt;当测试执行者开始执行测试类的 BeforeClass、Before、After、AfterClass 的时候，TestContextManager 将截获事件，发通知给对应的 TestExecutionListener&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据上面的例子和介绍，我们可以看到，Spring 测试框架的主要特点如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;完美的支持了 Junit4（提供特别的 SpringJunit4ClassRunner），比较好的支持了 TestNG&lt;/li&gt;
&lt;li&gt;在支持原有单元测试能力的基础上，通过各种监听器，支持了测试类的依赖注入、对 Spring applicationContext 的访问以及事务管理能力，为使用 Spring 架构的应用程序的测试带来了极大的便利性&lt;/li&gt;
&lt;li&gt;Spring 3.1 引入的基于 profile 的加载能力使得测试环境和正式环境可以在一个 XML 定义中完美的结合&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;总之，如果您的程序中使用了 Spring，且对用 Junit 或者 testNG 来对他们进行单元测试感到力不从心，可以考虑使用 Spring test framework，它将使您的应用程序的质量上一个新的台阶。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>SQL联合语句的视觉解释</title>
   <link href="http://beango.github.com/archives/2013/05/30/a-visual-explanation-of-sql-joins.html"/>
   <updated>2013-05-30T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/05/30/a-visual-explanation-of-sql-joins</id>
   <content type="html">&lt;p&gt;我认为Ligaya Turmelle的关于SQL联合（join）语句的帖子对于新开发者来说是份很好的材料。SQL联合语句好像是基于集合的，用韦恩图来解释咋一看是很自然而然的。不过正如在她的帖子的回复中所说的，在测试中我发现韦恩图并不是十分的匹配SQL联合语法。&lt;/p&gt;

&lt;p&gt;不过我还是喜欢这个观点，所以我们来看看能不能用上韦恩图。假设我们有下面两张表。表A在左边，表B在右边。我们给它们各四条记录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;id name       id  name
-- ----       --  ----
1  Pirate     1   Rutabaga
2  Monkey     2   Pirate
3  Ninja      3   Darth Vader
4  Spaghetti  4   Ninja
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们用过name字段用几种不同方式把这些表联合起来，看能否得到和那些漂亮的韦恩图在概念上的匹配。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT * FROM TableA
INNER JOIN TableB
ON TableA.name = TableB.name

id  name       id   name
--  ----       --   ----
1   Pirate     2    Pirate
3   Ninja      4    Ninja
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内联合（inner join）只生成同时匹配表A和表B的记录集。（如下图）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-05/iinner-join.png&quot; title=&quot;inner join&quot;&gt;&lt;img src=&quot;/assets/files/2013-05/iinner-join.png&quot; title=&quot;inner join&quot; alt=&quot;inner join&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;——————————————————————————-&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT * FROM TableA
FULL OUTER JOIN TableB
ON TableA.name = TableB.name

id    name       id    name
--    ----       --    ----
1     Pirate     2     Pirate
2     Monkey     null  null
3     Ninja      4     Ninja
4     Spaghetti  null  null
null  null       1     Rutabaga       
null  null       3     Darth Vader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全外联合（full outer join）生成表A和表B里的记录全集，包括两边都匹配的记录。如果有一边没有匹配的，缺失的这一边为null。（如下图）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-05/Full-outer-join.png&quot; title=&quot;Full outer join&quot;&gt;&lt;img src=&quot;/assets/files/2013-05/Full-outer-join.png&quot; title=&quot;Full outer join&quot; alt=&quot;Full outer join&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;——————————————————————————-&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT * FROM TableA
LEFT OUTER JOIN TableB
ON TableA.name = TableB.name

id  name       id    name
--  ----       --    ----
1   Pirate     2     Pirate
2   Monkey     null  null
3   Ninja      4     Ninja
4   Spaghetti  null  null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;左外联合（left outer join）生成表A的所有记录，包括在表B里匹配的记录。如果没有匹配的，右边将是null。（如下图）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-05/Left-outer-join.png&quot; title=&quot;Left outer join&quot;&gt;&lt;img src=&quot;/assets/files/2013-05/Left-outer-join.png&quot; title=&quot;Left outer join&quot; alt=&quot;Left outer join&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;——————————————————————————-&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT * FROM TableA
LEFT OUTER JOIN TableB
ON TableA.name = TableB.name
WHERE TableB.id IS null

id  name       id     name
--  ----       --     ----
2   Monkey     null   null
4   Spaghetti  null   null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了生成只在表A里而不在表B里的记录集，我们用同样的左外联合，然后用where语句排除我们不想要的记录。（如下图）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-05/WHERE-TableB.id-IS-nul.png&quot; title=&quot;WHERE TableB.id IS nul&quot;&gt;&lt;img src=&quot;/assets/files/2013-05/WHERE-TableB.id-IS-nul.png&quot; title=&quot;WHERE TableB.id IS nul&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;——————————————————————————-&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT * FROM TableA
FULL OUTER JOIN TableB
ON TableA.name = TableB.name
WHERE TableA.id IS null 
OR TableB.id IS null

id    name       id    name
--    ----       --    ----
2     Monkey     null  null
4     Spaghetti  null  null
null  null       1     Rutabaga
null  null       3     Darth Vader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了生成对于表A和表B唯一的记录集，我们用同样的全外联合，然后用where语句排除两边都不想要的记录。（如下图）&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-05/WHERE-TableA.id-IS-null.png&quot; title=&quot;WHERE TableA.id IS null&quot;&gt;&lt;img src=&quot;/assets/files/2013-05/WHERE-TableA.id-IS-null.png&quot; title=&quot;WHERE TableA.id IS null&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;———————————————————–&lt;/p&gt;

&lt;p&gt;还有一种笛卡尔积或者&lt;strong&gt;交叉联合（cross join）&lt;/strong&gt;，据我所知不能用韦恩图表示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT * FROM TableA
CROSS JOIN TableB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个把“所有”联接到“所有”，产生4乘4=16行，远多于原始的集合。如果你学过数学，你便知道为什么这个联合遇上大型的表很危险。&lt;/p&gt;

&lt;p&gt;英文原文；&lt;a href=&quot;http://www.codinghorror.com/blog/2007/10/a-visual-explanation-of-sql-joins.html&quot;&gt;Jeff Atwood&lt;/a&gt;，编译：&lt;a href=&quot;http://www.jobbole.com&quot; title=&quot;伯乐在线&quot;&gt;伯乐&lt;/a&gt;在线 – @&lt;a href=&quot;http://weibo.com/deepfish2567&quot; title=&quot;奇风余谷&quot;&gt;奇风余谷&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>C#性能优化实践</title>
   <link href="http://beango.github.com/archives/2013/05/16/c-sharp-performance-optimization.html"/>
   <updated>2013-05-16T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/05/16/c-sharp-performance-optimization</id>
   <content type="html">&lt;p&gt;性能主要指两个方面：内存消耗和执行速度。性能优化简而言之，就是在不影响系统运行正确性的前提下，使之运行地更快，完成特定功能所需的时间更短。&lt;/p&gt;

&lt;p&gt;本文以.NET平台下的控件产品MultiRow为例，描述C#性能优化的实践。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;性能优化原则&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;· &lt;strong&gt;理解需求&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MultiRow的一个性能需求是：“百万行数据绑定下平滑滚动。”整个MultiRow项目的开发过程一直在考虑这个目标。&lt;/p&gt;

&lt;p&gt;· &lt;strong&gt;理解瓶颈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;99%的性能消耗是由于1%的代码造成的。大部分性能优化都是针对这1%的瓶颈代码进行的。具体实施也就分为两步：“发现瓶颈”和“消除瓶颈”。&lt;/p&gt;

&lt;p&gt;· &lt;strong&gt;切忌过度&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;性能优化本身是有成本的。这个成本不单单体现在做性能优化所付出的工作量，还包括为性能优化而写出复杂的代码导致额外的维护成本，比如引入新的Bug，额外的内存开销等。性能优化常常需要在收益和成本之间做出权衡。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何发现性能瓶颈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;性能优化的第一步是发现性能瓶颈，下面是一些定位性能瓶颈的实践。&lt;/p&gt;

&lt;p&gt;· &lt;strong&gt;如何获取内存消耗&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以下代码可以获取某个操作的内存消耗。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;long start = GC.GetTotalMemory(true);
// 在这里写需要被测试内存消耗的代码，例如，创建一个GcMultiRow
var gcMulitRow1 = new GcMultiRow();
GC.Collect();
// 确保所有内存都被GC回收
GC.WaitForFullGCComplete();
long end = GC.GetTotalMemory(true);
long useMemory = end - start;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;· &lt;strong&gt;如何获取时间消耗&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以下代码可以获取某个操作时间消耗。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch();
watch.Start();
for (int i = 0; i &amp;lt; 1000; i++)
{
    gcMultiRow1.Sort();
}
watch.Stop();
var useTime = (double)watch.ElapsedMilliseconds / 1000;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了获得更加稳定的时间消耗，这里把一个操作循环执行了1000次，取时间消耗的平均值以排除不稳定数据。&lt;/p&gt;

&lt;p&gt;· &lt;strong&gt;ANTS Performance Profiler&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ANTS Performance
Profiler是款功能强大的性能检测软件。熟练使用这个工具，我们可以快速准确的定位到有性能问题的代码。这是一款收费软件，会在IL中加入一些钩子用来记录时间，所以在分析时，软件的执行速度会比实际运行慢一些，获得的数据也因此并不是百分之百的准确，还要结合其他技巧来分析程序的性能。&lt;/p&gt;

&lt;p&gt;· &lt;strong&gt;CodeReview&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CodeReview是发现性能问题的最后手段。CodeReview应该对产品的性能瓶颈尽可能多的关注，确保该部分逻辑执行的尽可能的快。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;性能优化的方法和技巧&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;定位了性能问题后，解决的办法有很多。下面是一些性能优化的技巧和实践。&lt;/p&gt;

&lt;p&gt;· &lt;strong&gt;优化程序结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在设计时就应该考虑产品结构是否可以达到性能需求。如果后期发现了性能问题，调整结构会带来非常大的开销。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;GcMultiRow要支持100万行数据。假设每行有10列的话，就需要有1000万个单元格，每个单元格上又有很多的属性。如果不做任何优化，大数据量时，一个GcMultiRow软件的内存开销会相当的大。GcMultiRow采用的方案是使用哈希表来存储行数据：只有用户改过的行放到哈希表里，大部分没有改过的行都直接使用模板代替。这就达到了节省内存的目的。&lt;/p&gt;

&lt;p&gt;WPF平台和Silverlight平台的画法和Winform平台不同，是通过组合Visual元素的方法实现的。SpreadGrid
for
WPF产品同样支持百万级的数据量，但是又不能给每个单元格都分配一个View。所以SpreadGrid使用了VirtualizingPanel来实现画法。思路是每一个Visual是一个Cell的展示模块，可以和Cell的数据模块分离，这样就只需要为显示出来的Cell创建Visual。当发生滚动时会有一部分Cell滚出屏幕，有一部分Cell滚入屏幕。这时，让滚出屏幕的Cell和Visual分离，然后再复用这部分Visual给新进入屏幕的Cell。如此循环，就只需要几百个Visual就可以支持很多的Cell。&lt;/p&gt;

&lt;p&gt;· &lt;strong&gt;缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;缓存（Cache）是性能优化中最常用的手段，针对需要频繁的获取一些数据，同时每次获取数据需要的时间比较长的场景。如果使用了缓存的优化方法，需要特别注意缓存数据的同步：如果真实的数据发生了变化，应该及时的清除缓存数据，确保不会因为缓存而使用了错误的数据。&lt;/p&gt;

&lt;p&gt;使用缓存的情况比较多。最简单的情况就是缓存到一个Field或临时变量里。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for（int i = 0; i &amp;lt; gcMultiRow.RowCount; i++）
{ 
// Do something; 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码一般情况下是没有问题的，但是，如果GcMultiRow的行数比较大。而RowCount属性的取值又比较慢的时候，就需要使用缓存来做性能优化。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int rowCount = gcMultiRow.RowCount;
for (int i = 0; i &amp;lt; rowCount; i++)
{
// Do something;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用对象池也是一个常见的缓存方案，比使用Field或临时变量稍微复杂一点。例如，在MultiRow中，画边线，画背景，需要用到大量的Brush和Pen。这些GDI对象每次用之前要创建，用完后要销毁。创建和销毁的过程是比较慢的。GcMultiRow使用的方案是创建一个GDIPool。本质上是一些Dictionary，使用颜色做Key。所以只有第一次取的时候需要创建，以后就直接使用以前创建好的。&lt;/p&gt;

&lt;p&gt;以下是GDIPool的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static class GDIPool 
{ 
    Dictionary&amp;lt;Color, Brush &amp;gt; _cacheBrush = new Dictionary&amp;lt;Color, Brush&amp;gt;(); 
    Dictionary&amp;lt;Color, Pen&amp;gt; _cachePen = new Dictionary&amp;lt;Color, Pen&amp;gt;(); 
    public static Pen GetPen(Color color) 
    { 
        Pen pen; 
        if_cachePen.TryGetValue(color, out pen)) 
        { 
            return pen; 
        } 
        pen = new Pen(color); 
        _cachePen.Add(color, pen); 
        return pen; 
    } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;· &lt;strong&gt;懒构造&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;大多时候，对于创建需要花费较长时间的对象，往往并不是所有的场景下都需要使用。这时，使用懒构造的方法可以有效提高程序启动性能。&lt;/p&gt;

&lt;p&gt;举例来说，对象A需要内部创建对象B。对象B的构造时间比较长。 一般做法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class A
{
    public B _b = new B();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般做法下，由于构造对象A的同时要构造对象B，导致A的构造速度也变慢了。&lt;/p&gt;

&lt;p&gt;优化做法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class A
{
    private B _b;
    public B BProperty
    {
        get
        {
            if(_b == null)
            {
                _b = new B();
            }
            return _b;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优化后，构造A的时候就不需要创建B对象，有效的提高了A的构造性能。&lt;/p&gt;

&lt;p&gt;· &lt;strong&gt;优化算法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;优化算法可以有效的提高特定操作的性能。使用一种算法时应该了解算法的适用情况、最好情况和最坏情况。
以GcMultiRow为例，最初MultiRow的排序算法使用了经典的快速排序算法。这看起来是没有问题的。但是，对于表格软件，用户经常的操作是对有序表进行排序，如顺序和倒序之间切换。而经典的快速排序算法的最差情况就是基本有序的情况。所以经典快速排序算法不适合MultiRow。&lt;/p&gt;

&lt;p&gt;改进的快速排序算法使用了3个中点来代替经典快排的一个中点的算法，每次交换都是从3个中点中选择中间值。这样，乱序和基本有序的情况都不是这个算法的最坏情况，从而优化了性能。&lt;/p&gt;

&lt;p&gt;· &lt;strong&gt;正确的使用既有数据结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们现在工作的.NET
framework平台有很多现成的数据结构。我们应该了解这些数据结构，提升我们程序的性能。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;​1. String的加运算符和StringBuilder：
字符串的操作是我们经常遇到的基本操作之一。 我们经常会写这样的代码 string
str = str1 +
str2。当操作的字符串很少的时候，这样的操作没有问题。但是如果大量操作的时候（例如文本文件的Save/Load，
Asp.net的Render），这样做就会带来严重的性能问题。这时，我们就应该用StringBuilder来代替string的加操作。&lt;/p&gt;

&lt;p&gt;​2. Dictionary和List:
Dictionary和List是最常用的两种集合类。选择正确的集合类可以很大的提升程序的性能。为了做出正确的选择，我们应该对Dictionary和List的各种操作的性能比较了解。
下表中粗略的列出了两种数据结构的性能比较。&lt;/p&gt;

&lt;table border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;操作&lt;/p&gt;
            &lt;/td&gt;
            &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;List&lt;/p&gt;
            &lt;/td&gt;
            &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;Dictionary&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;索引&lt;/p&gt;
            &lt;/td&gt;
            &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;快&lt;/p&gt;
            &lt;/td&gt;
            &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;慢&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;Find（Contains）&lt;/p&gt;
            &lt;/td&gt;
            &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;慢&lt;/p&gt;
            &lt;/td&gt;
            &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;快&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;Add&lt;/p&gt;
            &lt;/td&gt;
            &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;快&lt;/p&gt;
            &lt;/td&gt;
            &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;慢&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;Insert&lt;/p&gt;
            &lt;/td&gt;
            &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;慢&lt;/p&gt;
            &lt;/td&gt;
            &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;快&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;Remove&lt;/p&gt;
            &lt;/td&gt;
            &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;慢&lt;/p&gt;
            &lt;/td&gt;
            &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;快&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;​3. TryGetValue: 对于Dictionary的取值，比较直接的方法是如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(_dic.ContainKey(&quot;Key&quot;)
{
    return _dic[&quot;Key&quot;];
}      
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当需要大量取值的时候，这样的取法会带来性能问题。优化方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;object value;
if(_dic.TryGetValue(&quot;Key&quot;, out value))
{
return value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后一种用法要比前一种用法取值性能提高一倍。&lt;/p&gt;

&lt;p&gt;​4. 为Dictionary选择合适的Key:
Dictionary的取值性能很大情况下取决于做Key的对象的Equals和GetHashCode两个方法的性能。如果可以的话，使用Int做Key性能最好。如果是一个自定义的Class做Key的话，最好保证以下两点：1.
不同对象的GetHashCode重复率低。2. GetHashCode和Equals方法简单，效率高。&lt;/p&gt;

&lt;p&gt;​5. List的Sort和BinarySearch性能很好，如果能满足功能需求，推荐直接使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;{3, 10, 15}; 
list.BinarySearch(10); // 对于存在的值，结果是1 
list.BinarySearch(8); // 对于不存在的值，会使用负数表示位置， 
// 如查找8时，结果是-2， 查找0结果是-1，查找100结果是-4. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;· &lt;strong&gt;通过异步提升响应时间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;多线程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有些操作确实需要花费比较长的时间。在处理的过程中，如果用户进行操作时失去响应，这个用户体验是很差的。使用多线程技术可以解决这个问题。例如，有一个类似Excel的计算引擎，在构造的时候要初始化所有的函数定义。由于函数比较多，初始化时间会比较长。这是如果用到了多线程，在工作线程中做函数定义进行的初始化，就不会影响到UI线程快速响应用户的其他操作了。&lt;/p&gt;

&lt;p&gt;代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public CalcParser()
{
 if (_functions == null)
  {
   lock (_obtainFunctionLocker)
   {
    if (_functions == null)
    {
      System.Threading.ThreadPool.QueueUserWorkItem((s) =&amp;gt; 
      {
       if (_functions == null) 
       { 
         lock (_obtainFunctionLocker) 
         { 
           if (_functions == null) 
           { 
             _functions = EnsureFunctions(); 
            }
           }
         } 
        }); 
       } 
      } 
     } 
    } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里比较慢的操作就是EnsureFunctions函数，是在另一个线程里执行的，不会影响主线程的响应。当然，使用多线程是一个比较有难度的方案，需要充分考虑跨线程访问和死锁的问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;strong&gt;加延迟时间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在GcMultiRow实现AutoFilter功能的时候使用了一个类似于延迟执行的方案来提升响应速度。AutoFilter的功能是用户在输入的过程中根据用户的输入更新筛选的结果。数据量大的时候一次筛选需要较长时间，会导致用户输入不流畅，体验不好。使用多线程虽然是个好方案，但是会增加程序的复杂度。MultiRow的解决方案是当接收到用户的键盘输入消息的时候，并不立即出发Filter，而是等待0.3秒。如果用户连续输入，会在这0.3秒内再次收到键盘消息，放弃上一个任务，再等0.3秒，直到连续0.3秒内没有新的键盘消息时再触发Filter。这样就实现了比较流畅的用户体验。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. Application.Idle&lt;/strong&gt;&lt;strong&gt;事件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在GcMultiRow的Designer里，经常要根据当前的状态刷新ToolBar上按钮的Disable/Enable状态，一次刷新需要较长的时间。这个又一次影响了用户输入的流畅性。GcMultiRow的优化方案是通过系统的Application.Idle事件，仅当系统空闲的时候处理刷新逻辑。接到这个事件时，一般都是用户已经完成了连续的输入，这时就可以从容的刷新按钮的状态了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. Refresh, BeginInvoke&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;平台本身也提供了一些异步方案。例如在WinForm下触发一块区域重画的时候，调用Refresh方法不会导致立即重画，而是设置Invalidate标记，触发异步的刷新。在控件开发中，这个技巧可以有效的提高产品的性能，同时简化实现复杂度。&lt;/p&gt;

&lt;p&gt;Control.BeginInvoke方法可以被用来触发异步的自定义行为。&lt;/p&gt;

&lt;p&gt;· &lt;strong&gt;进度条，提升用户体验&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有时候，以上提到的方案都没有办法快速响应用户操作。进度条、一直转圈圈的图片、提示性文字（如&quot;你的操作可能需要较长时间，请耐心等待&quot;）等，都可以有效的提升用户体验，可以作为最后方案来考虑。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java 代码优化过程的实例介绍</title>
   <link href="http://beango.github.com/archives/2013/04/27/j-lo-codeoptimize.html"/>
   <updated>2013-04-27T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/04/27/j-lo-codeoptimize</id>
   <content type="html">&lt;p&gt;来源: &lt;a href=&quot;http://www.ibm.com/developerworks/cn/java/j-lo-codeoptimize/index.html?ca=drs-&quot;&gt;IBM developerworks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt; 通过笔者经历的一个项目实例，本文介绍了 Java 代码优化的过程，总结了优化 Java 程序的一些最佳实践，分析了进行优化的方法，并解释了性能提升的原因。从多个角度分析导致性能低的原因，并逐个进行优化，最终使得程序的性能得到极大提升，代码的可读性、可扩展性更强。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;衡量程序的标准&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;衡量一个程序是否优质，可以从多个角度进行分析。其中，最常见的衡量标准是程序的时间复杂度、空间复杂度，以及代码的可读性、可扩展性。针对程序的时间复杂度和空间复杂度，想要优化程序代码，需要对数据结构与算法有深入的理解，并且熟悉计算机系统的基本概念和原理；而针对代码的可读性和可扩展性，想要优化程序代码，需要深入理解软件架构设计，熟知并会应用合适的&lt;a href=&quot;http://www.amazon.cn/gp/product/B001130JN8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;tag=vastwork-23&amp;amp;linkCode=as2&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=B001130JN8&quot; title=&quot;1&quot;&gt;设计模式&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;首先，如今计算机系统的存储空间已经足够大了，达到了 TB 级别，因此相比于空间复杂度，时间复杂度是程序员首要考虑的因素。为了追求高性能，在某些频繁操作执行时，甚至可以考虑用空间换取时间。其次，由于受到处理器制造工艺的物理限制、成本限制，CPU 主频的增长遇到了瓶颈，摩尔定律已渐渐失效，每隔 18 个月 CPU 主频即翻倍的时代已经过去了，程序员的编程方式发生了彻底的改变。在目前这个多核多处理器的时代，涌现了原生支持多线程的语言（如Java）以及分布式并行计算框架（如 Hadoop）。为了使程序充分地利用多核CPU，简单地实现一个单线程的程序是远远不够的，程序员需要能够编写出并发或者并行的多线程程序。最后，大型软件系统的代码行数达到了百万级，如果没有一个设计良好的软件架构，想在已有代码的基础上进行开发，开发代价和维护成本是无法想象的。一个设计良好的软件应该具有可读性和可扩展性，遵循“开闭原则”、“依赖倒置原则”、“面向接口编程”等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;项目介绍&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本文将介绍笔者经历的一个项目中的一部分，通过这个实例剖析代码优化的过程。下面简要地介绍该系统的相关部分。&lt;/p&gt;

&lt;p&gt;该系统的开发语言为 Java，部署在共拥有 4 核 CPU 的 Linux 服务器上，相关部分主要有以下操作：通过某外部系统 D 提供的 REST API 获取信息，从中提取出有效的信息，并通过 JDBC 存储到某数据库系统 S 中，供系统其他部分使用，上述操作的执行频率为每天一次，一般在午夜当系统空闲时定时执行。为了实现高可用性（High Availability），外部系统 D 部署在两台服务器上，因此需要分别从这两台服务器上获取信息并将信息插入数据库中，有效信息的条数达到了上千条，数据库插入操作次数则为有效信息条数的两倍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 1. 系统体系结构图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-04/image002.jpg&quot; title=&quot;Java 代码优化过程的实例介绍&quot;&gt;&lt;img src=&quot;/assets/files/2013-04/image002.jpg&quot; title=&quot;Java 代码优化过程的实例介绍&quot; alt=&quot;Java代码优化过程的实例介绍&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为了快速地实现预期效果，在最初的实现中优先考虑了功能的实现，而未考虑系统性能和代码可读性等。系统大致有以下的实现：
（1）REST API获取信息、数据库操作可能抛出的异常信息都被记录到日志文件中，作为调试用；&lt;br/&gt;
（2）共有 5 次数据库连接操作，包括第一次清空数据库表，针对两个外部系统 D 各有两次数据库插入操作，这 5 个连接都是独立的，用完之后即释放；&lt;br/&gt;
（3）所有的数据库插入语句都是使用java.sql.Statement类生成的；&lt;br/&gt;
（4）所有的数据库插入语句，都是单条执行的，即生成一条执行一条；&lt;br/&gt;
（5）整个过程都是在单个线程中执行的，包括数据库表清空操作，数据库插入操作，释放数据库连接；&lt;br/&gt;
（6）数据库插入操作的JDBC代码散布在代码中。虽然这个版本的系统可以正常运行，达到了预期的效果，但是效率很低，从通过REST API 获取信息，到解析并提取有效信息，再到数据库插入操作，总共耗时 100 秒左右。而预期的时间应该在一分钟以内，这显然是不符合要求的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码优化过程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;笔者开始分析整个过程有哪些耗时操作，以及如何提升效率，缩短程序执行的时间。通过 REST API 获取信息，因为是使用外部系统提供的API，所以无法在此处提升效率；取得信息之后解析出有效部分，因为是对特定格式的信息进行解析，所以也无效率提升的空间。所以，效率可以大幅度提升的空间在数据库操作部分以及程序控制部分。下面，分条叙述对耗时操作的改进方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;针对日志记录的优化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关闭日志记录，或者更改日志输出级别。&lt;/strong&gt;因为从两台服务器的外部系统 D 上获取到的信息是相同的，所以数据库插入操作会抛出异常，异常信息类似于“Attempt to insert duplicate record”，这样的异常信息跟有效信息的条数相等，有上千条。这种情况是能预料到的，所以可以考虑关闭日志记录，或者不关闭日志记录而是更改日志输出级别，只记录严重级别（severe level）的错误信息，并将此类操作的日志级别调整为警告级别（warning level），这样就不会记录以上异常信息了。本项目使用的是 Java 自带的日志记录类，以下配置文件将日志输出级别设置为严重级别。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 1. log.properties 设置日志输出级别的片段&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# default file output is in user ’ s home directory. 
# levels can be: SEVERE, WARNING, INFO, FINE, FINER, FINEST 
java.util.logging.ConsoleHandler.level=SEVERE 
java.util.logging.FileHandler.formatter=java.util.logging.SimpleFormatter 
java.util.logging.FileHandler.append=true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上述的优化之后，性能有了大幅度的提升，从原来的 100 秒左右降到了 50 秒左右。为什么仅仅不记录日志就能有如此大幅度的性能提升呢？查阅资料，发现已经有人做了相关的研究与实验。经常听到 Java 程序比 C/C++ 程序慢的言论，但是运行速度慢的真正原因是什么，估计很多人并不清楚。对于 CPU 密集型的程序（即程序中包含大量计算），Java 程序可以达到 C/C++ 程序同等级别的速度，但是对于 I/O 密集型的程序（即程序中包含大量 I/O 操作），Java 程序的速度就远远慢于 C/C++ 程序了，很大程度上是因为 C/C++ 程序能直接访问底层的存储设备。因此，不记录日志而得到大幅度性能提升的原因是，Java 程序的 I/O 操作较慢，是一个很耗时的操作。&lt;/p&gt;

&lt;p&gt;针对数据库连接的优化&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;共享数据库连接。&lt;/strong&gt;共有 5 次数据库连接操作，每次都需重新建立数据库连接，数据库插入操作完成之后又立即释放了，数据库连接没有被复用。为了做到共享数据库连接，可以通过单例模式（Singleton Pattern）获得一个相同的数据库连接，每次数据库连接操作都共享这个数据库连接。这里没有使用数据库连接池（Database Connection Pool）是因为在程序只有少量的数据库连接操作，只有在大量并发数据库连接的时候才需要连接池。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 2. 共享数据库连接的代码片段&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class JdbcUtil { 
    private static Connection con; 
    // 从配置文件读取连接数据库的信息
    private static String driverClassName; 
    private static String url; 
    private static String username; 
    private static String password; 
    private static String currentSchema; 
    private static Properties properties = new Properties(); 

    static { 
    // driverClassName, url, username, password, currentSchema 等从配置文件读取，代码略去
        try { 
            Class.forName(driverClassName); 
        } catch (ClassNotFoundException e) { 
            e.printStackTrace(); 
        } 
        properties.setProperty(&quot;user&quot;, username); 
        properties.setProperty(&quot;password&quot;, password); 
        properties.setProperty(&quot;currentSchema&quot;, currentSchema); 
        try { 
            con = DriverManager.getConnection(url, properties); 
        } catch (SQLException e) { 
            e.printStackTrace(); 
        } 
    } 
    private JdbcUtil() {} 
     // 获得一个单例的、共享的数据库连接
     public static Connection getConnection() { 
        return con; 
    } 
    public static void close() throws SQLException { 
        if (con != null) 
            con.close(); 
    } 
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上述的优化之后，性能有了小幅度的提升，从 50 秒左右降到了 40 秒左右。共享数据库连接而得到的性能提升的原因是，数据库连接是一个耗时耗资源的操作，需要同远程计算机进行网络通信，建立 TCP 连接，还需要维护连接状态表，建立数据缓冲区。如果共享数据库连接，则只需要进行一次数据库连接操作，省去了多次重新建立数据库连接的时间。&lt;/p&gt;

&lt;p&gt;针对插入数据库记录的优化 1&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用预编译 SQL。&lt;/strong&gt;具体做法是使用 java.sql.PreparedStatement 代替 java.sql.Statement 生成 SQL 语句。PreparedStatement 使得数据库预先编译好 SQL 语句，可以传入参数。而 Statement 生成的 SQL 语句在每次提交时，数据库都需进行编译。在执行大量类似的 SQL 语句时，可以使用 PreparedStatement 提高执行效率。使用 PreparedStatement 的另一个好处是不需要拼接 SQL 语句，代码的可读性更强。通过上述的优化之后，性能有了小幅度的提升，从 40 秒左右降到了 30\~35 秒左右。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 3. 使用 Statement 的代码片段&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 需要拼接 SQL 语句，执行效率不高，代码可读性不强
StringBuilder sql = new StringBuilder(); 
sql.append(&quot;insert into table1(column1,column2) values('&quot;); 
sql.append(column1Value); 
sql.append(&quot;','&quot;); 
sql.append(column2Value); 
sql.append(&quot;');&quot;); 

Statement st; 
try { 
    st = con.createStatement(); 
    st.executeUpdate(sql.toString()); 
} catch (SQLException e) { 
    e.printStackTrace(); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;清单 4. 使用 PreparedStatement 的代码片段&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 预编译 SQL 语句，执行效率高，可读性强
String sql = “insert into table1(column1,column2) values(?,?)”; 
PreparedStatement pst = con.prepareStatement(sql); 
pst.setString(1,column1Value); 
pst.setString(2,column2Value); 
pst.execute();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;针对插入数据库记录的优化 2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用 SQL 批处理。&lt;/strong&gt;通过 java.sql.PreparedStatement 的 addBatch 方法将 SQL 语句加入到批处理，这样在调用 execute 方法时，就会一次性地执行 SQL 批处理，而不是逐条执行。通过上述的优化之后，性能有了小幅度的提升，从 30\~35 秒左右降到了 30 秒左右。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;针对多线程的优化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用多线程实现并发 / 并行。&lt;/strong&gt;清空数据库表的操作、把从 2 个外部系统 D 取得的数据插入数据库记录的操作，是相互独立的任务，可以给每个任务分配一个线程执行。清空数据库表的操作应该先于数据库插入操作完成，可以通过 java.lang.Thread 类的 join 方法控制线程执行的先后次序。在单核 CPU 时代，操作系统中某一时刻只有一个线程在运行，通过进程/线程调度，给每个线程分配一小段执行的时间片，可以实现多个进程/线程的并发（concurrent）执行。而在目前的多核多处理器背景下，操作系统中同一时刻可以有多个线程并行（parallel）执行，大大地提高了计算速度。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 5. 使用多线程的代码片段&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Thread t0 = new Thread(new ClearTableTask()); 
Thread t1 = new Thread(new StoreServersTask(ADDRESS1)); 
Thread t2 = new Thread(new StoreServersTask(ADDRESS2)); 

try { 
    t0.start(); 
    // 执行完清空操作后，再进行后续操作
    t0.join(); 
    t1.start(); 
    t2.start(); 
    t1.join(); 
    t2.join(); 
} catch (InterruptedException e) { 
    e.printStackTrace(); 
} 

// 断开数据库连接
try { 
    JdbcUtil.close(); 
} catch (SQLException e) { 
    e.printStackTrace(); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上述的优化之后，性能有了大幅度的提升，从 30 秒左右降到了 15 秒以下，10\~15秒之间。使用多线程而得到的性能提升的原因是，系统部署所在的服务器是多核多处理器的，使用多线程，给每个任务分配一个线程执行，可以充分地利用 CPU 计算资源。&lt;/p&gt;

&lt;p&gt;笔者试着给每个任务分配两个线程执行，希望能使程序运行得更快，但是事与愿违，此时程序运行的时间反而比每个任务分配一个线程执行的慢，大约 20 秒。笔者推测，这是因为线程较多（相对于 CPU 的内核数），使得 CPU 忙于线程的上下文切换，过多的线程上下文切换使得程序的性能反而不如之前。因此，要根据实际的硬件环境，给任务分配适量的线程执行。&lt;/p&gt;

&lt;p&gt;针对设计模式的优化&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用 DAO 模式抽象出数据访问层。&lt;/strong&gt;原来的代码中混杂着 JDBC 操作数据库的代码，代码结构显得十分凌乱。使用 DAO 模式（Data Access Object Pattern）可以抽象出数据访问层，这样使得程序可以独立于不同的数据库，即便访问数据库的代码发生了改变，上层调用数据访问的代码无需改变。并且程序员可以摆脱单调繁琐的数据库代码的编写，专注于业务逻辑层面的代码的开发。通过上述的优化之后，性能并未有提升，但是代码的可读性、可扩展性大大地提高了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 2. DAO 模式的层次结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-04/image003.jpg&quot; title=&quot;Java 代码优化过程的实例介绍&quot;&gt;&lt;img src=&quot;/assets/files/2013-04/image003.jpg&quot; title=&quot;Java 代码优化过程的实例介绍&quot; alt=&quot;Java代码优化过程的实例介绍&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 6. 使用 DAO 模式的代码片段&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// DeviceDAO.java，定义了 DAO 抽象，上层的业务逻辑代码引用该接口，面向接口编程
 public interface DeviceDAO { 
    public void add(Device device); 
 } 

 // DeviceDAOImpl.java，DAO 实现，具体的 SQL 语句和数据库操作由该类实现
 public class DeviceDAOImpl implements DeviceDAO { 
    private Connection con; 
    public DeviceDAOImpl() { 
        // 获得数据库连接，代码略去
    } 
 @Override
 public void add(Device device) { 
        // 使用 PreparedStatement 进行数据库插入记录操作，代码略去
    } 
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回顾以上代码优化过程：关闭日志记录、共享数据库连接、使用预编译 SQL、使用 SQL 批处理、使用多线程实现并发 / 并行、使用 DAO 模式抽象出数据访问层，程序运行时间从最初的 100 秒左右降低到 15 秒以下，在性能上得到了很大的提升，同时也具有了更好的可读性和可扩展性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结束语&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过该项目实例，笔者深深地感到，想要写出一个性能优化、可读性可扩展性强的程序，需要对计算机系统的基本概念、原理，&lt;a href=&quot;http://blog.jobbole.com/tag/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/&quot; title=&quot;如何选择语言和编程语言排名相关文章&quot;&gt;编程语言&lt;/a&gt;的特性，软件系统架构设计都有较深入的理解。“纸上得来终觉浅，绝知此事要躬行”，想要将这些基本理论、编程技巧融会贯通，还需要不断地实践，并总结心得体会。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Python中函数式编程，第三部分</title>
   <link href="http://beango.github.com/archives/2013/04/25/python-functional-programming-part3.html"/>
   <updated>2013-04-25T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/04/25/python-functional-programming-part3</id>
   <content type="html">&lt;p&gt;英文原文：&lt;a href=&quot;http://www.ibm.com/developerworks/linux/library/l-prog3/index.html&quot;&gt;Charming Python: Functional programming in Python, Part 3&lt;/a&gt;，翻译：&lt;a href=&quot;http://www.oschina.net/translate/python-functional-programming-part3&quot;&gt;开源中国&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;  作者David Mertz在其文章《可爱的Python：“Python中的函数式编程”》中的&lt;a href=&quot;http://blog.jobbole.com/35028/&quot;&gt;第一部分&lt;/a&gt;和&lt;a href=&quot;http://blog.jobbole.com/35042/&quot;&gt;第二部分&lt;/a&gt;中触及了函数式编程的大量基本概念。本文中他将继续前面的讨论，解释函数式编程的其它功能，如currying和Xoltar
Toolkit中的其它一些高阶函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;表达式绑定&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有一位从不满足于解决部分问题读者，名叫Richard Davies，提出了一个问题，问是否可以将所有的绑定全部都转移到一个单个的表达式之中。首先让我们简单看看，我们为什么想这么做，然后再看看由comp.lang.python中的一位朋友提供的一种异常优雅地写表达式的方式。&lt;/p&gt;

&lt;p&gt;让我们回想一下功能模块的绑定类。使用该类的特性，我们可以确认在一个给定的范围块内，一个特定的名字仅仅代表了一个唯一的事物。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;具有重新绑定向导的 Python 函数式编程(FP)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from functional import *
&amp;gt;&amp;gt;&amp;gt; let = Bindings()
&amp;gt;&amp;gt;&amp;gt; let.car = lambda lst: lst[0]
&amp;gt;&amp;gt;&amp;gt; let.car = lambda lst: lst[2]
Traceback (innermost last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in ?
  File &quot;d:\tools\functional.py&quot;, line 976, in __setattr__

raise BindingError, &quot;Binding '%s' cannot be modified.&quot; % name
functional.BindingError:  Binding 'car' cannot be modified.
&amp;gt;&amp;gt;&amp;gt; let.car(range(10))
0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;绑定类在一个模块或者一个功能定义范围内做这些我们希望的事情，但是没有办法在一条表达式内使之工作。然而在ML家族语言(译者注：ML是一种通用的函数式&lt;a href=&quot;http://blog.jobbole.com/tag/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/&quot; title=&quot;如何选择语言和编程语言排名相关文章&quot;&gt;编程语言&lt;/a&gt;),在一条表达式内创建绑定是很自然的事。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Haskell 命名绑定表达式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- car (x:xs) = x  -- *could* create module-level binding
list_of_list = [[1,2,3],[4,5,6],[7,8,9]]

-- 'where' clause for expression-level binding
firsts1 = [car x | x &amp;lt;- list_of_list] where car (x:xs) = x

-- 'let' clause for expression-level binding
firsts2 = let car (x:xs) = x in [car x | x &amp;lt;- list_of_list]

-- more idiomatic higher-order 'map' technique
firsts3 = map car list_of_list where car (x:xs) = x

-- Result: firsts1 == firsts2 == firsts3 == [1,4,7]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Greg Ewing发现用Python的list概念实现同样的效果是有可能的；甚至我们可以用几乎与Haskell语法一样干净的方式做到。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Python 2.0+ 命名绑定表达式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list_of_list = [[1,2,3],[4,5,6],[7,8,9]]
&amp;gt;&amp;gt;&amp;gt; [car_x for x in list_of_list for car_x in
 (x[0],)]
[1, 4, 7]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在列表解析（list comprehension）中将表达式放入一个单项元素（a single-item tuple）中的这个小技巧，并不能为使用带有表达式级绑定的高阶函数提供任何思路。要使用这样的高阶函数，还是需要使用块级（block-level）绑定，就象以下所示：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Python中的使用块级绑定的’map()’&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list_of_list = [[1,2,3],[4,5,6],[7,8,9]]
&amp;gt;&amp;gt;&amp;gt; let = Bindings()
&amp;gt;&amp;gt;&amp;gt; let.car = lambda l: l[0]
&amp;gt;&amp;gt;&amp;gt; map(let.car,list_of_list)
[1, 4, 7]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样真不错，但如果我们想使用函数map()，那么其中的绑定范围可能会比我们想要的更宽一些。然而，我们可以做到的，哄骗列表解析让它替我们做名字绑定，即使其中的列表并不是我们最终想要得到的列表的情况下也没问题：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;从Python的列表解析中“走下舞台”&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Compare Haskell expression:
# result = func car_car
#          where
#              car (x:xs) = x
#              car_car = car (car list_of_list)
#              func x = x + x^2
&amp;gt;&amp;gt;&amp;gt; [func for x in list_of_list
...       
for car in (x[0],)
...       
for func in (car+car**2,)][0]
2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们对list_of_list列表中第一个元素的第一个元素进行了一次算数运算，而且期间还对该算术运算进行了命名（但其作用域仅仅是在表达式的范围内）。作为一种“优化”，我们可以不用费心创建多于一个元素的列表就能开始运算了，因为我们结尾处用的索引为0，所以我们仅仅选择的是第一个元素。：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;从列表解析中高效地走下舞台&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Compare Haskell expression:
# result = func car_car
#          where
#              car (x:xs) = x
#              car_car = car (car list_of_list)
#              func x = x + x^2
&amp;gt;&amp;gt;&amp;gt; [func for x in list_of_list
...       
for car in (x[0],)
...       
for func in (car+car**2,)][0]
2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;高阶函数：currying&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Python内建的三个最常用的高阶函数是：map()、reduce()和filter()。这三个函数所做的事情 —— 以及谓之为“高阶”（higher-order）的原因 —— 是接受其它函数作为它们的（部分）参数。还有别的一些不属于内置的高阶函数，还会返回函数对象。
藉由函数对象在Python中具有首要地位，
Python一直都有能让其使用者构造自己的高阶函数的能力。举个如下所示的小例子：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Python中一个简单函数工厂（function factory）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def
 foo_factory():
...    
def
 foo():
...        
print
&quot;Foo function from factory&quot;
...    
return foo
...
&amp;gt;&amp;gt;&amp;gt; f = foo_factory()
&amp;gt;&amp;gt;&amp;gt; f()
Foo function from factory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本系列文章的第二部分我讨论过的Xoltar Toolkit中，有一组非常好用的高阶函数。Xoltar的functional模块中提供的绝大多数高阶函数都是在其它各种不同的传统型函数式编程语言中发展出来的高阶函数，其有用性已经过多年的实践验证。&lt;/p&gt;

&lt;p&gt;可能其中最著名、最有用和最重要的高阶函数要数curry()了。函数curry()的名字取自于逻辑学家Haskell Curry，前文提及的一种编程语言也是用他姓名当中的名字部分命名的。”currying”背后隐含的意思是，（几乎）每一个函数都可以视为只带一个参数的部分函数（partial function）。要使currying能够用起来所需要做的就是让函数本身的返回值也是个函数，只不过所返回的函数“缩小了范围”或者是“更加接近完整的函数”。这和我在第二部分中提到的闭包特别相似 —— 对经过curry后的返回的后继函数进行调用时一步一步“填入”最后计算所需的更多数据（附加到一个过程（procedure）之上的数据）&lt;/p&gt;

&lt;p&gt;现在让我们先用Haskell中一个很简单例子对curry进行讲解，然后在Python中使用functional模块重复展示一下这个简单的例子：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在Haskell计算中使用Curry&lt;/strong&gt;*&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;computation a b c d = (a + b^2+ c^3 + d^4)
check = 1 + 2^2 + 3^3 + 5^4

fillOne   = computation 1
-- specify &quot;a&quot;
fillTwo   = fillOne 2    
-- specify &quot;b&quot;
fillThree = fillTwo 3    
-- specify &quot;c&quot;
answer    = fillThree 5  
-- specify &quot;d&quot;

-- Result: check == answer == 657
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在使用Python：&lt;/p&gt;

&lt;p&gt;在Python计算中使用Curry&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from functional import curry
&amp;gt;&amp;gt;&amp;gt; computation = lambda a,b,c,d: (a + b**2 + c**3 + d**4)
&amp;gt;&amp;gt;&amp;gt; computation(1,2,3,5)
657
&amp;gt;&amp;gt;&amp;gt; fillZero  = curry(computation)
&amp;gt;&amp;gt;&amp;gt; fillOne   = fillZero(1)  
# specify &quot;a&quot;
&amp;gt;&amp;gt;&amp;gt; fillTwo   = fillOne(2)   
# specify &quot;b&quot;
&amp;gt;&amp;gt;&amp;gt; fillThree = fillTwo(3)   
# specify &quot;c&quot;
&amp;gt;&amp;gt;&amp;gt; answer    = fillThree(5) 
# specify &quot;d&quot;
&amp;gt;&amp;gt;&amp;gt; answer
657
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二部分中提到过的一个简单的计税程序的例子，当时用的是闭包（这次使用curry()），可以用来进一步做个对比：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Python中curry后的计税程序

from functional import *

taxcalc = lambda income,rate,deduct: (income-(deduct))*rate

taxCurry = curry(taxcalc)
taxCurry = taxCurry(50000)
taxCurry = taxCurry(0.30)
taxCurry = taxCurry(10000)
print &quot;Curried taxes due =&quot;,taxCurry

print &quot;Curried expression taxes due =&quot;, \
      curry(taxcalc)(50000)(0.30)(10000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和使用闭包不同，我们需要以特定的顺序（从左到右）对参数进行curry处理。当要注意的是，functional模块中还包含一个rcurry()类，能够以相反的方向进行curry处理（从右到左）。&lt;/p&gt;

&lt;p&gt;从一个层面讲，其中的第二个print语句同简单的同普通的taxcalc(50000,0.30,10000)函数调用相比只是个微小的拼写方面的变化。但从另一个不同的层面讲，它清晰地一个概念，那就是，每个函数都可以变换成仅仅带有一个参数的函数，这对于刚刚接触这个概念的人来讲，会有一种特别惊奇的感觉。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其它高阶函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;除了上述的curry功能，functional模块简直就是一个很有意思的高阶函数万能口袋。此外，无论用还是不用functional模块，编写你自己的高阶函数真的并不难。至少functional模块中的那些高阶函数为你提供了一些很值一看的思路。\&lt;/p&gt;

&lt;p&gt;它里面的其它高阶函数在很大程度上感觉有点象是“增强”版本的标准高阶函数map()、filter()和reduce()。这些函数的工作模式通常大致如此：将一个或多个函数以及一些列表作为参数接收进来，然后对这些列表参数运行它前面所接收到的函数。在这种工作模式方面，有非常大量很有意思也很有用的摆弄方法。还有一种模式是：拿到一组函数后，将这组函数的功能组合起来创建一个新函数。这种模式同样也有大量的变化形式。下面让我们看看functional模块里到底还有哪些其它的高阶函数。&lt;/p&gt;

&lt;p&gt;sequential()和also()这两个函数都是在一系列成分函数（component function）的基础上创建一个新函数。然后这些成分函数可以通过使用相同的参数进行调用。两者的主要区别就在于，sequential()需要一个单个的函数列表作为参数，而also()接受的是一系列的多个参数。在多数情况下，对于函数的副作用而已这些会很有用，只是sequential()可以让你随意选择将哪个函数的返回值作为组合起来后的新函数的返回值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt; 顺序调用一系列函数(使用相同的参数)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def a(x):
...     print x,
...     return &quot;a&quot;
...
&amp;gt;&amp;gt;&amp;gt; def b(x):
...     print x*2,
...     return &quot;b&quot;
...
&amp;gt;&amp;gt;&amp;gt; def c(x):
...     print x*3,
...     return &quot;c&quot;
...
&amp;gt;&amp;gt;&amp;gt; r = also(a,b,c)
&amp;gt;&amp;gt;&amp;gt; r
&amp;lt;functional.sequential instance at 0xb86ac&amp;gt;
&amp;gt;&amp;gt;&amp;gt; r(5)
5 10 15
'a'
&amp;gt;&amp;gt;&amp;gt; sequential([a,b,c],main=c)('x')
x xx xxx
'c'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;isjoin()和conjoin()这两个函数同equential()和also()在创建新函数并对参数进行多个成分函数的调用方面非常相似。只是disjoin()函数用来查询成分函数中是否有一个函数的返回值（针对给定的参数）为真；conjoin()函数用来查询是否所有的成分函数的返回值都为真。在这些函数中只要条件允许就会使用逻辑短路，因此disjoin()函数可能不会出现某些副作用。joinfuncs()i同also()类似，但它返回的是由所有成分函数的返回值组成的一个元组（tuple），而不是选中的某个主函数。&lt;/p&gt;

&lt;p&gt;前文所述的几个函数让你可以使用相同的参数对一系列函数进行调用，而any()、all()和none_of()这三个让你可以使用一个参数列表对同一个函数进行多次调用。在大的结构方面，这些函数同内置的map()、reduce()和filter()有点象。但funtional模块中的这三个高阶函数中都是对一组返回值进行布尔（boolean）运算得到其返回值的。例如：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt; 对一系列返回值的真、假情况进行判断&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from functional import *
&amp;gt;&amp;gt;&amp;gt; isEven = lambda n: (n%2 == 0)
&amp;gt;&amp;gt;&amp;gt; any([1,3,5,8], isEven)
1
&amp;gt;&amp;gt;&amp;gt; any([1,3,5,7], isEven)
0
&amp;gt;&amp;gt;&amp;gt; none_of([1,3,5,7], isEven)
1
&amp;gt;&amp;gt;&amp;gt; all([2,4,6,8], isEven)
1
&amp;gt;&amp;gt;&amp;gt; all([2,4,6,7], isEven)
0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有点数学基础的人会对这个高阶函数非常感兴趣：iscompose().将多个函数进行合成（compostion）指的是，将一个函数的返回值同下个函数的输入“链接到一起”。对多个函数进行合成的程序员需要负责保证函数间的输入和输出是相互匹配的，不过这个条件无论是程序员在何时想使用返回值时都是需要满足的。举个简单的例子和阐明这一点：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt; 创建合成函数&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def minus7(n): return n-7
...
&amp;gt;&amp;gt;&amp;gt; def times3(n): return n*3
...
&amp;gt;&amp;gt;&amp;gt; minus7(10)
3
&amp;gt;&amp;gt;&amp;gt; minustimes = compose(times3,minus7)
&amp;gt;&amp;gt;&amp;gt; minustimes(10)
9
&amp;gt;&amp;gt;&amp;gt; times3(minus7(10))
9
&amp;gt;&amp;gt;&amp;gt; timesminus = compose(minus7,times3)
&amp;gt;&amp;gt;&amp;gt; timesminus(10)
23
&amp;gt;&amp;gt;&amp;gt; minus7(times3(10))
23
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;后会有期&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;衷心希望我对高阶函数的思考能够引起读者的兴趣。无论如何，请动手试一试。试着编写一些你自己的高阶函数；一些可能很有用，很强大。告诉我它如何运行；或许这个系列之后的章节会讨论读者不断提供的新观点，新想法。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/archives/2013/03/04/python-functional-programming-part1.html&quot; title=&quot;Python中函数式编程，第一部分&quot;&gt;Python中的函数式编程，第一部分&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/archives/2013/04/11/python-functional-programming-part2.html&quot; title=&quot;Python中函数式编程，第二部分&quot;&gt;Python中的函数式编程，第二部分&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/archives/2013/04/25/python-functional-programming-part3.html&quot; title=&quot;Python中的函数式编程，第三部分&quot;&gt;Python中的函数式编程，第三部分&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Nginx模块fastcgi_cache的几个注意点</title>
   <link href="http://beango.github.com/archives/2013/04/23/several-reminder-in-nginx-fastcgi-cache-session-cache-limiter.html"/>
   <updated>2013-04-23T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/04/23/several-reminder-in-nginx-fastcgi-cache-session-cache-limiter</id>
   <content type="html">&lt;p&gt;　　在web项目中，大家都已经非常熟悉其架构流程了。都说Cache是万金油，哪里不舒服抹哪里。这些流程中，几乎每个环节都会进行cache。从&lt;a href=&quot;http://blog.jobbole.com/12749/&quot; title=&quot;浏览器&quot;&gt;浏览器&lt;/a&gt;到webserver，到cgi程序，到DB数据库，会进行浏览器cache，数据cache，SQL查询的cache等等。对于fastcgi这里的cache，很少被使用。去年年底，我对nginx的&lt;a href=&quot;http://wiki.nginx.org/HttpFastcgiModule&quot; title=&quot;Fastcgi_cache的WIKI&quot;&gt;fastcgi_cache&lt;/a&gt;进行摸索使用。在我的测试过程中，发现一些wiki以及网络上没被提到的注意点，这里分享一下。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-04browser-nginx-php-db.png&quot; title=&quot;Nginx模块fastcgi_cache的几个注意点&quot;&gt;&lt;img src=&quot;/assets/files/2013-04/browser-nginx-php-db-300x168.png&quot; alt=&quot;从浏览器到数据库的流程图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　从浏览器到数据库的流程图&lt;/p&gt;

&lt;p&gt;　　这里是我的NGinx配置信息&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  #增加调试信息&lt;br/&gt;
  add_header X-Cache-CFC &quot;$upstream_cache_status - $upstream_response_time&quot;;&lt;br/&gt;
  fastcgi_temp_path /dev/shm/nginx_tmp;&lt;/p&gt;

&lt;p&gt;  #cache设置&lt;br/&gt;
  fastcgi_cache_path   /dev/shm/nginx_cache  levels=1:2 keys_zone=cfcache:10m inactive=50m;&lt;br/&gt;
  fastcgi_cache_key &quot;$request_method://$host$request_uri&quot;;&lt;br/&gt;
  fastcgi_cache_methods GET HEAD;&lt;br/&gt;
  fastcgi_cache   cfcache;&lt;br/&gt;
  fastcgi_cache_valid   any 1d;&lt;br/&gt;
  fastcgi_cache_min_uses  1;&lt;br/&gt;
  fastcgi_cache_use_stale error  timeout invalid_header http_500;&lt;br/&gt;
  fastcgi_ignore_client_abort on;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　配置这些参数时，注意每个参数的作用域，像fastcgi_cache_path参数，只能在http配置项里配置，而fastcgi_cache_min_uses这个参数，可以在http、server、location三个配置项里配置。这样更灵活的会每个域名、每个匹配的location进行选择性cache了。具体的参数作用域，参考&lt;a href=&quot;http://wiki.nginx.org/HttpFastcgiModule&quot; title=&quot;Nginx HttpFastcgiModule模块wiki&quot;&gt;FASTCGI模块的官方WIKI&lt;/a&gt;。我为了调试方便，添加了一个『X-Cache-CFC』的http响应头，&lt;a href=&quot;http://wiki.nginx.org/HttpUpstreamModule&quot; title=&quot;Nginx HttpUpstreamModule模块的WIKI&quot;&gt;$upstream_cache_status &lt;/a&gt;变量表示此请求响应来自cache的状态，分别为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MISS 未命中&lt;/li&gt;
&lt;li&gt;EXPIRED – expired, request was passed to backend Cache已过期&lt;/li&gt;
&lt;li&gt;UPDATING – expired, stale response was used due to proxy/fastcgi_cache_use_stale updating Cache已过期，(被其他nginx子进程)更新中&lt;/li&gt;
&lt;li&gt;STALE – expired, stale response was used due to proxy/fastcgi_cache_use_stale Cache已过期，响应数据不合法，被污染&lt;/li&gt;
&lt;li&gt;HIT 命中cache&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;/assets/files/2013-04/fastcgi_cache_miss_session_start.png&quot; title=&quot;Nginx模块fastcgi_cache的几个注意点&quot;&gt;&lt;img src=&quot;/assets/files/2013-04/fastcgi_cache_miss_session_start-300x128.png&quot; alt=&quot;FASTCGI_CACHE $upstream_cache_status 结果为miss，一次也没命中&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;FASTCGI_CACHE $upstream_cache_status 结果为miss，一次也没命中&lt;/p&gt;

&lt;p&gt;　　程序代码是Discuz!论坛，随便开启测试了几下，发现/dev/shm/nginx_cache/下没有任何目录建立，也没有文件创建。调试的http header响应头里的X-Cache-CFC 结果一直是MISS。从服务器进程上来看，Nginx cache manager process 跟Nginx cache loader process 进程也正常运行：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  root      3100     1  0 14:52 ?        00:00:00 nginx: master process /usr/sbin/nginx&lt;br/&gt;
  www-data  3101  3100  0 14:52 ?        00:00:00 nginx: worker process&lt;br/&gt;
  www-data  3102  3100  0 14:52 ?        00:00:00 nginx: cache manager process&lt;br/&gt;
  www-data  3103  3100  0 14:52 ?        00:00:00 nginx: cache loader process&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　不知道为何会这样，为何没有cache成功，我以为我配置参数有问题，只好阅读WIKI。发现fastcgi_ignore_headers参数下解释有这么一段&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  fastcgi_ignore_headers&lt;br/&gt;
  Syntax: fastcgi_ignore_headers field …&lt;br/&gt;
  Default:&lt;br/&gt;
  Context: http&lt;br/&gt;
  server&lt;br/&gt;
  location&lt;br/&gt;
  Reference: fastcgi_ignore_headers&lt;/p&gt;

&lt;p&gt;  This directive forbids processing of the named headers from the&lt;br/&gt;
  FastCGI-server reply. It is possible to specify headers like&lt;br/&gt;
  “X-Accel-Redirect”, “X-Accel-Expires”, “Expires” or “Cache-Control”.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　也就是说这个参数的值，将会被忽略掉，同样被忽略掉的响应头比如”X-Accel-Redirect”,“X-Accel-Expires”, “Expires” or “Cache-Control”，而nginx配置中并没有fastcgi_ignore_headers参数的设定，那么问题会不会出现在FASTCGI响应结果里包含了类似”X-Accel-Redirect”,“X-Accel-Expires”, “Expires” or “Cache-Control”这几个响应头呢？用strace抓包，看了下nginx与fpm进程通讯的数据&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  ####为了确保准确抓到处理该http请求的进程，我把nginx 、fpm都只开启了一个进程处理。&lt;br/&gt;
  //strace -ff -tt -s 1000 -o xxx.log -p PHPFPM-PID&lt;br/&gt;
  14:52:07.837334 write(3, &quot;\1\6\0\1\0\343\5\0X-Powered-By: PHP/5.3.10-1ubuntu3.5\r\nExpires: Thu, 19 Nov 1981 08:52:00 GMT\r\nCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\r\nPragma: no-cache\r\nContent-type: text/html\r\n\r\nHello cfc4n1362034327\0\0\0\0\0\1\3\0\1\0\10\0\0\0\0\0\0\0\0\0\0&quot;, 256) = 256&lt;/p&gt;

&lt;p&gt;  //strace -ff -tt -s 1000 -o xxx.log -p Nginx-PID&lt;br/&gt;
  15:05:13.265663 recvfrom(12, &quot;\1\6\0\1\0\343\5\0X-Powered-By: PHP/5.3.10-1ubuntu3.5\r\nExpires: Thu, 19 Nov 1981 08:52:00 GMT\r\nCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\r\nPragma: no-cache\r\nContent-type: text/html\r\n\r\nHello cfc4n1362035113\0\0\0\0\0\1\3\0\1\0\10\0\0\0\0\0\0\0\0\0\0&quot;, 4023, 0, NULL, NULL) = 256&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　从抓取的数据包里可以看到，fpm确实返回了包含“Expires”、“Cache-Control”头的http响应头信息。那么疑问来了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;nginx的fastcgi_cache没缓存这条http响应，是因为响应头里包含“Expires”、“Cache-Control”的原因吗？&lt;/li&gt;
&lt;li&gt;程序里并没有输出“Expires”、“Cache-Control” http header的代码，这是谁输出的呢？&lt;/li&gt;
&lt;li&gt;既然是fpm响应的时候，就已经有了，那么是php的core模块，还是其他拓展模块输出的？&lt;/li&gt;
&lt;li&gt;“Expires:”时间为何是“&lt;strong&gt;Thu, 19 Nov 1981 08:52:00 GMT&lt;/strong&gt;”?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　疑问比较多，一个一个查起，先从Nginx的fastcgi_cache没缓存这条http响应查起。我根据测试环境nginx版本1.1.9(ubuntu 12.04默认的)，到nginx官方下了对应版本的源码，搜索了fastcgi参数使用的地方，在httpngx_http_upstream.c找到了。虽然不能很流程的读懂nginx的代码，但粗略的了解，根据了解的情况加以猜测，再动手测试实验，也得出了结论，确定了nginx的fastcgi_cache的规则。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//ngx_http_upstream.c
//line 3136  当fastcgi响应包含set-cookie时，不缓存
static ngx_int_t
ngx_http_upstream_process_set_cookie(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
#if (NGX_HTTP_CACHE)
    ngx_http_upstream_t  *u;

    u = r-&amp;gt;upstream;

    if (!(u-&amp;gt;conf-&amp;gt;ignore_headers &amp;amp; NGX_HTTP_UPSTREAM_IGN_SET_COOKIE)) {
        u-&amp;gt;cacheable = 0;
    }
#endif

    return NGX_OK;
}

//line 3242 当响应头包含Expires时，如果过期时间大于当前服务器时间，则nginx_cache会缓存该响应，否则，则不缓存
static ngx_int_t
ngx_http_upstream_process_expires(ngx_http_request_t *r, ngx_table_elt_t *h,
    ngx_uint_t offset)
{
    ngx_http_upstream_t  *u;

    u = r-&amp;gt;upstream;
    u-&amp;gt;headers_in.expires = h;

#if (NGX_HTTP_CACHE)
    {
    time_t  expires;

    if (u-&amp;gt;conf-&amp;gt;ignore_headers &amp;amp; NGX_HTTP_UPSTREAM_IGN_EXPIRES) {
        return NGX_OK;
    }

    if (r-&amp;gt;cache == NULL) {
        return NGX_OK;
    }

    if (r-&amp;gt;cache-&amp;gt;valid_sec != 0) {
        return NGX_OK;
    }

    expires = ngx_http_parse_time(h-&amp;gt;value.data, h-&amp;gt;value.len);

    if (expires == NGX_ERROR || expires &amp;lt; ngx_time()) {         u-&amp;gt;cacheable = 0;
        return NGX_OK;
    }

    r-&amp;gt;cache-&amp;gt;valid_sec = expires;
    }
#endif

    return NGX_OK;
}

//line 3199  当响应头包含Cache-Control时，#####如果####这里有如果啊。。。
//【注意】如果Cache-Control参数值为no-cache、no-store、private中任意一个时，则不缓存...不缓存...
//【注意】如果Cache-Control参数值为max-age时，会被缓存，且nginx设置的cache的过期时间，就是系统当前时间 + mag-age的值
    if (ngx_strlcasestrn(p, last, (u_char *) &quot;no-cache&quot;, 8 - 1) != NULL
        || ngx_strlcasestrn(p, last, (u_char *) &quot;no-store&quot;, 8 - 1) != NULL
        || ngx_strlcasestrn(p, last, (u_char *) &quot;private&quot;, 7 - 1) != NULL)
    {
        u-&amp;gt;cacheable = 0;
        return NGX_OK;
    }

    p = ngx_strlcasestrn(p, last, (u_char *) &quot;max-age=&quot;, 8 - 1);

    if (p == NULL) {
        return NGX_OK;
    }
    ...
    r-&amp;gt;cache-&amp;gt;valid_sec = ngx_time() + n;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　也就是说，fastcgi响应http请求的结果中，响应头包括Expires、Cache-Control、Set-Cookie三个，都会可能不被cache，但不只有这些，别忘了nginx配置中fastcgi_ignore_headers参数设定的部分。以及ngxin的&lt;a href=&quot;http://wiki.nginx.org/X-accel&quot; title=&quot;X-Accel-Redirect、X-Accel-Expires等nginx自定义的响应头&quot;&gt;X-ACCEL&lt;/a&gt; X-Accel-Redirect、X-Accel-Expires、X-Accel-Charset、X-Accel-Buffering等nginx自定义的响应头。由于这几个不常用，我也没深入研究。通过对nginx的ngx_http_upstream模块代码模糊理解，加猜测，以及写了脚本测试验证，可以得到结论是正确的。即Nginx fastcgi_cache在缓存后端fastcgi响应时，当响应里包含“set-cookie”时，不缓存;当响应头包含Expires时，如果过期时间大于当前服务器时间，则nginx_cache会缓存该响应，否则，则不缓存;当响应头包含Cache-Control时，如果Cache-Control参数值为no-cache、no-store、private中任意一个时，则不缓存，如果Cache-Control参数值为max-age时，会被缓存，且nginx设置的cache的过期时间，就是系统当前时间 + mag-age的值。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnxct.com/wp-content/uploads/2013/02/fastcgi_cache_expired.png&quot; title=&quot;Nginx模块fastcgi_cache的几个注意点&quot;&gt;&lt;img src=&quot;http://www.cnxct.com/wp-content/uploads/2013/02/fastcgi_cache_expired-300x110.png&quot; alt=&quot;nginx fastcgi_cache响应expired&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;nginx fastcgi_cache 响应expired&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnxct.com/wp-content/uploads/2013/02/fastcgi_cache_hit.png&quot; title=&quot;Nginx模块fastcgi_cache的几个注意点&quot;&gt;&lt;img src=&quot;http://www.cnxct.com/wp-content/uploads/2013/02/fastcgi_cache_hit-300x127.png&quot; alt=&quot;nginx fastcgi_cache hit命中&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;nginx fastcgi_cache hit命中&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnxct.com/wp-content/uploads/2013/02/fastcgi_cache_miss.png&quot; title=&quot;Nginx模块fastcgi_cache的几个注意点&quot;&gt;&lt;img src=&quot;http://www.cnxct.com/wp-content/uploads/2013/02/fastcgi_cache_miss-300x141.png&quot; alt=&quot;FASTCGI_CACHE $upstream_cache_status结果为miss，一次也没命中。&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;FASTCGI_CACHE $upstream_cache_status 结果为miss，一次也没命中。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  //逐个测试，测试时，注释其他的&lt;br/&gt;
  header(&quot;Expires: &quot;.gmdate(&quot;D, d M Y H:i:s&quot;, time()+10000).' GMT');&lt;br/&gt;
  header(&quot;Expires: &quot;.gmdate(&quot;D, d M Y H:i:s&quot;, time()-99999).' GMT');&lt;br/&gt;
  header(&quot;X-Accel-Expires:30&quot;);&lt;br/&gt;
  header(&quot;Cache-Control: no-cache&quot;);&lt;br/&gt;
  header(&quot;Cache-Control: no-store&quot;);&lt;br/&gt;
  header(&quot;Cache-Control: private&quot;);&lt;br/&gt;
  header(&quot;Cache-Control: max-age=10&quot;);&lt;br/&gt;
  setcookie('cfc4n',&quot;testaaaa&quot;);&lt;br/&gt;
  echo 'Hello cfc4n',time();&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　到了这里，疑问1解决了。那么疑问2、3呢？程序里并没有输出“Expires”、“Cache-Control” http header的代码，这是谁输出的呢？既然是fpm响应的时候，就已经有了，那么是php的core模块，还是其他拓展模块输出的？我精简了代码，只输出一个“hello world”，发现也确实被缓存了。显然，php脚本程序中并没输出http header的“Expires”、“Cache-Control”，多次测试，最终定位到session_start函数，翻阅源码找到了这些代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//ext/session/session.c  line:1190 左右
// ...
CACHE_LIMITER_FUNC(private) /* { { { */
{
    ADD_HEADER(&quot;Expires: Thu, 19 Nov 1981 08:52:00 GMT&quot;);
    CACHE_LIMITER(private_no_expire)(TSRMLS_C);
}
/* } } } */
//再到这里3 或者上面几个 ##默认是nocache
CACHE_LIMITER_FUNC(nocache) /* { { { */
{
    ADD_HEADER(&quot;Expires: Thu, 19 Nov 1981 08:52:00 GMT&quot;);

    /* For HTTP/1.1 conforming clients and the rest (MSIE 5) */
    ADD_HEADER(&quot;Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0&quot;);

    /* For HTTP/1.0 conforming clients */
    ADD_HEADER(&quot;Pragma: no-cache&quot;);
}
/* } } } */
//这里2
static php_session_cache_limiter_t php_session_cache_limiters[] = {
    CACHE_LIMITER_ENTRY(public)
    CACHE_LIMITER_ENTRY(private)
    CACHE_LIMITER_ENTRY(private_no_expire)
    CACHE_LIMITER_ENTRY(nocache)
    {0}
};

static int php_session_cache_limiter(TSRMLS_D) /* { { { */
{
    php_session_cache_limiter_t *lim;

    if (PS(cache_limiter)[0] == '\0') return 0;

    if (SG(headers_sent)) {
        const char *output_start_filename = php_output_get_start_filename(TSRMLS_C);
        int output_start_lineno = php_output_get_start_lineno(TSRMLS_C);

        if (output_start_filename) {
            php_error_docref(NULL TSRMLS_CC, E_WARNING, &quot;Cannot send session cache limiter - headers already sent (output started at %s:%d)&quot;, output_start_filename, output_start_lineno);
        } else {
            php_error_docref(NULL TSRMLS_CC, E_WARNING, &quot;Cannot send session cache limiter - headers already sent&quot;);
        }
        return -2;
    }

    for (lim = php_session_cache_limiters; lim-&amp;gt;name; lim++) {
        if (!strcasecmp(lim-&amp;gt;name, PS(cache_limiter))) {
            lim-&amp;gt;func(TSRMLS_C);   //这里1
            return 0;
        }
    }

    return -1;
}
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　到了这里，知道原因了，是程序调用session_start时，php的session拓展自己输出的。session.cache_limit参数来决定输出包含哪种Expires的header，默认是nocache，修改php.ini的session.cache_limit参数为“none”即可让session模块不再输出这些http响应头。或在调用session_start之前，使用session_cache_limiter函数来指定下该参数值。那为什么要在使用session时，发Expires、Cache-Control的http response header呢？我猜测了下，需要session时，基本上是用户跟服务器有交互，那么，既然有交互，就意味着用户的每次交互结果也可能不一样，就不能cache这个请求的结果，给返回给这个用户。同时，每个用户的交互结果都是不一样的，nginx也就不能把包含特殊Cache-Control的个人响应cache给其他人提供了。&lt;/p&gt;

&lt;p&gt;　　还有一个无聊的问题&lt;strong&gt;“Expires:时间为何是Thu, 19 Nov 1981 08:52:00 GMT”&lt;/strong&gt;？我翻阅了session.c这段代码的添加时间，版本，作者信息，在php官方版本库中找到了&lt;a href=&quot;http://svn.php.net/viewvc/php/php-src/trunk/ext/session/session.c?view=log&amp;amp;log_pagestart=400&quot;&gt;这次提交的信息&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  Revision 17092 – (view) (download) (as text) (annotate) – [select for diffs]&lt;br/&gt;
  Modified Sun Dec 12 14:16:55 1999 UTC (13 years, 2 months ago) by sas&lt;br/&gt;
  File length: 28327 byte(s)&lt;br/&gt;
  Diff to previous 16964&lt;br/&gt;
  Add cache_limiter and cache_expire options. Rename extern_referer_check&lt;br/&gt;
  to referer_check.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　对比&lt;a href=&quot;http://svn.php.net/viewvc/php/php-src/trunk/ext/session/session.c?r1=16964&amp;amp;r2=17092&quot; title=&quot;session.c增加session.cache_limiter参数&quot;&gt;session.c两个版本&lt;/a&gt;的变更，果然是这块代码。作者是sas，也就是&lt;a href=&quot;http://schumann.cx/&quot;&gt;Sascha Schumann&lt;/a&gt;， &lt;a href=&quot;http://php.net/credits.php&quot; title=&quot;php credits&quot;&gt;http://php.net/credits.php&lt;/a&gt;里可以看到他的大名。关于这个expires过期时间的问题，有人在stackoverflow也提问过，&lt;a href=&quot;http://stackoverflow.com/questions/8194481/why-is-expires-1981&quot; title=&quot;Why is “Expires” 1981?&quot;&gt;Why is “Expires” 1981?&lt;/a&gt;，别人说那天是他生日。这是真的么？如果那天是他生日的话，而他增加session.cache_limiter时是1999年，他才17岁，17岁呀。我17岁时在干嘛？还不知道电脑长啥样，正在玩『超级玛丽』呢。&lt;/p&gt;

&lt;p&gt;　　好奇的不是我一个人，还有个帖子是&lt;a href=&quot;http://bytes.com/topic/php/answers/540207-epoch-date-expires-thu-19-nov-1981-08-52-00-a&quot; title=&quot;epoch date -- Expires: Thu, 19 Nov 1981 08:52:00&quot;&gt;epoch date — Expires: Thu, 19 Nov 1981 08:52:00&lt;/a&gt;也问了。另外两个地址虽然没问，也有人提到那天是他生日了。&lt;a href=&quot;http://boinc.berkeley.edu/dev/forum_thread.php?id=2514&quot;&gt;http://boinc.berkeley.edu/dev/forum_thread.php?id=2514&lt;/a&gt;、&lt;a href=&quot;https://github.com/codeguy/Slim/issues/157&quot;&gt;https://github.com/codeguy/Slim/issues/157&lt;/a&gt;，这些帖子都提到说原帖是http://www.phpbuilder.com/lists/php3-list/199911/3159.php，我无法访问，被跳转到首页了。用http://web.archive.org找到了&lt;a href=&quot;http://web.archive.org/web/20120315000650/http://www.phpbuilder.com/lists/php3-list/199911/3159.php&quot;&gt;历史快照&lt;/a&gt;，发现上下文关系不大，也不能证明是他生日。
　　我更是好奇的发了两封邮件到他的不同邮箱里问他，不过，目前他还没回复。或许他没收到、没看到，或许懒得回了。N年后，&lt;strong&gt;“Expires:时间为何是Thu,19 Nov 1981 08:52:00 GMT”&lt;/strong&gt;这个日期，会不会又成了一段奇闻佳话了呢？&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>全面理解面向对象的 JavaScript</title>
   <link href="http://beango.github.com/archives/2013/04/22/a-comprehensive-understanding-of-object-oriented-javascript.html"/>
   <updated>2013-04-22T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/04/22/a-comprehensive-understanding-of-object-oriented-javascript</id>
   <content type="html">&lt;p&gt;来源：&lt;a href=&quot;http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/index.html&quot;&gt;DeveloperWorks – 曾滢著&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;　　JavaScript 函数式脚本语言特性以及其看似随意的编写风格，导致长期以来人们对这一门语言的误解，即认为JavaScript不是一门面向对象的语言，或者只是部分具备一些面向对象的特征。本文将回归面向对象本意，从对语言感悟的角度阐述为什么 JavaScript 是一门彻底的面向对象的语言，以及如何正确地使用这一特性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　当今 JavaScript 大行其道，各种应用对其依赖日深。web&lt;a href=&quot;http://blog.jobbole.com/821/&quot; title=&quot;程序员的本质&quot;&gt;程序员&lt;/a&gt;已逐渐习惯使用各种优秀的 JavaScript 框架快速开发 Web 应用，从而忽略了对原生 JavaScript 的学习和深入理解。所以，经常出现的情况是，很多做了多年 JS 开发的程序员对闭包、函数式编程、原型总是说不清道不明，即使使用了框架，其代码组织也非常糟糕。这都是对原生 JavaScript 语言特性理解不够的表现。要掌握好JavaScript，首先一点是必须摒弃一些其他高级语言如 Java、C#等类式面向对象思维的干扰，全面地从函数式语言的角度理解 JavaScript 原型式面向对象的特点。把握好这一点之后，才有可能进一步使用好这门语言。本文适合群体：使用过 JS 框架但对 JS 语言本质缺乏理解的程序员，具有 Java、C++等语言开发经验，准备学习并使用 JavaScript 的程序员，以及一直对 JavaScript 是否面向对象模棱两可，但希望知道真相的 JS 爱好者。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重新认识面向对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　为了说明 JavaScript 是一门彻底的面向对象的语言，首先有必要从面向对象的概念着手 ,探讨一下面向对象中的几个概念：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一切事物皆对象&lt;/li&gt;
&lt;li&gt;对象具有封装和继承特性&lt;/li&gt;
&lt;li&gt;对象与对象之间使用消息通信，各自存在信息隐藏&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　以这三点做为依据，C++是半面向对象半面向过程语言，因为，虽然他实现了类的封装、继承和多态，但存在非对象性质的全局函数和变量。Java、C#是完全的面向对象语言，它们通过类的形式组织函数和变量，使之不能脱离对象存在。但这里函数本身是一个过程，只是依附在某个类上。&lt;/p&gt;

&lt;p&gt;　　然而，面向对象仅仅是一个概念或者编程思想而已，它不应该依赖于某个语言存在。比如Java采用面向对象思想构造其语言，它实现了类、继承、派生、多态、接口等机制。但是这些机制，只是实现面向对象编程的一种手段，而非必须。换言之，一门语言可以根据其自身特性选择合适的方式来实现面向对象。所以，由于大多数程序员首先学习或者使用的是类似Java、C++ 等高级编译型语言（Java虽然是半编译半解释，但一般做为编译型来讲解），因而先入为主地接受了“类”这个面向对象实现方式，从而在学习脚本语言的时候，习惯性地用类式面向对象语言中的概念来判断该语言是否是面向对象语言，或者是否具备面向对象特性。这也是阻碍程序员深入学习并掌握JavaScript 的重要原因之一。&lt;/p&gt;

&lt;p&gt;　　实际上，JavaScript语言是通过一种叫做 &lt;strong&gt;原型（&lt;/strong&gt;&lt;strong&gt;prototype&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;的方式来实现面向对象编程的。下面就来讨论 &lt;strong&gt;基于类的（&lt;/strong&gt;&lt;strong&gt;class-based&lt;/strong&gt;&lt;strong&gt;）面向对象&lt;/strong&gt;和 &lt;strong&gt;基于原型的(&lt;/strong&gt;&lt;strong&gt;prototype-based&lt;/strong&gt;&lt;strong&gt;)面向对象&lt;/strong&gt;这两种方式在构造客观世界的方式上的差别。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基于类的面向对象和基于原型的面向对象方式比较&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在基于类的面向对象方式中，&lt;strong&gt;对象（&lt;/strong&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;依靠 &lt;strong&gt;类（&lt;/strong&gt;&lt;strong&gt;class&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;来产生。而在基于原型的面向对象方式中，&lt;strong&gt;对象（&lt;/strong&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;则是依靠 &lt;strong&gt;构造器（&lt;/strong&gt;&lt;strong&gt;constructor&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;利用 &lt;strong&gt;原型（&lt;/strong&gt;&lt;strong&gt;prototype&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;构造出来的。举个客观世界的例子来说明二种方式认知的差异。例如工厂造一辆车，一方面，工人必须参照一张工程图纸，设计规定这辆车应该如何制造。这里的工程图纸就好比是语言中的 &lt;strong&gt;类(&lt;/strong&gt;&lt;strong&gt;class&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;，而车就是按照这个 &lt;strong&gt;类（&lt;/strong&gt;&lt;strong&gt;class&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;制造出来的；另一方面，工人和机器( 相当于 constructor) 利用各种零部件如发动机，轮胎，方向盘 ( 相当于 prototype 的各个属性 ) 将汽车构造出来。&lt;/p&gt;

&lt;p&gt;　　事实上关于这两种方式谁更为彻底地表达了面向对象的思想，目前尚有争论。但笔者认为原型式面向对象是一种更为彻底的面向对象方式，理由如下：&lt;/p&gt;

&lt;p&gt;　　首先，客观世界中的对象的产生都是其它实物对象构造的结果，而抽象的“图纸”是不能产生“汽车”的，也就是说，类是一个抽象概念而并非实体，而对象的产生是一个实体的产生；&lt;/p&gt;

&lt;p&gt;　　其次，按照一切事物皆对象这个最基本的面向对象的法则来看，类 (class) 本身并不是一个对象，然而原型方式中的构造器 (constructor) 和原型 (prototype) 本身也是其他对象通过原型方式构造出来的对象。&lt;/p&gt;

&lt;p&gt;　　再次，在类式面向对象语言中，对象的状态 (state) 由对象实例 (instance) 所持有，对象的行为方法 (method) 则由声明该对象的类所持有，并且只有对象的结构和方法能够被继承；而在原型式面向对象语言中，对象的行为、状态都属于对象本身，并且能够一起被继承，这也更贴近客观实际。&lt;/p&gt;

&lt;p&gt;　　最后，类式面向对象语言比如Java，为了弥补无法使用面向过程语言中全局函数和变量的不便，允许在类中声明静态(static)属性和静态方法。而实际上，客观世界不存在所谓静态概念，因为一切事物皆对象！而在原型式面向对象语言中，除内建对象(build-in object)外，不允许全局对象、方法或者属性的存在，也没有静态概念。所有语言元素(primitive)必须依赖对象存在。但由于函数式语言的特点，语言元素所依赖的对象是随着运行时(runtime) 上下文 (context) 变化而变化的，具体体现在 this指针的变化。正是这种特点更贴近“万物皆有所属，宇宙乃万物生存之根本”的自然观点。在 程序清单1中 &lt;strong&gt;window&lt;/strong&gt; 便类似与宇宙的概念。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 1. 对象的上下文依赖&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt; 
 var str = &quot;我是一个 String 对象 , 我声明在这里 , 但我不是独立存在的！&quot;
 var obj = { des: &quot;我是一个 Object 对象 , 我声明在这里，我也不是独立存在的。&quot; }; 
 var fun = function() { 
    console.log( &quot;我是一个 Function 对象！谁调用我，我属于谁：&quot;, this ); 
 }; 

 obj.fun = fun; 

 console.log( this === window );     // 打印 true 
 console.log( window.str === str );  // 打印 true 
 console.log( window.obj === obj );  // 打印 true 
 console.log( window.fun === fun );  // 打印 true 
 fun();                              // 打印 我是一个 Function 对象！谁调用我，我属于谁：window 
 obj.fun();                          // 打印 我是一个 Function 对象！谁调用我，我属于谁：obj 
 fun.apply(str);                   // 打印 我是一个 Function 对象！谁调用我，我属于谁：str 
 &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　在接受了面向对象存在一种叫做基于原型实现的方式的事实之后，下面我们就可以来深入探讨 ECMAScript 是如何依据这一方式构造自己的语言的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最基本的面向对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;em&gt;ECMAScript&lt;/em&gt; 是一门彻底的面向对象的&lt;a href=&quot;http://blog.jobbole.com/tag/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/&quot; title=&quot;如何选择语言和编程语言排名相关文章&quot;&gt;编程语言&lt;/a&gt;（参考资源），JavaScript 是其中的一个变种 (variant)。它提供了 6 种基本数据类型，即Boolean、Number、String、Null、Undefined、Object。为了实现面向对象，&lt;em&gt;ECMAScript&lt;/em&gt;设计出了一种非常成功的数据结构 – JSON(JavaScript Object Notation),这一经典结构已经可以脱离语言而成为一种广泛应用的数据交互格式（参考资源）。&lt;/p&gt;

&lt;p&gt;　　应该说，具有基本数据类型和 JSON 构造语法的 ECMAScript已经基本可以实现面向对象的编程了。开发者可以随意地用 &lt;strong&gt;字面式声明（&lt;/strong&gt;&lt;strong&gt;literal notation&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;方式来构造一个对象，并对其不存在的属性直接赋值，或者用 delete 将属性删除 ( 注：JS 中的 delete关键字用于删除对象属性，经常被误作为 C++ 中的delete，而后者是用于释放不再使用的对象 )，如 程序清单 2。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 2. 字面式 (literal notation) 对象声明&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var person = { 
    name: “张三”, 
    age: 26, 
    gender: “男”, 
    eat: function( stuff ) { 
        alert( “我在吃” + stuff ); 
    } 
 }; 
 person.height = 176; 
 delete person[ “age” ];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　在实际开发过程中，大部分初学者或者对 JS应用没有太高要求的开发者也基本上只用到 ECMAScript 定义的这一部分内容，就能满足基本的开发需求。然而，这样的代码复用性非常弱，与其他实现了继承、派生、多态等等的类式面向对象的强类型语言比较起来显得有些干瘪，不能满足复杂的 JS 应用开发。所以 ECMAScript 引入原型来解决对象继承问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用函数构造器构造对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　除了 &lt;strong&gt;字面式声明（&lt;/strong&gt;&lt;strong&gt;literal notation&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;方式之外，ECMAScript允许通过 &lt;strong&gt;构造器（constructor）&lt;/strong&gt;创建对象。每个构造器实际上是一个 &lt;strong&gt;函数（&lt;/strong&gt;&lt;strong&gt;function&lt;/strong&gt;&lt;strong&gt;）对象&lt;/strong&gt;,该函数对象含有一个“prototype”属性用于实现 &lt;strong&gt;基于原型的继承&lt;/strong&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;prototype-based inheritance&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;和 &lt;strong&gt;共享属性（&lt;/strong&gt;&lt;strong&gt;shared properties&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;。&lt;/em&gt;&lt;/strong&gt;对象可以由“new 关键字 + 构造器调用”的方式来创建，如 程序清单 3：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 3. 使用构造器 (constructor) 创建对象&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 构造器 Person 本身是一个函数对象
 function Person() { 
     // 此处可做一些初始化工作
 } 
 // 它有一个名叫 prototype 的属性
 Person.prototype = { 
    name: “张三”, 
    age: 26, 
    gender: “男”, 
    eat: function( stuff ) { 
        alert( “我在吃” + stuff ); 
    } 
 } 
 // 使用 new 关键字构造对象
 var p = new Person();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　由于早期 JavaScript 的发明者为了使这门语言与大名鼎鼎的 Java 拉上关系 (虽然现在大家知道二者是雷锋和雷锋塔的关系)，使用了&lt;strong&gt;new&lt;/strong&gt; 关键字来限定构造器调用并创建对象，以使其在语法上跟 Java 创建对象的方式看上去类似。但需要指出的是，这两门语言的&lt;strong&gt;new&lt;/strong&gt;含义毫无关系，因为其对象构造的机理完全不同。也正是因为这里语法上的类似，众多习惯了类式面向对象语言中对象创建方式的程序员，难以透彻理解 JS 对象原型构造的方式，因为他们总是不明白在 JS 语言中，为什么“函数名可以作为类名”的现象。而实质上，JS这里仅仅是借用了关键字 new，仅此而已；换句话说，ECMAScript完全可以用其它 &lt;strong&gt;非&lt;/strong&gt; &lt;strong&gt;new&lt;/strong&gt; 表达式来用调用构造器创建对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;彻底理解原型链 (prototype chain)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在 ECMAScript 中，每个由构造器创建的对象拥有一个指向构造器 prototype 属性值的 &lt;strong&gt;隐式引用（&lt;/strong&gt;&lt;strong&gt;implicit reference&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;，这个引用称之为 &lt;strong&gt;原型（&lt;/strong&gt;&lt;strong&gt;prototype&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;。进一步，每个原型可以拥有指向自己原型的 &lt;strong&gt;隐式引用&lt;/strong&gt;（即该原型的原型），如此下去，这就是所谓的&lt;strong&gt;原型链（&lt;/strong&gt;&lt;strong&gt;prototype chain&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt; （参考资源）。在具体的语言实现中，每个对象都有一个 &lt;strong&gt;__proto__属性&lt;/strong&gt;来实现对原型的 &lt;strong&gt;隐式引用&lt;/strong&gt;。程序清单 4说明了这一点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 4. 对象的 __proto__ 属性和隐式引用&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Person( name ) { 
    this.name = name; 
 } 
 var p = new Person(); 
 // 对象的隐式引用指向了构造器的 prototype 属性，所以此处打印 true 
 console.log( p.__proto__ === Person.prototype ); 

 // 原型本身是一个 Object 对象，所以他的隐式引用指向了
 // Object 构造器的 prototype 属性 , 故而打印 true 
 console.log( Person.prototype.__proto__ === Object.prototype ); 

 // 构造器 Person 本身是一个函数对象，所以此处打印 true 
 console.log( Person.__proto__ === Function.prototype );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　有了 &lt;strong&gt;原型链&lt;/strong&gt;，便可以定义一种所谓的 &lt;strong&gt;属性隐藏机制&lt;/strong&gt;，并通过这种机制实现继承。ECMAScript规定，当要给某个对象的属性赋值时，解释器会查找该对象原型链中第一个含有该属性的对象（注：原型本身就是一个对象，那么原型链即为一组对象的链。对象的原型链中的第一个对象是该对象本身）进行赋值。反之，如果要获取某个对象属性的值，解释器自然是返回该对象原型链中首先具有该属性的对象属性值。图1说名了这中隐藏机制：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 1. 原型链中的属性隐藏机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-04/image001.png&quot; title=&quot;全面理解面向对象的 JavaScript&quot; alt=&quot;全面理解面向对象的JavaScript&quot; /&gt; &lt;/p&gt;

&lt;p&gt;　　在图1 中，object1-&gt;prototype1-&gt;prototype2 构成了 对象 object1的原型链，根据上述属性隐藏机制，可以清楚地看到 prototype1 对象中的property4 属性和 prototype2 对象中的 property3属性皆被隐藏。理解了原型链，那么将非常容易理解 JS中基于原型的继承实现原理，程序清单 5 是利用原型链实现继承的简单例子。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 5. 利用原型链 Horse-&gt;Mammal-&gt;Animal 实现继承&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 声明 Animal 对象构造器
 function Animal() { 
 } 
 // 将 Animal 的 prototype 属性指向一个对象，
 // 亦可直接理解为指定 Animal 对象的原型
 Animal.prototype = { 
    name: &quot;animal&quot;, 
    weight: 0, 
    eat: function() { 
        alert( &quot;Animal is eating!&quot; ); 
    } 
 } 
 // 声明 Mammal 对象构造器
 function Mammal() { 
    this.name = &quot;mammal&quot;; 
 } 
 // 指定 Mammal 对象的原型为一个 Animal 对象。
 // 实际上此处便是在创建 Mammal 对象和 Animal 对象之间的原型链
 Mammal.prototype = new Animal(); 

 // 声明 Horse 对象构造器
 function Horse( height, weight ) { 
    this.name = &quot;horse&quot;; 
    this.height = height; 
    this.weight = weight; 
 } 
 // 将 Horse 对象的原型指定为一个 Mamal 对象，继续构建 Horse 与 Mammal 之间的原型链
 Horse.prototype = new Mammal(); 

 // 重新指定 eat 方法 , 此方法将覆盖从 Animal 原型继承过来的 eat 方法
 Horse.prototype.eat = function() { 
    alert( &quot;Horse is eating grass!&quot; ); 
 } 
 // 验证并理解原型链
 var horse = new Horse( 100, 300 ); 
 console.log( horse.__proto__ === Horse.prototype ); 
 console.log( Horse.prototype.__proto__ === Mammal.prototype ); 
 console.log( Mammal.prototype.__proto__ === Animal.prototype );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　理解清单 5 中对象原型继承逻辑实现的关键在于 Horse.prototype = new Mammal() 和 Mammal.prototype = new Animal()这两句代码。首先，等式右边的结果是构造出一个临时对象，然后将这个对象赋值给等式左边对象的 prototype 属性。也就是说将右边新建的对象作为左边对象的原型。读者可以将这两个等式替换到相应的程序清单5 代码最后两行的等式中自行领悟。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JavaScript 类式继承的实现方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　从代码清单 5可以看出，基于原型的继承方式，虽然实现了代码复用，但其行文松散且不够流畅，可阅读性差，不利于实现扩展和对源代码进行有效地组织管理。不得不承认，类式继承方式在语言实现上更具健壮性，且在构建可复用代码和组织架构程序方面具有明显的优势。这使得程序员们希望寻找到一种能够在JavaScript中以类式继承风格进行编码的方法途径。从抽象的角度来讲，既然类式继承和原型继承都是为实现面向对象而设计的，并且他们各自实现的载体语言在计算能力上是等价的( 因为图灵机的计算能力与 Lambda 演算的计算能力是等价的)，那么能不能找到一种变换，使得原型式继承语言通过该变换实现具有类式继承编码的风格呢？&lt;/p&gt;

&lt;p&gt;　　目前一些主流的 JS 框架都提供了这种转换机制，也即类式声明方法，比如Dojo.declare()、Ext.entend()等等。用户使用这些框架，可以轻易而友好地组织自己的 JS 代码。其实，在众多框架出现之前，JavaScript 大师 &lt;em&gt;Douglas Crockford&lt;/em&gt; 最早利用三个函数对 Function 对象进行扩展，实现了这种变换，关于它的实现细节可以（参考资源）。此外还有由 &lt;em&gt;Dean Edwards&lt;/em&gt;实现的著名的 Base.js（参考资源）。值得一提的是，jQuery 之父 &lt;em&gt;John Resig&lt;/em&gt; 在搏众家之长之后，用不到 30 行代码便实现了自己的 &lt;strong&gt;Simple Inheritance&lt;/strong&gt;。使用其提供的 extend 方法声明类非常简单。程序清单6是使用了 &lt;strong&gt;Simple Inheritance&lt;/strong&gt;库实现类的声明的例子。其中最后一句打印输出语句是对 &lt;strong&gt;Simple Inheritance&lt;/strong&gt;实现类式继承的最好说明。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 6. 使用 Simple Inheritance 实现类式继承&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 声明 Person 类
 var Person = Class.extend( { 
    _issleeping: true, 
    init: function( name ) { 
        this._name = name; 
    }, 
    isSleeping: function() { 
        return this._issleeping; 
    } 
 } ); 
 // 声明 Programmer 类，并继承 Person 
 var Programmer = Person.extend( { 
    init: function( name, issleeping ) { 
        // 调用父类构造函数
        this._super( name ); 
        // 设置自己的状态
        this._issleeping = issleeping; 
    } 
 } ); 
 var person = new Person( &quot;张三&quot; ); 
 var diors = new Programmer( &quot;张江男&quot;, false ); 
 // 打印 true 
 console.log( person.isSleeping() ); 
 // 打印 false 
 console.log( diors.isSleeping() ); 
 // 此处全为 true，故打印 true 
 console.log( person instanceof Person &amp;amp;&amp;amp; person instanceof Class 
    &amp;amp;&amp;amp; diors instanceof Programmer &amp;amp;&amp;amp; 
    diors instanceof Person &amp;amp;&amp;amp; diors instanceof Class );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　如果您已对原型、函数构造器、闭包和基于上下文的 this 有了充分的理解，那么理解 Simple Inheritance 的实现原理也并非相当困难。从本质上讲，&lt;em&gt;var Person = Class.extend(…)&lt;/em&gt;该语句中，左边的 Person 实际上是获得了由 Class 调用 extend 方法返回的一个构造器，也即一个 function 对象的引用。顺着这个思路，我们继续介绍 Simple Inheritance 是如何做到这一点，进而实现了由原型继承方式到类式继承方式的转换的。图 2 是 Simple Inheritance 的源码及其附带注释。为了方便理解，用中文对代码逐行补充说明。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 2.Simple Inheritance 源码解析&lt;/strong&gt; &lt;img src=&quot;/assets/files/2013-04/image003.png&quot; title=&quot;全面理解面向对象的 JavaScript&quot; alt=&quot;全面理解面向对象的JavaScript&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　抛开代码第二部分，整体连贯地考察第一和第三部分会发现，extend 函数的根本目的就是要构造一个具有新原型属性的新构造器。我们不禁感叹 &lt;em&gt;John Resig&lt;/em&gt;的大师手笔及其对 JS 语言本质把握的细腻程度。至于 &lt;em&gt;John Resig&lt;/em&gt;是如何想到这样精妙的实现方法，感兴趣的读者可以阅读本文（参考资源），其中有详细介绍关于最初设计 Simple Inheritance 的思维过程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JavaScript 私有成员实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　到此为止，如果您任然对 JavaScript 面向对象持怀疑态度，那么这个怀疑一定是，JavaScript 没有实现面向对象中的信息隐藏，即私有和公有。与其他类式面向对象那样显式地声明私有公有成员的方式不同，JavaScript的信息隐藏就是靠闭包实现的。见 程序清单 7:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 7. 使用闭包实现信息隐藏&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 声明 User 构造器
 function User( pwd ) { 
    // 定义私有属性
    var password = pwd; 
    // 定义私有方法 
    function getPassword() { 
        // 返回了闭包中的 password 
        return password; 
    } 
    // 特权函数声明，用于该对象其他公有方法能通过该特权方法访问到私有成员
    this.passwordService = function() { 
        return getPassword(); 
    } 
 } 
 // 公有成员声明
 User.prototype.checkPassword = function( pwd ) { 
    return this.passwordService() === pwd; 
 }; 
 // 验证隐藏性
 var u = new User( &quot;123456&quot; ); 
 // 打印 true 
 console.log( u.checkPassword( &quot;123456&quot; ) ); 
 // 打印 undefined 
 console.log( u.password ); 
 // 打印 true 
 console.log( typeof u.gePassword === &quot;undefined&quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　JavaScript必须依赖闭包实现信息隐藏，是由其函数式语言特性所决定的。本文不会对函数式语言和闭包这两个话题展开讨论，正如上文默认您理解 JavaScript 中基于上下文的 this 一样。关于 JavaScript 中实现信息隐藏，&lt;em&gt;Douglas Crockford&lt;/em&gt;在《Private members in JavaScript》（参考资源）一文中有更权威和详细的介绍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结束语&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　JavaScript 被认为是世界上最受误解的编程语言，因为它身披 c 语言家族的外衣，表现的却是 LISP 风格的函数式语言特性；没有类，却实也彻底实现了面向对象。要对这门语言有透彻的理解，就必须扒开其 c 语言的外衣，从新回到函数式编程的角度，同时摒弃原有类的面向对象概念去学习领悟它。随着近些年来 Web 应用的普及和 JS 语言自身的长足发展，特别是后台 JS 引擎的出现 ( 如基于 V8 的 NodeJS 等 )，可以预见，原来只是作为玩具编写页面效果的 JS 将获得更广阔发展天地。这样的发展趋势，也对 JS 程序员提出了更高要求。只有彻底领悟了这门语言，才有可能在大型的 JS 项目中发挥她的威力。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;参考资料&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;学习&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-262.htm&quot;&gt;Standard ECMA-262: ECMAScript
官方标准&lt;/a&gt;，学习它，可以让你全面理解
JavaScript 的本质。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.otimaideia.com.br/material/javascript/pro-javascript-techniques.9781590597279.26383.pdf&quot;&gt;Pro JavaScript: 《精通 JavaScript
》&lt;/a&gt;：jQuery
之父 John Resig
的鼎力之作。他不是一本介绍语法知识及相关入门的书。您可以在书中学习到现代
JavaScript 编程方法。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.json.org/&quot;&gt;Introducing JSON: JSON
官方介绍&lt;/a&gt;：学习它可以理解 JSON 的构造本质。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ejohn.org/blog/simple-javascript-inheritance&quot;&gt;Simple JavaScript
Inheritance&lt;/a&gt;：John
Resig 关于实现的简单 JS
继承的详细介绍，包含源码和思维过程及使用实例。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://javascript.crockford.com/javascript.html&quot;&gt;The World’s Most Misunderstood Programming
Language&lt;/a&gt;：这是 JS
大师 Douglas Crockford 写的一篇关于介绍 JavaScript 语言本质的文章。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dean.edwards.name/weblog/2006/03/base/&quot;&gt;A Base Class for JavaScript
Inheritance&lt;/a&gt;：JS 大师
Dean Edwards 实现的 Base.js。&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>HTTP负载测试</title>
   <link href="http://beango.github.com/archives/2013/04/20/http-benchmark-rules.html"/>
   <updated>2013-04-20T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/04/20/http-benchmark-rules</id>
   <content type="html">&lt;p&gt;英文原文：&lt;a href=&quot;http://www.mnot.net/blog/2011/05/18/http_benchmark_rules&quot;&gt;ON HTTP LOAD TESTING&lt;/a&gt; 来源：&lt;a href=&quot;http://www.oschina.net/translate/http_benchmark_rules&quot;&gt;oschina&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;有很多人在谈论HTTP服务器软件的性能测试，也许是因为现在有太多的服务器选择。&lt;/p&gt;

&lt;p&gt;这很好，但是我看到有人很多基本相同的问题，使得测试结果的推论值得怀疑。在日常工作中花费了很多时间在高性能代理缓存和源站性能测试方面之后，这里有我认为比较重要的一些方面来分享。&lt;/p&gt;

&lt;p&gt;希望能抛砖引玉。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;0. 一致性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最最重要的是，每次都测试同一个时间点。因为系统发生的每个改变，无论是OS升级还是运行了其它消耗带宽和CPU的应用，都会影响测试的结果，所以一定要把测试环境固定下来。&lt;/p&gt;

&lt;p&gt;也许，有人会说那就把测试放虚拟机里做吧，听起来不错。但是，这种方式加多了一个抽象层(而且宿主机上也跑了更多的进程)，如果说这样就能得到更加一致的结果，我是无论如何也不会相信的。我觉得，最好的办法是为测试准备一套专用硬件。如果做不到这个，那么一定要把所有测试放在同一个会话里，不要去比较不同会话里的测试结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 每台机器，各司其职&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;人们常常会犯另一个错误，他们把负载生成器和被测试的服务器放在同一台机器上。这样做将导致产生不可靠的测试结果，因为，负载生成器实际上是「窃取」了一部分资源，而且这部分资源的量还会随着服务器处理负载情况的变化而变化。&lt;/p&gt;

&lt;p&gt;最好的做法是，为测试主体和负载生成器分配不同的硬件，而且将它们放在封闭的网络上。这样做的代价并不是太高，我们并不需要非常高精尖的配置，只需要确保一致性就好。&lt;/p&gt;

&lt;p&gt;所以，如果有人跟你说，他们的测试是在localhost上做的，或者拒绝透露测试用了几台机器，那么你尽可以忽略他们的结果。因为，这样的结果，往好了说，只有最基本的定性作用，往坏了说，甚至可能会误人子弟。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 检查网络&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在测试前，一定要知道你的网络有多大容量，这样，你才会知道，什么时候是你测试的服务器制约了测试，什么时候是网络制约了测试。&lt;/p&gt;

&lt;p&gt;一种方法是通过&lt;a href=&quot;http://iperf.sourceforge.net/&quot;&gt;iperf&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qa1:~&amp;gt; iperf -c qa2
------------------------------------------------------------
Client connecting to qa2, TCP port 5001
TCP window size: 16.0 KByte (default)
------------------------------------------------------------
[  3] local 192.168.1.106 port 56014 connected with 192.168.1.107 port 5001
[ ID] Interval       Transfer     Bandwidth
[  3]  0.0-10.0 sec  1.10 GBytes   943 Mbits/sec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的输出中可以看到，我的千兆网可以达到943Mbps的速度(之所以不到1000Mbps，是由于TCP的开销)。&lt;/p&gt;

&lt;p&gt;知道网络容量后，我们需要确保它不会成为制约测试的因素。有几种方法，最简单的是记录当前使用的带宽。例如，httperf可以像这样展示当前的带宽用量:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  Net I/O: 23399.7 KB/s (191.7*10&lt;sup&gt;6&lt;/sup&gt; bps)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;上例表明，我们目前只用了192Mbps。&lt;/p&gt;

&lt;p&gt;记住，我们在负载产生工具中看到的数字并没有包括TCP开销，而且，如果我们的负载在整个测试期间并不固定，那么突发带宽一定会有超过平均值的时候。而且除了带宽以外还有其它的问题，例如，廉价的网卡和交换机很有可能会被大量的数据包淹没。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-04/17043810_eBxe.png&quot; title=&quot;HTTP负载测试&quot;&gt;&lt;img src=&quot;/assets/files/2013-04/17043810_eBxe.png&quot; title=&quot;HTTP负载测试&quot; alt=&quot;HTTP负载测试&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;基于以上的种种原因，我们最好不要让测试的带宽逼近网络的可用带宽，最好是不要超过某个比例，比如2/3。对网络(包括网卡和交换机)错误和峰值速率进行监控也是一个很好的办法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 去除OS限制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;同样，我们还需要确保OS不会对服务器的表现构成限制。&lt;/p&gt;

&lt;p&gt;TCP参数的调整颇为重要，但它会对所有测试主体产生相同的影响。更为重要的是，不要让你测试的服务器用光文件描述符(file
descriptor)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 避免压测客户端&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现代高性能服务器使得容易将负载产生器的限制当作服务器的能力。所以，认真检查以确保你的客户端没有用爆CPU，如果有任何怀疑，就使用更多客户端压力来验证（&lt;a href=&quot;http://www.xenoclast.org/autobench/&quot;&gt;autobench&lt;/a&gt;可以让这件事更简单）。&lt;/p&gt;

&lt;p&gt;确保负载产生器的硬件优于要测试的服务端硬件，也很有帮助；比如，使用4核心的i5-750服务器产生负载，将服务器运行在较慢的双核i3-350服务器上，而且经常只用两个核心之一。&lt;/p&gt;

&lt;p&gt;另外一个需要注意的因素是客户端错误，尤其是&lt;a href=&quot;http://en.wikipedia.org/wiki/Ephemeral_port&quot;&gt;临时端口(ephemeral ports)&lt;/a&gt;用尽。处理这个问题有很多策略，扩大服务器的可用端口范围，或设置多个网络接口，确认由客户端使用它们（有时需要一些技巧）。也可以优化TIME_WAIT时间（只有是测试环境就没问题），或仅仅使用HTTP长连接和激进的客户端超时策略，确保连接速率不会用尽端口数。&lt;/p&gt;

&lt;p&gt;我喜欢httperf的一个原因是它在结束时提供了错误的概要：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  Errors: total 0 client-timo 0 socket-timo 0 connrefused 0 connreset 0&lt;br/&gt;
  Errors: fd-unavail 0 addrunavail 0 ftab-full 0 other 0&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;这里，服务器的问题位于第一行（比如由于服务器端超过–timeout设置的超时时间而造成的请求超时，或拒绝连接，或连接重置），客户端错误（如文件描述符用尽或地址用尽）在第二行。&lt;/p&gt;

&lt;p&gt;在测试本身出错时，这能够帮你及时了解。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 过载时的容量并不是真正的容量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;产生尽可能大的负载，扔给服务器，这是许多负载产生工具的工作模式。&lt;/p&gt;

&lt;p&gt;这种方法对于检查服务器在过载情况下的表现也许不错，但它并不能真正帮我们确定服务器的容量。因为，许多服务器在过载的情况下都会损失一部分的容量。&lt;/p&gt;

&lt;p&gt;更好的方法是逐步加大负载，直到服务器达到容量上限，出现性能下降为止。我们可以把结果绘制成一条先抵达峰值、随后下降的曲线，而下降的程度意味着服务器应对过载时的表现情况。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.xenoclast.org/autobench/&quot;&gt;autobench&lt;/a&gt;是其中的一种方法，我们可以设置测试的范围，然后就可以得到这样一张图:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-04/17043810_197M.jpg&quot; title=&quot;HTTP负载测试&quot;&gt;&lt;img src=&quot;/assets/files/2013-04/17043810_197M.jpg&quot; title=&quot;HTTP负载测试&quot; alt=&quot;HTTP负载测试&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;可以看到，在响应消息最小时，服务器的处理峰值为16,000响应/秒，但在过载情况下快速衰落至14,000响应/秒。而在响应消息更大时，过载情况下的衰落并没有这么多，但可以看到错误条不停弹出来，说明了服务器的紧张境况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. 30秒的测试不算测试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于处于应用、OS与网络栈各层的缓冲区需要一定的稳定时间，所以30秒的测试很可能不准确。如果你的测试数据是要正式发布的，请至少测试3分钟，或者更长一些，比如5到10分钟。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7. 不要仅仅测试Hello World&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果要测试服务器的响应是否迅速，用4字节的响应消息过于局限，意义不大，4k甚至100k才更有现实意义。&lt;/p&gt;

&lt;p&gt;另外一个需要测试的是服务器在面对大量空闲连接时的表现，比如10,000个连接。这对现代的成熟服务器来说本来不算什么，但往往会导致一些你想象不到的问题。&lt;/p&gt;

&lt;p&gt;当然，以上仅仅只是两个例子而已。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8. 仅仅平均值是不够的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果有人告诉你，服务器可以每秒产生1000个响应，平均时延为5ms，听起来是不是很棒？但是，如果这1000个响应里，有些需要100ms呢？或者，如果说在整个测试的10%时间里，由于垃圾收集的关系，只能达到500个响应/秒的速度，你怎么看？&lt;/p&gt;

&lt;p&gt;平均值是个快速指标，但是，仅此而已。有许多重要的信息，包含在时间线和直方图(histogram)中，但平均值并没有提供。如果你的测试工具不提供时间线和直方图，那么还是换一个吧(开源的话，还可以选择提交一个patch)。&lt;/p&gt;

&lt;p&gt;httperf可以显示:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  Total: connections 180000 requests 180000 replies 180000 test-duration 179.901 s&lt;/p&gt;

&lt;p&gt;  Connection rate: 1000.0 conn/s (99.9 ms/conn, &amp;lt;=2 concurrent connections)&lt;br/&gt;
  Connection time [ms]: min 0.4 avg 0.5 max 12.9 median 0.5 stddev 0.4&lt;br/&gt;
  Connection time [ms]: connect 0.1&lt;br/&gt;
  Connection length [replies/conn]: 1.000&lt;/p&gt;

&lt;p&gt;  Request rate: 1000.0 req/s (.9 ms/req)&lt;br/&gt;
  Request size [B]: 79.0&lt;/p&gt;

&lt;p&gt;  Reply rate [replies/s]: min 999.1 avg 1000.0 max 1000.2 stddev 0.1 (35 samples)&lt;br/&gt;
  Reply time [ms]: response 0.4 transfer 0.0&lt;br/&gt;
  Reply size [B]: header 385.0 content 1176.0 footer 0.0 (total 1561.0)&lt;br/&gt;
  Reply status: 1xx=0 2xx=0 3xx=0 4xx=1800 5xx=0&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;可以看到，它不仅显示了响应速度的平均值，还显示了最小值、最大值和标准差(deviation)。连接时间也是这样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9. 把相关信息全部发布出来&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果只是给出一个结果，而不给出重现它的必要信息，那么往好了说，这个结果只是一个全凭大家靠信仰来相信的没有用的结论，往坏了说，它甚至有故意误人子弟之嫌(译者注:
各种数据库的宣传式的benchmark表示纷纷中枪)。所以，如果要发布测试结果，记得要把测试的相关上下文也一起发布，不光是测试所用的硬件，还应包括OS版本与配置、网络设置、服务器与负载产生器的版本与配置、所用的负载，甚至必要时还要加上源代码。&lt;/p&gt;

&lt;p&gt;理想情况下，我们可以采用代码库(比如&lt;a href=&quot;https://github.com/&quot;&gt;github&lt;/a&gt;)的形式，使任何人都能以最小的代价(用自己的硬件)重现你的结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10. 尝试不同工具&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;看到这里，你也许会以为我只认httperf和autobench这两个工具。我很喜欢全能型选手，可惜httperf不是。对于现代的一些服务器来说，httperf太慢了，也许是由于它缺乏事件循环的缘故。httperf只能以每秒50到500个请求的速度测试一些PHP应用，但无论如何也做不到以每秒上万个请求的速度去测试那些现代的web服务器。&lt;/p&gt;

&lt;p&gt;而且，如果只认准一个工具的话，可能会由于客户端与服务器之间一些奇怪的交互，导致对某个实现特别不利的情况发生。例如，有些工具建立持久连接的方式对一些服务器不够友好，导致它们的测试结果不佳。&lt;/p&gt;

&lt;p&gt;而我之所以喜欢httperf，上文中也已经提过，由于它有很详细的统计信息和错误报告，而且可以自定义负载速率，让我们可以更清晰地了解我们的服务器。我希望其它工具也能输出同样详细的信息。&lt;/p&gt;

&lt;p&gt;我最近还用了&lt;a href=&quot;http://www.joedog.org/index/siege-home&quot;&gt;siege&lt;/a&gt;，虽然在信息方面还比不上httperf那么详细，不过也很好用，尤其速度真叫一个快。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Linux Netcat命令：网络工具中的瑞士军刀</title>
   <link href="http://beango.github.com/archives/2013/04/16/linux-netcat-command.html"/>
   <updated>2013-04-16T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/04/16/linux-netcat-command</id>
   <content type="html">&lt;p&gt;英文原文：&lt;a href=&quot;http://mylinuxbook.com/linux-netcat-command/&quot; title=&quot;http://mylinuxbook.com/linux-netcat-command/&quot;&gt;Linux Netcat command – The swiss army knife of networking&lt;/a&gt;，编译：&lt;a href=&quot;http://www.oschina.net/translate/linux-netcat-command&quot; title=&quot;http://www.oschina.net/translate/linux-netcat-command&quot;&gt;oschina&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;netcat&lt;/strong&gt;是网络工具中的瑞士军刀，它能通过TCP和UDP在网络中读写数据。通过与其他工具结合和重定向，你可以在脚本中以多种方式使用它。使用netcat命令所能完成的事情令人惊讶。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;netcat&lt;/strong&gt;所做的就是在两台电脑之间建立链接并返回两个数据流，在这之后所能做的事就看你的想像力了。你能建立一个服务器，传输文件，与朋友聊天，传输流媒体或者用它作为其它协议的独立客户端。&lt;/p&gt;

&lt;p&gt;下面是一些使用netcat的例子.&lt;/p&gt;

&lt;p&gt;[A(172.31.100.7) B(172.31.100.23)]&lt;/p&gt;

&lt;p&gt;Linux netcat 命令实例：&lt;/p&gt;

&lt;h3&gt;1，端口扫描&lt;/h3&gt;

&lt;p&gt;端口扫描经常被系统管理员和黑客用来发现在一些机器上开放的端口，帮助他们识别系统中的漏洞。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc -z -v -n 172.31.100.7 21-25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以运行在TCP或者UDP模式，默认是TCP，-u参数调整为udp.&lt;/p&gt;

&lt;p&gt;z 参数告诉netcat使用0 IO,连接成功后立即关闭连接，不进行数据交换(谢谢@jxing 指点)&lt;/p&gt;

&lt;p&gt;v 参数指使用冗余选项（译者注：即详细输出）&lt;/p&gt;

&lt;p&gt;n 参数告诉netcat 不要使用DNS反向查询IP地址的域名&lt;/p&gt;

&lt;p&gt;这个命令会打印21到25所有开放的端口。Banner是一个文本，Banner是一个你连接的服务发送给你的文本信息。当你试图鉴别漏洞或者服务的类型和版本的时候，Banner信息是非常有用的。但是，并不是所有的服务都会发送banner。&lt;/p&gt;

&lt;p&gt;一旦你发现开放的端口，你可以容易的使用netcat 连接服务抓取他们的banner。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nc -v 172.31.100.7 21
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;netcat 命令会连接开放端口21并且打印运行在这个端口上服务的banner信息。&lt;/p&gt;

&lt;h3&gt;Chat Server&lt;/h3&gt;

&lt;p&gt;假如你想和你的朋友聊聊，有很多的软件和信息服务可以供你使用。但是，如果你没有这么奢侈的配置，比如你在计算机实验室，所有的对外的连接都是被限制的，你怎样和整天坐在隔壁房间的朋友沟通那？不要郁闷了，netcat提供了这样一种方法，你只需要创建一个Chat服务器，一个预先确定好的端口，这样子他就可以联系到你了。&lt;/p&gt;

&lt;p&gt;Server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc -l 1567
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;netcat 命令在1567端口启动了一个tcp服务器，所有的标准输出和输入会输出到该端口。输出和输入都在此shell中展示。&lt;/p&gt;

&lt;p&gt;Client&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc 172.31.100.7 1567
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不管你在机器B上键入什么都会出现在机器A上。&lt;/p&gt;

&lt;h3&gt;3，文件传输&lt;/h3&gt;

&lt;p&gt;大部分时间中，我们都在试图通过网络或者其他工具传输文件。有很多种方法，比如FTP,SCP,SMB等等，但是当你只是需要临时或者一次传输文件，真的值得浪费时间来安装配置一个软件到你的机器上嘛。假设，你想要传一个文件file.txt从A 到B。A或者B都可以作为服务器或者客户端，以下，让A作为服务器，B为客户端。&lt;/p&gt;

&lt;p&gt;Server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc -l 1567 &amp;lt; file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Client&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc -n 172.31.100.7 1567 &amp;gt; file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们创建了一个服务器在A上并且重定向netcat的输入为文件file.txt，那么当任何成功连接到该端口，netcat会发送file的文件内容。&lt;/p&gt;

&lt;p&gt;在客户端我们重定向输出到file.txt，当B连接到A，A发送文件内容，B保存文件内容到file.txt.&lt;/p&gt;

&lt;p&gt;没有必要创建文件源作为Server，我们也可以相反的方法使用。像下面的我们发送文件从B到A，但是服务器创建在A上，这次我们仅需要重定向netcat的输出并且重定向B的输入文件。&lt;/p&gt;

&lt;p&gt;B作为Server&lt;/p&gt;

&lt;p&gt;Server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc -l 1567 &amp;gt; file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Client&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nc 172.31.100.23 1567 &amp;lt; file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4，目录传输&lt;/h3&gt;

&lt;p&gt;发送一个文件很简单，但是如果我们想要发送多个文件，或者整个目录，一样很简单，只需要使用压缩工具tar，压缩后发送压缩包。&lt;/p&gt;

&lt;p&gt;如果你想要通过网络传输一个目录从A到B。&lt;/p&gt;

&lt;p&gt;Server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$tar -cvf – dir_name | nc -l 1567
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Client&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc -n 172.31.100.7 1567 | tar -xvf -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里在A服务器上，我们创建一个tar归档包并且通过-在控制台重定向它，然后使用管道，重定向给netcat，netcat可以通过网络发送它。&lt;/p&gt;

&lt;p&gt;在客户端我们下载该压缩包通过netcat 管道然后打开文件。&lt;/p&gt;

&lt;p&gt;如果想要节省带宽传输压缩包，我们可以使用bzip2或者其他工具压缩。&lt;/p&gt;

&lt;p&gt;Server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$tar -cvf – dir_name| bzip2 -z | nc -l 1567
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过bzip2压缩&lt;/p&gt;

&lt;p&gt;Client&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc -n 172.31.100.7 1567 | bzip2 -d |tar -xvf -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用bzip2解压&lt;/p&gt;

&lt;h3&gt;5. 加密你通过网络发送的数据&lt;/h3&gt;

&lt;p&gt;如果你担心你在网络上发送数据的安全，你可以在发送你的数据之前用如mcrypt的工具加密。&lt;/p&gt;

&lt;p&gt;服务端&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc localhost 1567 | mcrypt –flush –bare -F -q -d -m ecb &amp;gt; file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用mcrypt工具加密数据。&lt;/p&gt;

&lt;p&gt;客户端&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$mcrypt –flush –bare -F -q -m ecb &amp;lt; file.txt | nc -l 1567
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用mcrypt工具解密数据。&lt;/p&gt;

&lt;p&gt;以上两个命令会提示需要密码，确保两端使用相同的密码。&lt;/p&gt;

&lt;p&gt;这里我们是使用mcrypt用来加密，使用其它任意加密工具都可以。&lt;/p&gt;

&lt;h3&gt;6. 流视频&lt;/h3&gt;

&lt;p&gt;虽然不是生成流视频的最好方法，但如果服务器上没有特定的工具，使用netcat，我们仍然有希望做成这件事。&lt;/p&gt;

&lt;p&gt;服务端&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cat video.avi | nc -l 1567
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们只是从一个视频文件中读入并重定向输出到netcat客户端&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc 172.31.100.7 1567 | mplayer -vo x11 -cache 3000 -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们从socket中读入数据并重定向到mplayer。&lt;/p&gt;

&lt;h3&gt;7，克隆一个设备&lt;/h3&gt;

&lt;p&gt;如果你已经安装配置一台Linux机器并且需要重复同样的操作对其他的机器，而你不想在重复配置一遍。不在需要重复配置安装的过程，只启动另一台机器的一些引导可以随身碟和克隆你的机器。&lt;/p&gt;

&lt;p&gt;克隆Linux PC很简单，假如你的系统在磁盘/dev/sda上&lt;/p&gt;

&lt;p&gt;Server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$dd if=/dev/sda | nc -l 1567
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Client&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc -n 172.31.100.7 1567 | dd of=/dev/sda
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dd是一个从磁盘读取原始数据的工具，我通过netcat服务器重定向它的输出流到其他机器并且写入到磁盘中，它会随着分区表拷贝所有的信息。但是如果我们已经做过分区并且只需要克隆root分区，我们可以根据我们系统root分区的位置，更改sda为sda1，sda2.等等。&lt;/p&gt;

&lt;h3&gt;8，打开一个shell&lt;/h3&gt;

&lt;p&gt;我们已经用过远程shell-使用telnet和ssh，但是如果这两个命令没有安装并且我们没有权限安装他们，我们也可以使用netcat创建远程shell。&lt;/p&gt;

&lt;p&gt;假设你的netcat支持 -c -e 参数(默认 netcat)&lt;/p&gt;

&lt;p&gt;Server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc -l 1567 -e /bin/bash -i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Client&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc 172.31.100.7 1567
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们已经创建了一个netcat服务器并且表示当它连接成功时执行/bin/bash&lt;/p&gt;

&lt;p&gt;假如netcat 不支持-c 或者 -e 参数（openbsd netcat）,我们仍然能够创建远程shell&lt;/p&gt;

&lt;p&gt;Server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$mkfifo /tmp/tmp_fifo
$cat /tmp/tmp_fifo | /bin/sh -i 2&amp;gt;&amp;amp;1 | nc -l 1567 &amp;gt; /tmp/tmp_fifo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们创建了一个fifo文件，然后使用管道命令把这个fifo文件内容定向到shell 2&gt;&amp;amp;1中。是用来重定向标准错误输出和标准输出，然后管道到netcat运行的端口1567上。至此，我们已经把netcat的输出重定向到fifo文件中。&lt;/p&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;从网络收到的输入写到fifo文件中&lt;/p&gt;

&lt;p&gt;cat 命令读取fifo文件并且其内容发送给sh命令&lt;/p&gt;

&lt;p&gt;sh命令进程受到输入并把它写回到netcat。&lt;/p&gt;

&lt;p&gt;netcat 通过网络发送输出到client&lt;/p&gt;

&lt;p&gt;至于为什么会成功是因为管道使命令平行执行，fifo文件用来替代正常文件，因为fifo使读取等待而如果是一个普通文件，cat命令会尽快结束并开始读取空文件。&lt;/p&gt;

&lt;p&gt;在客户端仅仅简单连接到服务器&lt;/p&gt;

&lt;p&gt;Client&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc -n 172.31.100.7 1567
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你会得到一个shell提示符在客户端&lt;/p&gt;

&lt;h3&gt;反向shell&lt;/h3&gt;

&lt;p&gt;反向shell是指在客户端打开的shell。反向shell这样命名是因为不同于其他配置，这里服务器使用的是由客户提供的服务。&lt;/p&gt;

&lt;p&gt;服务端&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc -l 1567
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在客户端，简单地告诉netcat在连接完成后，执行shell。&lt;/p&gt;

&lt;p&gt;客户端&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc 172.31.100.7 1567 -e /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，什么是反向shell的特别之处呢&lt;/p&gt;

&lt;p&gt;反向shell经常被用来绕过防火墙的限制，如阻止入站连接。例如，我有一个专用IP地址为172.31.100.7，我使用代理服务器连接到外部网络。如果我想从网络外部访问 这台机器如1.2.3.4的shell，那么我会用反向外壳用于这一目的。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;10. 指定源端口&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;假设你的防火墙过滤除25端口外其它所有端口，你需要使用-p选项指定源端口。&lt;/p&gt;

&lt;p&gt;服务器端&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc -l 1567
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc 172.31.100.7 1567 -p 25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用1024以内的端口需要root权限。&lt;/p&gt;

&lt;p&gt;该命令将在客户端开启25端口用于通讯，否则将使用随机端口。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;11. 指定源地址&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;假设你的机器有多个地址，希望明确指定使用哪个地址用于外部数据通讯。我们可以在netcat中使用-s选项指定ip地址。&lt;/p&gt;

&lt;p&gt;服务器端&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc -u -l 1567 &amp;lt; file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nc -u 172.31.100.7 1567 -s 172.31.100.5 &amp;gt; file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该命令将绑定地址172.31.100.5。&lt;/p&gt;

&lt;p&gt;这仅仅是使用netcat的一些示例。&lt;/p&gt;

&lt;p&gt;其它用途有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用-t选项模拟Telnet客户端，&lt;/li&gt;
&lt;li&gt;HTTP客户端用于下载文件，&lt;/li&gt;
&lt;li&gt;连接到邮件服务器，使用SMTP协议检查邮件，&lt;/li&gt;
&lt;li&gt;使用ffmpeg截取屏幕并通过流式传输分享，等等。其它更多用途。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;简单来说，只要你了解协议就可以使用netcat作为网络通讯媒介，实现各种客户端。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考文档&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://linux.die.net/man/1/nc&quot;&gt;Netcat手册&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Python中函数式编程，第二部分</title>
   <link href="http://beango.github.com/archives/2013/04/11/python-functional-programming-part2.html"/>
   <updated>2013-04-11T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/04/11/python-functional-programming-part2</id>
   <content type="html">&lt;p&gt;英文原文：&lt;a href=&quot;http://www.ibm.com/developerworks/linux/library/l-prog2/index.html&quot;&gt;Charming Python: Functional programming in Python, Part 2&lt;/a&gt;，翻译：&lt;a href=&quot;http://www.oschina.net/translate/python-functional-programming-part2&quot;&gt;开源中国&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt; 
本专栏继续让David对Python中的函数式编程(FP)进行介绍。读完本文，可以享受到使用不同的编程范型（paradigm）解决问题所带来的乐趣。David在本文中对FP中的多个中级和高级概念进行了详细的讲解。&lt;/p&gt;

&lt;p&gt;一个对象就是附有若干过程（procedure）的一段数据。。。一个闭包（closure）就是附有一段数据的一个过程（procedure）。&lt;/p&gt;

&lt;p&gt;在我讲解函数式编程的上一篇文章，&lt;a href=&quot;http://blog.jobbole.com/35028/&quot;&gt;第一部分&lt;/a&gt;，中，我介绍了FP中的一些基本概念。本文将更加深入的对这个内容十分丰富的概念领域进行探讨。在我们探讨的大部分内容中，Bryn Keller的”Xoltar Toolkit”为我们提供一些非常有价值的帮助作用。Keller将FP中的许多强项集中到了一个很棒且很小的模块中，他在这个模块中用纯Python代码实现了这些强项。除了&lt;em&gt;functional&lt;/em&gt;模块外，Xoltar Toolkit还包含了一个&lt;em&gt;延迟（&lt;strong&gt;lazy&lt;/strong&gt;）&lt;/em&gt;模块，对“仅在需要时”才进行求值提供了支持。许多传统的函数式语言中也都具有延迟求值的手段，这样，使用Xoltar Toolkit中的这些组件，你就可以做到使用象Haskell这样的函数式语言能够做到的大部分事情了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;绑定（Binding）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有心的读者会记得，我在第一部分中所述的函数式技术中指出过Python的一个局限。具体讲，就是Python中没有任何手段禁止对用来指代函数式表达式的名字进行重新绑定。在FP中，名字一般是理解为对比较长的表达式的简称，但这里面隐含了一个诺言，就是“同一个表达式总是具有同一个值”。如果对用来指代的名字重新进行绑定，就会违背这个诺言。例如，假如我们如以下所示，定义了一些要用在函数式程序中的简记表达式:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Python中由于重新绑定而引起问题的FP编程片段&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; car = lambda lst: lst[0]
&amp;gt;&amp;gt;&amp;gt; cdr = lambda lst: lst[1:]
&amp;gt;&amp;gt;&amp;gt; sum2 = lambda lst: car(lst)+car(cdr(lst))
&amp;gt;&amp;gt;&amp;gt; sum2(range(10))
1
&amp;gt;&amp;gt;&amp;gt; car = lambda lst: lst[2]
&amp;gt;&amp;gt;&amp;gt; sum2(range(10))
5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;非常不幸，程序中完全相同的表达式sum2(range(10))在两个不同的点求得的值却不相同,尽管在该表达式的参数中根本没有使用任何可变的（mutable）变量。&lt;/p&gt;

&lt;p&gt;幸运的是，functional模块提供了一个叫做Bindings(由鄙人向Keller进行的提议，proposed to Keller by yours truly)的类，可以用来避免这种重新绑定（至少可以避免意外的重新绑定，Python并不阻止任何拿定主意就是要打破规则的程序员）。尽管要用Bindings类就需要使用一些额外的语法，但这么做就能让这种事故不太容易发生。Keller在functional模块里给出的例子中，有个Bindings的实例名字叫做let（我推测这么叫是为了仿照ML族语言中的let关键字）。例如，我们可以这么做：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Python中对重新绑定进行监视后的FP编程片段&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from functional import *
&amp;gt;&amp;gt;&amp;gt; let = Bindings()
&amp;gt;&amp;gt;&amp;gt; let.car = lambda lst: lst[0]
&amp;gt;&amp;gt;&amp;gt; let.car = lambda lst: lst[2]
Traceback (innermost last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in ?
  File &quot;d:\tools\functional.py&quot;, line 976, in __setattr__
    raise BindingError, &quot;Binding '%s' cannot be modified.&quot; % name
functional.BindingError:  Binding 'car' cannot be modified.
&amp;gt;&amp;gt;&amp;gt; car(range(10))
0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显而易见，在真正的程序中应该去做一些事情，捕获这种”BindingError”异常，但发出这些异常这件事，就能够避免产生这一大类的问题。&lt;/p&gt;

&lt;p&gt;functional模块随同Bindings一起还提供了一个叫做namespace的函数，这个函数从Bindings实例中弄出了一个命名空间(实际就是个字典)。如果你想计算一个表达式，而该表达式是在定义于一个Bindings中的一个（不可变）命名空间中时，这个函数就可以很方便地拿来使用。Python的eval()函数允许在命名空间中进行求值。举个例子就能说明这一切：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Python中使用不可变命名空间的FP编程片段&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; let = Bindings()      # &quot;Real world&quot; function names
&amp;gt;&amp;gt;&amp;gt; let.r10 = range(10)
&amp;gt;&amp;gt;&amp;gt; let.car = lambda lst: lst[0]
&amp;gt;&amp;gt;&amp;gt; let.cdr = lambda lst: lst[1:]
&amp;gt;&amp;gt;&amp;gt; eval('car(r10)+car(cdr(r10))', namespace(let))
&amp;gt;&amp;gt;&amp;gt; inv = Bindings()      # &quot;Inverted list&quot; function names
&amp;gt;&amp;gt;&amp;gt; inv.r10 = let.r10
&amp;gt;&amp;gt;&amp;gt; inv.car = lambda lst: lst[-1]
&amp;gt;&amp;gt;&amp;gt; inv.cdr = lambda lst: lst[:-1]
&amp;gt;&amp;gt;&amp;gt; eval('car(r10)+car(cdr(r10))', namespace(inv))
17
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FP中有一个特别有引人关注的概念叫做闭包。实际上，闭包充分引起了很多程序员的关注，即使通常意义上的非函数式&lt;a href=&quot;http://blog.jobbole.com/tag/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/&quot; title=&quot;如何选择语言和编程语言排名相关文章&quot;&gt;编程语言&lt;/a&gt;，比如Perl和Ruby，都包含了闭包这一特性。此外，Python 2.1 目前一定会添加上词法域（lexical scoping），
这样一来就提供的闭包的绝大多数功能。那么，闭包到底是什么？Steve Majewski最近在Python新闻组中对这个概念的特性提出了一个准确的描述：
就是说，闭包就象是FP的Jekyll，OOP（面向对象编程）的 Hyde（或者可能是将这两个角色互换）（译者注：Jekyll和Hyde是一部小说中的两个人物）.和象对象实例类似，闭包是一种把一堆数据和一些功能打包一起进行传递的手段。&lt;/p&gt;

&lt;p&gt;先让我们后退一小步，看看对象和闭包都能解决一些什么样的问题，然后再看看在两样都不用的情况下这些问题是如何得到解决的。函数返回的值通常是由它在计算过程中使用的上下文决定的。最常见可能也是最显然的指定该上下文的方式就是给函数传递一些参数，让该函数对这些参数进行一些运算。但有时候在参数的“背景”（background）和“前景”（foreground）两者之间也有一种自然的区分，也就是说，函数在某特定时刻正在做什么和函数“被配置”为处于多种可能的调用情况之下这两者之间有不同之处。\&lt;/p&gt;

&lt;p&gt;在集中处理前景的同时，有多种方式进行背景处理。一种就是“忍辱负重”，每次调用时都将函数需要的每个参数传递给函数。这通常就相对于在函数调用链中不断的将很多值（或者是一个具有很多字段的数据结构）传上传下，就是因为在链中的某个地方可能会用到这些值。下面举个简单的例子：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;用了货船变量的Python代码片段&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def a(n):
...     add7 = b(n)
...     return add7
...
&amp;gt;&amp;gt;&amp;gt; def b(n):
...     i = 7
...     j = c(i,n)
...     return j
...
&amp;gt;&amp;gt;&amp;gt; def c(i,n):
...     return i+n
...
&amp;gt;&amp;gt;&amp;gt; a(10)     # Pass cargo value for use downstream
17
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上述的货船变量例子中，函数b()中的变量n毫无意义，就只是为了传递给函数c()。另一种办法是使用全局变量:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;使用全局变量的Python代码片段&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; N = 10
&amp;gt;&amp;gt;&amp;gt; def  addN(i):
...     global N
...     return i+N
...
&amp;gt;&amp;gt;&amp;gt; addN(7)   # Add global N to argument
17
&amp;gt;&amp;gt;&amp;gt; N = 20
&amp;gt;&amp;gt;&amp;gt; addN(6)   # Add global N to argument
26
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全局变量N只要你想调用ddN()就可以直接使用，就不需要显式地传递这个全局背景“上下文”了。有个稍微更加Python化的技巧，可以用来在定义函数时，通过使用缺省参数将一个变量“冻结”到该函数中：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;使用冻结变量的Python代码片段&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; N = 10
&amp;gt;&amp;gt;&amp;gt; def addN(i, n=N):
...     return i+n
...
&amp;gt;&amp;gt;&amp;gt; addN(5)   # Add 10
15
&amp;gt;&amp;gt;&amp;gt; N = 20
&amp;gt;&amp;gt;&amp;gt; addN(6)   # Add 10 (current N doesn't matter)
16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们冻结的变量实质上就是个闭包。我们将一些数据“附加”到了addN()函数之上。对于一个完整的闭包而言，在函数addN()定义时所出现的数据，应该在该函数被调用时也可以拿到。然而，本例中（以及更多更健壮的例子中），使用缺省参数让足够的数据可用非常简单。函数addN()不再使用的变量因而对计算结构捕获产生丝毫影响。&lt;/p&gt;

&lt;p&gt;现在让我们再看一个用OOP的方式解决一个稍微更加现实的问题。今年到了这个时候，让我想起了颇具“面试”风格的计税程序，先收集一些数据，数据不一定有什么特别的顺序，最后使用所有这些数据进行一个计算。让我们为这种情况些个简化版本的程序：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Python风格的计税类/实例&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class TaxCalc:
    def taxdue(self):return (self.income-self.deduct)*self.rate
taxclass = TaxCalc()
taxclass.income = 50000
taxclass.rate = 0.30
taxclass.deduct = 10000
print&quot;Pythonic OOP taxes due =&quot;, taxclass.taxdue()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我们的TaxCalc类(或者更准确的讲，在它的实例中)，我们先收集了一些数据，数据的顺序随心所欲，然后所有需要的数据收集完成后，我们可以调用这个对象的一个方法，对这堆数据进行计算。所有的一切都呆在一个实例中，而且，不同的实例可以拥有一堆不同的数据。能够创建多个实例，而多个实例仅仅是数据不同，这通过“全局变量”和“冻结变量”这两种方法是无法办到的。”货船”方法能够做到这一点，但从那个展开的例子中我们能够看出，它可能不得不在开始时就传递多个数值。讨论到这里，注意到OOP风格的消息传递方式可能会如何来解决这一问题会非常有趣(Smalltalk或者Self与此类似，我所用过的好几种xBase的变种OOP语言也是类似的）：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Smalltalk风格的(Python) 计税程序&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class TaxCalc:
    def taxdue(self):return (self.income-self.deduct)*self.rate
    def setIncome(self,income):
        self.income = income
        return self
    def setDeduct(self,deduct):
        self.deduct = deduct
        return self
    def setRate(self,rate):
        self.rate = rate
        return self
print&quot;Smalltalk-style taxes due =&quot;, \
      TaxCalc().setIncome(50000).setRate(0.30).setDeduct(10000).taxdue()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个”setter”方法都返回self可以让我们将每个方法调用的结果当作“当前”对象进行处理。这和FP中的闭包方式有些相似。&lt;/p&gt;

&lt;p&gt;通过使用Xoltar toolkit，我们可以生成完整的闭包，能够将数据和函数结合起来，获得我们所需的特性；另外还可以让多个闭包（以前成为对象）包含不同的数据：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Python的函数式风格的计税程序&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from functional import *

taxdue        = lambda: (income-deduct)*rate
incomeClosure = lambda income,taxdue: closure(taxdue)
deductClosure = lambda deduct,taxdue: closure(taxdue)
rateClosure   = lambda rate,taxdue: closure(taxdue)

taxFP = taxdue
taxFP = incomeClosure(50000,taxFP)
taxFP = rateClosure(0.30,taxFP)
taxFP = deductClosure(10000,taxFP)
print&quot;Functional taxes due =&quot;,taxFP()

print&quot;Lisp-style taxes due =&quot;, \
      incomeClosure(50000,
          rateClosure(0.30,
              deductClosure(10000, taxdue)))()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们所定义的每个闭包函数可以获取函数定义范围内的任意值，然后将这些值绑定到改函数对象的全局范围之中。然而，一个函数的全局范围并不一定就是真正的模块全局范围，也和不同的闭包的“全局”范围不相同。闭包就是“将数据带”在了身边。\&lt;/p&gt;

&lt;p&gt;在我们的例子中，我们利用了一些特殊的函数把特定的绑定限定到了一个闭包作用范围之中(income,deduct,rate)。要想修改设计，将任意的绑定限定在闭包之中，也非常简单。只是为了好玩，在本例子中我们也使用了两种稍微不同的函数式风格。第一种风格连续将多个值绑定到了闭包的作用范围；通过允许taxFP成为可变的变量，这些“添加绑定”的代码行可以任意顺序出现。然而，如果我们想要使用tax_with_Income这样的不可变名字，我们就需要以特定的顺序来安排这几行进行绑定的代码，将靠前的绑定结果传递给下一个绑定。无论在哪种情况下，在全部所需数据都绑定进闭包范围之后，我们就可以调用“种子”（seeded）方法了。&lt;/p&gt;

&lt;p&gt;第二种风格在我看来，更象是Lisp（那些括号最象了）。除去美学问题，这第二种风格有两点值得注意。第一点就是完全避免了名字绑定，变成了一个单个的表达式，连语句都没有使用（关于为什么不使用语句很重要，请参见P第一部分）。\&lt;/p&gt;

&lt;p&gt;第二点是闭包的“Lips”风格的用法和前文给出的“Smalltalk”风格的信息传递何其相似。实际上两者都在调用taxdue()函数/方法的过程中积累了所有值(如果以这种原始的方式拿不到正确的数据，两种方式都会出错）。“Smalltalk”风格的方法中每一步传递的是一个对象，而“Lisp”风格的方法中传递是持续进行的。但实际上，函数式编程和面向对象式编程两者旗鼓相当。&lt;/p&gt;

&lt;p&gt;在本文中，我们干掉了函数式编程领域中更多的内容。剩下的要比以前（本小节的题目是个小玩笑；很不幸，这里还没有解释过尾递归的概念）少多了（或者可以证明也简单多了？）。阅读functional模块中的源代码是继续探索FP中大量概念的一种非常好的方法。该模块中的注释很完备，在注释里为模块中的大多数方法/类提供了相关的例子。其中有很多简化性的元函数（meta-function）本专栏里并没有讨论到的，使用这些元函数可以大大简化对其它函数的结合（combination）和交互（interaction）的处理。对于想继续探索函数式范型的Python程序员而言，这些绝对值得好好看看。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/archives/2013/03/04/python-functional-programming-part1.html&quot; title=&quot;Python中函数式编程，第一部分&quot;&gt;Python中的函数式编程，第一部分&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/archives/2013/04/11/python-functional-programming-part2.html&quot; title=&quot;Python中函数式编程，第二部分&quot;&gt;Python中的函数式编程，第二部分&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/archives/2013/04/25/python-functional-programming-part3.html&quot; title=&quot;Python中的函数式编程，第三部分&quot;&gt;Python中的函数式编程，第三部分&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>浅谈JavaScript的语言特性</title>
   <link href="http://beango.github.com/archives/2013/03/26/javascript-language-features.html"/>
   <updated>2013-03-26T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/03/26/javascript-language-features</id>
   <content type="html">&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;在JavaScript中，作用域、上下文、闭包、函数等算是精华中的精华了。对于初级JSer来说，是进阶必备。对于前端攻城师来说，只有静下心来，理解了这些精华，才能写出优雅的代码。&lt;/p&gt;

&lt;p&gt;本文旨在总结容易忘记的重要知识，不会讲基本的概念。如果对基本知识不太熟悉，就去翻下《&lt;a href=&quot;http://www.amazon.cn/mn/detailApp/ref=as_li_qf_sp_asin_tl?_encoding=UTF8&amp;amp;tag=vastwork-23&amp;amp;linkCode=as2&amp;amp;asin=B0012UMVYA&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=B0012UMVYA&quot; title=&quot;JavaScript权威指南&quot;&gt;JavaScript权威指南&lt;/a&gt;》吧~&lt;/p&gt;

&lt;p&gt;参考文章如下(建议读者朋友用chrome看这些文章吧，不然的话会错过很多精彩哦~)：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/&quot;&gt;http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/javascript-the-core/&quot;&gt;http://dmitrysoshnikov.com/ecmascript/javascript-the-core/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h2&gt;语言特性&lt;/h2&gt;

&lt;h3&gt;函数表达式&lt;/h3&gt;

&lt;p&gt;先看代码段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var f = function foo(){
    return typeof foo; // foo是在内部作用域内有效
};
// foo在外部用于是不可见的
typeof foo; // &quot;undefined&quot;
f(); // &quot;function&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里想说一点的就是，在函数表达式中的foo，只能在函数内部引用，外面是不能引用的。&lt;/p&gt;

&lt;h3&gt;json&lt;/h3&gt;

&lt;p&gt;很多JavaScript开发人员都错误地把JavaScript对象字面量(Object Literals)称为JSON对象(JSON Objects)。
JSON是设计成描述数据交换格式的，它也有自己的语法，这个语法是JavaScript的一个子集。&lt;/p&gt;

&lt;p&gt;{ “prop”: “val” }这样的声明有可能是JavaScript对象字面量，也有可能是JSON字符串，取决于什么上下文使用它。如果是用在string上下文(用单引号或双引
号引住，或者从text文件读取)的话，那它就是JSON字符串，如果是用在对象字面量上下文中，那它就是对象字面量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 这是JSON字符串
var foo = '{ &quot;prop&quot;: &quot;val&quot; }';

// 这是对象字面量
var bar = { &quot;prop&quot;: &quot;val&quot; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一点需要知道的是，JSON.parse用来将JSON字符串反序列化成对象，JSON.stringify用来将对象序列化成JSON字符串。&lt;strong&gt;老版本的&lt;a href=&quot;http://blog.jobbole.com/12749/&quot; title=&quot;浏览器&quot;&gt;浏览器&lt;/a&gt;不支持这个对象，但你可以通过json2.js来实现同样的功能。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;原型&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function Animal (){  
    // ...
}
function cat (){  
    // ...
}  
cat.prototype = new Animal();//这种方式会继承构造函数里面的。
cat.prototype = Animal.prototype;//这种方式不会继承构造函数里面的。

//还有一个重要的细节需要注意的就是一定要维护自己的原型链,新手总会忘记这个！
cat.prototype.constructor = cat;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们彻底改变函数的prototype属性（通过分配一个新的对象），那原始构造函数的引用就是丢失，这是因为我们创建的对象不包括constructor属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function A() {}
A.prototype = {
  x: 10
};

var a = new A();
alert(a.x); // 10
alert(a.constructor === A); // false!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让我们一起看下MDN上关于constructor的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/constructor&quot;&gt;解释&lt;/a&gt;吧：prototype：Returns a reference to the Object function that created the instance’s prototype.因此，对函数的原型引用需要手工恢复：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function A() {}
A.prototype = {
  constructor: A,
  x: 10
};

var a = new A();
alert(a.x); // 10
alert(a.constructor === A); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，提交prototype属性不会影响已经创建对象的原型（只有在构造函数的prototype属性改变的时候才会影响到)，就是说新创建的对象才有有新的原型，而已创建对象还是引用到原来的旧原型（这个原型已经不能被再被修改了）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function A() {}
A.prototype.x = 10;

var a = new A();
alert(a.x); // 10

A.prototype = {
  constructor: A,
  x: 20
  y: 30
};

// 对象a是通过隐式的[[Prototype]]引用从原油的prototype上获取的值
alert(a.x); // 10
alert(a.y) // undefined

var b = new A();

// 但新对象是从新原型上获取的值
alert(b.x); // 20
alert(b.y) // 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此，“动态修改原型将影响所有的对象都会拥有新的原型”是错误的，新原型仅仅在原型修改以后的新创建对象上生效。这里的主要规则是：对象的原型是对象的创建的时候创建的，并且在此之后不能修改为新的对象，如果依然引用到同一个对象，可以通过构造函数的显式prototype引用，对象创建以后，只能对原型的属性进行添加或修改。&lt;/p&gt;

&lt;h3&gt;变量对象&lt;/h3&gt;

&lt;p&gt;在函数执行上下文中，VO(variable
object)是不能直接访问的，此时由活动对象(activation object)扮演VO的角色。
活动对象是在进入函数上下文时刻被创建的，它通过函数的arguments属性初始化。arguments属性的值是Arguments对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo(x, y, z) {
  // 声明的函数参数数量arguments (x, y, z)
  alert(foo.length); // 3

  // 真正传进来的参数个数(only x, y)
  alert(arguments.length); // 2

  // 参数的callee是函数自身
  alert(arguments.callee === foo); // true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当进入执行上下文(代码执行之前)时，VO里已经包含了下列属性：1.
函数的所有形参(如果我们是在函数执行上下文中)；&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;所有函数声明(FunctionDeclaration, FD)；&lt;/li&gt;
&lt;li&gt;所有变量声明(var, VariableDeclaration)；&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;另一个经典例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alert(x); // function

var x = 10;
alert(x); // 10

x = 20;

function x() {};

alert(x); // 20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据规范函数声明是在当进入上下文时填入的;
在进入上下文的时候还有一个变量声明“x”，那么正如我们在上面所说，&lt;strong&gt;变量声明在顺序上跟在函数声明和形式参数声明之后&lt;/strong&gt;，而且在这个进入上下文阶段，变量声明不会干扰VO中已经存在的同名函数声明或形式参数声明。变量相对于简单属性来说，变量有一个特性(attribute)：{DontDelete},这个特性的含义就是不能用delete操作符直接删除变量属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = 10;
alert(window.a); // 10
alert(delete a); // true
alert(window.a); // undefined

var b = 20;
alert(window.b); // 20
alert(delete b); // false
alert(window.b); // still 20。b is variable,not property!

var a = 10; // 全局上下文中的变量

(function () {
  var b = 20; // function上下文中的局部变量
})();
alert(a); // 10
alert(b); // 全局变量 &quot;b&quot; 没有声明.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;this&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用括号()的左边是引用类型的值，this将设为引用类型值
的base对象（base
object），在其他情况下（与引用类型不同的任何其它属性），这个值为null。不过，实际不存在this的值为null的情况，因为当this的值
为null的时候，其值会被隐式转换为全局对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function () {
  alert(this); // null =&amp;gt; global
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，我们有一个函数对象但不是引用类型的对象（它不是标示符，也不是属性访问器），相应地，this值最终设为全局对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var foo = {
    bar: function () {
      alert(this);
    }
};

foo.bar(); // Reference, OK =&amp;gt; foo
(foo.bar)(); // Reference, OK =&amp;gt; foo

(foo.bar = foo.bar)(); // global
(false || foo.bar)(); // global
(foo.bar, foo.bar)(); // global
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题在于后面的三个调用，在应用一定的运算操作之后，在调用括号的左边的值不在是引用类型。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;第一个例子很明显———明显的引用类型，结果是，this为base对象，即foo。&lt;/li&gt;
&lt;li&gt;在第二个例子中，组运算符并不适用，想想上面提到的，从引用类型中获得一个对象真正的值的方法，如GetValue。相应的，在组运算的返回中———我们得到仍是一个引用类型。这就是this值为什么再次设为base对象，即foo。&lt;/li&gt;
&lt;li&gt;第三个例子中，与组运算符不同，赋值运算符调用了GetValue方法。返回的结果是函数对象（但不是引用类型），这意味着this设为null，结果是global对象。&lt;/li&gt;
&lt;li&gt;第四个和第五个也是一样——逗号运算符和逻辑运算符（OR）调用了GetValue
方法，相应地，我们失去了引用而得到了函数。并再次设为global。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;正如我们知道的，局部变量、内部函数、形式参数储存在给定函数的激活对象中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
   function bar() {
      alert(this); // global
   }
   bar(); // the same as AO.bar()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;活动对象总是作为this返回，值为null——（即伪代码的AO.bar()相当于null.bar()）。这里我们再次回到上面描述的例子，this设置为全局对象。&lt;/p&gt;

&lt;h3&gt;作用域链&lt;/h3&gt;

&lt;p&gt;通过函构造函数创建的函数的scope属性总是唯一的全局对象。&lt;/p&gt;

&lt;p&gt;一个重要的例外，它涉及到通过函数构造函数创建的函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 10;
function foo() {
   var y = 20;
   function barFD() { // 函数声明
      alert(x);
      alert(y);
   }
   var barFn = Function('alert(x); alert(y);');
   barFD(); // 10, 20
   barFn(); // 10, &quot;y&quot; is not defined
}
foo();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 10, y = 10;

with ({x: 20}) {

  var x = 30, y = 30;
 //这里的 x = 30 覆盖了x = 20；
  alert(x); // 30
  alert(y); // 30
}

alert(x); // 10
alert(y); // 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在进入上下文时发生了什么？标识符“x”和“y”已被添加到变量对象中。此外，在代码运行阶段作如下修改：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;x = 10, y = 10;&lt;/li&gt;
&lt;li&gt;对象{x:20}添加到作用域的前端;&lt;/li&gt;
&lt;li&gt;在with内部，遇到了var声明，当然什么也没创建，因为在进入上下文时，所有变量已被解析添加;&lt;/li&gt;
&lt;li&gt;在第二步中，仅修改变量“x”，实际上对象中的“x”现在被解析，并添加到作用域链的最前端，“x”为20，变为30;&lt;/li&gt;
&lt;li&gt;同样也有变量对象“y”的修改，被解析后其值也相应的由10变为30;&lt;/li&gt;
&lt;li&gt;此外，在with声明完成后，它的特定对象从作用域链中移除（已改变的变量“x”－－30也从那个对象中移除），即作用域链的结构恢复到with得到加强以前的状态。&lt;/li&gt;
&lt;li&gt;在最后两个alert中，当前变量对象的“x”保持同一，“y”的值现在等于30，在with声明运行中已发生改变。&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;函数&lt;/h3&gt;

&lt;p&gt;关于圆括号的问题&lt;/p&gt;

&lt;p&gt;让我们看下这个问题：‘
为何在函数创建后的立即调用中必须用圆括号来包围它？’，答案就是：表达式句子的限制就是这样的。&lt;/p&gt;

&lt;p&gt;按照标准，表达式语句不能以一个大括号 {
开始是因为他很难与代码块区分，同样，他也不能以函数关键字开始，因为很难与函数声明进行区分。即，所以，如果我们定义一个立即执行的函数，在其创建后立即按以下方式调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function () {
  ...
}();

// 即便有名称

function foo() {
  ...
}();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们使用了函数声明，上述2个定义，解释器在解释的时候都会报错，但是可能有多种原因。如果在全局代码里定义（也就是程序级别），解释器会将它看做是函数声明，因为他是以function关键字开头，第一个例子，我们会得到SyntaxError错误，是因为函数声明没有名字（我们前面提到了函数声明必须有名字）。第二个例子，我们有一个名称为foo的一个函数声明正常创建，但是我们依然得到了一个语法错误——没有任何表达式的分组操作符错误。在函数声明后面他确实是一个分组操作符，而不是一个函数调用所使用的圆括号。所以如果我们声明如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// &quot;foo&quot; 是一个函数声明，在进入上下文的时候创建
alert(foo); // 函数
function foo(x) {
   alert(x);
}(1); // 这只是一个分组操作符，不是函数调用！
foo(10); // 这才是一个真正的函数调用，结果是10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建表达式最简单的方式就是用分组操作符括号，里边放入的永远是表达式，所以解释器在解释的时候就不会出现歧义。在代码执行阶段这个的function就会被创建，并且立即执行，然后自动销毁（如果没有引用的话）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function foo(x) {
    alert(x);
})(1); // 这才是调用，不是分组操作符
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码就是我们所说的在用括号括住一个表达式，然后通过（1）去调用。注意，下面一个立即执行的函数，周围的括号不是必须的，因为函数已经处在表达式的位置，解析器知道它处理的是在函数执行阶段应该被创建的FE，这样在函数创建后立即调用了函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var foo = {
    bar: function (x) {
        return x % 2 != 0 ? 'yes' : 'no';
    }(1)
};

alert(foo.bar); // 'yes'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就像我们看到的，foo.bar是一个字符串而不是一个函数，这里的函数仅仅用来根据条件参数初始化这个属性——它创建后并立即调用。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;因此，”关于圆括号”问题完整的答案如下：
当函数不在表达式的位置的时候，分组操作符圆括号是必须的——也就是手工将函数转化成FE。
如果解析器知道它处理的是FE，就没必要用圆括号。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;自由变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function testFn() {
   var localVar = 10;//对于innerFn函数来说，localVar就属于自由变量。
   function innerFn(innerParam) {
      alert(innerParam + localVar);
   }
   return innerFn;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;闭包的静态作用域：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums js&quot;&gt;
var z = 10;
 
function foo() {
  alert(z);
}
 
foo(); // 10 – 使用静态和动态作用域的时候
 
(function () {
  var z = 20;
  foo(); // 10 – 使用静态作用域, 20 – 使用动态作用域
})();
 
// 将foo作为参数的时候是一样的
(function (funArg) {
    var z = 30;
    funArg(); // 10 – 静态作用域, 30 – 动态作用域
})(foo);
&lt;/pre&gt;


&lt;p&gt;&lt;strong&gt;理论&lt;/strong&gt;：因为作用域链，使得所有的函数都是闭包（与函数类型无关：匿名函数，FE，NFE，FD都是闭包）。&lt;br/&gt;
&lt;strong&gt;从实践角度&lt;/strong&gt;：以下函数才算是闭包：&lt;/p&gt;

&lt;p&gt;* 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）&lt;br/&gt;
* 在代码中引用了自由变量&lt;/p&gt;

&lt;h2&gt;最后：&lt;/h2&gt;

&lt;p&gt;ECMAScript是一种面向对象语言，支持基于原型的委托式继承。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>加速你的Python代码</title>
   <link href="http://beango.github.com/archives/2013/03/25/speeding-up-your-python-code.html"/>
   <updated>2013-03-25T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/03/25/speeding-up-your-python-code</id>
   <content type="html">&lt;p&gt;来源：&lt;a href=&quot;http://www.oschina.net/translate/speeding-up-your-python-code&quot;&gt;oschina&lt;/a&gt;,英文原文：&lt;a href=&quot;http://maxburstein.com/blog/speeding-up-your-python-code/&quot; title=&quot;Speeding Up Your Python Code&quot;&gt;Speeding Up Your Python Code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在我看来，python社区分为了三个流派，分别是python2.x组织，3.x组织和PyPy组织。这个分类基本上可以归根于类库的兼容性和速度。这篇文章将聚焦于一些通用代码的优化技巧以及编译成C后性能的显著提升，当然我也会给出三大主要python流派运行时间。我的目的不是为了证明一个比另一个强，只是为了让你知道如何在不同的环境下使用这些具体例子作比较。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用生成器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个普遍被忽略的内存优化是生成器的使用。生成器让我们创建一个函数一次只返回一条记录，而不是一次返回所有的记录，如果你正在使用python2.x，这就是你为啥使用xrange替代range或者使用ifilter替代filter的原因。一个很好地例子就是创建一个很大的列表并将它们拼合在一起。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import timeit
import random

def generate(num):
    while num:
        yield random.randrange(10)
        num -= 1

def create_list(num):
    numbers = []
    while num:
        numbers.append(random.randrange(10))
        num -= 1
    return numbers

print(timeit.timeit(&quot;sum(generate(999))&quot;, setup=&quot;from __main__ import generate&quot;, number=1000))
&amp;gt;&amp;gt;&amp;gt; 0.88098192215 #Python 2.7
&amp;gt;&amp;gt;&amp;gt; 1.416813850402832 #Python 3.2
print(timeit.timeit(&quot;sum(create_list(999))&quot;, setup=&quot;from __main__ import create_list&quot;, number=1000))
&amp;gt;&amp;gt;&amp;gt; 0.924163103104 #Python 2.7
&amp;gt;&amp;gt;&amp;gt; 1.5026731491088867 #Python 3.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这不仅是快了一点，也避免了你在内存中存储全部的列表!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ctypes的介绍&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于关键性的性能代码python本身也提供给我们一个API来调用C方法，主要通过 &lt;a href=&quot;http://docs.python.org/3/library/ctypes.html&quot;&gt;ctypes&lt;/a&gt;来实现，你可以不写任何C代码来利用ctypes。默认情况下python提供了预编译的标准c库，我们再回到生成器的例子，看看使用ctypes实现花费多少时间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import timeit
from ctypes import cdll

def generate_c(num):
    #Load standard C library
    libc = cdll.LoadLibrary(&quot;libc.so.6&quot;) #Linux
    #libc = cdll.msvcrt #Windows
    while num:
        yield libc.rand() % 10
        num -= 1

print(timeit.timeit(&quot;sum(generate_c(999))&quot;, setup=&quot;from __main__ import generate_c&quot;, number=1000))
&amp;gt;&amp;gt;&amp;gt; 0.434374809265 #Python 2.7
&amp;gt;&amp;gt;&amp;gt; 0.7084300518035889 #Python 3.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仅仅换成了c的随机函数，运行时间减了大半！现在如果我告诉你我们还能做得更好，你信吗?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cython的介绍&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cython.org/&quot;&gt;Cython&lt;/a&gt; 是python的一个超集，允许我们调用C函数以及声明变量来提高性能。尝试使用之前我们需要先安装Cython.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo pip install cython
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cython本质上是另一个不再开发的类似类库Pyrex的分支，它将我们的类Python代码编译成C库，我们可以在一个python文件中调用。对于你的python文件使用.pyx后缀替代.py后缀，让我们看一下使用Cython如何来运行我们的生成器代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cython_generator.pyx
import random

def generate(num):
    while num:
        yield random.randrange(10)
        num -= 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们需要创建个setup.py以便我们能获取到Cython来编译我们的函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from distutils.core import setup
from distutils.extension import Extension
from Cython.Distutils import build_ext

setup(
    cmdclass = {'build_ext': build_ext},
    ext_modules = [Extension(&quot;generator&quot;, [&quot;cython_generator.pyx&quot;])]
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译使用:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python setup.py build_ext --inplace
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你应该可以看到两个文件cython_generator.c 文件 和 generator.so文件，我们使用下面方法测试我们的程序:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import timeit
print(timeit.timeit(&quot;sum(generator.generate(999))&quot;, setup=&quot;import generator&quot;, number=1000))
&amp;gt;&amp;gt;&amp;gt; 0.835658073425
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还不赖，让我们看看是否还有可以改进的地方。我们可以先声明“num”为整形，接着我们可以导入标准的C库来负责我们的随机函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cython_generator.pyx
cdef extern from &quot;stdlib.h&quot;:
    int c_libc_rand &quot;rand&quot;()

def generate(int num):
    while num:
        yield c_libc_rand() % 10
        num -= 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们再次编译运行我们会看到这一串惊人的数字。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 0.033586025238
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仅仅的几个改变带来了不赖的结果。然而，有时这个改变很乏味，因此让我们来看看如何使用规则的python来实现吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PyPy的介绍&lt;/strong&gt;&lt;a href=&quot;http://pypy.org/index.html&quot;&gt;PyPy&lt;/a&gt; 是一个Python2.7.3的&lt;a href=&quot;http://en.wikipedia.org/wiki/Just-in-time_compilation&quot;&gt;即时编译器&lt;/a&gt;，通俗地说这意味着让你的代码运行的更快。&lt;a href=&quot;http://www.quora.com/Alex-Gaynor/Posts/Quora-is-now-running-on-PyPy&quot;&gt;Quora&lt;/a&gt;在生产环境中使用了PyPy。PyPy在它们的下载页面有一些安装说明，但是如果你使用的Ubuntu系统，你可以通过apt-get来安装。它的运行方式是立即可用的，因此没有疯狂的bash或者运行脚本，只需下载然后运行即可。让我们看看我们原始的生成器代码在PyPy下的性能如何。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import timeit
import random

def generate(num):
    while num:
        yield random.randrange(10)
        num -= 1

def create_list(num):
    numbers = []
    while num:
        numbers.append(random.randrange(10))
        num -= 1
    return numbers

print(timeit.timeit(&quot;sum(generate(999))&quot;, setup=&quot;from __main__ import generate&quot;, number=1000))
&amp;gt;&amp;gt;&amp;gt; 0.115154981613 #PyPy 1.9
&amp;gt;&amp;gt;&amp;gt; 0.118431091309 #PyPy 2.0b1
print(timeit.timeit(&quot;sum(create_list(999))&quot;, setup=&quot;from __main__ import create_list&quot;, number=1000))
&amp;gt;&amp;gt;&amp;gt; 0.140175104141 #PyPy 1.9
&amp;gt;&amp;gt;&amp;gt; 0.140514850616 #PyPy 2.0b1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;哇！没有修改一行代码运行速度是纯python实现的8倍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进一步测试&lt;/strong&gt;为什么还要进一步研究？PyPy是冠军！并不全对。虽然大多数程序可以运行在PyPy上，但是还是有一些库没有被完全支持。而且，为你的项目写C的扩展相比换一个编译器更加容易。让我们更加深入一些，看看ctypes如何让我们使用C来写库。我们来测试一下归并排序和计算斐波那契数列的速度。下面是我们要用到的C代码（functions.c）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* functions.c */
#include &quot;stdio.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;string.h&quot;

/* http://rosettacode.org/wiki/Sorting_algorithms/Merge_sort#C */
inline
void merge(int *left, int l_len, int *right, int r_len, int *out)
{
    int i, j, k;
    for (i = j = k = 0; i &amp;lt; l_len &amp;amp;&amp;amp; j &amp;lt; r_len; )
        out[k++] = left[i] &amp;lt; right[j] ? left[i++] : right[j++];

    while (i &amp;lt; l_len) out[k++] = left[i++];
    while (j &amp;lt; r_len) out[k++] = right[j++];
}

/* inner recursion of merge sort */
void recur(int *buf, int *tmp, int len)
{
    int l = len / 2;
    if (len &amp;lt;= 1) return;

    /* note that buf and tmp are swapped */
    recur(tmp, buf, l);
    recur(tmp + l, buf + l, len - l);

    merge(tmp, l, tmp + l, len - l, buf);
}

/* preparation work before recursion */
void merge_sort(int *buf, int len)
{
    /* call alloc, copy and free only once */
    int *tmp = malloc(sizeof(int) * len);
    memcpy(tmp, buf, sizeof(int) * len);

    recur(buf, tmp, len);

    free(tmp);
}

int fibRec(int n){
    if(n &amp;lt; 2)
        return n;
    else
        return fibRec(n-1) + fibRec(n-2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Linux平台，我们可以用下面的方法把它编译成一个共享库：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -Wall -fPIC -c functions.c
gcc -shared -o libfunctions.so functions.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用ctypes，通过加载”libfunctions.so”这个共享库，就像我们前边对标准C库所作的那样，就可以使用这个库了。这里我们将要比较Python实现和C实现。现在我们开始计算斐波那契数列：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# functions.py
from ctypes import *
import time

libfunctions = cdll.LoadLibrary(&quot;./libfunctions.so&quot;)

def fibRec(n):
    if n &amp;lt; 2:
        return n
    else:
        return fibRec(n-1) + fibRec(n-2)

start = time.time() 
fibRec(32)
finish = time.time()
print(&quot;Python: &quot; + str(finish - start))

#C Fibonacci
start = time.time() 
x = libfunctions.fibRec(32)
finish = time.time()
print(&quot;C: &quot; + str(finish - start))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;label /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Python: 1.18783187866 #Python 2.7
Python: 1.272292137145996 #Python 3.2
Python: 0.563600063324 #PyPy 1.9
Python: 0.567229032516 #PyPy 2.0b1
C: 0.043830871582 #Python 2.7 + ctypes
C: 0.04574108123779297 #Python 3.2 + ctypes
C: 0.0481240749359 #PyPy 1.9 + ctypes
C: 0.046403169632 #PyPy 2.0b1 + ctypes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如我们预料的那样，C比Python和PyPy更快。我们也可以用同样的方式比较归并排序。&lt;/p&gt;

&lt;p&gt;我们还没有深挖Cypes库，所以这些例子并没有反映python强大的一面，Cypes库只有少量的标准类型限制，比如int型，char数组，float型，字节（bytes）等等。默认情况下，没有整形数组，然而通过与c_int相乘（ctype为int类型）我们可以间接获得这样的数组。这也是代码第7行所要呈现的。我们创建了一个c_int数组，有关我们数字的数组并分解打包到c_int数组中&lt;/p&gt;

&lt;p&gt;主要的是c语言不能这样做，而且你也不想。我们用指针来修改函数体。为了通过我们的c_numbers的数列，我们必须通过引用传递merge_sort功能。运行merge_sort后，我们利用c_numbers数组进行排序，我已经把下面的代码加到我的functions.py文件中了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Python Merge Sort
from random import shuffle, sample

#Generate 9999 random numbers between 0 and 100000
numbers = sample(range(100000), 9999)
shuffle(numbers)
c_numbers = (c_int * len(numbers))(*numbers)

from heapq import merge

def merge_sort(m):
    if len(m) &amp;lt;= 1:
        return m

    middle = len(m) // 2
    left = m[:middle]
    right = m[middle:]

    left = merge_sort(left)
    right = merge_sort(right)
    return list(merge(left, right))

start = time.time()
numbers = merge_sort(numbers)
finish = time.time()
print(&quot;Python: &quot; + str(finish - start))

#C Merge Sort
start = time.time()
libfunctions.merge_sort(byref(c_numbers), len(numbers))
finish = time.time()
print(&quot;C: &quot; + str(finish - start))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;label /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Python: 0.190635919571 #Python 2.7
Python: 0.11785483360290527 #Python 3.2
Python: 0.266992092133 #PyPy 1.9
Python: 0.265724897385 #PyPy 2.0b1
C: 0.00201296806335 #Python 2.7 + ctypes
C: 0.0019741058349609375 #Python 3.2 + ctypes
C: 0.0029308795929 #PyPy 1.9 + ctypes
C: 0.00287103652954 #PyPy 2.0b1 + ctypes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这儿通过表格和图标来比较不同的结果。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/speeding-up-your-python-code.jpg&quot; title=&quot;加速你的Python代码&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/speeding-up-your-python-code.jpg&quot; title=&quot;加速你的Python代码&quot; alt=&quot;加速你的Python代码&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;table border=&quot;1&quot; style=&quot;width:100%;text-align:center;&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Merge Sort&lt;/th&gt;
&lt;th&gt;Fibonacci&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;Python 2.7&lt;/th&gt;
&lt;td&gt;0.191&lt;/td&gt;
&lt;td&gt;1.187&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;Python 2.7 + ctypes&lt;/th&gt;
&lt;td&gt;0.002&lt;/td&gt;
&lt;td&gt;0.044&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;Python 3.2&lt;/th&gt;
&lt;td&gt;0.118&lt;/td&gt;
&lt;td&gt;1.272&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;Python 3.2 + ctypes&lt;/th&gt;
&lt;td&gt;0.002&lt;/td&gt;
&lt;td&gt;0.046&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;PyPy 1.9&lt;/th&gt;
&lt;td&gt;0.267&lt;/td&gt;
&lt;td&gt;0.564&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;PyPy 1.9 + ctypes&lt;/th&gt;
&lt;td&gt;0.003&lt;/td&gt;
&lt;td&gt;0.048&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;PyPy 2.0b1&lt;/th&gt;
&lt;td&gt;0.266&lt;/td&gt;
&lt;td&gt;0.567&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;PyPy 2.0b1 + ctypes&lt;/th&gt;
&lt;td&gt;0.003&lt;/td&gt;
&lt;td&gt;0.046&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;希望你利用C和PyPy优化你的python代码并以此为敲门砖找到一个好职位。像往常一样如果你有任何意见或问题，请随时把评论下载下面或者在我的网页上与我取得联系。感谢您的阅读！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>可扩展Web架构与分布式系统</title>
   <link href="http://beango.github.com/archives/2013/03/22/scalable-web-architecture-and-distributed-systems.html"/>
   <updated>2013-03-22T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/03/22/scalable-web-architecture-and-distributed-systems</id>
   <content type="html">&lt;p&gt;英文原文：&lt;a href=&quot;http://www.aosabook.org/en/distsys.html#&quot;&gt;Scalable Web Architecture and Distributed Systems&lt;/a&gt;，翻译：&lt;a href=&quot;http://www.oschina.net/translate/scalable-web-architecture-and-distributed-systems&quot;&gt;oschina&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　开放源代码已经成为一些大型网站的基本原则。而在这些网站成长的过程中，一些优秀的实践经验和规则也出现在他们的结构中。本文旨在介绍一些在大型网站结构设计的过程中需要注意的关键问题以及实现目标的基础工作。&lt;/p&gt;

&lt;p&gt;本文侧重于介绍网络系统，尽管一些准则在其他分布式系统中也是适用的。&lt;/p&gt;

&lt;h2&gt;1.1. web分布式系统的设计原则&lt;/h2&gt;

&lt;p&gt;　　搭建和运营一个可伸缩的web站点或者应用程序意味着什么？在原始层面上这仅仅是用户通过互联网连接到远程资源-使系统变得可伸缩的部分是将资源、或者访问的资源，分布于多个服务器上。&lt;/p&gt;

&lt;p&gt;　　像生活中大多数事情一样，当构建一个web服务时花时间提前做好计划从长远看来还是很有帮助的；了解一些注意事项和大网站背后的权衡原则可以在创建小型网站时做出更明智的决定。以下是一些影响大规模web系统设计的关键原则:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可用性:&lt;/strong&gt;对于很多公司来说一个网站的正常运行时间是非常关键的声誉和功能，像一些大型的在线零售系统，即使一分钟的宕机都有可能导致数千或者数百万美元的损失，因此设计系统的时时可用性和弹性的错误处理机制既是一个基本业务也是一个技术要求。
高可用分布式系统需要仔细考虑关键组件的冗余，分系统失败后能快速修复，并且当问题出现时优雅型降级。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能:&lt;/strong&gt;网站的性能正在变成大多数站点考虑的一个重要的方面，网站的速度影响正常使用和用户的满意度，同样影响搜索的排名，这也是影响网站收益和保留用户的一个因素。因此，创建一个快速响应和低延迟的系统是非常关键的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可靠性:&lt;/strong&gt;一个系统需要具备可靠性，比如同一个数据的请求始终返回同样的数据响应
。如果数据改变或者被更新，那么同样的数据将返回一个新的数据。用户需要知道一些东西被写入系统或者被存储到系统后，系统会保持不变并且可以在以后恢复到合适的位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可伸缩性:&lt;/strong&gt;当谈到任何大型的分布式系统时，规模大小只是考虑的其中一个方面，同样重要的是增强处理较大规模的负载性能所做的努力，这通常称为系统的可伸缩性。可伸缩性可以代表系统很多不同的参数：额外流量的处理量，添加存储容量的便意性，甚至事务的处理量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可管理性:&lt;/strong&gt; 设计一个系统可以方便操作是另一个重要的考虑方面，系统的可管理性等同于操作的可伸缩性：维护和升级。可管理性需要考虑的事情是当问题发生时方便诊断和了解问题，易于升级和修改，以及系统能简单性的操作（即，例行的操作有没有失败和异常？）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成本:&lt;/strong&gt; 成本是一个重要的因素。很明显这包含硬件和软件成本，但同样重要需要考虑的其他方面是部署和维护系统的成本。开发者构建系统花费的大量时间，运维部署时间，甚至培训时间都需要考虑，成本是总体成本。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　以上每个原则都为设计分布式web架构提供了基础决策。然而，他们也能彼此互斥，例如要实现某个目标就要以另外的作为代价。一个基本的例子：选择通过单纯增加更多的服务器（可扩展性）来增加地址容量，是以可管理性（你必须操作增加的服务器）和成本（服务器的价格）为代价的。&lt;/p&gt;

&lt;p&gt;　　当设计任何的web应用程序时，考虑这些关键原则都是很重要的，即使得承认一个设计可能要牺牲它们之中的一个或者多个。&lt;/p&gt;

&lt;h2&gt;1.2. 基础&lt;/h2&gt;

&lt;p&gt;　　当设计一个系统架构时，有一些东西是要考虑的：正确的部分是什么，怎样让这些部分很好地融合在一起，以及好的折中方法是什么。通常在系统架构需要之前就为它的可扩展性投资不是一个聪明的商业抉择；然而，在设计上的深谋远虑能在未来节省大量的时间和资源。&lt;/p&gt;

&lt;p&gt;　　这部分关注点是几乎所有大型web应用程序中心的一些核心因素：服务、冗余、划分和错误处理。每一个因素都包含了选择和妥协，特别是上部分提到的设计原则。为了详细的解析这些，最好是用一个例子来开始。&lt;/p&gt;

&lt;h2&gt;实例：图片托管应用&lt;/h2&gt;

&lt;p&gt;　　有时候你可能会在线上传一张图片。对于那些托管并负责分发大量图片的网站来说，要搭建一个既节省成本又高效还能具备较低的延迟性（你能快速的获图片）的网站架构确实是一种挑战。&lt;/p&gt;

&lt;p&gt;　　我们来假设一个系统，用户可以上传他们的图片到中心服务器，这些图片又能够让一些web链接或者API获取这些图片，就如同现在的Flickr或者Picasa。为了简化的需要，我们假设应用程序分为两个主要的部分：一个是上传图片到服务器的能力（通常说的写操作），另一个是查询一个图片的能力。然而，我们当然想上传功能很高效，但是我们更关心的是能够快速分发能力，也就是说当某个人请求一个图片的时候（比如，一个web页面或者其它应用程序请求图片）能够快速的满足。这种分发能力很像web服务器或者CDN连接服务器（CDN服务器一般用来在多个位置存储内容一边这些内容能够从地理位置或者物理上更靠近访问它的用户，已达到高效访问的目的）气的作用。&lt;/p&gt;

&lt;p&gt;系统其他重要方面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对图片存储的数量没有限制，所以存储需要可扩展，在图像数量方面需要考虑。&lt;/li&gt;
&lt;li&gt;图片的下载和请求不需要低延迟。&lt;/li&gt;
&lt;li&gt;如果用户上传一个图片，图片应该都在那里（图片数据的可靠性）。&lt;/li&gt;
&lt;li&gt;系统应该容易管理（可管理性）。&lt;/li&gt;
&lt;li&gt;由于图片主机不会有高利润的空间，所以系统需要具有成本效益。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Figure 1.1是一个简化的功能图。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-01.jpg&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-01.jpg&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 1.1: 图片主机应用的简化架构图&lt;/center&gt;


&lt;p&gt;　　在这个图片主机的例子里，可遇见系统必需快速，它的数据存储要可靠以及这些所有的属性都应该高度的可扩展。建立这个应用程序的一个小版本不是很重要而且很容易部署在单一的服务器上；然而，这不是这节里的感兴趣部分。假设下我们想建一个会增长到和Flickr痛让规模的东西。&lt;/p&gt;

&lt;h3&gt;服务&lt;/h3&gt;

&lt;p&gt;　　当要考虑设计一个可扩展的系统时，为功能解耦和考虑下系统每部分的服务都定义一个清晰的接口都是很有帮助的。在实际中，在这种方式下的系统设计被成为面向服务架构（SOA）。对于这类型的系统，每个服务有自己独立的方法上下文，以及使用抽象接口与上下文的外部任何东西进行交互，典型的是别的服务的公共API。&lt;/p&gt;

&lt;p&gt;　　把一个系统解构为一些列互补的服务，能够为这些部分从别的部分的操作解耦。这样的抽象帮助在这些服务服、它的基础环境和服务的消费者之间建立清晰的关系。建立这种清晰的轮廓能帮助隔离问题，但也允许各模块相对其它部分独立扩展。这类面向服务设计系统是非常类似面向对象设计编程的。&lt;/p&gt;

&lt;p&gt;在我们的例子中，上传和检索图像的请求都是由同一个服务器处理的；然而，因为系统需要具有伸缩性，有理由要将这两个功能分解为各由自己的服务进行处理。&lt;/p&gt;

&lt;p&gt;　　快速转发（Fast-forward）假定服务处于大量使用中；在这种情况下就很容易看到，读取图像所花的时间中有多少是由于受到了写入操作的影响（因为这两个功能将竞争使用它们共享的资源）。取决于所采用的体系结构，这种影响可能是巨大的。即使上传和下载的速度完全相同（在绝大多数IP网络中都不是这样的情况，大部分下载速度和上传速度之比都至少设计为3:1），文件读取操作一般都是从高速缓存中进行的，而写操作却不得不进行最终的磁盘操作（而且可能要写几次才能达成最后的一致状态）。即使所有内容都已在内存中，或者从磁盘（比如SSD磁盘）中进行读取，数据库写入操作几乎往往都要慢于读取操作。（Pole Position是一个开源的DB基准测试工具，&lt;a href=&quot;http://polepos.org/&quot;&gt;http://polepos.org/&lt;/a&gt;，测试结果参见 &lt;a href=&quot;http://polepos.sourceforge.net/results/PolePositionClientServer.pdf&quot;&gt;http://polepos.sourceforge.net/results/PolePositionClientServer.pdf&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;　　这种设计另一个潜在的问题出在web服务器上，像Apache或者lighttpd通常都有一个能够维持的并发连接数上限（默认情况下在500左右，不过可以更高）和最高流量数，它们会很快被写操作消耗掉。因为读操作可以异步进行，或者采用其它一些像gizp压缩的性能优化或者块传输编码方式，web服务器可以通过在多个请求服务之间切换来满足比最大连接数更多的请求（一台Apache的最大连接数设置为500，它每秒钟提供近千次读请求服务也是正常的）。写操作则不同，它需要在上传过程中保持连接，所以大多数家庭网络环境下，上传一个1MB的文件可能需要超过1秒的时间，所以web服务器只能处理500个这样并发写操作请求。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-02.png&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-02.png&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　对于这种瓶颈，一个好的规划案例是将读取和写入图片分离为两个独立的服务，如图Figure1.2.所示。这让我们可以单独的扩展其中任意一个（因为有可能我们读操作比写操作要频繁很多），同时也有助于我们理清每个节点在做什么。最后，这也避免了未来的忧虑，这使得故障诊断和查找问题更简单，像慢读问题。&lt;/p&gt;

&lt;p&gt;　　这种方法的优点是我们能够单独的解决各个模块的问题-我们不用担心写入和检索新图片在同一个上下文环境中。这两种服务仍然使用全球资料库的图片，但是它们可通过适当的服务接口自由优化它们自己的性能（比如，请求队列，或者缓存热点图片-在这之上的优化）。从维护和成本角度来看，每个服务按需进行独立规模的规划，这点非常有用，试想如果它们都组合混杂在一起，其中一个无意间影响到了性能，另外的也会受影响。&lt;/p&gt;

&lt;p&gt;　　当然，上面的例子在你使用两个不同端点时可以很好的工作（事实上，这非常类似于云存储和内容分发网络）。虽然有很多方式来解决这样的瓶颈，但每个都有各自的取舍。&lt;/p&gt;

&lt;p&gt;　　比如，Flickr通过分配用户访问不同的分片解决这类读/写问题，每一个分片只可以处理一定数量的用户，随着用户的增加更多的分片被添加到集群上（参看“Flickr缩影”的描述&lt;a href=&quot;http://mysqldba.blogspot.com/2008/04/mysql-uc-2007-presentation-file.html&quot;&gt;http://mysqldba.blogspot.com/2008/04/mysql-uc-2007-presentation-file.html&lt;/a&gt;）。在第一个例子中，可以根据实际用途更简单的规划硬件资源（在整个系统中读和写的比例），然而，Flickr规划是根据用户基数（假定每个用户拥有相同的资源空间）。在前者中一个故障或者问题会导致整个系统功能的下降（比如，全部不能写入文件了），然而Flickr一个分片的故障只会影响到相关的那部分用户。在第一个例子中，更容易操作整个数据集-比如，在所有的图像元数据上更新写入服务用来包含新的元数据或者检索-然而在Flickr架构上每一个分片都需要执行更新或者检索（或者需要创建个索引服务来核对元数据-找出哪一个才是实际结果）。&lt;/p&gt;

&lt;h3&gt;冗余(Redundancy)&lt;/h3&gt;

&lt;p&gt;　　为了优雅的处理故障，web架构必须冗余它的服务和数据。例如，单服务器只拥有单文件的话，文件丢失就意味这永远丢失了。丢失数据是个很糟糕的事情，常见的方法是创建多个或者冗余备份。&lt;/p&gt;

&lt;p&gt;　　同样的原则也适用于服务。如果应用有一个核心功能，确保它同时运行多个备份或者版本可以安全的应对单点故障。&lt;/p&gt;

&lt;p&gt;　　在系统中创建冗余可以消除单点故障，可以在紧急时刻提供备用功能。例如，如果在一个产品中同时运行服务的两个实例，当其中一个发生故障或者降级(degrade)，系统可以转移(&lt;em&gt;failover&lt;/em&gt;)到好的那个备份上。故障转移(Failover)可以自动执行或者人工手动干预。&lt;/p&gt;

&lt;p&gt;　　服务冗余的另一个关键部分是创建无共享(&lt;em&gt;shared-nothing&lt;/em&gt;)架构。采用这种架构，每个接点都可以独立的运作，没有中心”大脑”管理状态或者协调活动。这可以大大提高可伸缩性(scalability)因为新的接点可以随时加入而不需要特殊的条件或者知识。而且更重要的是，系统没有单点故障。所以可以更好的应对故障。&lt;/p&gt;

&lt;p&gt;　　例如，在我们的图片服务应用，所有的图片应该都冗余备份在另外的一个硬件上（理想的情况下，在不同的地理位置，以防数据中心发生大灾难，例如地震，火灾），而且访问图片的服务（见Figure
1.3.）-包括所有潜在的服务请求-也应该冗余。（负载均衡器是个很好的方法冗余服务，但是下面的方法不仅仅是负载均衡）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-03.png&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-03.png&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 1.3: 使用冗余的图片存储&lt;/center&gt;


&lt;h3&gt;分区&lt;/h3&gt;

&lt;p&gt;　　我们可能遇见单一服务器无法存放的庞大数据集。也可能遇到一个需要过多计算资源的操作，导致性能下降，急需增添容量。这些情况下，你都有两种选择：横向或纵向扩展。&lt;/p&gt;

&lt;p&gt;　　纵向扩展意味着对单一服务器增添更多资源。对于一个非常庞大的数据集，这可能意味着为单一服务器增加更多（或更大）的硬盘以存放整个数据集。而对于计算操作，这可能意味着将操作移到一个拥有更快的 CPU 或更大的内存的服务器中。无论哪种情况，纵向扩展都是为了使单个服务器能够自己处理更多的方法。&lt;/p&gt;

&lt;p&gt;　　另一方面，对于横向扩展，则是增加更多的节点。例如庞大的数据集，你可以用第二个服务器来存放部分数据；而对于计算操作，你可以切割计算，或是通过额外的节点加载。想要充分的利用横向扩展的优势，你应该以内在的系统构架设计原则来实现，否则的话，实现的方法将会变成繁琐的修改和切分操作。&lt;/p&gt;

&lt;p&gt;　　说道横向分区，更常见的技术是将你的服务分区，或分片。分区可以通过对每个功能逻辑集的分割分配而来;可以通过地域划分，也可以通过类似付费vs.未付费用户来区分。这种方式的优势是可以通过增添容量来运行服务或实现数据存储。&lt;/p&gt;

&lt;p&gt;　　以我们的图像服务器为例，将曾经储存在单一的文件服务器的图片重新保存到多个文件服务器中是可以实现的，每个文件服务器都有自己惟一的图片集。（见图表1.4。）这种构架允许系统将图片保存到某个文件服务器中，在服务器都即将存满时，像增加硬盘一样增加额外的服务器。这种设计需要一种能够将文件名和存放服务器绑定的命名规则。一个图像的名称可能是映射全部服务器的完整散列方案的形式。或者可选的，每个图像都被分配给一个递增的ID，当用户请求图像时，图像检索服务只需要保存映射到每个服务器的 ID
范围（类似索引）就可以了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-04.png&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-04.png&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图 1.4: 使用冗余和分区实现的图片存储服务&lt;/center&gt;


&lt;p&gt;　　当然，为多个服务器分配数据或功能是充满挑战的。一个关键的问题就是&lt;em&gt;数据局部性&lt;/em&gt;；对于分布式系统，计算或操作的数据越相近，系统的性能越佳。因此，一个潜在的问题就是数据的存放遍布多个服务器，当需要一个数据时，它们并不在一起，迫使服务器不得不为从网络中获取数据而付出昂贵的性能代价。&lt;/p&gt;

&lt;p&gt;　　另一个潜在的问题是&lt;em&gt;不一致性&lt;/em&gt;。当多个不同的服务读取和写入同一共享资源时，有可能会遭遇竞争状态——某些数据应当被更新，但读取操作恰好发生在更新之前——这种情形下，数据就是不一致的。例如图像托管方案中可能出现的竞争状态，一个客户端发送请求，将其某标题为“狗”的图像改名为”小家伙“。而同时另一个客户端发送读取此图像的请求。第二个客户端中显示的标题是“狗”还是“小家伙”是不能明确的。&lt;/p&gt;

&lt;p&gt;　　当然，对于分区还有一些障碍存在，但分区允许将问题——数据、负载、使用模式等——切割成可以管理的数据块。这将极大的提高可扩展性和可管理性，但并非没有风险。有很多可以降低风险，处理故障的方法；不过篇幅有限，不再赘述。若有兴趣，可见于&lt;a href=&quot;http://katemats.com/2011/11/13/distributed-systems-basics-handling-failure-fault-tolerance-and-monitoring/&quot;&gt;此文&lt;/a&gt;，获取更多容错和检测的信息。&lt;/p&gt;

&lt;h2&gt;1.3. 构建高效和可伸缩的数据访问模块&lt;/h2&gt;

&lt;p&gt;　　在设计分布式系统时一些核心问题已经考虑到，现在让我们来讨论下比较困难的一部分：可伸缩的数据访问。&lt;/p&gt;

&lt;p&gt;　　对于大多数简单的web应用程序，比如LAMP系统，类似于图 Figure 1.5.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-05.png&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-05.png&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 1.5: 简单web应用程序&lt;/center&gt;


&lt;p&gt;　　随着它们的成长，主要发生了两方面的变化：应用服务器和数据库的扩展。在一个高度可伸缩的应用程序中，应用服务器通常最小化并且一般是shared-nothing架构（译注：shared nothing architecture是一种分布式计算架构，这种架构中不存在集中存储的状态，整个系统中没有资源竞争，这种架构具有非常强的扩张性，在web应用中广泛使用）方式的体现，这使得系统的应用服务器层水平可伸缩。由于这种设计，数据库服务器可以支持更多的负载和服务；在这一层真正的扩展和性能改变开始发挥作用了。&lt;/p&gt;

&lt;p&gt;　　剩下的章节主要集中于通过一些更常用的策略和方法提供快速的数据访问来使这些类型服务变得更加迅捷。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-06.png&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-06.png&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 1.6: Oversimplified web application&lt;/center&gt;


&lt;p&gt;　　大多数系统简化为如图 Figure 1.6所示，这是一个良好的开始。如果你有大量的数据，你想快捷的访问，就像一堆糖果摆放在你办公室抽屉的最上方。虽然过于简化，前面的声明暗示了两个困难的问题：存储的可伸缩性和数据的快速访问。&lt;/p&gt;

&lt;p&gt;　　为了这一节内容，我们假设你有很大的数据存储空间（TB），并且你想让用户随机访问一小部分数据（查看Figure 1.7）。这类似于在图像应用的例子里在文件服务器定位一个图片文件。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-07.png&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-07.png&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 1.7: Accessing specific data&lt;/center&gt;


&lt;p&gt;　　这非常具有挑战性，因为它需要把数TB的数据加载到内存中；并且直接转化为磁盘的IO。要知道从磁盘读取比从内存读取慢很多倍-内存的访问速度如同敏捷的查克·诺里斯（译注：空手道冠军），而磁盘的访问速度就像笨重的卡车一样。这个速度差异在大数据集上会增加更多；在实数顺序读取上内存访问速度至少是磁盘的6倍，随机读取速度比磁盘快100,000倍（参考“大数据之殇”&lt;a href=&quot;http://queue.acm.org/detail.cfm?id=1563874&quot;&gt;http://queue.acm.org/detail.cfm?id=1563874&lt;/a&gt;）。另外，即使使用唯一的ID，解决获取少量数据存放位置的问题也是个艰巨的任务。这就如同不用眼睛看在你的糖果存放点取出最后一块Jolly Rancher口味的糖果一样。&lt;/p&gt;

&lt;p&gt;　　谢天谢地，有很多方式你可以让这样的操作更简单些；其中四个比较重要的是缓存，代理，索引和负载均衡。本章的剩余部分将讨论下如何使用每一个概念来使数据访问加快。&lt;/p&gt;

&lt;h3&gt;缓存&lt;/h3&gt;

&lt;p&gt;　　缓存利用局部访问原则：最近请求的数据可能会再次被请求。它们几乎被用于计算机的每一层：硬件，操作系统，web&lt;a href=&quot;http://blog.jobbole.com/12749/&quot; title=&quot;浏览器&quot;&gt;浏览器&lt;/a&gt;，web应用程序等等。缓存就像短期存储的内存：它有空间的限制，但是通常访问速度比源数据源快并且包含了大多数最近访问的条目。缓存可以在架构的各个层级存在，但是常常在前端比较常见，在这里通常需要在没有下游层级的负担下快速返回数据。&lt;/p&gt;

&lt;p&gt;　　在我们的API例子中如何使用缓存来快速访问数据？在这种情况下，有两个地方你可以插入缓存。一个操作是在你的请求层节点添加一个缓存，如图 Figure 1.8.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-08.png&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-08.png&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 1.8: Inserting a cache on your request layer node&lt;/center&gt;


&lt;p&gt;　　直接在一个请求层节点配置一个缓存可以在本地存储相应数据。每次发送一个请求到服务，如果数据存在节点会快速的返回本地缓存的数据。如果数据不在缓存中，请求节点将在磁盘查找数据。请求层节点缓存可以存放在内存和节点本地磁盘中（比网络存储快些）。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-09.png&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-09.png&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 1.9: Multiple caches&lt;/center&gt;


&lt;p&gt;　　当你扩展这些节点后会发生什么呢？如图Figure 1.9所示，如果请求层扩展为多个节点，每个主机仍然可能有自己的缓存。然而，如果你的负载均衡器随机分配请求到节点，同样的请求将指向不同的节点，从而增加了缓存的命中缺失率。有两种选择可以解决这个问题：全局缓存和分布式缓存。&lt;/p&gt;

&lt;h3&gt;全局缓存&lt;/h3&gt;

&lt;p&gt;　　全局缓存顾名思义：所有的节点使用同一个缓存空间，这涉及到添加一个服务器，或者某种文件存储系统，速度比访问源存储和通过所有节点访问要快些。每个请求节点以同样的方式查询本地的一个缓存，这种缓存方案可能有点复杂，因为在客户端和请求数量增加时它很容易被压倒，但是在有些架构里它还是很有用的（尤其是那些专门的硬件来使全局缓存变得非常快，或者是固定数据集需要被缓存的）。&lt;/p&gt;

&lt;p&gt;　　在描述图中有两种常见形式的缓存。在图Figure 1.10中，当一个缓存响应没有在缓存中找到时，缓存自身从底层存储中查找出数据。在 Figure 1.11中，当在缓存中招不到数据时，请求节点会向底层去检索数据。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-10.png&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-10.png&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 1.10: Global cache where cache is responsible for retrieval&lt;/center&gt;


&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-11.png&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-11.png&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 1.11: Global cache where request nodes are responsible for retrieval&lt;/center&gt;


&lt;p&gt;　　大多数使用全局缓存的应用程序趋向于第一类，这类缓存可以管理数据的读取，防止客户端大量的请求同样的数据。然而，一些情况下，第二类实现方式似乎更有意义。比如，如果一个缓存被用于非常大的文件，一个低命中比的缓存将会导致缓冲区来填满未命中的缓存；在这种情况下，将使缓存中有一个大比例的总数据集。另一个例子是架构设计中文件在缓存中存储是静态的并且不会被排除。（这可能是因为应用程序要求周围数据的延迟-某些片段的数据可能需要在大数据集中非常快-在有些地方应用程序逻辑理清排除策略或者热点 比缓存方案好使些）&lt;/p&gt;

&lt;h3&gt;分布式缓存&lt;/h3&gt;

&lt;p&gt;　　在分布式缓存（图1.12）中，每个节点都会缓存一部分数据。如果把冰箱看作食杂店的缓存的话，那么分布式缓存就象是把你的食物分别放到多个地方
—— 你的冰箱、柜橱&lt;em&gt;以及&lt;/em&gt;便当盒
——放到这些便于随时取用的地方就无需一趟趟跑去食杂店了。缓存一般使用一个具有一致性的哈希函数进行分割，如此便可在某请求节点寻找某数据时，能够迅速知道要到分布式缓存中的哪个地方去找它，以确定改数据是否从缓存中可得。在这种情况下，每个节点都有一个小型缓存，在直接到原数据所作处找数据之前就可以向别的节点发出寻找数据的请求。由此可得，分布式缓存的一个优势就是，仅仅通过向请求池中添加新的节点便可以拥有更多的缓存空间。&lt;/p&gt;

&lt;p&gt;　　分布式缓存的一个缺点是修复缺失的节点。一些分布式缓存系统通过在不同节点做多个备份绕过了这个问题；然而，你可以想象这个逻辑迅速变复杂了，尤其是当你在请求层添加或者删除节点时。即便是一个节点消失和部分缓存数据丢失了，我们还可以在源数据存储地址获取-因此这不一定是灾难性的!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-12.png&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-12.png&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 1.12: Distributed cache&lt;/center&gt;


&lt;p&gt;　　缓存的伟大之处在于它们使我们的访问速度更快了（当然前提是正确使用），你选择的方法要在更多请求下更快才行。然而，所有这些缓存的代价是必须有额外的存储空间，通常在放在昂贵的内存中；从来没有嗟来之食。缓存让事情处理起来更快，而且在高负载情况下提供系统功能，否则将会使服务器出现降级。&lt;/p&gt;

&lt;p&gt;　　有一个很流行的开源缓存项目Memcached (&lt;a href=&quot;http://memcached.org/&quot;&gt;http://memcached.org/&lt;/a&gt;)（它可以当做一个本地缓存，也可以用作分布式缓存）；当然，还有一些其他操作的支持（包括语言包和框架的一些特有设置）。&lt;/p&gt;

&lt;p&gt;　　Memcached被用作很多大型的web站点，尽管他很强大，但也只是简单的内存key-value存储方式，它优化了任意数据存储和快速检索（o(1)）。&lt;/p&gt;

&lt;p&gt;　　Facebook使用了多种不同的缓存来提高他们站点的性能（查看”&lt;a href=&quot;http://sizzo.org/talks/&quot;&gt;Facebook caching and performance”&lt;/a&gt;）。在语言层面上（使用PHP内置函数调用）他们使用\$GLOBALSand APC缓存，这有助于使中间函数调用和结果返回更快（大多数语言都有这样的类库用来提高web页面的性能）。Facebook使用的全局缓存分布在多个服务器上（查看 ”&lt;a href=&quot;http://www.facebook.com/note.php?note_id=39391378919&quot;&gt;Scaling memcached at Facebook”&lt;/a&gt;），这样一个访问缓存的函数调用可以使用很多并行的请求在不同的Memcached服务器上获取存储的数据。这使得他们在为用户分配数据空间时有了更高的性能和吞吐量，同时有一个中央服务器做更新（这非常重要，因为当你运行上千服务器时，缓存失效和一致性将是一个大挑战）。&lt;/p&gt;

&lt;p&gt;　　现在让我们讨论下当数据不在缓存中时该如何处理···&lt;/p&gt;

&lt;h3&gt;代理&lt;/h3&gt;

&lt;p&gt;　　简单来说，代理服务器是一种处于客户端和服务器中间的硬件或软件，它从客户端接收请求，并将它们转交给服务器。代理一般用于过滤请求、记录日志或对请求进行转换(增加/删除头部、加密/解密、压缩，等等)。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-13.png&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-13.png&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图1.13: 代理服务器&lt;/center&gt;


&lt;p&gt;　　当需要协调来自多个服务器的请求时，代理服务器也十分有用，它允许我们从整个系统的角度出发、对请求流量执行优化。压缩转发(collapsed forwarding)是利用代理加快访问的其中一种方法，将多个相同或相似的请求压缩在同一个请求中，然后将单个结果发送给各个客户端。&lt;/p&gt;

&lt;p&gt;　　假设，有几个节点都希望请求同一份数据，而且它并不在缓存中。在这些请求经过代理时，代理可以通过压缩转发技术将它们合并成为一个请求，这样一来，数据只需要从磁盘上读取一次即可(见图1.14)。这种技术也有一些缺点，由于每个请求都会有一些时延，有些请求会由于等待与其它请求合并而有所延迟。不管怎么样，这种技术在高负载环境中是可以帮助提升性能的，特别是在同一份数据被反复访问的情况下。压缩转发有点类似缓存技术，只不过它并不对数据进行存储，而是充当客户端的代理人，对它们的请求进行某种程度的优化。&lt;/p&gt;

&lt;p&gt;　　在一个LAN代理服务器中，客户端不需要通过自己的IP连接到Internet，而代理会将请求相同内容的请求合并起来。这里比较容易搞混，因为许多代理同时也充当缓存(这里也确实是一个很适合放缓存的地方)，但缓存却不一定能当代理。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-14.png&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-14.png&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图1.14: 通过代理来合并请求&lt;/center&gt;


&lt;p&gt;　　另一个使用代理的方式不只是合并相同数据的请求，同时也可以用来合并靠近存储源（一般是磁盘）的数据请求。采用这种策略可以让请求最大化使用本地数据，这样可以减少请求的数据延迟。比如，一群节点请求B部分信息：partB1,partB2等，我们可以设置代理来识别各个请求的空间区域，然后把它们合并为一个请求并返回一个bigB，大大减少了读取的数据来源（查看图Figure 1.15）。当你随机访问上TB数据时这个请求时间上的差异就非常明显了！代理在高负载情况下，或者限制使用缓存时特别有用，因为它基本上可以批量的把多个请求合并为一个。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-15.png&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-15.png&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 1.15: Using a proxy to collapse requests for data that is spatially close together&lt;/center&gt;


&lt;p&gt;　　值得注意的是，代理和缓存可以放到一起使用，但通常最好把缓存放到代理的前面，放到前面的原因和在参加者众多的马拉松比赛中最好让跑得较快的选手在队首起跑一样。因为缓存从内存中提取数据，速度飞快，它并不介意存在对同一结果的多个请求。但是如果缓存位于代理服务器的另一边，那么在每个请求到达cache之前都会增加一段额外的时延，这就会影响性能。&lt;/p&gt;

&lt;p&gt;　　如果你正想在系统中添加代理，那你可以考虑的选项有很多；&lt;a href=&quot;http://www.squid-cache.org/&quot;&gt;Squid&lt;/a&gt;和&lt;a href=&quot;https://www.varnish-cache.org/&quot;&gt;Varnish&lt;/a&gt;都经过了实践检验，广泛用于很多实际的web站点中。这些代理解决方案针对大部分client－server通信提供了大量的优化措施。将二者之中的某一个安装为web服务器层的反向代理（reverse proxy，下面负载均衡器一节中解释）可以大大提高web服务器的性能，减少处理来自客户端的请求所需的工作量。&lt;/p&gt;

&lt;h3&gt;索引&lt;/h3&gt;

&lt;p&gt;　　使用索引快速访问数据是个优化数据访问性能公认的策略；可能我们大多数人都是从数据库了解到的索引。索引用增长的存储空间占用和更慢的写（因为你必须写和更新索引）来换取更快的读取。&lt;/p&gt;

&lt;p&gt;　　你可以把这个概念应用到大数据集中就像应用在传统的关系数据存储。索引要关注的技巧是你必须仔细考虑用户会怎样访问你的数据。如果数据集有很多TBs，但是每个数据包(payload)很小(可能只有1KB)，这时就必须用索引来优化数据访问。在这么大的数据集找到小的数据包是个很有挑战性的工作因为你不可能在合理的时间內遍历所有数据。甚至，更有可能的是这么大的数据集分布在几个（甚至很多个）物理设备上-这意味着你要用些方法找到期望数据的正确物理位置。索引是最适合的方法做这种事情。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-16.jpg&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-16.jpg&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 1.16: Indexes&lt;/center&gt;


&lt;p&gt;　　索引可以作为内容的一个表格-表格的每一项指明你的数据存储的位置。例如，如果你正在查找B的第二部分数据-你如何知道去哪里找？如果你有个根据数据类型(数据A，B，C)排序的索引，索引会告诉你数据B的起点位置。然后你就可以跳转(seek)到那个位置，读取你想要的数据B的第二部分。(See Figure 1.16.)&lt;/p&gt;

&lt;p&gt;　　这些索引常常存储在内存中，或者存储在对于客户端请求来说非常快速的本地位置(somewhere very local)。Berkeley DBs (BDBs)和树状数据结构常常按顺序存储数据，非常理想用来存储索引。&lt;/p&gt;

&lt;p&gt;　　常常索引有很多层，当作数据地图，把你从一个地方指向另外一个地方，一直到你的得到你想要的那块数据。(See Figure 1.17.)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-17.jpg&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-17.jpg&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 1.17: Many layers of indexes&lt;/center&gt;


&lt;p&gt;　　索引也可以用来创建同样数据的多个不同视图(views)。对于大数据集来说，这是个很棒的方法来定义不同的过滤器(filter)和类别(sort)，而不用创建多个额外的数据拷贝。&lt;/p&gt;

&lt;p&gt;　　例如，想象一下，图片存储系统开始实际上存储的是书的每一页的图像，而且服务允许客户查询这些图片中的文字，搜索每个主题的所有书的内容，就像搜索引擎允许你搜索HTML内容一样。在这种情况下，所有的书的图片占用了很多很多服务器存储，查找其中的一页给用户显示有点难度。首先，用来查询任意词或者词数组(tuples)的倒排索引(inverse indexes)需要很容易的访问到；然后，导航到那本书的确切页面和位置并获取准确的图片作为返回结果，也有点挑战性。所以，这种境况下，倒排索引应该映射到每个位置(例如书B)，然后B要包含一个索引每个部分所有单词，位置和出现次数的索引。&lt;/p&gt;

&lt;p&gt;可以表示上图Index1的一个倒排索引，可能看起来像下面的样子-每个词或者词数组对应一个包含他们的书。&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;Word(s)&lt;/th&gt;
&lt;th&gt;Book(s)&lt;/th&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;being awesome&lt;/td&gt;
&lt;td&gt;Book B, Book C, Book D&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;always&lt;/td&gt;
&lt;td&gt;Book C, Book F&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;believe&lt;/td&gt;
&lt;td&gt;Book B&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;　　这个中间索引可能看起来像上面的样子，但是可能只包含词，位置和书B的信息。这种嵌套的索引架构要使每个子索引占用足够小的空间，以防所有的这些信息必须保存在一个大的倒排索引中。&lt;/p&gt;

&lt;p&gt;　　这是大型系统的关键点，因为即使压缩，这些索引也太大，太昂贵（expensive）而难以存储。在这个系统，如果我们假设我们世界上的很多书-100,000,000(see &lt;a href=&quot;http://booksearch.blogspot.com/2010/08/books-of-world-stand-up-and-be-counted.html&quot;&gt;Inside Google Books&lt;/a&gt; blog post)-每个书只有10页(只是为了下面好计算)，每页有250个词，那就是2500亿(250 billion)个词。如果我们假设每个词有5个字符，每个字符占用8位(或者1个字节，即使某些字符要用2个字节)，所以每个词占用5个字节，那么每个词即使只包含一次，这个索引也要占用超过1000GB存储空间。那么，你可以明白创建包含很多其他信息-词组，数据位置和出现次数-的索引，存储空间增长多快了吧。&lt;/p&gt;

&lt;p&gt;　　创建这些中间索引和用更小分段表示数据，使的大数据问题可以得到解决。数据可以分散到多个服务器，访问仍然很快。索引是信息检索(information retrieval)的奠基石，是现代搜索引擎的基础。当然，我们这段只是浅显的介绍，还有其他很多深入研究没有涉及-例如如何使索引更快，更小，包含更多信息(例如关联(relevancy))，和无缝的更新（在竞争条件下(race conditions)，有一些管理性难题；在海量添加或者修改数据的更新中，尤其还涉及到关联(relevancy)和得分(scoring)，也有一些难题）。&lt;/p&gt;

&lt;p&gt;快速简便的查找到数据是很重要的；索引是可以达到这个目的有效简单工具。&lt;/p&gt;

&lt;h3&gt;负载均衡器&lt;/h3&gt;

&lt;p&gt;　　最后还要讲讲所有分布式系统中另一个比较关键的部分，负载均衡器。负载均衡器是各种体系结构中一个不可或缺的部分，因为它们担负着将负载在处理服务请求的一组节点中进行分配的任务。这样就可以让系统中的多个节点透明地服务于同一个功能（参见图1.18）。它的主要目的就是要处理大量并发的连接并将这些连接分配给某个请求处理节点，从而可使系统具有伸缩性，仅仅通过添加新节点便能处理更多的请求。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-18.png&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-18.png&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图1.18: 负载均衡器&lt;/center&gt;


&lt;p&gt;　　用于处理这些请求的算法有很多种，包括随机选取节点、循环式选取，甚至可以按照内存或CPU的利用率等等这样特定的条件进行节点选取。负载均衡器可以用软件或硬件设备来实现。近来得到广泛应用的一个开源的软件负载均衡器叫做 &lt;a href=&quot;http://haproxy.1wt.eu/&quot;&gt;HAProxy&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;　　在分布式系统中，负载均衡器往往处于系统的最前端，这样所有发来的请求才能进行相应的分发。在一些比较复杂的分布式系统中，将一个请求分发给多个负载均衡器也是常事，如图1.19所示。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-19.png&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-19.png&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图1.19: 多重负载均衡器&lt;/center&gt;


&lt;p&gt;　　和代理类似，有些负载均衡器还可以基于请求的类型对不同的请求进行不同的处理（技术上讲，这样的叫做反向代理）。&lt;/p&gt;

&lt;p&gt;　　负载均衡器面临的一个难题是怎么管理同用户的session相关的数据。在电子商务网站中，如果你只有一个客户端，那么很容易就可以把用户放入购物车里的东西保存起来，等他下次访问访问时购物车里仍能看到那些东西（这很重要，因为当用户回来发现仍然呆在购物车里的产品时很有可能就会买它）。然而，如果在一个session中将用户分发到了某个节点，但该用户下次访问时却分发到了另外一个节点，这里就有可能产生不一致性，因为新的节点可能就没有保留下用户购物车里的东西。（要是你把6盒子子农夫山泉放到购物车里了，可下次回来一看购物车空了，难道你不会发火吗？）
解决该问题的一个方法是可以使session具有保持性，让同一用户总是分发到同一个节点之上，但这样一来就很难利用类似failover这样的可靠性措施了。如果这样的话，用户的购物车里的东西不会丢，但如果用户保持的那个节点失效，就会出现一种特殊的情况，购物车里的东西不会丢这个假设再也不成立了（虽然但愿不要把这个假设写到程序里）。当然，这个问题还可以用本章中讲到的其它策略和工具来解决，比如服务以及许多并没有讲到的方法（象服务器缓存、cookie以及URL重写）。&lt;/p&gt;

&lt;p&gt;　　如果系统中只有不太多的节点，循环式（round robin）DNS系统这样的方案也许更有意义，因为负载均衡器可能比较贵，而且还额外增加了一层没必要的复杂性。当然，在比较大的系统中会有各种各样的调度以及负载均衡算法，简单点的有随机选取或循环式选取，复杂点的可以考虑上利用率以及处理能力这些因素。所有这些算法都是对浏览和请求进行分发，并能提供很有用的可靠性工具，比如自动failover或者自动提出失效节点（比如节点失去响应）。然而，这些高级特性会让问题诊断难以进行。例如，当系统载荷较大时，负载均衡器可能会移除慢速或者超时的节点（由于节点要处理大量请求），但对其它节点而言，这么做实际上是加剧了情况的恶化程度。在这时进行大量的监测非常重要，因为系统总体流量和吞吐率可能看上去是在下降（因为节点处理的请求变少了），但个别节点却越来越忙得不可开交。&lt;/p&gt;

&lt;p&gt;　　负载均衡器是一种能让你扩展系统能力的简单易行的方式，和本文中所讲的其它技术一样，它在分布式系统架构中起着基础性的作用。负载均衡器还要提供一个比较关键的功能，它必需能够探测出节点的运行状况，比如，如果一个节点失去响应或处于过载状态，负载均衡器可以将其总处理请求的节点池中移除出去，还接着使用系统中冗余的其它不同节点。&lt;/p&gt;

&lt;h3&gt;队列&lt;/h3&gt;

&lt;p&gt;　　目前为止我们已经介绍了许多更快读取数据的方法，但另一个使数据层具伸缩性的重要部分是对写的有效管理。当系统简单的时候，只有最小的处理负载和很小的数据库，写的有多快可以预知；然而，在更复杂的系统，写可能需要几乎无法决定的长久时间。例如，数据可能必须写到不同数据库或索引中的几个地方，或者系统可能正好处于高负载。这些情况下，写或者任何那一类任务，有可能需要很长的时间，追求性能和可用性需要在系统中创建异步；一个通常的做到那一点的办法是通过队列。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-20.png&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-20.png&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 1.20: Synchronous request&lt;/center&gt;


&lt;p&gt;　　设想一个系统，每个客户端都在发起一个远程服务的任务请求。每一个客户端都向服务器发送它们的请求，服务器尽可能快的完成这些任务，并分别返回结果给各个客户端。在一个小型系统，一个服务器（或逻辑服务）可以给传入的客户端请求提供迅速服务，就像它们来的一样快，这种情形应该工作的很好。然而，当服务器收到了超过它所能处理数量的请求时，每个客户端在产生一个响应前，将被迫等待其他客户端的请求结束。这是一个同步请求的例子，示意在图1.20。&lt;/p&gt;

&lt;p&gt;　　这种同步的行为会严重的降低客户端性能；客户端被迫等待，有效的执行零工作，直到它的请求被应答。添加额外的服务器承担系统负载也不会解决这个问题；即使是有效的负载均衡，为了最大化客户端性能，保证平等的公平的分发工作也是极其困难的。而且，如果服务器处理请求不可及，或者失败了，客户端上行也会失败。有效解决这个问题在于，需要在客户端请求与实际的提供服务的被执行工作之间建立抽象。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/scalable-web-architecture-21.png&quot; title=&quot;可扩展Web架构与分布式系统&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/scalable-web-architecture-21.png&quot; title=&quot;可扩展Web架构与分布式系统&quot; alt=&quot;可扩展Web架构与分布式系统&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图 1.21:用队列管理请求&lt;/center&gt;


&lt;p&gt;　　进入队列。一个队列就像它听起来那么简单：一个任务进入，被加入队列然后工人们只要有能力去处理就会拿起下一个任务。（看图1.21）这些任务可能是代表了简单的写数据库，或者一些复杂的事情，像为一个文档生成一个缩略预览图一类的。当一个客户端提交一个任务请求到一个队列，它们再也不会被迫等待结果；它们只需要确认请求被正确的接收了。这个确认之后可能在客户端请求的时候，作为一个工作结果的参考。&lt;/p&gt;

&lt;p&gt;　　队列使客户端能以异步的方式工作，提供了一个客户端请求与其响应的战略抽象。换句话说，在一个同步系统，没有请求与响应的区别，因此它们不能被单独的管理。在一个异步的系统，客户端请求一个任务，服务端响应一个任务已收到的确认，然后客户端可以周期性的检查任务的状态，一旦它结束就请求结果。当客户端等待一个异步的请求完成，它可以自由执行其它工作，甚至异步请求其它的服务。后者是队列与消息在分布式系统如何成为杠杆的例子。&lt;/p&gt;

&lt;p&gt;　　队列也对服务中断和失败提供了防护。例如，创建一个高度强健的队列，这个队列能够重新尝试由于瞬间服务器故障而失败的服务请求，是非常容易的事。相比直接暴露客户端于间歇性服务中断，需要复杂的而且经常矛盾的客户端错误处理程序，用一个队列去加强服务质量的担保更为可取。&lt;/p&gt;

&lt;p&gt;　　队列对管理任何大规模分布式系统不同部分之间的分布式通信，是一个基础，而且实现它们有许多的方法。有不少开源的队列如 &lt;a href=&quot;http://www.rabbitmq.com/&quot;&gt;RabbitMQ&lt;/a&gt;, &lt;a href=&quot;http://activemq.apache.org/&quot;&gt;ActiveMQ&lt;/a&gt;, &lt;a href=&quot;http://kr.github.com/beanstalkd/&quot;&gt;BeanstalkD&lt;/a&gt;，但是有些也用像 &lt;a href=&quot;http://zookeeper.apache.org/&quot;&gt;Zookeeper&lt;/a&gt;的服务，或者甚至像&lt;a href=&quot;http://redis.io/&quot;&gt;Redis&lt;/a&gt;的数据存储。&lt;/p&gt;

&lt;h2&gt;1.4. 结论&lt;/h2&gt;

&lt;p&gt;设计有效的系统来进行快速的大数据访问是有趣的，同时有大量的好工具来帮助各种各样的应用程序进行设计。
这文章只覆盖了一些例子，仅仅是一些表面的东西，但将会越来越多–同时在这个领域里一定会继续有更多创新东西。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>每个程序员都应该了解的“虚拟内存”知识</title>
   <link href="http://beango.github.com/archives/2013/03/21/what-every-programmer-should-know-about-virtual-memory-part3.html"/>
   <updated>2013-03-21T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/03/21/what-every-programmer-should-know-about-virtual-memory-part3</id>
   <content type="html">&lt;p&gt;英文原文：&lt;a href=&quot;http://lwn.net/Articles/253361/&quot;&gt;Memory part 3: Virtual Memory&lt;/a&gt; 来源：&lt;a href=&quot;http://www.oschina.net/translate/what-every-programmer-should-know-about-virtual-memory-part3&quot;&gt;oschina&lt;/a&gt;&lt;/p&gt;

&lt;p style=&quot;color:#888888;&quot;&gt;[编辑注：本文是Ulrich Drepper的“每个[程序员](http://blog.jobbole.com/821/ &quot;程序员的本质&quot;)应该了解的内存方面的知识”文章的第三部分；这一部分谈论了虚拟内存，特别是TLB性能。没有阅读[第1部分](http://blog.jobbole.com/34303/)和[第2部分](http://blog.jobbole.com/36263/)的人可能现在就想读一读了。和往常一样，请将排字错误报告之类发送到lwn@lwn.net，而不要发送到这里的评论。]&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;4 虚拟内存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　处理器的虚拟内存子系统为每个进程实现了虚拟地址空间。这让每个进程认为它在系统中是独立的。虚拟内存的优点列表别的地方描述的非常详细，所以这里就不重复了。本节集中在虚拟内存的实际的实现细节，和相关的成本。&lt;/p&gt;

&lt;p&gt;　　虚拟地址空间是由CPU的内存管理单元(MMU)实现的。OS必须填充页表数据结构，但大多数CPU自己做了剩下的工作。这事实上是一个相当复杂的机制；最好的理解它的方法是引入数据结构来描述虚拟地址空间。&lt;/p&gt;

&lt;p&gt;　　由MMU进行地址翻译的输入地址是虚拟地址。通常对它的值很少有限制 —
假设还有一点的话。虚拟地址在32位系统中是32位的数值，在64位系统中是64位的数值。在一些系统，例如x86和x86-64，使用的地址实际上包含了另一个层次的间接寻址：这些结构使用分段，这些分段只是简单的给每个逻辑地址加上位移。我们可以忽略这一部分的地址产生，它不重要，不是程序员非常关心的内存处理性能方面的东西。{&lt;em&gt;x86的分段限制是与性能相关的，但那是另一回事了&lt;/em&gt;}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.1 最简单的地址转换&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　有趣的地方在于由虚拟地址到物理地址的转换。MMU可以在逐页的基础上重新映射地址。就像地址缓存排列的时候，虚拟地址被分割为不同的部分。这些部分被用来做多个表的索引，而这些表是被用来创建最终物理地址用的。最简单的模型是只有一级表。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/123.png&quot; title=&quot;每个程序员都应该了解的“虚拟内存”知识&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/123.png&quot; title=&quot;每个程序员都应该了解的“虚拟内存”知识&quot; alt=&quot;每个程序员都应该了解的“虚拟内存”知识&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 4.1: 1-Level Address Translation&lt;/center&gt;


&lt;p&gt;　　图 4.1 显示了虚拟地址的不同部分是如何使用的。高字节部分是用来选择一个页目录的条目；那个目录中的每个地址可以被OS分别设置。页目录条目决定了物理内存页的地址；页面中可以有不止一个条目指向同样的物理地址。完整的内存物理地址是由页目录获得的页地址和虚拟地址低字节部分合并起来决定的。页目录条目还包含一些附加的页面信息，如访问权限。&lt;/p&gt;

&lt;p&gt;　　页目录的数据结构存储在内存中。OS必须分配连续的物理内存，并将这个地址范围的基地址存入一个特殊的寄存器。然后虚拟地址的适当的位被用来作为页目录的索引，这个页目录事实上是目录条目的列表。&lt;/p&gt;

&lt;p&gt;　　作为一个具体的例子，这是x86机器4MB分页设计。虚拟地址的位移部分是22位大小，足以定位一个4M页内的每一个字节。虚拟地址中剩下的10位指定页目录中1024个条目的一个。每个条目包括一个10位的4M页内的基地址，它与位移结合起来形成了一个完整的32位地址。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.2 多级页表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　4MB的页不是规范，它们会浪费很多内存，因为OS需要执行的许多操作需要内存页的队列。对于4kB的页（32位机器的规范，甚至通常是64位机器的规范），虚拟地址的位移部分只有12位大小。这留下了20位作为页目录的指针。具有2&lt;sup&gt;20&lt;/sup&gt; 个条目的表是不实际的。即使每个条目只要4比特，这个表也要4MB大小。由于每个进程可能具有其唯一的页目录，因为这些页目录许多系统中物理内存被绑定起来。&lt;/p&gt;

&lt;p&gt;　　解决办法是用多级页表。然后这些就能表示一个稀疏的大的页目录，目录中一些实际不用的区域不需要分配内存。因此这种表示更紧凑，使它可能为内存中的很多进程使用页表而并不太影响性能。.&lt;/p&gt;

&lt;p&gt;　　今天最复杂的页表结构由四级构成。图4.2显示了这样一个实现的原理图。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/216.png&quot; title=&quot;每个程序员都应该了解的“虚拟内存”知识&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/216.png&quot; title=&quot;每个程序员都应该了解的“虚拟内存”知识&quot; alt=&quot;每个程序员都应该了解的“虚拟内存”知识&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 4.2: 4-Level Address Translation&lt;/center&gt;


&lt;p&gt;　　在这个例子中，虚拟地址被至少分为五个部分。其中四个部分是不同的目录的索引。被引用的第4级目录使用CPU中一个特殊目的的寄存器。第4级到第2级目录的内容是对次低一级目录的引用。如果一个目录条目标识为空，显然就是不需要指向任何低一级的目录。这样页表树就能稀疏和紧凑。正如图4.1，第1级目录的条目是一部分物理地址，加上像访问权限的辅助数据。&lt;/p&gt;

&lt;p&gt;　　为了决定相对于虚拟地址的物理地址，处理器先决定最高级目录的地址。这个地址一般保存在一个寄存器。然后CPU取出虚拟地址中相对于这个目录的索引部分，并用那个索引选择合适的条目。这个条目是下一级目录的地址，它由虚拟地址的下一部分索引。处理器继续直到它到达第1级目录，那里那个目录条目的值就是物理地址的高字节部分。物理地址在加上虚拟地址中的页面位移之后就完整了。这个过程称为页面树遍历。一些处理器（像x86和x86-64）在硬件中执行这个操作，其他的需要OS的协助。&lt;/p&gt;

&lt;p&gt;　　系统中运行的每个进程可能需要自己的页表树。有部分共享树的可能，但是这相当例外。因此如果页表树需要的内存尽可能小的话将对性能与可扩展性有利。理想的情况是将使用的内存紧靠着放在虚拟地址空间；但实际使用的物理地址不影响。一个小程序可能只需要第2，3，4级的一个目录和少许第1级目录就能应付过去。在一个采用4kB页面和每个目录512条目的x86-64机器上，这允许用4级目录对2MB定位（每一级一个）。1GB连续的内存可以被第2到第4级的一个目录和第1级的512个目录定位。&lt;/p&gt;

&lt;p&gt;　　但是，假设所有内存可以被连续分配是太简单了。由于复杂的原因，大多数情况下，一个进程的栈与堆的区域是被分配在地址空间中非常相反的两端。这样使得任一个区域可以根据需要尽可能的增长。这意味着最有可能需要两个第2级目录和相应的更多的低一级的目录。&lt;/p&gt;

&lt;p&gt;　　但即使这也不常常匹配现在的实际。由于安全的原因，一个可运行的（代码，数据，堆，栈，动态共享对象，aka共享库）不同的部分被映射到随机的地址[未选中的]。随机化延伸到不同部分的相对位置；那意味着一个进程使用的不同的内存范围，遍布于虚拟地址空间。通过对随机的地址位数采用一些限定，范围可以被限制，但在大多数情况下，这当然不会让一个进程只用一到两个第2和第3级目录运行。&lt;/p&gt;

&lt;p&gt;　　如果性能真的远比安全重要，随机化可以被关闭。OS然后通常是在虚拟内存中至少连续的装载所有的动态共享对象(DSO)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.3 优化页表访问&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　页表的所有数据结构都保存在主存中；在那里OS建造和更新这些表。当一个进程创建或者一个页表变化，CPU将被通知。页表被用来解决每个虚拟地址到物理地址的转换，用上面描述的页表遍历方式。更多有关于此：至少每一级有一个目录被用于处理虚拟地址的过程。这需要至多四次内存访问（对一个运行中的进程的单次访问来说），这很慢。有可能像普通数据一样处理这些目录表条目，并将他们缓存在L1d,L2等等，但这仍然非常慢。&lt;/p&gt;

&lt;p&gt;　　从虚拟内存的早期阶段开始，CPU的设计者采用了一种不同的优化。简单的计算显示，只有将目录表条目保存在L1d和更高级的缓存，才会导致可怕的性能问题。每个绝对地址的计算，都需要相对于页表深度的大量的L1d访问。这些访问不能并行，因为它们依赖于前面查询的结果。在一个四级页表的机器上，这种单线性将至少至少需要12次循环。再加上L1d的非命中的可能性，结果是指令流水线没有什么能隐藏的。额外的L1d访问也消耗了珍贵的缓存带宽。&lt;/p&gt;

&lt;p&gt;　　所以，替代于只是缓存目录表条目，物理页地址的完整的计算结果被缓存了。因为同样的原因，代码和数据缓存也工作起来，这样的地址计算结果的缓存是高效的。由于虚拟地址的页面位移部分在物理页地址的计算中不起任何作用，只有虚拟地址的剩余部分被用作缓存的标签。根据页面大小这意味着成百上千的指令或数据对象共享同一个标签，因此也共享同一个物理地址前缀。&lt;/p&gt;

&lt;p&gt;　　保存计算数值的缓存叫做旁路转换缓存(TLB)。因为它必须非常的快，通常这是一个小的缓存。现代CPU像其它缓存一样，提供了多级TLB缓存；越高级的缓存越大越慢。小号的L1级TLB通常被用来做全相联映像缓存，采用LRU回收策略。最近这种缓存大小变大了，而且在处理器中变得集相联。其结果之一就是，当一个新的条目必须被添加的时候，可能不是最久的条目被回收于替换了。&lt;/p&gt;

&lt;p&gt;　　正如上面提到的，用来访问TLB的标签是虚拟地址的一个部分。如果标签在缓存中有匹配，最终的物理地址将被计算出来，通过将来自虚拟地址的页面位移地址加到缓存值的方式。这是一个非常快的过程；也必须这样，因为每条使用绝对地址的指令都需要物理地址，还有在一些情况下，因为使用物理地址作为关键字的L2查找。如果TLB查询未命中，处理器就必须执行一次页表遍历；这可能代价非常大。&lt;/p&gt;

&lt;p&gt;　　通过软件或硬件预取代码或数据，会在地址位于另一页面时，暗中预取TLB的条目。硬件预取不可能允许这样，因为硬件会初始化非法的页面表遍历。因此程序员不能依赖硬件预取机制来预取TLB条目。它必须使用预取指令明确的完成。就像数据和指令缓存，TLB可以表现为多个等级。正如数据缓存，TLB通常表现为两种形式：指令TLB(ITLB)和数据TLB(DTLB)。高级的TLB像L2TLB通常是统一的，就像其他的缓存情形一样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.3.1 使用TLB的注意事项&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　TLB是以处理器为核心的全局资源。所有运行于处理器的线程与进程使用同一个TLB。由于虚拟到物理地址的转换依赖于安装的是哪一种页表树，如果页表变化了，CPU不能盲目的重复使用缓存的条目。每个进程有一个不同的页表树（不算在同一个进程中的线程），内核与内存管理器VMM(管理程序)也一样，如果存在的话。也有可能一个进程的地址空间布局发生变化。有两种解决这个问题的办法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当页表树变化时TLB刷新。&lt;/li&gt;
&lt;li&gt;TLB条目的标签附加扩展并唯一标识其涉及的页表树&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　第一种情况，只要执行一个上下文切换TLB就被刷新。因为大多数OS中，从一个线程/进程到另一个的切换需要执行一些核心代码，TLB刷新被限制进入或离开核心地址空间。在虚拟化的系统中，当内核必须调用内存管理器VMM和返回的时候，这也会发生。如果内核和/或内存管理器没有使用虚拟地址，或者当进程或内核调用系统/内存管理器时，能重复使用同一个虚拟地址，TLB必须被刷新。当离开内核或内存管理器时，处理器继续执行一个不同的进程或内核。&lt;/p&gt;

&lt;p&gt;　　刷新TLB高效但昂贵。例如，当执行一个系统调用，触及的内核代码可能仅限于几千条指令，或许少许新页面（或一个大的页面，像某些结构的Linux的就是这样）。这个工作将替换触及页面的所有TLB条目。对Intel带128ITLB和256DTLB条目的Core2架构，完全的刷新意味着多于100和200条目（分别的）将被不必要的刷新。当系统调用返回同一个进程，所有那些被刷新的TLB条目可能被再次用到，但它们没有了。内核或内存管理器常用的代码也一样。每条进入内核的条目上，TLB必须擦去再装，即使内核与内存管理器的页表通常不会改变。因此理论上说，TLB条目可以被保持一个很长时间。这也解释了为什么现在处理器中的TLB缓存都不大：程序很有可能不会执行时间长到装满所有这些条目。&lt;/p&gt;

&lt;p&gt;　　当然事实逃脱不了CPU的结构。对缓存刷新优化的一个可能的方法是单独的使TLB条目失效。例如，如果内核代码与数据落于一个特定的地址范围，只有落入这个地址范围的页面必须被清除出TLB。这只需要比较标签，因此不是很昂贵。在部分地址空间改变的场合，例如对去除内存页的一次调用，这个方法也是有用的，&lt;/p&gt;

&lt;p&gt;　　更好的解决方法是为TLB访问扩展标签。如果除了虚拟地址的一部分之外，一个唯一的对应每个页表树的标识（如一个进程的地址空间）被添加，TLB将根本不需要完全刷新。内核，内存管理程序，和独立的进程都可以有唯一的标识。这种场景唯一的问题在于，TLB标签可以获得的位数异常有限，但是地址空间的位数却不是。这意味着一些标识的再利用是有必要的。这种情况发生时TLB必须部分刷新（如果可能的话）。所有带有再利用标识的条目必须被刷新，但是希望这是一个非常小的集合。&lt;/p&gt;

&lt;p&gt;　　当多个进程运行在系统中时，这种扩展的TLB标签具有一般优势。如果每个可运行进程对内存的使用（因此TLB条目的使用）做限制，进程最近使用的TLB条目,当其再次列入计划时，有很大机会仍然在TLB。但还有两个额外的优势：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;特殊的地址空间，像内核和内存管理器使用的那些，经常仅仅进入一小段时间；之后控制经常返回初始化此次调用的地址空间。没有标签，就有两次TLB刷新操作。有标签，调用地址空间缓存的转换地址将被保存，而且由于内核与内存管理器地址空间根本不会经常改变TLB条目，系统调用之前的地址转换等等可以仍然使用。&lt;/li&gt;
&lt;li&gt;当同一个进程的两个线程之间切换时，TLB刷新根本就不需要。虽然没有扩展TLB标签时，进入内核的条目会破坏第一个线程的TLB的条目。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;　　有些处理器在一些时候实现了这些扩展标签。AMD给帕西菲卡（Pacifica）虚拟化扩展引入了一个1位的扩展标签。在虚拟化的上下文中，这个1位的地址空间ID（ASID）被用来从客户域区别出内存管理程序的地址空间。这使得OS能够避免在每次进入内存管理程序的时候（例如为了处理一个页面错误）刷新客户的TLB条目，或者当控制回到客户时刷新内存管理程序的TLB条目。这个架构未来会允许使用更多的位。其它主流处理器很可能会随之适应并支持这个功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.3.2 影响TLB性能&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　有一些因素会影响TLB性能。第一个是页面的大小。显然页面越大，装进去的指令或数据对象就越多。所以较大的页面大小减少了所需的地址转换总次数，即需要更少的TLB缓存条目。大多数架构允许使用多个不同的页面尺寸；一些尺寸可以并存使用。例如，x86/x86-64处理器有一个普通的4kB的页面尺寸，但它们也可以分别用4MB和2MB页面。IA-64和 PowerPC允许如64kB的尺寸作为基本的页面尺寸。&lt;/p&gt;

&lt;p&gt;　　然而，大页面尺寸的使用也随之带来了一些问题。用作大页面的内存范围必须是在物理内存中连续的。如果物理内存管理的单元大小升至虚拟内存页面的大小，浪费的内存数量将会增长。各种内存操作（如加载可执行文件）需要页面边界对齐。这意味着平均每次映射浪费了物理内存中页面大小的一半。这种浪费很容易累加；因此它给物理内存分配的合理单元大小划定了一个上限。&lt;/p&gt;

&lt;p&gt;　　在x86-64结构中增加单元大小到2MB来适应大页面当然是不实际的。这是一个太大的尺寸。但这转而意味着每个大页面必须由许多小一些的页面组成。这些小页面必须在物理内存中连续。以4kB单元页面大小分配2MB连续的物理内存具有挑战性。它需要找到有512个连续页面的空闲区域。在系统运行一段时间并且物理内存开始碎片化以后，这可能极为困难（或者不可能）&lt;/p&gt;

&lt;p&gt;　　因此在Linux中有必要在系统启动的时候，用特别的Huge TLBfs文件系统，预分配这些大页面。一个固定数目的物理页面被保留，以单独用作大的虚拟页面。这使可能不会经常用到的资源捆绑留下来。它也是一个有限的池；增大它一般意味着要重启系统。尽管如此，大页面是进入某些局面的方法，在这些局面中性能具有保险性，资源丰富，而且麻烦的安装不会成为大的妨碍。数据库服务器就是一个例子。&lt;/p&gt;

&lt;p&gt;　　增大最小的虚拟页面大小（正如选择大页面的相反面）也有它的问题。内存映射操作（例如加载应用）必须确认这些页面大小。不可能有更小的映射。对大多数架构来说，一个可执行程序的各个部分位置有一个固定的关系。如果页面大小增加到超过了可执行程序或DSO(Dynamic Shared Object)创建时考虑的大小，加载操作将无法执行。脑海里记得这个限制很重要。图4.3显示了一个ELF二进制的对齐需求是如何决定的。它编码在ELF程序头部。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eu-readelf -l /bin/ls
Program Headers:
  Type   Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align
...
  LOAD   0x000000 0x0000000000400000 0x0000000000400000 0x0132ac 0x0132ac R E 0x200000
  LOAD   0x0132b0 0x00000000006132b0 0x00000000006132b0 0x001a71 0x001a71 RW  0x200000
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Figure 4.3: ELF 程序头表明了对齐需求&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在这个例子中，一个x86-64二进制，它的值为0×200000 = 2,097,152 = 2MB，符合处理器支持的最大页面尺寸。&lt;/p&gt;

&lt;p&gt;　　使用较大内存尺寸有第二个影响：页表树的级数减少了。由于虚拟地址相对于页面位移的部分增加了，需要用来在页目录中使用的位，就没有剩下许多了。这意味着当一个TLB未命中时，需要做的工作数量减少了。&lt;/p&gt;

&lt;p&gt;　　超出使用大页面大小，它有可能减少移动数据时需要同时使用的TLB条目数目，减少到数页。这与一些上面我们谈论的缓存使用的优化机制类似。只有现在对齐需求是巨大的。考虑到TLB条目数目如此小，这可能是一个重要的优化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.4 虚拟化的影响&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　OS映像的虚拟化将变得越来越流行；这意味着另一个层次的内存处理被加入了想象。进程（基本的隔间）或者OS容器的虚拟化，因为只涉及一个OS而没有落入此分类。类似Xen或KVM的技术使OS映像能够独立运行 — 有或者没有处理器的协助。这些情形下，有一个单独的软件直接控制物理内存的访问。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/39.png&quot; title=&quot;每个程序员都应该了解的“虚拟内存”知识&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/39.png&quot; title=&quot;每个程序员都应该了解的“虚拟内存”知识&quot; alt=&quot;每个程序员都应该了解的“虚拟内存”知识&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图 4.4: Xen 虚拟化模型&lt;/center&gt;


&lt;p&gt;　　对Xen来说（见图4.4），Xen VMM(Xen内存管理程序)就是那个软件。但是，VMM没有自己实现许多硬件的控制，不像其他早先的系统（包括Xen VMM的第一个版本）的VMM，内存以外的硬件和处理器由享有特权的Dom0域控制。现在，这基本上与没有特权的DomU内核一样，就内存处理方面而言，它们没有什么不同。这里重要的是，VMM自己分发物理内存给Dom0和DomU内核，然后就像他们是直接运行在一个处理器上一样，实现通常的内存处理&lt;/p&gt;

&lt;p&gt;　　为了实现完成虚拟化所需的各个域之间的分隔，Dom0和DomU内核中的内存处理不具有无限制的物理内存访问权限。VMM不是通过分发独立的物理页并让客户OS处理地址的方式来分发内存；这不能提供对错误或欺诈客户域的防范。替代的，VMM为每一个客户域创建它自己的页表树，并且用这些数据结构分发内存。好处是对页表树管理信息的访问能得到控制。如果代码没有合适的特权，它不能做任何事。
在虚拟化的Xen支持中，这种访问控制已被开发，不管使用的是参数的或硬件的（又名全）虚拟化。客户域以意图上与参数的和硬件的虚拟化极为相似的方法，给每个进程创建它们的页表树。每当客户OS修改了VMM调用的页表，VMM就会用客户域中更新的信息去更新自己的影子页表。这些是实际由硬件使用的页表。显然这个过程非常昂贵：每次对页表树的修改都需要VMM的一次调用。而没有虚拟化时内存映射的改变也不便宜，它们现在变得甚至更昂贵。
考虑到从客户OS的变化到VMM以及返回，其本身已经相当昂贵，额外的代价可能真的很大。这就是为什么处理器开始具有避免创建影子页表的额外功能。这样很好不仅是因为速度的问题，而且它减少了VMM消耗的内存。Intel有扩展页表(EPTs)，AMD称之为嵌套页表(NPTs)。基本上两种技术都具有客户OS的页表，来产生虚拟的物理地址。然后通过每个域一个EPT/NPT树的方式，这些地址会被进一步转换为真实的物理地址。这使得可以用几乎非虚拟化情境的速度进行内存处理，因为大多数用来内存处理的VMM条目被移走了。它也减少了VMM使用的内存，因为现在一个域（相对于进程）只有一个页表树需要维护。
额外的地址转换步骤的结果也存储于TLB。那意味着TLB不存储虚拟物理地址，而替代以完整的查询结果。已经解释过AMD的帕西菲卡扩展为了避免TLB刷新而给每个条目引入ASID。ASID的位数在最初版本的处理器扩展中是一位；这正好足够区分VMM和客户OS。Intel有服务同一个目的的虚拟处理器ID(VPIDs)，它们只有更多位。但对每个客户域VPID是固定的，因此它不能标记单独的进程，也不能避免TLB在那个级别刷新。&lt;/p&gt;

&lt;p&gt;　　对虚拟OS，每个地址空间的修改需要的工作量是一个问题。但是还有另一个内在的基于VMM虚拟化的问题：没有什么办法处理两层的内存。但内存处理很难（特别是考虑到像NUMA一样的复杂性，见第5部分）。Xen方法使用一个单独的VMM，这使最佳的（或最好的）处理变得困难，因为所有内存管理实现的复杂性，包括像发现内存范围之类“琐碎的”事情，必须被复制于VMM。OS有完全成熟的与最佳的实现；人们确实想避免复制它们。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/47.png&quot; title=&quot;每个程序员都应该了解的“虚拟内存”知识&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/47.png&quot; title=&quot;每个程序员都应该了解的“虚拟内存”知识&quot; alt=&quot;每个程序员都应该了解的“虚拟内存”知识&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图 4.5: KVM 虚拟化模型&lt;/center&gt;


&lt;p&gt;　　这就是为什么对VMM/Dom0模型的分析是这么有吸引力的一个选择。图4.5显示了KVM的Linux内核扩展如何尝试解决这个问题的。并没有直接运行在硬件之上且管理所有客户的单独的VMM，替代的，一个普通的Linux内核接管了这个功能。这意味着Linux内核中完整且复杂的内存管理功能，被用来管理系统的内存。客户域运行于普通的用户级进程，创建者称其为“客户模式”。虚拟化的功能，参数的或全虚拟化的，被另一个用户级进程KVM VMM控制。这也就是另一个进程用特别的内核实现的KVM设备，去恰巧控制一个客户域。&lt;/p&gt;

&lt;p&gt;　　这个模型相较Xen独立的VMM模型好处在于，即使客户OS使用时，仍然有两个内存处理程序在工作，只需要在Linux内核里有一个实现。不需要像Xen VMM那样从另一段代码复制同样的功能。这带来更少的工作，更少的bug，或许还有更少的两个内存处理程序接触产生的摩擦，因为一个Linux客户的内存处理程序与运行于裸硬件之上的Linux内核的外部内存处理程序，做出了相同的假设。&lt;/p&gt;

&lt;p&gt;　　总的来说，程序员必须清醒认识到，采用虚拟化时，内存操作的代价比没有虚拟化要高很多。任何减少这个工作的优化，将在虚拟化环境付出更多。随着时间的过去，处理器的设计者将通过像EPT和NPT技术越来越减少这个差距，但它永远都不会完全消失。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>每个程序员都应该了解的CPU高速缓存</title>
   <link href="http://beango.github.com/archives/2013/03/20/what-every-programmer-should-know-about-cpu-cache-part2.html"/>
   <updated>2013-03-20T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/03/20/what-every-programmer-should-know-about-cpu-cache-part2</id>
   <content type="html">&lt;p&gt;英文原文：&lt;a href=&quot;http://lwn.net/Articles/252125/&quot;&gt;Memory part 2: CPU caches&lt;/a&gt; 来源：&lt;a href=&quot;http://www.oschina.net/translate/what-every-programmer-should-know-about-cpu-cache-part2&quot;&gt;oschina&lt;/a&gt;&lt;/p&gt;

&lt;p style=&quot;color:#888888;&quot;&gt;[编者按：这是Ulrich Drepper写“[程序员](http://blog.jobbole.com/821/ &quot;程序员的本质&quot;)都该知道存储器”的第二部。那些没有读过[*第一部 *](http://blog.jobbole.com/34303/)的读者可能希望从这一部开始。这本书写的非常好，并且感谢Ulrich授权我们出版。&lt;/p&gt;




&lt;p style=&quot;color:#888888;&quot;&gt;一点说明：书籍出版时可能会有一些印刷错误，如果你发现，并且想让它在后续的出版中更正，请将意见发邮件到lwn@lwn.net，我们一定会更正，并反馈给Ulrich的文档副本，别的读者就不会受到这些困扰。]&lt;/p&gt;


&lt;p&gt;　　现在的CPU比25年前要精密得多了。在那个年代，CPU的频率与内存总线的频率基本在同一层面上。内存的访问速度仅比寄存器慢那么一点点。但是，这一局面在上世纪90年代被打破了。CPU的频率大大提升，但内存总线的频率与内存芯片的性能却没有得到成比例的提升。并不是因为造不出更快的内存，只是因为太贵了。内存如果要达到目前CPU那样的速度，那么它的造价恐怕要贵上好几个数量级。&lt;/p&gt;

&lt;p&gt;　　如果有两个选项让你选择，一个是速度非常快、但容量很小的内存，一个是速度还算快、但容量很多的内存，如果你的工作集比较大，超过了前一种情况，那么人们总是会选择第二个选项。原因在于辅存(一般为磁盘)的速度。由于工作集超过主存，那么必须用辅存来保存交换出去的那部分数据，而辅存的速度往往要比主存慢上好几个数量级。&lt;/p&gt;

&lt;p&gt;　　好在这问题也并不全然是非甲即乙的选择。在配置大量DRAM的同时，我们还可以配置少量SRAM。将地址空间的某个部分划给SRAM，剩下的部分划给DRAM。一般来说，SRAM可以当作扩展的寄存器来使用。&lt;/p&gt;

&lt;p&gt;　　上面的做法看起来似乎可以，但实际上并不可行。首先，将SRAM内存映射到进程的虚拟地址空间就是个非常复杂的工作，而且，在这种做法中，每个进程都需要管理这个SRAM区内存的分配。每个进程可能有大小完全不同的SRAM区，而组成程序的每个模块也需要索取属于自身的SRAM，更引入了额外的同步需求。简而言之，快速内存带来的好处完全被额外的管理开销给抵消了。
　　基于以上的原因，我们不将SRAM放在OS或用户的控制下，而是将它交由处理器来使用和管理。在这种模式下，SRAM用于对存储在主存中、即将使用的数据进行临时拷贝(换句话说，缓存)。这种做法的依据是程序代码和数据具有时间局部性和空间局部性。也就是说，在一段较短的时间内，同一份代码和数据有很大的可能被重复使用。对代码来说，是循环，即同一段代码被反复执行(完美的&lt;em&gt;空间局部性&lt;/em&gt;)。对数据来说，是反复访问某一小片区域中的数据。即使在短时间内对内存的访问并不连续，但仍有很大可能在不长的时间内重复访问同一份数据(&lt;em&gt;空间局部性&lt;/em&gt;)。这两个局部性是我们理解CPU高速缓存的关键。&lt;/p&gt;

&lt;p&gt;　　我们先用一个简单的计算来展示一下高速缓存的效率。假设，访问主存需要200个周期，而访问高速缓存需要15个周期。如果使用100个数据元素100次，那么在没有高速缓存的情况下，需要2000000个周期，而在有高速缓存、而且所有数据都已被缓存的情况下，只需要168500个周期。节约了91.5%的时间。&lt;/p&gt;

&lt;p&gt;　　用作高速缓存的SRAM容量比主存小得多。以我的经验来说，高速缓存的大小一般是主存的千分之一左右(目前一般是4GB主存、4MB缓存)。这一点本身并不是什么问题。只是，计算机一般都会有比较大的主存，因此工作集的大小总是会大于缓存。特别是那些运行多进程的系统，它的工作集大小是所有进程加上内核的总和。&lt;/p&gt;

&lt;p&gt;　　处理高速缓存大小的限制需要制定一套很好的策略来决定在给定的时间内什么数据应该被缓存。由于不是所有数据的工作集都是在完全相同的时间段内被使用的，我们可以用一些技术手段将需要用到的数据临时替换那些当前并未使用的缓存数据。这种预取将会减少部分访问主存的成本，因为它与程序的执行是异步的。所有的这些技术将会使高速缓存在使用的时候看起来比实际更大。我们将在3.3节讨论这些问题。 我们将在第6章讨论如何让这些技术能很好地帮助程序员，让处理器更高效地工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1 高速缓存的位置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在深入介绍高速缓存的技术细节之前，有必要说明一下它在现代计算机系统中所处的位置。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/120.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/120.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.1: 最简单的高速缓存配置图&lt;/center&gt;


&lt;p&gt;　　图3.1展示了最简单的高速缓存配置。早期的一些系统就是类似的架构。在这种架构中，CPU核心不再直连到主存。{在一些更早的系统中，高速缓存像CPU与主存一样连到系统总线上。那种做法更像是一种hack，而不是真正的解决方案。}数据的读取和存储都经过高速缓存。CPU核心与高速缓存之间是一条特殊的快速通道。在简化的表示法中，主存与高速缓存都连到系统总线上，这条总线同时还用于与其它组件通信。我们管这条总线叫“FSB”——就是现在称呼它的术语，参见第2.2节。在这一节里，我们将忽略北桥。&lt;/p&gt;

&lt;p&gt;　　在过去的几十年，经验表明使用了冯诺伊曼结构的 计算机，将用于代码和数据的高速缓存分开是存在巨大优势的。自1993年以来，Intel 并且一直坚持使用独立的代码和数据高速缓存。由于所需的代码和数据的内存区域是几乎相互独立的，这就是为什么独立缓存工作得更完美的原因。近年来，独立缓存的另一个优势慢慢显现出来：常见处理器解码 指令的步骤 是缓慢的，尤其当管线为空的时候，往往会伴随着错误的预测或无法预测的分支的出现， 将高速缓存技术用于 指令 解码可以加快其执行速度。&lt;/p&gt;

&lt;p&gt;　　在高速缓存出现后不久，系统变得更加复杂。高速缓存与主存之间的速度差异进一步拉大，直到加入了另一级缓存。新加入的这一级缓存比第一级缓存更大，但是更慢。由于加大一级缓存的做法从经济上考虑是行不通的，所以有了二级缓存，甚至现在的有些系统拥有三级缓存，如图3.2所示。随着单个CPU中核数的增加，未来甚至可能会出现更多层级的缓存。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/214.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/214.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.2: 三级缓存的处理器&lt;/center&gt;


&lt;p&gt;　　图3.2展示了三级缓存，并介绍了本文将使用的一些术语。L1d是一级数据缓存，L1i是一级指令缓存，等等。请注意，这只是示意图，真正的数据流并不需要流经上级缓存。CPU的设计者们在设计高速缓存的接口时拥有很大的自由。而程序员是看不到这些设计选项的。&lt;/p&gt;

&lt;p&gt;　　另外，我们有多核CPU，每个核心可以有多个“线程”。核心与线程的不同之处在于，核心拥有独立的硬件资源({早期的多核CPU甚至有独立的二级缓存。})。在不同时使用相同资源(比如，通往外界的连接)的情况下，核心可以完全独立地运行。而线程只是共享资源。Intel的线程只有独立的寄存器，而且还有限制——不是所有寄存器都独立，有些是共享的。综上，现代CPU的结构就像图3.3所示。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/38.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/38.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.3 多处理器、多核心、多线程&lt;/center&gt;


&lt;p&gt;　　在上图中，有两个处理器，每个处理器有两个核心，每个核心有两个线程。线程们共享一级缓存。核心(以深灰色表示)有独立的一级缓存，同时共享二级缓存。处理器(淡灰色)之间不共享任何缓存。这些信息很重要，特别是在讨论多进程和多线程情况下缓存的影响时尤为重要。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2 高级的缓存操作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　了解成本和节约使用缓存，我们必须结合在第二节中讲到的关于计算机体系结构和RAM技术，以及前一节讲到的缓存描述来探讨。&lt;/p&gt;

&lt;p&gt;　　默认情况下，CPU核心所有的数据的读或写都存储在缓存中。当然，也有内存区域不能被缓存的，但是这种情况只发生在操作系统的实现者对数据考虑的前提下；对程序实现者来说，这是不可见的。这也说明，程序设计者可以故意绕过某些缓存，不过这将是第六节中讨论的内容了。&lt;/p&gt;

&lt;p&gt;　　如果CPU需要访问某个字(word)，先检索缓存。很显然，缓存不可能容纳主存所有内容(否则还需要主存干嘛)。系统用字的内存地址来对缓存条目进行标记。如果需要读写某个地址的字，那么根据标签来检索缓存即可。这里用到的地址可以是虚拟地址，也可以是物理地址，取决于缓存的具体实现。&lt;/p&gt;

&lt;p&gt;　　标签是需要额外空间的，用字作为缓存的粒度显然毫无效率。比如，在x86机器上，32位字的标签可能需要32位，甚至更长。另一方面，由于空间局部性的存在，与当前地址相邻的地址有很大可能会被一起访问。再回忆下2.2.1节——内存模块在传输位于同一行上的多份数据时，由于不需要发送新CAS信号，甚至不需要发送RAS信号，因此可以实现很高的效率。基于以上的原因，缓存条目并不存储单个字，而是存储若干连续字组成的“线”。在早期的缓存中，线长是32字节，现在一般是64字节。对于64位宽的内存总线，每条线需要8次传输。而DDR对于这种传输模式的支持更为高效。&lt;/p&gt;

&lt;p&gt;　　当处理器需要内存中的某块数据时，整条缓存线被装入L1d。缓存线的地址通过对内存地址进行掩码操作生成。对于64字节的缓存线，是将低6位置0。这些被丢弃的位作为线内偏移量。其它的位作为标签，并用于在缓存内定位。在实践中，我们将地址分为三个部分。32位地址的情况如下:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/46.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/46.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　如果缓存线长度为2&lt;sup&gt;O&lt;/sup&gt; ，那么地址的低O位用作线内偏移量。上面的S位选择“缓存集”。后面我们会说明使用缓存集的原因。现在只需要明白一共有2&lt;sup&gt;S&lt;/sup&gt; 个缓存集就够了。剩下的32 – S – O = T位组成标签。它们用来区分别名相同的各条线{有相同S部分的缓存线被称为有相同的别名。}用于定位缓存集的S部分不需要存储，因为属于同一缓存集的所有线的S部分都是相同的。&lt;/p&gt;

&lt;p&gt;　　当某条指令修改内存时，仍然要先装入缓存线，因为任何指令都不可能同时修改整条线(只有一个例外——第6.1节中将会介绍的写合并(write-combine))。因此需要在写操作前先把缓存线装载进来。如果缓存线被写入，但还没有写回主存，那就是所谓的“脏了”。脏了的线一旦写回主存，脏标记即被清除。&lt;/p&gt;

&lt;p&gt;　　为了装入新数据，基本上总是要先在缓存中清理出位置。L1d将内容逐出L1d，推入L2(线长相同)。当然，L2也需要清理位置。于是L2将内容推入L3，最后L3将它推入主存。这种逐出操作一级比一级昂贵。这里所说的是现代AMD和VIA处理器所采用的&lt;em&gt;独占型缓存(exclusive cache)&lt;/em&gt;。而Intel采用的是&lt;em&gt;包容型缓存(inclusive cache)，&lt;/em&gt;{并不完全正确，Intel有些缓存是独占型的，还有一些缓存具有独占型缓存的特点。}L1d的每条线同时存在于L2里。对这种缓存，逐出操作就很快了。如果有足够L2，对于相同内容存在不同地方造成内存浪费的缺点可以降到最低，而且在逐出时非常有利。而独占型缓存在装载新数据时只需要操作L1d，不需要碰L2，因此会比较快。&lt;/p&gt;

&lt;p&gt;　　处理器体系结构中定义的作为存储器的模型只要还没有改变，那就允许多CPU按照自己的方式来管理高速缓存。这表示，例如，设计优良的处理器，利用很少或根本没有内存总线活动，并主动写回主内存脏高速缓存行。这种高速缓存架构在如x86和x86-64各种各样的处理器间存在。制造商之间，即使在同一制造商生产的产品中，证明了的内存模型抽象的力量。&lt;/p&gt;

&lt;p&gt;　　在对称多处理器（SMP）架构的系统中，CPU的高速缓存不能独立的工作。在任何时候，所有的处理器都应该拥有相同的内存内容。保证这样的统一的内存视图被称为“高速缓存一致性”。如果在其自己的高速缓存和主内存间，处理器设计简单，它将不会看到在其他处理器上的脏高速缓存行的内容。从一个处理器直接访问另一个处理器的高速缓存这种模型设计代价将是非常昂贵的，它是一个相当大的瓶颈。相反，当另一个处理器要读取或写入到高速缓存线上时，处理器会去检测。&lt;/p&gt;

&lt;p&gt;　　如果CPU检测到一个写访问，而且该CPU的cache中已经缓存了一个cache line的原始副本，那么这个cache line将被标记为无效的cache line。接下来在引用这个cache line之前，需要重新加载该cache line。需要注意的是读访问并不会导致cache line被标记为无效的。&lt;/p&gt;

&lt;p&gt;　　更精确的cache实现需要考虑到其他更多的可能性，比如第二个CPU在读或者写他的cache line时，发现该cache line在第一个CPU的cache中被标记为脏数据了，此时我们就需要做进一步的处理。在这种情况下，主存储器已经失效，第二个CPU需要读取第一个CPU的cache line。通过测试，我们知道在这种情况下第一个CPU会将自己的cache line数据自动发送给第二个CPU。这种操作是绕过主存储器的，但是有时候存储控制器是可以直接将第一个CPU中的cache line数据存储到主存储器中。对第一个CPU的cache的写访问会导致本地cache line的所有拷贝被标记为无效。&lt;/p&gt;

&lt;p&gt;　　随着时间的推移，一大批缓存一致性协议已经建立。其中，最重要的是MESI,我们将在第3.3.4节进行介绍。以上结论可以概括为几个简单的规则:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个脏缓存线不存在于任何其他处理器的缓存之中。&lt;/li&gt;
&lt;li&gt;同一缓存线中的干净拷贝可以驻留在任意多个其他缓存之中。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　如果遵守这些规则,处理器甚至可以在多处理器系统中更加有效的使用它们的缓存。所有的处理器需要做的就是监控其他每一个写访问和比较本地缓存中的地址。在下一节中,我们将介绍更多细节方面的实现,尤其是存储开销方面的细节。&lt;/p&gt;

&lt;p&gt;　　最后，我们至少应该关注高速缓存命中或未命中带来的消耗。下面是英特尔奔腾 M 的数据：&lt;/p&gt;

&lt;table border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;To Where&lt;/th&gt;
&lt;th&gt;Cycles&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Register&lt;/td&gt;
&lt;td&gt;&amp;lt;= 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L1d&lt;/td&gt;
&lt;td&gt;~3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L2&lt;/td&gt;
&lt;td&gt;~14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Main Memory&lt;/td&gt;
&lt;td&gt;~240&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;　　这是在CPU周期中的实际访问时间。有趣的是，对于L2高速缓存的访问时间很大一部分（甚至是大部分）是由线路的延迟引起的。这是一个限制，增加高速缓存的大小变得更糟。只有当减小时（例如，从60纳米的Merom到45纳米Penryn处理器），可以提高这些数据。&lt;/p&gt;

&lt;p&gt;　　表格中的数字看起来很高，但是，幸运的是，整个成本不必须负担每次出现的缓存加载和缓存失效。某些部分的成本可以被隐藏。现在的处理器都使用不同长度的内部管道，在管道内指令被解码，并为准备执行。如果数据要传送到一个寄存器，那么部分的准备工作是从存储器（或高速缓存）加载数据。如果内存加载操作在管道中足够早的进行，它可以与其他操作并行发生，那么加载的全部发销可能会被隐藏。对L1D常常可能如此；某些有长管道的处理器的L2也可以。&lt;/p&gt;

&lt;p&gt;　　提早启动内存的读取有许多障碍。它可能只是简单的不具有足够资源供内存访问，或者地址从另一个指令获取，然后加载的最终地址才变得可用。在这种情况下，加载成本是不能隐藏的（完全的）。&lt;/p&gt;

&lt;p&gt;　　对于写操作，CPU并不需要等待数据被安全地放入内存。只要指令具有类似的效果，就没有什么东西可以阻止CPU走捷径了。它可以早早地执行下一条指令，甚至可以在影子寄存器(shadow register)的帮助下，更改这个写操作将要存储的数据。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/56.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/56.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.4: 随机写操作的访问时间&lt;/center&gt;


&lt;p&gt;　　图3.4展示了缓存的效果。关于产生图中数据的程序，我们会在稍后讨论。这里大致说下，这个程序是连续随机地访问某块大小可配的内存区域。每个数据项的大小是固定的。数据项的多少取决于选择的工作集大小。Y轴表示处理每个元素平均需要多少个CPU周期，注意它是对数刻度。X轴也是同样，工作集的大小都以2的n次方表示。&lt;/p&gt;

&lt;p&gt;　　图中有三个比较明显的不同阶段。很正常，这个处理器有L1d和L2，没有L3。根据经验可以推测出，L1d有2&lt;sup&gt;13&lt;/sup&gt; 字节，而L2有2&lt;sup&gt;20&lt;/sup&gt; 字节。因为，如果整个工作集都可以放入L1d，那么只需不到10个周期就可以完成操作。如果工作集超过L1d，处理器不得不从L2获取数据，于是时间飘升到28个周期左右。如果工作集更大，超过了L2，那么时间进一步暴涨到480个周期以上。这时候，许多操作将不得不从主存中获取数据。更糟糕的是，如果修改了数据，还需要将这些脏了的缓存线写回内存。&lt;/p&gt;

&lt;p&gt;　　看了这个图，大家应该会有足够的动力去检查代码、改进缓存的利用方式了吧？这里的性能改善可不只是微不足道的几个百分点，而是几个数量级呀。在第6节中，我们将介绍一些编写高效代码的技巧。而下一节将进一步深入缓存的设计。虽然精彩，但并不是必修课，大家可以选择性地跳过。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3 CPU 缓存实现细节&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　高速缓存的实现者遇到这样的难题：巨大的主内存中每一个单元都潜在的需要缓存。如果程序的工作集足够大，这意味着很多主内存单元竞争高速缓存的每一个地方。先前有过提示，主存和高速缓存的大小比是1000：1，这是不常见的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3.1 关联性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　可以这样实现一个高速缓存，每个高速缓存段（高速缓存行：cache line）都可以容纳任何内存位置的一个副本。这就是所谓的全关联。要访问一个缓存段，处理器核心不得不用所有缓存段的标签和请求地址的标签一一做比较。标签将包含除去缓存段的偏移量全部的地址，（译注：也就是去除3.2节中图的O）（这意味着，S在3.2节的图中是零）&lt;/p&gt;

&lt;p&gt;　　高速缓存有类似这样的实现，但是，看看在今天使用的L2的数目，表明这是不切实际的。给定4MB的高速缓存和64B的高速缓存段，高速缓存将有65,536个项。为了达到足够的性能，缓存逻辑必须能够在短短的几个时钟周期内，从所有这些项中，挑一个匹配给定的标签。实现这一点的工作将是巨大的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/65.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/65.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 3.5: 全关联高速缓存原理图&lt;/center&gt;


&lt;p&gt;　　对于每个高速缓存行，比较器是需要比较大标签（注意，S是零）。每个连接旁边的字母表示位的宽度。如果没有给出，它是一个单比特线。每个比较器都要比较两个T-位宽的值。然后，基于该结果，适当的高速缓存行的内容被选中，并使其可用。这需要合并多套O数据线，因为他们是缓存桶（译注：这里类似把O输出接入多选器，所以需要合并）。实现仅仅一个比较器，需要晶体管的数量就非常大，特别是因为它必须非常快。没有迭代比较器是可用的。节省比较器的数目的唯一途径是通过反复比较标签，以减少它们的数目。这是不适合的，出于同样的原因，迭代比较器不可用：它的时间太长。&lt;/p&gt;

&lt;p&gt;　　全关联高速缓存对 小缓存是实用的（例如，在某些Intel处理器的TLB缓存是全关联的），但这些缓存都很小，非常小的。我们正在谈论的最多几十项。&lt;/p&gt;

&lt;p&gt;　　对于L1i，L1d和更高级别的缓存，需要采用不同的方法。可以做的就是是限制搜索。最极端的限制是，每个标签映射到一个明确的缓存条目。计算很简单：给定的4MB/64B缓存有65536项，我们可以使用地址的bit6到bit21（16位）来直接寻址高速缓存的每一个项。地址的低6位作为高速缓存段的索引。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/74.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/74.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 3.6: Direct-Mapped Cache Schematics&lt;/center&gt;


&lt;p&gt;　　在图3.6中可以看出，这种直接映射的高速缓存，速度快，比较容易实现。它只是需要一个比较器，一个多路复用器（在这个图中有两个，标记和数据是分离的，但是对于设计这不是一个硬性要求），和一些逻辑来选择只是有效的高速缓存行的内容。由于速度的要求，比较器是复杂的，但是现在只需要一个，结果是可以花更多的精力，让其变得快速。这种方法的复杂性在于在多路复用器。一个简单的多路转换器中的晶体管的数量增速是O（log N）的，其中N是高速缓存段的数目。这是可以容忍的，但可能会很慢，在某种情况下，速度可提升，通过增加多路复用器晶体管数量，来并行化的一些工作和自身增速。晶体管的总数只是随着快速增长的高速缓存缓慢的增加，这使得这种解决方案非常有吸引力。但它有一个缺点：只有用于直接映射地址的相关的地址位均匀分布，程序才能很好工作。如果分布的不均匀，而且这是常态，一些缓存项频繁的使用，并因此多次被换出，而另一些则几乎不被使用或一直是空的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/82.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/82.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 3.7: 组关联高速缓存原理图&lt;/center&gt;


&lt;p&gt;　　可以通过使高速缓存的组关联来解决此问题。组关联结合高速缓存的全关联和直接映射高速缓存特点，在很大程度上避免那些设计的弱点。图3.7显示了一个组关联高速缓存的设计。标签和数据存储分成不同的组并可以通过地址选择。这类似直接映射高速缓存。但是，小数目的值可以在同一个高速缓存组缓存，而不是一个缓存组只有一个元素，用于在高速缓存中的每个设定值是相同的一组值的缓存。所有组的成员的标签可以并行比较，这类似全关联缓存的功能。&lt;/p&gt;

&lt;p&gt;　　其结果是高速缓存，不容易被不幸或故意选择同属同一组编号的地址所击败，同时高速缓存的大小并不限于由比较器的数目，可以以并行的方式实现。如果高速缓存增长，只（在该图中）增加列的数目，而不增加行数。只有高速缓存之间的关联性增加，行数才会增加。今天，处理器的L2高速缓存或更高的高速缓存，使用的关联性高达16。L1高速缓存通常使用8。&lt;/p&gt;

&lt;table border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt;L2&lt;/strong&gt;&lt;/span&gt;&lt;br&gt;
&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt; Cache&lt;/strong&gt;&lt;/span&gt;&lt;br&gt;
&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt; Size&lt;/strong&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt;Associativity&lt;/strong&gt;&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt;Direct&lt;/strong&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt;8&lt;/strong&gt;&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt;CL=32&lt;/strong&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt;CL=64&lt;/strong&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt;CL=32&lt;/strong&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt;CL=64&lt;/strong&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt;CL=32&lt;/strong&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt;CL=64&lt;/strong&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt;CL=32&lt;/strong&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt;CL=64&lt;/strong&gt;&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;512k&lt;/td&gt;
&lt;td&gt;27,794,595&lt;/td&gt;
&lt;td&gt;20,422,527&lt;/td&gt;
&lt;td&gt;25,222,611&lt;/td&gt;
&lt;td&gt;18,303,581&lt;/td&gt;
&lt;td&gt;24,096,510&lt;/td&gt;
&lt;td&gt;17,356,121&lt;/td&gt;
&lt;td&gt;23,666,929&lt;/td&gt;
&lt;td&gt;17,029,334&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1M&lt;/td&gt;
&lt;td&gt;19,007,315&lt;/td&gt;
&lt;td&gt;13,903,854&lt;/td&gt;
&lt;td&gt;16,566,738&lt;/td&gt;
&lt;td&gt;12,127,174&lt;/td&gt;
&lt;td&gt;15,537,500&lt;/td&gt;
&lt;td&gt;11,436,705&lt;/td&gt;
&lt;td&gt;15,162,895&lt;/td&gt;
&lt;td&gt;11,233,896&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2M&lt;/td&gt;
&lt;td&gt;12,230,962&lt;/td&gt;
&lt;td&gt;8,801,403&lt;/td&gt;
&lt;td&gt;9,081,881&lt;/td&gt;
&lt;td&gt;6,491,011&lt;/td&gt;
&lt;td&gt;7,878,601&lt;/td&gt;
&lt;td&gt;5,675,181&lt;/td&gt;
&lt;td&gt;7,391,389&lt;/td&gt;
&lt;td&gt;5,382,064&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4M&lt;/td&gt;
&lt;td&gt;7,749,986&lt;/td&gt;
&lt;td&gt;5,427,836&lt;/td&gt;
&lt;td&gt;4,736,187&lt;/td&gt;
&lt;td&gt;3,159,507&lt;/td&gt;
&lt;td&gt;3,788,122&lt;/td&gt;
&lt;td&gt;2,418,898&lt;/td&gt;
&lt;td&gt;3,430,713&lt;/td&gt;
&lt;td&gt;2,125,103&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8M&lt;/td&gt;
&lt;td&gt;4,731,904&lt;/td&gt;
&lt;td&gt;3,209,693&lt;/td&gt;
&lt;td&gt;2,690,498&lt;/td&gt;
&lt;td&gt;1,602,957&lt;/td&gt;
&lt;td&gt;2,207,655&lt;/td&gt;
&lt;td&gt;1,228,190&lt;/td&gt;
&lt;td&gt;2,111,075&lt;/td&gt;
&lt;td&gt;1,155,847&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16M&lt;/td&gt;
&lt;td&gt;2,620,587&lt;/td&gt;
&lt;td&gt;1,528,592&lt;/td&gt;
&lt;td&gt;1,958,293&lt;/td&gt;
&lt;td&gt;1,089,580&lt;/td&gt;
&lt;td&gt;1,704,878&lt;/td&gt;
&lt;td&gt;883,530&lt;/td&gt;
&lt;td&gt;1,671,541&lt;/td&gt;
&lt;td&gt;862,324&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;center&gt;Table 3.1: 高速缓存大小，关联行，段大小的影响&lt;/center&gt;


&lt;p&gt;　　给定我们4MB/64B高速缓存，8路组关联，相关的缓存留给我们的有8192组，只用标签的13位，就可以寻址缓集。要确定哪些（如果有的话）的缓存组设置中的条目包含寻址的高速缓存行，8个标签都要进行比较。在很短的时间内做出来是可行的。通过一个实验，我们可以看到，这是有意义的。&lt;/p&gt;

&lt;p&gt;　　表3.1显示一个程序在改变缓存大小，缓存段大小和关联集大小，L2高速缓存的缓存失效数量（根据Linux内核相关的方面人的说法，GCC在这种情况下，是他们所有中最重要的标尺）。在7.2节中，我们将介绍工具来模拟此测试要求的高速缓存。&lt;/p&gt;

&lt;p&gt;　　万一这还不是很明显，所有这些值之间的关系是高速缓存的大小为：&lt;/p&gt;

&lt;p&gt;cache line size × associativity × number of sets&lt;/p&gt;

&lt;p&gt;　　地址被映射到高速缓存使用&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O&lt;/strong&gt; = log&lt;sub&gt;2&lt;/sub&gt; cache line size&lt;br/&gt;
&lt;strong&gt;S&lt;/strong&gt; = log&lt;sub&gt;2&lt;/sub&gt; number of sets&lt;/p&gt;

&lt;p&gt;　　在第3.2节中的图显示的方式。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/92.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/92.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;Figure 3.8: 缓存段大小 vs 关联行 (CL=32)&lt;/center&gt;


&lt;p&gt;　　图3.8表中的数据更易于理解。它显示一个固定的32个字节大小的高速缓存行的数据。对于一个给定的高速缓存大小，我们可以看出，关联性，的确可以帮助明显减少高速缓存未命中的数量。对于8MB的缓存，从直接映射到2路组相联，可以减少近44％的高速缓存未命中。组相联高速缓存和直接映射缓存相比，该处理器可以把更多的工作集保持在缓存中。&lt;/p&gt;

&lt;p&gt;　　在文献中，偶尔可以读到，引入关联性，和加倍高速缓存的大小具有相同的效果。在从4M缓存跃升到8MB缓存的极端的情况下，这是正确的。关联性再提高一倍那就肯定不正确啦。正如我们所看到的数据，后面的收益要小得多。我们不应该完全低估它的效果，虽然。在示例程序中的内存使用的峰值是5.6M。因此，具有8MB缓存不太可能有很多（两个以上）使用相同的高速缓存的组。从较小的缓存的关联性的巨大收益可以看出，较大工作集可以节省更多。&lt;/p&gt;

&lt;p&gt;　　在一般情况下，增加8以上的高速缓存之间的关联性似乎对只有一个单线程工作量影响不大。随着介绍一个使用共享L2的多核处理器，形势发生了变化。现在你基本上有两个程序命中相同的缓存，实际上导致高速缓存减半（对于四核处理器是1/4）。因此，可以预期，随着核的数目的增加，共享高速缓存的相关性也应增长。一旦这种方法不再可行（16路组关联性已经很难）处理器设计者不得不开始使用共享的三级高速缓存和更高级别的，而L2高速缓存只被核的一个子集共享。&lt;/p&gt;

&lt;p&gt;　　从图3.8中，我们还可以研究缓存大小对性能的影响。这一数据需要了解工作集的大小才能进行解读。很显然，与主存相同的缓存比小缓存能产生更好的结果，因此，缓存通常是越大越好。&lt;/p&gt;

&lt;p&gt;　　上文已经说过，示例中最大的工作集为5.6M。它并没有给出最佳缓存大小值，但我们可以估算出来。问题主要在于内存的使用并不连续，因此，即使是16M的缓存，在处理5.6M的工作集时也会出现冲突(参见2路集合关联式16MB缓存vs直接映射式缓存的优点)。不管怎样，我们可以有把握地说，在同样5.6M的负载下，缓存从16MB升到32MB基本已没有多少提高的余地。但是，工作集是会变的。如果工作集不断增大，缓存也需要随之增大。在购买计算机时，如果需要选择缓存大小，一定要先衡量工作集的大小。原因可以参见图3.10。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/103.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/103.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.9: 测试的内存分布情况&lt;/center&gt;


&lt;p&gt;　　我们执行两项测试。第一项测试是按顺序地访问所有元素。测试程序循着指针n进行访问，而所有元素是链接在一起的，从而使它们的被访问顺序与在内存中排布的顺序一致，如图3.9的下半部分所示，末尾的元素有一个指向首元素的引用。而第二项测试(见图3.9的上半部分)则是按随机顺序访问所有元素。在上述两个测试中，所有元素都构成一个单向循环链表。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3.2 Cache的性能测试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　用于测试程序的数据可以模拟一个任意大小的工作集：包括读、写访问，随机、连续访问。在图3.4中我们可以看到，程序为工作集创建了一个与其大小和元素类型相同的数组：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct l {
  struct l *n;
  long int pad[NPAD];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　n字段将所有节点随机得或者顺序的加入到环形链表中，用指针从当前节点进入到下一个节点。pad字段用来存储数据，其可以是任意大小。在一些测试程序中，pad字段是可以修改的,在其他程序中，pad字段只可以进行读操作。&lt;/p&gt;

&lt;p&gt;　　在性能测试中，我们谈到工作集大小的问题，工作集使用结构体l定义的元素表示的。2&lt;sup&gt;N&lt;/sup&gt; 字节的工作集包含2&lt;sup&gt;N&lt;/sup&gt;
/sizeof(struct l)个元素. 显然sizeof(struct l)的值取决于NPAD的大小。在32位系统上，NPAD=7意味着数组的每个元素的大小为32字节，在64位系统上，NPAD=7意味着数组的每个元素的大小为64字节。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;单线程顺序访问&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　最简单的情况就是遍历链表中顺序存储的节点。无论是从前向后处理，还是从后向前，对于处理器来说没有什么区别。下面的测试中，我们需要得到处理链表中一个元素所需要的时间，以CPU时钟周期最为计时单元。图3.10显示了测试结构。除非有特殊说明,所有的测试都是在Pentium 4 64-bit平台上进行的，因此结构体l中NPAD=0，大小为8字节。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/1110.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/1110.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图 3.10: 顺序读访问, NPAD=0&lt;/center&gt;


&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/122.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/122.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图 3.11: 顺序读多个字节&lt;/center&gt;


&lt;p&gt;　　一开始的两个测试数据收到了噪音的污染。由于它们的工作负荷太小，无法过滤掉系统内其它进程对它们的影响。我们可以认为它们都是4个周期以内的。这样一来，整个图可以划分为比较明显的三个部分:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;工作集小于2&lt;sup&gt;14&lt;/sup&gt; 字节的。&lt;/li&gt;
&lt;li&gt;工作集从2&lt;sup&gt;15&lt;/sup&gt; 字节到2&lt;sup&gt;20&lt;/sup&gt; 字节的。&lt;/li&gt;
&lt;li&gt;工作集大于2&lt;sup&gt;21&lt;/sup&gt; 字节的。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　这样的结果很容易解释——是因为处理器有16KB的L1d和1MB的L2。而在这三个部分之间，并没有非常锐利的边缘，这是因为系统的其它部分也在使用缓存，我们的测试程序并不能独占缓存的使用。尤其是L2，它是统一式的缓存，处理器的指令也会使用它(注:Intel使用的是包容式缓存)。&lt;/p&gt;

&lt;p&gt;　　测试的实际耗时可能会出乎大家的意料。L1d的部分跟我们预想的差不多，在一台P4上耗时为4个周期左右。但L2的结果则出乎意料。大家可能觉得需要14个周期以上，但实际只用了9个周期。这要归功于处理器先进的处理逻辑，当它使用连续的内存区时，会 &lt;em&gt;预先读取&lt;/em&gt; 下一条缓存线的数据。这样一来，当真正使用下一条线的时候，其实已经早已读完一半了，于是真正的等待耗时会比L2的访问时间少很多。&lt;/p&gt;

&lt;p&gt;　　在工作集超过L2的大小之后，预取的效果更明显了。前面我们说过，主存的访问需要耗时200个周期以上。但在预取的帮助下，实际耗时保持在9个周期左右。200 vs 9，效果非常不错。&lt;/p&gt;

&lt;p&gt;　　我们可以观察到预取的行为，至少可以间接地观察到。图3.11中有4条线，它们表示处理不同大小结构时的耗时情况。随着结构的变大，元素间的距离变大了。图中4条线对应的元素距离分别是0、56、120和248字节。&lt;/p&gt;

&lt;p&gt;　　图中最下面的这一条线来自前一个图，但在这里更像是一条直线。其它三条线的耗时情况比较差。图中这些线也有比较明显的三个阶段，同时，在小工作集的情况下也有比较大的错误(请再次忽略这些错误)。在只使用L1d的阶段，这些线条基本重合。因为这时候还不需要预取，只需要访问L1d就行。&lt;/p&gt;

&lt;p&gt;　　在L2阶段，三条新加的线基本重合，而且耗时比老的那条线高很多，大约在28个周期左右，差不多就是L2的访问时间。这表明，从L2到L1d的预取并没有生效。这是因为，对于最下面的线(NPAD=0)，由于结构小，8次循环后才需要访问一条新缓存线，而上面三条线对应的结构比较大，拿相对最小的NPAD=7来说，光是一次循环就需要访问一条新线，更不用说更大的NPAD=15和31了。而预取逻辑是无法在每个周期装载新线的，因此每次循环都需要从L2读取，我们看到的就是从L2读取的时延。&lt;/p&gt;

&lt;p&gt;　　更有趣的是工作集超过L2容量后的阶段。快看，4条线远远地拉开了。元素的大小变成了主角，左右了性能。处理器应能识别每一步(stride)的大小，不去为NPAD=15和31获取那些实际并不需要的缓存线(参见6.3.1)。元素大小对预取的约束是根源于硬件预取的限制——它无法跨越页边界。如果允许预取器跨越页边界，而下一页不存在或无效，那么OS还得去寻找它。这意味着，程序需要遭遇一次并非由它自己产生的页错误，这是完全不能接受的。在NPAD=7或者更大的时候，由于每个元素都至少需要一条缓存线，预取器已经帮不上忙了，它没有足够的时间去从内存装载数据。
　　另一个导致慢下来的原因是TLB缓存的未命中。TLB是存储虚实地址映射的缓存，参见第4节。为了保持快速，TLB只有很小的容量。如果有大量页被反复访问，超出了TLB缓存容量，就会导致反复地进行地址翻译，这会耗费大量时间。TLB查找的代价分摊到所有元素上，如果元素越大，那么元素的数量越少，每个元素承担的那一份就越多。&lt;/p&gt;

&lt;p&gt;　　为了观察TLB的性能，我们可以进行另两项测试。第一项：我们还是顺序存储列表中的元素，使NPAD=7，让每个元素占满整个cache line，第二项：我们将列表的每个元素存储在一个单独的页上，忽略每个页没有使用的部分以用来计算工作集的大小。（这样做可能不太一致，因为在前面的测试中，我计算了结构体中每个元素没有使用的部分，从而用来定义NPAD的大小，因此每个元素占满了整个页，这样以来工作集的大小将会有所不同。但是这不是这项测试的重点，预取的低效率多少使其有点不同）。结果表明，第一项测试中，每次列表的迭代都需要一个新的cache line，而且每64个元素就需要一个新的页。第二项测试中，每次迭代都会在一个新的页中加载一个新的cache line。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/132.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/132.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图 3.12: TLB 对顺序读的影响&lt;/center&gt;


&lt;p&gt;　　结果见图3.12。该测试与图3.11是在同一台机器上进行的。基于可用RAM空间的有限性，测试设置容量空间大小为2的24次方字节，这就需要1GB的容量将对象放置在分页上。图3.12中下方的红色曲线正好对应了图3.11中NPAD等于7的曲线。我们看到不同的步长显示了高速缓存L1d和L2的大小。第二条曲线看上去完全不同，其最重要的特点是当工作容量到达2的13次方字节时开始大幅度增长。这就是TLB缓存溢出的时候。我们能计算出一个64字节大小的元素的TLB缓存有64个输入。成本不会受页面错误影响，因为程序锁定了存储器以防止内存被换出。&lt;/p&gt;

&lt;p&gt;　　可以看出，计算物理地址并把它存储在TLB中所花费的周期数量级是非常高的。图3.12的表格显示了一个极端的例子，但从中可以清楚的得到：TLB缓存效率降低的一个重要因素是大型NPAD值的减缓。由于物理地址必须在缓存行能被L2或主存读取之前计算出来，地址转换这个不利因素就增加了内存访问时间。这一点部分解释了为什么NPAD等于31时每个列表元素的总花费比理论上的RAM访问时间要高。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/142.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/142.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.13 NPAD等于1时的顺序读和写&lt;/center&gt;


&lt;p&gt;　　通过查看链表元素被修改时测试数据的运行情况，我们可以窥见一些更详细的预取实现细节。图3.13显示了三条曲线。所有情况下元素宽度都为16个字节。第一条曲线“Follow”是熟悉的链表走线在这里作为基线。第二条曲线，标记为“Inc”，仅仅在当前元素进入下一个前给其增加thepad[0]成员。第三条曲线，标记为”Addnext0″，取出下一个元素的thepad[0]链表元素并把它添加为当前链表元素的thepad[0]成员。&lt;/p&gt;

&lt;p&gt;　　在没运行时，大家可能会以为”Addnext0″更慢，因为它要做的事情更多——在没进到下个元素之前就需要装载它的值。但实际的运行结果令人惊讶——在某些小工作集下，”Addnext0″比”Inc”更快。这是为什么呢？原因在于，系统一般会对下一个元素进行强制性预取。当程序前进到下个元素时，这个元素其实早已被预取在L1d里。因此，只要工作集比L2小，”Addnext0″的性能基本就能与”Follow”测试媲美。&lt;/p&gt;

&lt;p&gt;　　但是，”Addnext0″比”Inc”更快离开L2，这是因为它需要从主存装载更多的数据。而在工作集达到2&lt;sup&gt;21&lt;/sup&gt; 字节时，”Addnext0″的耗时达到了28个周期，是同期”Follow”14周期的两倍。这个两倍也很好解释。”Addnext0″和”Inc”涉及对内存的修改，因此L2的逐出操作不能简单地把数据一扔了事，而必须将它们写入内存。因此FSB的可用带宽变成了一半，传输等量数据的耗时也就变成了原来的两倍。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/152.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/152.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.14: 更大L2/L3缓存的优势&lt;/center&gt;


&lt;p&gt;　　决定顺序式缓存处理性能的另一个重要因素是缓存容量。虽然这一点比较明显，但还是值得一说。图3.14展示了128字节长元素的测试结果(64位机，NPAD=15)。这次我们比较三台不同计算机的曲线，两台P4，一台Core 2。两台P4的区别是缓存容量不同，一台是32k的L1d和1M的L2，一台是16K的L1d、512k的L2和2M的L3。Core 2那台则是32k的L1d和4M的L2。&lt;/p&gt;

&lt;p&gt;　　图中最有趣的地方，并不是Core 2如何大胜两台P4，而是工作集开始增长到连末级缓存也放不下、需要主存热情参与之后的部分。&lt;/p&gt;

&lt;table border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;&lt;span style=&quot;color: #000000;&quot;&gt;Set&lt;/span&gt;&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;&lt;span style=&quot;color: #000000;&quot;&gt; Size&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;&lt;span style=&quot;color: #000000;&quot;&gt;Sequential&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;&lt;span style=&quot;color: #000000;&quot;&gt;Random&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;&lt;span style=&quot;color: #000000;&quot;&gt;L2 Hit&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;&lt;span style=&quot;color: #000000;&quot;&gt;L2 Miss&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;&lt;span style=&quot;color: #000000;&quot;&gt;#Iter&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;&lt;span style=&quot;color: #000000;&quot;&gt;Ratio Miss/Hit&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;&lt;span style=&quot;color: #000000;&quot;&gt;L2 Accesses Per Iter&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;&lt;span style=&quot;color: #000000;&quot;&gt;L2 Hit&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;&lt;span style=&quot;color: #000000;&quot;&gt;L2 Miss&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;&lt;span style=&quot;color: #000000;&quot;&gt;#Iter&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;&lt;span style=&quot;color: #000000;&quot;&gt;Ratio Miss/Hit&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;&lt;span style=&quot;color: #000000;&quot;&gt;L2 Accesses Per Iter&lt;/span&gt;&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;sup&gt;20&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;88,636&lt;/td&gt;
&lt;td&gt;843&lt;/td&gt;
&lt;td&gt;16,384&lt;/td&gt;
&lt;td&gt;0.94%&lt;/td&gt;
&lt;td&gt;5.5&lt;/td&gt;
&lt;td&gt;30,462&lt;/td&gt;
&lt;td&gt;4721&lt;/td&gt;
&lt;td&gt;1,024&lt;/td&gt;
&lt;td&gt;13.42%&lt;/td&gt;
&lt;td&gt;34.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;88,105&lt;/td&gt;
&lt;td&gt;1,584&lt;/td&gt;
&lt;td&gt;8,192&lt;/td&gt;
&lt;td&gt;1.77%&lt;/td&gt;
&lt;td&gt;10.9&lt;/td&gt;
&lt;td&gt;21,817&lt;/td&gt;
&lt;td&gt;15,151&lt;/td&gt;
&lt;td&gt;512&lt;/td&gt;
&lt;td&gt;40.98%&lt;/td&gt;
&lt;td&gt;72.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;88,106&lt;/td&gt;
&lt;td&gt;1,600&lt;/td&gt;
&lt;td&gt;4,096&lt;/td&gt;
&lt;td&gt;1.78%&lt;/td&gt;
&lt;td&gt;21.9&lt;/td&gt;
&lt;td&gt;22,258&lt;/td&gt;
&lt;td&gt;22,285&lt;/td&gt;
&lt;td&gt;256&lt;/td&gt;
&lt;td&gt;50.03%&lt;/td&gt;
&lt;td&gt;174.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;sup&gt;23&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;88,104&lt;/td&gt;
&lt;td&gt;1,614&lt;/td&gt;
&lt;td&gt;2,048&lt;/td&gt;
&lt;td&gt;1.80%&lt;/td&gt;
&lt;td&gt;43.8&lt;/td&gt;
&lt;td&gt;27,521&lt;/td&gt;
&lt;td&gt;26,274&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;48.84%&lt;/td&gt;
&lt;td&gt;420.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;sup&gt;24&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;88,114&lt;/td&gt;
&lt;td&gt;1,655&lt;/td&gt;
&lt;td&gt;1,024&lt;/td&gt;
&lt;td&gt;1.84%&lt;/td&gt;
&lt;td&gt;87.7&lt;/td&gt;
&lt;td&gt;33,166&lt;/td&gt;
&lt;td&gt;29,115&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;46.75%&lt;/td&gt;
&lt;td&gt;973.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;sup&gt;25&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;88,112&lt;/td&gt;
&lt;td&gt;1,730&lt;/td&gt;
&lt;td&gt;512&lt;/td&gt;
&lt;td&gt;1.93%&lt;/td&gt;
&lt;td&gt;175.5&lt;/td&gt;
&lt;td&gt;39,858&lt;/td&gt;
&lt;td&gt;32,360&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;44.81%&lt;/td&gt;
&lt;td&gt;2,256.8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;sup&gt;26&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;88,112&lt;/td&gt;
&lt;td&gt;1,906&lt;/td&gt;
&lt;td&gt;256&lt;/td&gt;
&lt;td&gt;2.12%&lt;/td&gt;
&lt;td&gt;351.6&lt;/td&gt;
&lt;td&gt;48,539&lt;/td&gt;
&lt;td&gt;38,151&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;44.01%&lt;/td&gt;
&lt;td&gt;5,418.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;sup&gt;27&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;88,114&lt;/td&gt;
&lt;td&gt;2,244&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;2.48%&lt;/td&gt;
&lt;td&gt;705.9&lt;/td&gt;
&lt;td&gt;62,423&lt;/td&gt;
&lt;td&gt;52,049&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;45.47%&lt;/td&gt;
&lt;td&gt;14,309.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;sup&gt;28&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;88,120&lt;/td&gt;
&lt;td&gt;2,939&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;3.23%&lt;/td&gt;
&lt;td&gt;1,422.8&lt;/td&gt;
&lt;td&gt;81,906&lt;/td&gt;
&lt;td&gt;87,167&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;51.56%&lt;/td&gt;
&lt;td&gt;42,268.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;sup&gt;29&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;88,137&lt;/td&gt;
&lt;td&gt;4,318&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;4.67%&lt;/td&gt;
&lt;td&gt;2,889.2&lt;/td&gt;
&lt;td&gt;119,079&lt;/td&gt;
&lt;td&gt;163,398&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;57.84%&lt;/td&gt;
&lt;td&gt;141,238.5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;&lt;strong&gt;表3.2: 顺序访问与随机访问时L2命中与未命中的情况，NPAD=0&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　与我们预计的相似，最末级缓存越大，曲线停留在L2访问耗时区的时间越长。在220字节的工作集时，第二台P4(更老一些)比第一台P4要快上一倍，这要完全归功于更大的末级缓存。而Core 2拜它巨大的4M L2所赐，表现更为卓越。&lt;/p&gt;

&lt;p&gt;对于随机的工作负荷而言，可能没有这么惊人的效果，但是，如果我们能将工作负荷进行一些裁剪，让它匹配末级缓存的容量，就完全可以得到非常大的性能提升。也是由于这个原因，有时候我们需要多花一些钱，买一个拥有更大缓存的处理器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;单线程随机访问模式的测量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　前面我们已经看到，处理器能够利用L1d到L2之间的预取消除访问主存、甚至是访问L2的时延。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/162.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/162.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.15: 顺序读取vs随机读取，NPAD=0&lt;/center&gt;


&lt;p&gt;　　但是，如果换成随机访问或者不可预测的访问，情况就大不相同了。图3.15比较了顺序读取与随机读取的耗时情况。&lt;/p&gt;

&lt;p&gt;　　换成随机之后，处理器无法再有效地预取数据，只有少数情况下靠运气刚好碰到先后访问的两个元素挨在一起的情形。&lt;/p&gt;

&lt;p&gt;　　图3.15中有两个需要关注的地方。首先，在大的工作集下需要非常多的周期。这台机器访问主存的时间大约为200-300个周期，但图中的耗时甚至超过了450个周期。我们前面已经观察到过类似现象(对比图3.11)。这说明，处理器的自动预取在这里起到了反效果。&lt;/p&gt;

&lt;p&gt;　　其次，代表随机访问的曲线在各个阶段不像顺序访问那样保持平坦，而是不断攀升。为了解释这个问题，我们测量了程序在不同工作集下对L2的访问情况。结果如图3.16和表3.2。&lt;/p&gt;

&lt;p&gt;　　从图中可以看出，当工作集大小超过L2时，未命中率(L2未命中次数/L2访问次数)开始上升。整条曲线的走向与图3.15有些相似:
先急速爬升，随后缓缓下滑，最后再度爬升。它与耗时图有紧密的关联。L2未命中率会一直爬升到100%为止。只要工作集足够大(并且内存也足够大)，就可以将缓存线位于L2内或处于装载过程中的可能性降到非常低。&lt;/p&gt;

&lt;p&gt;　　缓存未命中率的攀升已经可以解释一部分的开销。除此以外，还有一个因素。观察表3.2的L2/#Iter列，可以看到每个循环对L2的使用次数在增长。由于工作集每次为上一次的两倍，如果没有缓存的话，内存的访问次数也将是上一次的两倍。在按顺序访问时，由于缓存的帮助及完美的预见性，对L2使用的增长比较平缓，完全取决于工作集的增长速度。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/assets/files/2013-03/172.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/172.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.16: L2d未命中率&lt;/center&gt;


&lt;p&gt;　　&lt;a href=&quot;/assets/files/2013-03/182.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/182.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.17: 页意义上(Page-Wise)的随机化，NPAD=7&lt;/center&gt;


&lt;p&gt;　　而换成随机访问后，单位耗时的增长超过了工作集的增长，根源是TLB未命中率的上升。图3.17描绘的是NPAD=7时随机访问的耗时情况。这一次，我们修改了随机访问的方式。正常情况下是把整个列表作为一个块进行随机(以∞表示)，而其它11条线则是在小一些的块里进行随机。例如，标签为’60′的线表示以60页(245760字节)为单位进行随机。先遍历完这个块里的所有元素，再访问另一个块。这样一来，可以保证任意时刻使用的TLB条目数都是有限的。NPAD=7对应于64字节，正好等于缓存线的长度。由于元素顺序随机，硬件预取不可能有任何效果，特别是在元素较多的情况下。这意味着，分块随机时的L2未命中率与整个列表随机时的未命中率没有本质的差别。随着块的增大，曲线逐渐逼近整个列表随机对应的曲线。这说明，在这个测试里，性能受到TLB命中率的影响很大，如果我们能提高TLB命中率，就能大幅度地提升性能(在后面的一个例子里，性能提升了38%之多)。&lt;/p&gt;

&lt;h4&gt;3.3.3 写入时的行为&lt;/h4&gt;

&lt;p&gt;　　在我们开始研究多个线程或进程同时使用相同内存之前，先来看一下缓存实现的一些细节。我们要求缓存是一致的，而且这种一致性必须对用户级代码完全透明。而内核代码则有所不同，它有时候需要对缓存进行转储(flush)。&lt;/p&gt;

&lt;p&gt;　　这意味着，如果对缓存线进行了修改，那么在这个时间点之后，系统的结果应该是与没有缓存的情况下是相同的，即主存的对应位置也已经被修改的状态。这种要求可以通过两种方式或策略实现：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;写通(write-through)&lt;/li&gt;
&lt;li&gt;写回(write-back)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　写通比较简单。当修改缓存线时，处理器立即将它写入主存。这样可以保证主存与缓存的内容永远保持一致。当缓存线被替代时，只需要简单地将它丢弃即可。这种策略很简单，但是速度比较慢。如果某个程序反复修改一个本地变量，可能导致FSB上产生大量数据流，而不管这个变量是不是有人在用，或者是不是短期变量。&lt;/p&gt;

&lt;p&gt;　　写回比较复杂。当修改缓存线时，处理器不再马上将它写入主存，而是打上已弄脏(dirty)的标记。当以后某个时间点缓存线被丢弃时，这个已弄脏标记会通知处理器把数据写回到主存中，而不是简单地扔掉。&lt;/p&gt;

&lt;p&gt;　　写回有时候会有非常不错的性能，因此较好的系统大多采用这种方式。采用写回时，处理器们甚至可以利用FSB的空闲容量来存储缓存线。这样一来，当需要缓存空间时，处理器只需清除脏标记，丢弃缓存线即可。&lt;/p&gt;

&lt;p&gt;　　但写回也有一个很大的问题。当有多个处理器(或核心、超线程)访问同一块内存时，必须确保它们在任何时候看到的都是相同的内容。如果缓存线在其中一个处理器上弄脏了(修改了，但还没写回主存)，而第二个处理器刚好要读取同一个内存地址，那么这个读操作不能去读主存，而需要读第一个处理器的缓存线。在下一节中，我们将研究如何实现这种需求。&lt;/p&gt;

&lt;p&gt;　　在此之前，还有其它两种缓存策略需要提一下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;写入合并&lt;/li&gt;
&lt;li&gt;不可缓存&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　这两种策略用于真实内存不支持的特殊地址区，内核为地址区设置这些策略(x86处理器利用内存类型范围寄存器MTRR)，余下的部分自动进行。MTRR还可用于写通和写回策略的选择。&lt;/p&gt;

&lt;p&gt;　　写入合并是一种有限的缓存优化策略，更多地用于显卡等设备之上的内存。由于设备的传输开销比本地内存要高的多，因此避免进行过多的传输显得尤为重要。如果仅仅因为修改了缓存线上的一个字，就传输整条线，而下个操作刚好是修改线上的下一个字，那么这次传输就过于浪费了。而这恰恰对于显卡来说是比较常见的情形——屏幕上水平邻接的像素往往在内存中也是靠在一起的。顾名思义，写入合并是在写出缓存线前，先将多个写入访问合并起来。在理想的情况下，缓存线被逐字逐字地修改，只有当写入最后一个字时，才将整条线写入内存，从而极大地加速内存的访问。&lt;/p&gt;

&lt;p&gt;　　最后来讲一下不可缓存的内存。一般指的是不被RAM支持的内存位置，它可以是硬编码的特殊地址，承担CPU以外的某些功能。对于商用硬件来说，比较常见的是映射到外部卡或设备的地址。在嵌入式主板上，有时也有类似的地址，用来开关LED。对这些地址进行缓存显然没有什么意义。比如上述的LED，一般是用来调试或报告状态，显然应该尽快点亮或关闭。而对于那些PCI卡上的内存，由于不需要CPU的干涉即可更改，也不该缓存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3.4 多处理器支持&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在上节中我们已经指出当多处理器开始发挥作用的时候所遇到的问题。甚至对于那些不共享的高速级别的缓存（至少在L1d级别）的多核处理器也有问题。&lt;/p&gt;

&lt;p&gt;　　直接提供从一个处理器到另一处理器的高速访问，这是完全不切实际的。从一开始，连接速度根本就不够快。实际的选择是，在其需要的情况下，转移到其他处理器。需要注意的是，这同样应用在相同处理器上无需共享的高速缓存。&lt;/p&gt;

&lt;p&gt;　　现在的问题是，当该高速缓存线转移的时候会发生什么？这个问题回答起来相当容易：当一个处理器需要在另一个处理器的高速缓存中读或者写的脏的高速缓存线的时候。但怎样处理器怎样确定在另一个处理器的缓存中的高速缓存线是脏的？假设它仅仅是因为一个高速缓存线被另一个处理器加载将是次优的（最好的）。通常情况下，大多数的内存访问是只读的访问和产生高速缓存线，并不脏。在高速缓存线上处理器频繁的操作（当然，否则为什么我们有这样的文件呢？），也就意味着每一次写访问后，都要广播关于高速缓存线的改变将变得不切实际。&lt;/p&gt;

&lt;p&gt;　　多年来，人们开发除了MESI缓存一致性协议(MESI=Modified, Exclusive, Shared,
Invalid，变更的、独占的、共享的、无效的)。协议的名称来自协议中缓存线可以进入的四种状态:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;变更的&lt;/strong&gt;:
本地处理器修改了缓存线。同时暗示，它是所有缓存中唯一的拷贝。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;独占的&lt;/strong&gt;: 缓存线没有被修改，而且没有被装入其它处理器缓存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共享的&lt;/strong&gt;: 缓存线没有被修改，但可能已被装入其它处理器缓存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无效的&lt;/strong&gt;: 缓存线无效，即，未被使用。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　MESI协议开发了很多年，最初的版本比较简单，但是效率也比较差。现在的版本通过以上4个状态可以有效地实现写回式缓存，同时支持不同处理器对只读数据的并发访问。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/assets/files/2013-03/192.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/192.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.18: MESI协议的状态跃迁图&lt;/center&gt;


&lt;p&gt;　　在协议中，通过处理器监听其它处理器的活动，不需太多努力即可实现状态变更。处理器将操作发布在外部引脚上，使外部可以了解到处理过程。目标的缓存线地址则可以在地址总线上看到。在下文讲述状态时，我们将介绍总线参与的时机。&lt;/p&gt;

&lt;p&gt;　　一开始，所有缓存线都是空的，缓存为无效(Invalid)状态。当有数据装进缓存供写入时，缓存变为变更(Modified)状态。如果有数据装进缓存供读取，那么新状态取决于其它处理器是否已经状态了同一条缓存线。如果是，那么新状态变成共享(Shared)状态，否则变成独占(Exclusive)状态。&lt;/p&gt;

&lt;p&gt;　　如果本地处理器对某条Modified缓存线进行读写，那么直接使用缓存内容，状态保持不变。如果另一个处理器希望读它，那么第一个处理器将内容发给第一个处理器，然后可以将缓存状态置为Shared。而发给第二个处理器的数据由内存控制器接收，并放入内存中。如果这一步没有发生，就不能将这条线置为Shared。如果第二个处理器希望的是写，那么第一个处理器将内容发给它后，将缓存置为Invalid。这就是臭名昭著的”请求所有权(Request For Ownership,RFO)”操作。在末级缓存执行RFO操作的代价比较高。如果是写通式缓存，还要加上将内容写入上一层缓存或主存的时间，进一步提升了代价。对于Shared缓存线，本地处理器的读取操作并不需要修改状态，而且可以直接从缓存满足。而本地处理器的写入操作则需要将状态置为Modified，而且需要将缓存线在其它处理器的所有拷贝置为Invalid。因此，这个写入操作需要通过RFO消息发通知其它处理器。如果第二个处理器请求读取，无事发生。因为主存已经包含了当前数据，而且状态已经为Shared。如果第二个处理器需要写入，则将缓存线置为Invalid。不需要总线操作。&lt;/p&gt;

&lt;p&gt;　　Exclusive状态与Shared状态很像，只有一个不同之处: 在Exclusive状态时，本地写入操作不需要在总线上声明，因为本地的缓存是系统中唯一的拷贝。这是一个巨大的优势，所以处理器会尽量将缓存线保留在Exclusive状态，而不是Shared状态。只有在信息不可用时，才退而求其次选择shared。放弃Exclusive不会引起任何功能缺失，但会导致性能下降，因为E→M要远远快于S→M。&lt;/p&gt;

&lt;p&gt;　　从以上的说明中应该已经可以看出，在多处理器环境下，哪一步的代价比较大了。填充缓存的代价当然还是很高，但我们还需要留意RFO消息。一旦涉及RFO，操作就快不起来了。&lt;/p&gt;

&lt;p&gt;　　RFO在两种情况下是必需的:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;线程从一个处理器迁移到另一个处理器，需要将所有缓存线移到新处理器。&lt;/li&gt;
&lt;li&gt;某条缓存线确实需要被两个处理器使用。{&lt;em&gt;对于同一处理器的两个核心，也有同样的情况，只是代价稍低。RFO消息可能会被发送多次。&lt;/em&gt;}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　多线程或多进程的程序总是需要同步，而这种同步依赖内存来实现。因此，有些RFO消息是合理的，但仍然需要尽量降低发送频率。除此以外，还有其它来源的RFO。在第6节中，我们将解释这些场景。缓存一致性协议的消息必须发给系统中所有处理器。只有当协议确定已经给过所有处理器响应机会之后，才能进行状态跃迁。也就是说，协议的速度取决于最长响应时间。{&lt;em&gt;这也是现在能看到三插槽AMD Opteron系统的原因。这类系统只有三个超级链路(hyperlink)，其中一个连接南桥，每个处理器之间都只有一跳的距离。&lt;/em&gt;}总线上可能会发生冲突，NUMA系统的延时很大，突发的流量会拖慢通信。这些都是让我们避免无谓流量的充足理由。&lt;/p&gt;

&lt;p&gt;　　此外，关于多处理器还有一个问题。虽然它的影响与具体机器密切相关，但根源是唯一的——FSB是共享的。在大多数情况下，所有处理器通过唯一的总线连接到内存控制器(参见图2.1)。如果一个处理器就能占满总线(十分常见)，那么共享总线的两个或四个处理器显然只会得到更有限的带宽。&lt;/p&gt;

&lt;p&gt;　　即使每个处理器有自己连接内存控制器的总线，如图2.2，但还需要通往内存模块的总线。一般情况下，这种总线只有一条。退一步说，即使像图2.2那样不止一条，对同一个内存模块的并发访问也会限制它的带宽。&lt;/p&gt;

&lt;p&gt;　　对于每个处理器拥有本地内存的AMD模型来说，也是同样的问题。的确，所有处理器可以非常快速地同时访问它们自己的内存。但是，多线程呢？多进程呢？它们仍然需要通过访问同一块内存来进行同步。&lt;/p&gt;

&lt;p&gt;　　对同步来说，有限的带宽严重地制约着并发度。程序需要更加谨慎的设计，将不同处理器访问同一块内存的机会降到最低。以下的测试展示了这一点，还展示了与多线程代码相关的其它效果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多线程测量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　为了帮助大家理解问题的严重性，我们来看一些曲线图，主角也是前文的那个程序。只不过这一次，我们运行多个线程，并测量这些线程中最快那个的运行时间。也就是说，等它们全部运行完是需要更长时间的。我们用的机器有4个处理器，而测试是做多跑4个线程。所有处理器共享同一条通往内存控制器的总线，另外，通往内存模块的总线也只有一条。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/assets/files/2013-03/202.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/202.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.19: 顺序读操作，多线程&lt;/center&gt;


&lt;p&gt;　　图3.19展示了顺序读访问时的性能，元素为128字节长(64位计算机，NPAD=15)。对于单线程的曲线，我们预计是与图3.11相似，只不过是换了一台机器，所以实际的数字会有些小差别。&lt;/p&gt;

&lt;p&gt;　　更重要的部分当然是多线程的环节。由于是只读，不会去修改内存，不会尝试同步。但即使不需要RFO，而且所有缓存线都可共享，性能仍然分别下降了18%(双线程)和34%(四线程)。由于不需要在处理器之间传输缓存，因此这里的性能下降完全由以下两个瓶颈之一或同时引起: 一是从处理器到内存控制器的共享总线，二是从内存控制器到内存模块的共享总线。当工作集超过L3后，三种情况下都要预取新元素，而即使是双线程，可用的带宽也无法满足线性扩展(无惩罚)。&lt;/p&gt;

&lt;p&gt;　　当加入修改之后，场面更加难看了。图3.20展示了顺序递增测试的结果。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/assets/files/2013-03/215.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/215.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.20: 顺序递增，多线程&lt;/center&gt;


&lt;p&gt;　　图中Y轴采用的是对数刻度，不要被看起来很小的差值欺骗了。现在，双线程的性能惩罚仍然是18%，但四线程的惩罚飙升到了93%！原因在于，采用四线程时，预取的流量与写回的流量加在一起，占满了整个总线。&lt;/p&gt;

&lt;p&gt;　　我们用对数刻度来展示L1d范围的结果。可以发现，当超过一个线程后，L1d就无力了。单线程时，仅当工作集超过L1d时访问时间才会超过20个周期，而多线程时，即使在很小的工作集情况下，访问时间也达到了那个水平。&lt;/p&gt;

&lt;p&gt;　　这里并没有揭示问题的另一方面，主要是用这个程序很难进行测量。问题是这样的，我们的测试程序修改了内存，所以本应看到RFO的影响，但在结果中，我们并没有在L2阶段看到更大的开销。原因在于，要看到RFO的影响，程序必须使用大量内存，而且所有线程必须同时访问同一块内存。如果没有大量的同步，这是很难实现的，而如果加入同步，则会占满执行时间。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/assets/files/2013-03/222.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/222.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.21: 随机的Addnextlast，多线程&lt;/center&gt;


&lt;p&gt;　　最后，在图3.21中，我们展示了随机访问的Addnextlast测试的结果。这里主要是为了让大家感受一下这些巨大到爆的数字。极端情况下，甚至用了1500个周期才处理完一个元素。如果加入更多线程，真是不可想象哪。我们把多线程的效能总结了一下:&lt;/p&gt;

&lt;table border=&quot;&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;#Threads&lt;/th&gt;
&lt;th&gt;Seq Read&lt;/th&gt;
&lt;th&gt;Seq Inc&lt;/th&gt;
&lt;th&gt;Rand Add&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1.69&lt;/td&gt;
&lt;td&gt;1.69&lt;/td&gt;
&lt;td&gt;1.54&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2.98&lt;/td&gt;
&lt;td&gt;2.07&lt;/td&gt;
&lt;td&gt;1.65&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;表3.3: 多线程的效能&lt;/p&gt;

&lt;p&gt;　　这个表展示了图3.21中多线程运行大工作集时的效能。表中的数字表示测试程序在使用多线程处理大工作集时可能达到的最大加速因子。双线程和四线程的理论最大加速因子分别是2和4。从表中数据来看，双线程的结果还能接受，但四线程的结果表明，扩展到双线程以上是没有什么意义的，带来的收益可以忽略不计。只要我们把图3.21换个方式呈现，就可以很容易看清这一点。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/assets/files/2013-03/232.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/232.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.22: 通过并行化实现的加速因子&lt;/center&gt;


&lt;p&gt;　　图3.22中的曲线展示了加速因子，即多线程相对于单线程所能获取的性能加成值。测量值的精确度有限，因此我们需要忽略比较小的那些数字。可以看到，在L2与L3范围内，多线程基本可以做到线性加速，双线程和四线程分别达到了2和4的加速因子。但是，一旦工作集的大小超出L3，曲线就崩塌了，双线程和四线程降到了基本相同的数值(参见表3.3中第4列)。也是部分由于这个原因，我们很少看到4CPU以上的主板共享同一个内存控制器。如果需要配置更多处理器，我们只能选择其它的实现方式(参见第5节)。&lt;/p&gt;

&lt;p&gt;　　可惜，上图中的数据并不是普遍情况。在某些情况下，即使工作集能够放入末级缓存，也无法实现线性加速。实际上，这反而是正常的，因为普通的线程都有一定的耦合关系，不会像我们的测试程序这样完全独立。而反过来说，即使是很大的工作集，即使是两个以上的线程，也是可以通过并行化受益的，但是需要程序员的聪明才智。我们会在第6节进行一些介绍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特例: 超线程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　由CPU实现的超线程(有时又叫对称多线程，SMT)是一种比较特殊的情况，每个线程并不能真正并发地运行。它们共享着除寄存器外的绝大多数处理资源。每个核心和CPU仍然是并行工作的，但核心上的线程则受到这个限制。理论上，每个核心可以有大量线程，不过到目前为止，Intel的CPU最多只有两个线程。CPU负责对各线程进行时分复用，但这种复用本身并没有多少厉害。它真正的优势在于，CPU可以在当前运行的超线程发生延迟时，调度另一个线程。这种延迟一般由内存访问引起。&lt;/p&gt;

&lt;p&gt;　　如果两个线程运行在一个超线程核心上，那么只有当两个线程&lt;em&gt;合起来**的&lt;/em&gt;运行时间少于单线程运行时间时，效率才会比较高。我们可以将通常先后发生的内存访问叠合在一起，以实现这个目标。有一个简单的计算公式，可以帮助我们计算如果需要某个加速因子，最少需要多少的缓存命中率。&lt;/p&gt;

&lt;p&gt;　　程序的执行时间可以通过一个只有一级缓存的简单模型来进行估算(参见[htimpact]):&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/latex-math-1.gif&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/latex-math-1.gif&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;各变量的含义如下:&lt;/p&gt;

&lt;table style=&quot;width:70%;text-align:center;&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;指令数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F&lt;sub&gt;mem&lt;/sub&gt;&lt;/td&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;N中访问内存的比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G&lt;sub&gt;hit&lt;/sub&gt;&lt;/td&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;命中缓存的比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T&lt;sub&gt;proc&lt;/sub&gt;&lt;/td&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;每条指令所用的周期数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T&lt;sub&gt;cache&lt;/sub&gt;&lt;/td&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;缓存命中所用的周期数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T&lt;sub&gt;miss&lt;/sub&gt;&lt;/td&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;缓冲未命中所用的周期数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T&lt;sub&gt;exe&lt;/sub&gt;&lt;/td&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;程序的执行时间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;　　为了让任何判读使用双线程，两个线程之中任一线程的执行时间最多为单线程指令的一半。两者都有一个唯一的变量缓存命中数。如果我们要解决最小缓存命中率相等的问题需要使我们获得的线程的执行率不少于50%或更多，如图3.23.&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/assets/files/2013-03/241.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/241.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图 3.23: 最小缓存命中率-加速&lt;/center&gt;


&lt;p&gt;　　X轴表示单线程指令的缓存命中率G~hit，~Y轴表示多线程指令所需的缓存命中率。这个值永远不能高于单线程命中率，否则，单线程指令也会使用改良的指令。为了使单线程的命中率在低于55%的所有情况下优于使用多线程，cup要或多或少的足够空闲因为缓存丢失会运行另外一个超线程。&lt;/p&gt;

&lt;p&gt;　　绿色区域是我们的目标。如果线程的速度没有慢过50%，而每个线程的工作量只有原来的一半，那么它们合起来的耗时应该会少于单线程的耗时。对我们用的示例系统来说(使用超线程的P4机器)，如果单线程代码的命中率为60%，那么多线程代码至少要达到10%才能获得收益。这个要求一般来说还是可以做到的。但是，如果单线程代码的命中率达到了95%，那么多线程代码要做到80%才行。这就很难了。而且，这里还涉及到超线程，在两个超线程的情况下，每个超线程只能分到一半的有效缓存。因为所有超线程是使用同一个缓存来装载数据的，如果两个超线程的工作集没有重叠，那么原始的95%也会被打对折——47%，远低于80%。&lt;/p&gt;

&lt;p&gt;　　因此，超线程只在某些情况下才比较有用。单线程代码的缓存命中率必须低到一定程度，从而使缓存容量变小时新的命中率仍能满足要求。只有在这种情况下，超线程才是有意义的。在实践中，采用超线程能否获得更快的结果，取决于处理器能否有效地将每个进程的等待时间与其它进程的执行时间重叠在一起。并行化也需要一定的开销，需要加到总的运行时间里，这个开销往往是不能忽略的。&lt;/p&gt;

&lt;p&gt;　　在6.3.4节中，我们会介绍一种技术，它将多个线程通过公用缓存紧密地耦合起来。这种技术适用于许多场合，前提是程序员们乐意花费时间和精力扩展自己的代码。&lt;/p&gt;

&lt;p&gt;　　如果两个超线程执行完全不同的代码(两个线程就像被当成两个处理器，分别执行不同进程)，那么缓存容量就真的会降为一半，导致缓冲未命中率大为攀升，这一点应该是很清楚的。这样的调度机制是很有问题的，除非你的缓存足够大。所以，除非程序的工作集设计得比较合理，能够确实从超线程获益，否则还是建议在BIOS中把超线程功能关掉。{我们可能会因为另一个原因 &lt;em&gt;开启&lt;/em&gt; &lt;em&gt;超线程，那就是调试，因为SMT在查找并行代码的问题方面真的非常好用。&lt;/em&gt;}&lt;/p&gt;

&lt;h4&gt;3.3.5 其它细节&lt;/h4&gt;

&lt;p&gt;　　我们已经介绍了地址的组成，即标签、集合索引和偏移三个部分。那么，实际会用到什么样的地址呢？目前，处理器一般都向进程提供虚拟地址空间，意味着我们有两种不同的地址:
虚拟地址和物理地址。&lt;/p&gt;

&lt;p&gt;　　虚拟地址有个问题——并不唯一。随着时间的变化，虚拟地址可以变化，指向不同的物理地址。同一个地址在不同的进程里也可以表示不同的物理地址。那么，是不是用物理地址会比较好呢？&lt;/p&gt;

&lt;p&gt;　　问题是，处理器指令用的虚拟地址，而且需要在内存管理单元(MMU)的协助下将它们翻译成物理地址。这并不是一个很小的操作。在执行指令的管线(pipeline)中，物理地址只能在很后面的阶段才能得到。这意味着，缓存逻辑需要在很短的时间里判断地址是否已被缓存过。而如果可以使用虚拟地址，缓存查找操作就可以更早地发生，一旦命中，就可以马上使用内存的内容。结果就是，使用虚拟内存后，可以让管线把更多内存访问的开销隐藏起来。&lt;/p&gt;

&lt;p&gt;　　处理器的设计人员们现在使用虚拟地址来标记第一级缓存。这些缓存很小，很容易被清空。在进程页表树发生变更的情况下，至少是需要清空部分缓存的。如果处理器拥有指定变更地址范围的指令，那么可以避免缓存的完全刷新。由于一级缓存L1i及L1d的时延都很小(\~3周期)，基本上必须使用虚拟地址。&lt;/p&gt;

&lt;p&gt;　　对于更大的缓存，包括L2和L3等，则需要以物理地址作为标签。因为这些缓存的时延比较大，虚拟到物理地址的映射可以在允许的时间里完成，而且由于主存时延的存在，重新填充这些缓存会消耗比较长的时间，刷新的代价比较昂贵。&lt;/p&gt;

&lt;p&gt;　　一般来说，我们并不需要了解这些缓存处理地址的细节。我们不能更改它们，而那些可能影响性能的因素，要么是应该避免的，要么是有很高代价的。填满缓存是不好的行为，缓存线都落入同一个集合，也会让缓存早早地出问题。对于后一个问题，可以通过缓存虚拟地址来避免，但作为一个用户级程序，是不可能避免缓存物理地址的。我们唯一可以做的，是尽最大努力不要在同一个进程里用多个虚拟地址映射同一个物理地址。&lt;/p&gt;

&lt;p&gt;　　另一个细节对程序员们来说比较乏味，那就是缓存的替换策略。大多数缓存会优先逐出最近最少使用(Least Recently Used,LRU)的元素。这往往是一个效果比较好的策略。在关联性很大的情况下(随着以后核心数的增加，关联性势必会变得越来越大)，维护LRU列表变得越来越昂贵，于是我们开始看到其它的一些策略。&lt;/p&gt;

&lt;p&gt;　　在缓存的替换策略方面，程序员可以做的事情不多。如果缓存使用物理地址作为标签，我们是无法找出虚拟地址与缓存集之间关联的。有可能会出现这样的情形: 所有逻辑页中的缓存线都映射到同一个缓存集，而其它大部分缓存却空闲着。即使有这种情况，也只能依靠OS进行合理安排，避免频繁出现。&lt;/p&gt;

&lt;p&gt;　　虚拟化的出现使得这一切变得更加复杂。现在不仅操作系统可以控制物理内存的分配。虚拟机监视器（VMM，也称为 hypervisor）也负责分配内存。&lt;/p&gt;

&lt;p&gt;　　对程序员来说，最好 a) 完全使用逻辑内存页面 b) 在有意义的情况下，使用尽可能大的页面大小来分散物理地址。更大的页面大小也有其他好处，不过这是另一个话题（见第4节）。&lt;/p&gt;

&lt;h3&gt;3.4 指令缓存&lt;/h3&gt;

&lt;p&gt;　　其实，不光处理器使用的数据被缓存，它们执行的指令也是被缓存的。只不过，指令缓存的问题相对来说要少得多，因为:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;执行的代码量取决于代码大小。而代码大小通常取决于问题复杂度。问题复杂度则是固定的。&lt;/li&gt;
&lt;li&gt;程序的数据处理逻辑是程序员设计的，而程序的指令却是编译器生成的。编译器的作者知道如何生成优良的代码。&lt;/li&gt;
&lt;li&gt;程序的流向比数据访问模式更容易预测。现如今的CPU很擅长模式检测，对预取很有利。&lt;/li&gt;
&lt;li&gt;代码永远都有良好的时间局部性和空间局部性。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　有一些准则是需要程序员们遵守的，但大都是关于如何使用工具的，我们会在第6节介绍它们。而在这里我们只介绍一下指令缓存的技术细节。&lt;/p&gt;

&lt;p&gt;　　随着CPU的核心频率大幅上升，缓存与核心的速度差越拉越大，CPU的处理开始管线化。也就是说，指令的执行分成若干阶段。首先，对指令进行解码，随后，准备参数，最后，执行它。这样的管线可以很长(例如，Intel的Netburst架构超过了20个阶段)。在管线很长的情况下，一旦发生延误(即指令流中断)，需要很长时间才能恢复速度。管线延误发生在这样的情况下: 下一条指令未能正确预测，或者装载下一条指令耗时过长(例如，需要从内存读取时)。&lt;/p&gt;

&lt;p&gt;　　为了解决这个问题，CPU的设计人员们在分支预测上投入大量时间和芯片资产(chip real estate)，以降低管线延误的出现频率。&lt;/p&gt;

&lt;p&gt;　　在CISC处理器上，指令的解码阶段也需要一些时间。x86及x86-64处理器尤为严重。近年来，这些处理器不再将指令的原始字节序列存入L1i，而是缓存解码后的版本。这样的L1i被叫做“追踪缓存(trace cache)”。追踪缓存可以在命中的情况下让处理器跳过管线最初的几个阶段，在管线发生延误时尤其有用。&lt;/p&gt;

&lt;p&gt;　　前面说过，L2以上的缓存是统一缓存，既保存代码，也保存数据。显然，这里保存的代码是原始字节序列，而不是解码后的形式。&lt;/p&gt;

&lt;p&gt;　　在提高性能方面，与指令缓存相关的只有很少的几条准则:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;生成尽量少的代码。也有一些例外，如出于管线化的目的需要更多的代码，或使用小代码会带来过高的额外开销。&lt;/li&gt;
&lt;li&gt;尽量帮助处理器作出良好的预取决策，可以通过代码布局或显式预取来实现。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;　　这些准则一般会由编译器的代码生成阶段强制执行。至于程序员可以参与的部分，我们会在第6节介绍。&lt;/p&gt;

&lt;h4&gt;3.4.1 自修改的代码&lt;/h4&gt;

&lt;p&gt;　　在计算机的早期岁月里，内存十分昂贵。人们想尽千方百计，只为了尽量压缩程序容量，给数据多留一些空间。其中，有一种方法是修改程序自身，称为自修改代码(SMC)。现在，有时候我们还能看到它，一般是出于提高性能的目的，也有的是为了攻击安全漏洞。&lt;/p&gt;

&lt;p&gt;　　一般情况下，应该避免SMC。虽然一般情况下没有问题，但有时会由于执行错误而出现性能问题。显然，发生改变的代码是无法放入追踪缓存(追踪缓存放的是解码后的指令)的。即使没有使用追踪缓存(代码还没被执行或有段时间没执行)，处理器也可能会遇到问题。如果某个进入管线的指令发生了变化，处理器只能扔掉目前的成果，重新开始。在某些情况下，甚至需要丢弃处理器的大部分状态。&lt;/p&gt;

&lt;p&gt;　　最后，由于处理器认为代码页是不可修改的(这是出于简单化的考虑，而且在99.9999999%情况下确实是正确的)，L1i用到并不是MESI协议，而是一种简化后的SI协议。这样一来，如果万一检测到修改的情况，就需要作出大量悲观的假设。&lt;/p&gt;

&lt;p&gt;　　因此，对于SMC，强烈建议能不用就不用。现在内存已经不再是一种那么稀缺的资源了。最好是写多个函数，而不要根据需要把一个函数改来改去。也许有一天可以把SMC变成可选项，我们就能通过这种方式检测入侵代码。如果一定要用SMC，应该让写操作越过缓存，以免由于L1i需要L1d里的数据而产生问题。更多细节，请参见6.1节。&lt;/p&gt;

&lt;p&gt;　　在Linux上，判断程序是否包含SMC是很容易的。利用正常工具链(toolchain)构建的程序代码都是写保护(write-protected)的。程序员需要在链接时施展某些关键的魔术才能生成可写的代码页。现代的Intel x86和x86-64处理器都有统计SMC使用情况的专用计数器。通过这些计数器，我们可以很容易判断程序是否包含SMC，即使它被准许运行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.5 缓存未命中的因素&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　我们已经看过内存访问没有命中缓存时，那陡然猛涨的高昂代价。但是有时候，这种情况又是无法避免的，因此我们需要对真正的代价有所认识，并学习如何缓解这种局面。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.5.1 缓存与内存带宽&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　为了更好地理解处理器的能力，我们测量了各种理想环境下能够达到的带宽值。由于不同处理器的版本差别很大，所以这个测试比较有趣，也因为如此，这一节都快被测试数据灌满了。我们使用了x86和x86-64处理器的SSE指令来装载和存储数据，每次16字节。工作集则与其它测试一样，从1kB增加到512MB，测量的具体对象是每个周期所处理的字节数。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/assets/files/2013-03/251.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/251.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.24: P4的带宽&lt;/center&gt;


&lt;p&gt;　　图3.24展示了一颗64位Intel Netburst处理器的性能图表。当工作集能够完全放入L1d时，处理器的每个周期可以读取完整的16字节数据，即每个周期执行一条装载指令(moveaps指令，每次移动16字节的数据)。测试程序并不对数据进行任何处理，只是测试读取指令本身。当工作集增大，无法再完全放入L1d时，性能开始急剧下降，跌至每周期6字节。在2&lt;sup&gt;18&lt;/sup&gt; 工作集处出现的台阶是由于DTLB缓存耗尽，因此需要对每个新页施加额外处理。由于这里的读取是按顺序的，预取机制可以完美地工作，而FSB能以5.3字节/周期的速度传输内容。但预取的数据并不进入L1d。当然，真实世界的程序永远无法达到以上的数字，但我们可以将它们看作一系列实际上的极限值。&lt;/p&gt;

&lt;p&gt;　　更令人惊讶的是写操作和复制操作的性能。即使是在很小的工作集下，写操作也始终无法达到4字节/周期的速度。这意味着，Intel为Netburst处理器的L1d选择了写通(write-through)模式，所以写入性能受到L2速度的限制。同时，这也意味着，复制测试的性能不会比写入测试差太多(复制测试是将某块内存的数据拷贝到另一块不重叠的内存区)，因为读操作很快，可以与写操作实现部分重叠。最值得关注的地方是，两个操作在工作集无法完全放入L2后出现了严重的性能滑坡，降到了0.5字节/周期！比读操作慢了10倍！显然，如果要提高程序性能，优化这两个操作更为重要。&lt;/p&gt;

&lt;p&gt;　　再来看图3.25，它来自同一颗处理器，只是运行双线程，每个线程分别运行在处理器的一个超线程上。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/261.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/261.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.25: P4开启两个超线程时的带宽表现&lt;/center&gt;


&lt;p&gt;　　图3.25采用了与图3.24相同的刻度，以方便比较两者的差异。图3.25中的曲线抖动更多，是由于采用双线程的缘故。结果正如我们预期，由于超线程共享着几乎所有资源(仅除寄存器外)，所以每个超线程只能得到一半的缓存和带宽。所以，即使每个线程都要花上许多时间等待内存，从而把执行时间让给另一个线程，也是无济于事——因为另一个线程也同样需要等待。这里恰恰展示了使用超线程时可能出现的最坏情况。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/assets/files/2013-03/271.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/271.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.26: Core 2的带宽表现&lt;/center&gt;


&lt;p&gt;　　再来看Core 2处理器的情况。看看图3.26和图3.27，再对比下P4的图3.24和3.25，可以看出不小的差异。Core 2是一颗双核处理器，有着共享的L2，容量是P4 L2的4倍。但更大的L2只能解释写操作的性能下降出现较晚的现象。&lt;/p&gt;

&lt;p&gt;　　当然还有更大的不同。可以看到，读操作的性能在整个工作集范围内一直稳定在16字节/周期左右，在2&lt;sup&gt;20&lt;/sup&gt; 处的下降同样是由于DTLB的耗尽引起。能够达到这么高的数字，不但表明处理器能够预取数据，并且按时完成传输，而且还意味着，预取的数据是被装入L1d的。&lt;/p&gt;

&lt;p&gt;　　写/复制操作的性能与P4相比，也有很大差异。处理器没有采用写通策略，写入的数据留在L1d中，只在必要时才逐出。这使得写操作的速度可以逼近16字节/周期。一旦工作集超过L1d，性能即飞速下降。由于Core 2读操作的性能非常好，所以两者的差值显得特别大。当工作集超过L2时，两者的差值甚至超过20倍！但这并不表示Core 2的性能不好，相反，Core 2永远都比Netburst强。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/assets/files/2013-03/281.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/281.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.27: Core 2运行双线程时的带宽表现&lt;/center&gt;


&lt;p&gt;　　在图3.27中，启动双线程，各自运行在Core
2的一个核心上。它们访问相同的内存，但不需要完美同步。从结果上看，读操作的性能与单线程并无区别，只是多了一些多线程情况下常见的抖动。&lt;/p&gt;

&lt;p&gt;　　有趣的地方来了——当工作集小于L1d时，写操作与复制操作的性能很差，就好像数据需要从内存读取一样。两个线程彼此竞争着同一个内存位置，于是不得不频频发送RFO消息。问题的根源在于，虽然两个核心共享着L2，但无法以L2的速度处理RFO请求。而当工作集超过L1d后，性能出现了迅猛提升。这是因为，由于L1d容量不足，于是将被修改的条目刷新到共享的L2。由于L1d的未命中可以由L2满足，只有那些尚未刷新的数据才需要RFO，所以出现了这样的现象。这也是这些工作集情况下速度下降一半的原因。这种渐进式的行为也与我们期待的一致: 由于每个核心共享着同一条FSB，每个核心只能得到一半的FSB带宽，因此对于较大的工作集来说，每个线程的性能大致相当于单线程时的一半。&lt;/p&gt;

&lt;p&gt;　　由于同一个厂商的不同处理器之间都存在着巨大差异，我们没有理由不去研究一下其它厂商处理器的性能。图3.28展示了AMD家族10h Opteron处理器的性能。这颗处理器有64kB的L1d、512kB的L2和2MB的L3，其中L3缓存由所有核心所共享。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/assets/files/2013-03/291.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/291.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.28: AMD家族10h Opteron的带宽表现&lt;/center&gt;


&lt;p&gt;　　大家首先应该会注意到，在L1d缓存足够的情况下，这个处理器每个周期能处理两条指令。读操作的性能超过了32字节/周期，写操作也达到了18.7字节/周期。但是，不久，读操作的曲线就急速下降，跌到2.3字节/周期，非常差。处理器在这个测试中并没有预取数据，或者说，没有有效地预取数据。&lt;/p&gt;

&lt;p&gt;　　另一方面，写操作的曲线随几级缓存的容量而流转。在L1d阶段达到最高性能，随后在L2阶段下降到6字节/周期，在L3阶段进一步下降到2.8字节/周期，最后，在工作集超过L3后，降到0.5字节/周期。它在L1d阶段超过了Core 2，在L2阶段基本相当(Core 2的L2更大一些)，在L3及主存阶段比Core 2慢。&lt;/p&gt;

&lt;p&gt;　　复制的性能既无法超越读操作的性能，也无法超越写操作的性能。因此，它的曲线先是被读性能压制，随后又被写性能压制。&lt;/p&gt;

&lt;p&gt;　　图3.29显示的是Opteron处理器在多线程时的性能表现。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/assets/files/2013-03/30.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/30.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.29: AMD Fam 10h在双线程时的带宽表现&lt;/center&gt;


&lt;p&gt;　　读操作的性能没有受到很大的影响。每个线程的L1d和L2表现与单线程下相仿，L3的预取也依然表现不佳。两个线程并没有过渡争抢L3。问题比较大的是写操作的性能。两个线程共享的所有数据都需要经过L3，而这种共享看起来却效率很差。即使是在L3足够容纳整个工作集的情况下，所需要的开销仍然远高于L3的访问时间。再来看图3.27，可以发现，在一定的工作集范围内，Core 2处理器能以共享的L2缓存的速度进行处理。而Opteron处理器只能在很小的一个范围内实现相似的性能，而且，它仅仅只能达到L3的速度，无法与Core 2的L2相比。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.5.2 关键字加载&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　内存以比缓存线还小的块从主存储器向缓存传送。如今64位可一次性传送，缓存线的大小为64或128比特。这意味着每个缓存线需要8或16次传送。&lt;/p&gt;

&lt;p&gt;　　DRAM芯片可以以触发模式传送这些64位的块。这使得不需要内存控制器的进一步指令和可能伴随的延迟，就可以将缓存线充满。如果处理器预取了缓存，这有可能是最好的操作方式。&lt;/p&gt;

&lt;p&gt;　　如果程序在访问数据或指令缓存时没有命中(这可能是强制性未命中或容量性未命中，前者是由于数据第一次被使用，后者是由于容量限制而将缓存线逐出)，情况就不一样了。程序需要的并不总是缓存线中的第一个字，而数据块的到达是有先后顺序的，即使是在突发模式和双倍传输率下，也会有明显的时间差，一半在4个CPU周期以上。举例来说，如果程序需要缓存线中的第8个字，那么在首字抵达后它还需要额外等待30个周期以上。&lt;/p&gt;

&lt;p&gt;　　当然，这样的等待并不是必需的。事实上，内存控制器可以按不同顺序去请求缓存线中的字。当处理器告诉它，程序需要缓存中具体某个字，即「关键字(critical word)」时，内存控制器就会先请求这个字。一旦请求的字抵达，虽然缓存线的剩余部分还在传输中，缓存的状态还没有达成一致，但程序已经可以继续运行。这种技术叫做关键字优先及较早重启(Critical Word First &amp;amp; Early Restart)。&lt;/p&gt;

&lt;p&gt;　　现在的处理器都已经实现了这一技术，但有时无法运用。比如，预取操作的时候，并不知道哪个是关键字。如果在预取的中途请求某条缓存线，处理器只能等待，并不能更改请求的顺序。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/assets/files/2013-03/311.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/311.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.30: 关键字位于缓存线尾时的表现&lt;/center&gt;


&lt;p&gt;　　在关键字优先技术生效的情况下，关键字的位置也会影响结果。图3.30展示了下一个测试的结果，图中表示的是关键字分别在线首和线尾时的性能对比情况。元素大小为64字节，等于缓存线的长度。图中的噪声比较多，但仍然可以看出，当工作集超过L2后，关键字处于线尾情况下的性能要比线首情况下低0.7%左右。而顺序访问时受到的影响更大一些。这与我们前面提到的预取下条线时可能遇到的问题是相符的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.5.3 缓存设定&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　缓存放置的位置与超线程，内核和处理器之间的关系，不在程序员的控制范围之内。但是程序员可以决定线程执行的位置，接着高速缓存与使用的CPU的关系将变得非常重要。&lt;/p&gt;

&lt;p&gt;　　这里我们将不会深入（探讨）什么时候选择什么样的内核以运行线程的细节。我们仅仅描述了在设置关联线程的时候，程序员需要考虑的系统结构的细节。&lt;/p&gt;

&lt;p&gt;　　超线程，通过定义，共享除去寄存器集以外的所有数据。包括 L1 缓存。这里没有什么可以多说的。多核处理器的独立核心带来了一些乐趣。每个核心都至少拥有自己的 L1 缓存。除此之外，下面列出了一些不同的特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;早期多核心处理器有独立的 L2 缓存且没有更高层级的缓存。&lt;/li&gt;
&lt;li&gt;之后英特尔的双核心处理器模型拥有共享的L2
缓存。对四核处理器，则分对拥有独立的L2 缓存，且没有更高层级的缓存。&lt;/li&gt;
&lt;li&gt;AMD 家族的 10h 处理器有独立的 L2 缓存以及一个统一的L3 缓存。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　关于各种处理器模型的优点，已经在它们各自的宣传手册里写得够多了。在每个核心的工作集互不重叠的情况下，独立的L2拥有一定的优势，单线程的程序可以表现优良。考虑到目前实际环境中仍然存在大量类似的情况，这种方法的表现并不会太差。不过，不管怎样，我们总会遇到工作集重叠的情况。如果每个缓存都保存着某些通用运行库的常用部分，那么很显然是一种浪费。&lt;/p&gt;

&lt;p&gt;　　如果像Intel的双核处理器那样，共享除L1外的所有缓存，则会有一个很大的优点。如果两个核心的工作集重叠的部分较多，那么综合起来的可用缓存容量会变大，从而允许容纳更大的工作集而不导致性能的下降。如果两者的工作集并不重叠，那么则是由Intel的高级智能缓存管理(Advanced Smart Cache management)发挥功用，防止其中一个核心垄断整个缓存。&lt;/p&gt;

&lt;p&gt;　　即使每个核心只使用一半的缓存，也会有一些摩擦。缓存需要不断衡量每个核心的用量，在进行逐出操作时可能会作出一些比较差的决定。我们来看另一个测试程序的结果。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/assets/files/2013-03/321.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/321.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.31: 两个进程的带宽表现&lt;/center&gt;


&lt;p&gt;　　这次，测试程序两个进程，第一个进程不断用SSE指令读/写2MB的内存数据块，选择2MB，是因为它正好是Core 2处理器L2缓存的一半，第二个进程则是读/写大小变化的内存区域，我们把这两个进程分别固定在处理器的两个核心上。图中显示的是每个周期读/写的字节数，共有4条曲线，分别表示不同的读写搭配情况。例如，标记为读/写(read/write)的曲线代表的是后台进程进行写操作(固定2MB工作集)，而被测量进程进行读操作(工作集从小到大)。&lt;/p&gt;

&lt;p&gt;　　图中最有趣的是220到223之间的部分。如果两个核心的L2是完全独立的，那么所有4种情况下的性能下降均应发生在221到222之间，也就是L2缓存耗尽的时候。但从图上来看，实际情况并不是这样，特别是背景进程进行写操作时尤为明显。当工作集达到1MB(220)时，性能即出现恶化，两个进程并没有共享内存，因此并不会产生RFO消息。所以，完全是缓存逐出操作引起的问题。目前这种智能的缓存处理机制有一个问题，每个核心能实际用到的缓存更接近1MB，而不是理论上的2MB。如果未来的处理器仍然保留这种多核共享缓存模式的话，我们唯有希望厂商会把这个问题解决掉。&lt;/p&gt;

&lt;p&gt;　　推出拥有双L2缓存的4核处理器仅仅只是一种临时措施，是开发更高级缓存之前的替代方案。与独立插槽及双核处理器相比，这种设计并没有带来多少性能提升。两个核心是通过同一条总线(被外界看作FSB)进行通信，并没有什么特别快的数据交换通道。&lt;/p&gt;

&lt;p&gt;　　未来，针对多核处理器的缓存将会包含更多层次。AMD的10h家族是一个开始，至于会不会有更低级共享缓存的出现，还需要我们拭目以待。我们有必要引入更多级别的缓存，因为频繁使用的高速缓存不可能被许多核心共用，否则会对性能造成很大的影响。我们也需要更大的高关联性缓存，它们的数量、容量和关联性都应该随着共享核心数的增长而增长。巨大的L3和适度的L2应该是一种比较合理的选择。L3虽然速度较慢，但也较少使用。&lt;/p&gt;

&lt;p&gt;　　对于程序员来说，不同的缓存设计就意味着调度决策时的复杂性。为了达到最高的性能，我们必须掌握工作负载的情况，必须了解机器架构的细节。好在我们在判断机器架构时还是有一些支援力量的，我们会在后面的章节介绍这些接口。&lt;/p&gt;

&lt;h4&gt;3.5.4 FSB的影响&lt;/h4&gt;

&lt;p&gt;　　FSB在性能中扮演了核心角色。缓存数据的存取速度受制于内存通道的速度。我们做一个测试，在两台机器上分别跑同一个程序，这两台机器除了内存模块的速度有所差异，其它完全相同。图3.32展示了Addnext0测试(将下一个元素的pad[0]加到当前元素的pad[0]上)在这两台机器上的结果(NPAD=7，64位机器)。两台机器都采用Core
2处理器，一台使用667MHz的DDR2内存，另一台使用800MHz的DDR2内存(比前一台增长20%)。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/assets/files/2013-03/331.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/331.png&quot; title=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; alt=&quot;每个程序员都应该了解的 CPU 高速缓存&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图3.32: FSB速度的影响&lt;/center&gt;


&lt;p&gt;　　图上的数字表明，当工作集大到对FSB造成压力的程度时，高速FSB确实会带来巨大的优势。在我们的测试中，性能的提升达到了18.5%，接近理论上的极限。而当工作集比较小，可以完全纳入缓存时，FSB的作用并不大。当然，这里我们只测试了一个程序的情况，在实际环境中，系统往往运行多个进程，工作集是很容易超过缓存容量的。&lt;/p&gt;

&lt;p&gt;　　如今，一些英特尔的处理器，支持前端总线(FSB)的速度高达1,333MHz，这意味着速度有另外60％的提升。将来还会出现更高的速度。速度是很重要的，工作集会更大，快速的RAM和高FSB速度的内存肯定是值得投资的。我们必须小心使用它，因为即使处理器可以支持更高的前端总线速度，但是主板的北桥芯片可能不会。使用时，检查它的规范是至关重要的。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>注释驱动的 Spring cache 缓存介绍</title>
   <link href="http://beango.github.com/archives/2013/03/16/os-cn-spring-cache.html"/>
   <updated>2013-03-16T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/03/16/os-cn-spring-cache</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Spring 3.1引入了激动人心的基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如EHCache 或者OSCache），而是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种annotation，即能够达到缓存方法的返回对象的效果。&lt;/p&gt;

&lt;p&gt;Spring 的缓存技术还具备相当的灵活性，不仅能够使用 SpEL（Spring Expression Language）来定义缓存的 key 和各种condition，还提供开箱即用的缓存临时存储方案，也支持和主流的专业缓存例如 EHCache 集成。&lt;/p&gt;

&lt;p&gt;其特点总结如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过少量的配置 annotation 注释即可使得既有代码支持缓存&lt;/li&gt;
&lt;li&gt;支持开箱即用 Out-Of-The-Box，即不用安装和部署额外第三方组件即可使用缓存&lt;/li&gt;
&lt;li&gt;支持 Spring Express Language，能使用对象的任何属性或者方法来定义缓存的 key 和 condition&lt;/li&gt;
&lt;li&gt;支持 AspectJ，并通过其实现任何方法的缓存支持&lt;/li&gt;
&lt;li&gt;支持自定义 key 和自定义缓存管理者，具有相当的灵活性和扩展性&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;本文将针对上述特点对 Spring cache 进行详细的介绍，主要通过一个简单的例子和原理介绍展开，然后我们将一起看一个比较实际的缓存例子，最后会介绍 spring cache 的使用限制和注意事项。OK，Let ’ s begin!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原来我们是怎么做的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里先展示一个完全自定义的缓存实现，即不用任何第三方的组件来实现某种对象的内存缓存。&lt;/p&gt;

&lt;p&gt;场景是：对一个账号查询方法做缓存，以账号名称为 key，账号对象为value，当以相同的账号名称查询账号的时候，直接从缓存中返回结果，否则更新缓存。账号查询服务还支持 reload 缓存（即清空缓存）。&lt;/p&gt;

&lt;p&gt;首先定义一个实体类：账号类，具备基本的 id 和 name 属性，且具备 getter 和 setter 方法&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 1. Account.java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; package cacheOfAnno; 

 public class Account { 
   private int id; 
   private String name; 

   public Account(String name) { 
     this.name = name; 
   } 
   public int getId() { 
     return id; 
   } 
   public void setId(int id) { 
     this.id = id; 
   } 
   public String getName() { 
     return name; 
   } 
   public void setName(String name) { 
     this.name = name; 
   } 
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后定义一个缓存管理器，这个管理器负责实现缓存逻辑，支持对象的增加、修改和删除，支持值对象的泛型。如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 2. MyCacheManager.java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; package oldcache; 

 import java.util.Map; 
 import java.util.concurrent.ConcurrentHashMap; 

 public class MyCacheManager&amp;lt;T&amp;gt; { 
   private Map&amp;lt;String,T&amp;gt; cache = 
       new ConcurrentHashMap&amp;lt;String,T&amp;gt;(); 

   public T getValue(Object key) { 
     return cache.get(key); 
   } 

   public void addOrUpdateCache(String key,T value) { 
     cache.put(key, value); 
   } 

   public void evictCache(String key) {// 根据 key 来删除缓存中的一条记录
     if(cache.containsKey(key)) { 
       cache.remove(key); 
     } 
   } 

   public void evictCache() {// 清空缓存中的所有记录
     cache.clear(); 
   } 
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好，现在我们有了实体类和一个缓存管理器，还需要一个提供账号查询的服务类，此服务类使用缓存管理器来支持账号查询缓存，如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 3. MyAccountService.java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; package oldcache; 

 import cacheOfAnno.Account; 

 public class MyAccountService { 
   private MyCacheManager&amp;lt;Account&amp;gt; cacheManager; 

   public MyAccountService() { 
     cacheManager = new MyCacheManager&amp;lt;Account&amp;gt;();// 构造一个缓存管理器
   } 

   public Account getAccountByName(String acctName) { 
     Account result = cacheManager.getValue(acctName);// 首先查询缓存
     if(result!=null) { 
       System.out.println(&quot;get from cache...&quot;+acctName); 
       return result;// 如果在缓存中，则直接返回缓存的结果
     } 
     result = getFromDB(acctName);// 否则到数据库中查询
     if(result!=null) {// 将数据库查询的结果更新到缓存中
       cacheManager.addOrUpdateCache(acctName, result); 
     } 
     return result; 
   } 

   public void reload() { 
     cacheManager.evictCache(); 
   } 

   private Account getFromDB(String acctName) { 
     System.out.println(&quot;real querying db...&quot;+acctName); 
     return new Account(acctName); 
   } 
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们开始写一个测试类，用于测试刚才的缓存是否有效&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 4. Main.java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; package oldcache; 

 public class Main { 

   public static void main(String[] args) { 
     MyAccountService s = new MyAccountService(); 
     // 开始查询账号
     s.getAccountByName(&quot;somebody&quot;);// 第一次查询，应该是数据库查询
     s.getAccountByName(&quot;somebody&quot;);// 第二次查询，应该直接从缓存返回

     s.reload();// 重置缓存
     System.out.println(&quot;after reload...&quot;); 

     s.getAccountByName(&quot;somebody&quot;);// 应该是数据库查询
     s.getAccountByName(&quot;somebody&quot;);// 第二次查询，应该直接从缓存返回

   } 

 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照分析，执行结果应该是：首先从数据库查询，然后直接返回缓存中的结果，重置缓存后，应该先从数据库查询，然后返回缓存中的结果，实际的执行结果如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 5. 运行结果&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; real querying db...somebody// 第一次从数据库加载
 get from cache...somebody// 第二次从缓存加载
 after reload...// 清空缓存
 real querying db...somebody// 又从数据库加载
 get from cache...somebody// 从缓存加载
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出我们的缓存起效了，但是这种自定义的缓存方案有如下劣势：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;缓存代码和业务代码耦合度太高，如上面的例子，AccountService 中的 getAccountByName（）方法中有了太多缓存的逻辑，不便于维护和变更&lt;/li&gt;
&lt;li&gt;不灵活，这种缓存方案不支持按照某种条件的缓存，比如只有某种类型的账号才需要缓存，这种需求会导致代码的变更&lt;/li&gt;
&lt;li&gt;缓存的存储这块写的比较死，不能灵活的切换为使用第三方的缓存模块&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;如果你的代码中有上述代码的影子，那么你可以考虑按照下面的介绍来优化一下你的代码结构了，也可以说是简化，你会发现，你的代码会变得优雅的多！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hello World，注释驱动的 Spring Cache&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hello World 的实现目标&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本 Hello World 类似于其他任何的 Hello World 程序，从最简单实用的角度展现 spring cache 的魅力，它基于刚才自定义缓存方案的实体类Account.java，重新定义了 AccountService.java 和测试类 Main.java（注意这个例子不用自己定义缓存管理器，因为 spring 已经提供了缺省实现）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;需要的 jar 包&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了实用 spring cache 缓存方案，在工程的 classpath 必须具备下列 jar 包。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;图 1. 工程依赖的 jar 包图&lt;/em&gt;&lt;/strong&gt;
&lt;a href=&quot;/assets/files/2013-03/image001.jpg&quot; title=&quot;注释驱动的 Spring cache 缓存介绍&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/image001.jpg&quot; title=&quot;注释驱动的 Spring cache 缓存介绍&quot; alt=&quot;注释驱动的 Spring cache 缓存介绍&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意这里我引入的是最新的 spring 3.2.0.M1 版本 jar 包，其实只要是 spring 3.1 以上，都支持 spring cache。其中 spring-context-*.jar 包含了 cache 需要的类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义实体类、服务类和相关配置文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;实体类就是上面自定义缓存方案定义的Account.java，这里重新定义了服务类，如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 6. AccountService.java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; package cacheOfAnno; 

 import org.springframework.cache.annotation.CacheEvict; 
 import org.springframework.cache.annotation.Cacheable; 

 public class AccountService { 
   @Cacheable(value=&quot;accountCache&quot;)// 使用了一个缓存名叫 accountCache 
   public Account getAccountByName(String userName) { 
     // 方法内部实现不考虑缓存逻辑，直接实现业务
     System.out.println(&quot;real query account.&quot;+userName); 
     return getFromDB(userName); 
   } 

   private Account getFromDB(String acctName) { 
     System.out.println(&quot;real querying db...&quot;+acctName); 
     return new Account(acctName); 
   } 
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，此类的 getAccountByName 方法上有一个注释 annotation，即@Cacheable(value=”accountCache”)，这个注释的意思是，当调用这个方法的时候，会从一个名叫accountCache的缓存中查询，如果没有，则执行实际的方法（即查询数据库），并将执行的结果存入缓存中，否则返回缓存中的对象。这里的缓存中的key 就是参数 userName，value 就是 Account 对象。“accountCache”缓存是在spring*.xml 中定义的名称。&lt;/p&gt;

&lt;p&gt;好，因为加入了 spring，所以我们还需要一个 spring 的配置文件来支持基于注释的缓存&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 7. Spring-cache-anno.xml&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xmlns:cache=&quot;http://www.springframework.org/schema/cache&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 

http://www.springframework.org/schema/beans/spring-beans.xsd


http://www.springframework.org/schema/cache


http://www.springframework.org/schema/cache/spring-cache.xsd&quot;&amp;gt;

   &amp;lt;cache:annotation-driven /&amp;gt;

   &amp;lt;bean id=&quot;accountServiceBean&quot; class=&quot;cacheOfAnno.AccountService&quot;/&amp;gt; 

    &amp;lt;!-- generic cache manager --&amp;gt;
   &amp;lt;bean id=&quot;cacheManager&quot;
   class=&quot;org.springframework.cache.support.SimpleCacheManager&quot;&amp;gt;
     &amp;lt;property name=&quot;caches&quot;&amp;gt; 
       &amp;lt;set&amp;gt; 
         &amp;lt;bean
           class=&quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&quot;
           p:name=&quot;default&quot; /&amp;gt; 

         &amp;lt;bean
           class=&quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&quot;
           p:name=&quot;accountCache&quot; /&amp;gt; 
       &amp;lt;/set&amp;gt; 
     &amp;lt;/property&amp;gt; 
   &amp;lt;/bean&amp;gt; 
 &amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这个 spring 配置文件有一个关键的支持缓存的配置项：&lt;code&gt;&amp;lt;cache:annotation-driven /&amp;gt;，&lt;/code&gt;这个配置项缺省使用了一个名字叫 cacheManager 的缓存管理器，这个缓存管理器有一个 spring 的缺省实现，即org.springframework.cache.support.SimpleCacheManager，这个缓存管理器实现了我们刚刚自定义的缓存管理器的逻辑，它需要配置一个属性caches，即此缓存管理器管理的缓存集合，除了缺省的名字叫 default 的缓存，我们还自定义了一个名字叫 accountCache 的缓存，使用了缺省的内存存储方案 ConcurrentMapCacheFactoryBean，它是基于 java.util.concurrent.ConcurrentHashMap 的一个内存缓存实现方案。&lt;/p&gt;

&lt;p&gt;OK，现在我们具备了测试条件，测试代码如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 8. Main.java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; package cacheOfAnno; 

 import org.springframework.context.ApplicationContext; 
 import org.springframework.context.support.ClassPathXmlApplicationContext; 

 public class Main { 
   public static void main(String[] args) { 
     ApplicationContext context = new ClassPathXmlApplicationContext( 
        &quot;spring-cache-anno.xml&quot;);// 加载 spring 配置文件

     AccountService s = (AccountService) context.getBean(&quot;accountServiceBean&quot;); 
     // 第一次查询，应该走数据库
     System.out.print(&quot;first query...&quot;); 
     s.getAccountByName(&quot;somebody&quot;); 
     // 第二次查询，应该不查数据库，直接返回缓存的值
     System.out.print(&quot;second query...&quot;); 
     s.getAccountByName(&quot;somebody&quot;); 
     System.out.println(); 
   } 
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的测试代码主要进行了两次查询，第一次应该会查询数据库，第二次应该返回缓存，不再查数据库，我们执行一下，看看结果&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 9. 执行结果&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; first query...real query account.somebody// 第一次查询
 real querying db...somebody// 对数据库进行了查询
 second query...// 第二次查询，没有打印数据库查询日志，直接返回了缓存中的结果
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出我们设置的基于注释的缓存起作用了，而在 AccountService.java 的代码中，我们没有看到任何的缓存逻辑代码，只有一行注释：@Cacheable(value=”accountCache”)，就实现了基本的缓存方案，是不是很强大？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何清空缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;好，到目前为止，我们的 spring cache 缓存程序已经运行成功了，但是还不完美，因为还缺少一个重要的缓存管理逻辑：清空缓存，当账号数据发生变更，那么必须要清空某个缓存，另外还需要定期的清空所有缓存，以保证缓存数据的可靠性。&lt;/p&gt;

&lt;p&gt;为了加入清空缓存的逻辑，我们只要对 AccountService.java 进行修改，从业务逻辑的角度上看，它有两个需要清空缓存的地方&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当外部调用更新了账号，则我们需要更新此账号对应的缓存&lt;/li&gt;
&lt;li&gt;当外部调用说明重新加载，则我们需要清空所有缓存&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 10. AccountService.java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package cacheOfAnno; 

import org.springframework.cache.annotation.CacheEvict; 
import org.springframework.cache.annotation.Cacheable; 

public class AccountService { 
  @Cacheable(value=&quot;accountCache&quot;)// 使用了一个缓存名叫 accountCache 
  public Account getAccountByName(String userName) { 
    // 方法内部实现不考虑缓存逻辑，直接实现业务
    return getFromDB(userName); 
  } 
  &amp;lt;strong&amp;gt;@CacheEvict(value=&quot;accountCache&quot;,key=&quot;#account.getName()&quot;)// 清空 accountCache 缓存&amp;lt;/strong&amp;gt;
               &amp;lt;strong&amp;gt; public void updateAccount(Account account) {&amp;lt;/strong&amp;gt;
    updateDB(account); 
  } 

&amp;lt;strong&amp;gt; @CacheEvict(value=&quot;accountCache&quot;,allEntries=true)// 清空 accountCache 缓存&amp;lt;/strong&amp;gt;
  public void reload() { 
  } 

  private Account getFromDB(String acctName) { 
    System.out.println(&quot;real querying db...&quot;+acctName); 
    return new Account(acctName); 
  } 

  private void updateDB(Account account) { 
    System.out.println(&quot;real update db...&quot;+account.getName()); 
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 11. Main.java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; package cacheOfAnno; 

 import org.springframework.context.ApplicationContext; 
 import org.springframework.context.support.ClassPathXmlApplicationContext; 

 public class Main { 

   public static void main(String[] args) { 
     ApplicationContext context = new ClassPathXmlApplicationContext( 
        &quot;spring-cache-anno.xml&quot;);// 加载 spring 配置文件

     AccountService s = (AccountService) context.getBean(&quot;accountServiceBean&quot;); 
     // 第一次查询，应该走数据库
     System.out.print(&quot;first query...&quot;); 
     s.getAccountByName(&quot;somebody&quot;); 
     // 第二次查询，应该不查数据库，直接返回缓存的值
     System.out.print(&quot;second query...&quot;); 
     s.getAccountByName(&quot;somebody&quot;); 
     System.out.println(); 

     &amp;lt;strong&amp;gt;System.out.println(&quot;start testing clear cache...&quot;);&amp;lt;/strong&amp;gt;
                &amp;lt;strong&amp;gt; // 更新某个记录的缓存，首先构造两个账号记录，然后记录到缓存中&amp;lt;/strong&amp;gt;
     Account account1 = s.getAccountByName(&quot;somebody1&quot;); 
     Account account2 = s.getAccountByName(&quot;somebody2&quot;); 
 &amp;lt;strong&amp;gt; // 开始更新其中一个&amp;lt;/strong&amp;gt;
                &amp;lt;strong&amp;gt; account1.setId(1212);&amp;lt;/strong&amp;gt;
     s.updateAccount(account1); 
 &amp;lt;strong&amp;gt; s.getAccountByName(&quot;somebody1&quot;);// 因为被更新了，所以会查询数据库&amp;lt;/strong&amp;gt;
                &amp;lt;strong&amp;gt; s.getAccountByName(&quot;somebody2&quot;);// 没有更新过，应该走缓存&amp;lt;/strong&amp;gt;
                &amp;lt;strong&amp;gt; s.getAccountByName(&quot;somebody1&quot;);// 再次查询，应该走缓存&amp;lt;/strong&amp;gt;
                &amp;lt;strong&amp;gt; // 更新所有缓存&amp;lt;/strong&amp;gt;
     s.reload(); 
 &amp;lt;strong&amp;gt; s.getAccountByName(&quot;somebody1&quot;);// 应该会查询数据库&amp;lt;/strong&amp;gt;
                &amp;lt;strong&amp;gt; s.getAccountByName(&quot;somebody2&quot;);// 应该会查询数据库&amp;lt;/strong&amp;gt;
                &amp;lt;strong&amp;gt; s.getAccountByName(&quot;somebody1&quot;);// 应该走缓存&amp;lt;/strong&amp;gt;
                &amp;lt;strong&amp;gt; s.getAccountByName(&quot;somebody2&quot;);// 应该走缓存&amp;lt;/strong&amp;gt;
   } 
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 12. 运行结果&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; first query...real querying db...somebody 
 second query... 
 start testing clear cache... 
 real querying db...somebody1 
 real querying db...somebody2 
 real update db...somebody1 
 real querying db...somebody1 
 real querying db...somebody1 
 real querying db...somebody2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果和我们期望的一致，所以，我们可以看出，spring cache 清空缓存的方法很简单，就是通过 @CacheEvict 注释来标记要清空缓存的方法，当这个方法被调用后，即会清空缓存。注意其中一个@CacheEvict(value=”accountCache”,key=”#account.getName()”)，其中的 Key是用来指定缓存的 key 的，这里因为我们保存的时候用的是 account 对象的 name 字段，所以这里还需要从参数 account 对象中获取 name 的值来作为 key，前面的# 号代表这是一个 SpEL 表达式，此表达式可以遍历方法的参数对象，具体语法可以参考 Spring 的相关文档手册。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何按照条件操作缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面介绍的缓存方法，没有任何条件，即所有对 accountService 对象的 getAccountByName 方法的调用都会起动缓存效果，不管参数是什么值，如果有一个需求，就是只有账号名称的长度小于等于 4 的情况下，才做缓存，大于 4 的不使用缓存，那怎么实现呢？&lt;/p&gt;

&lt;p&gt;Spring cache 提供了一个很好的方法，那就是基于 SpEL 表达式的 condition 定义，这个 condition 是 @Cacheable 注释的一个属性，下面我来演示一下&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 13. AccountService.java（getAccountByName 方法修订，支持条件）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; @Cacheable(value=&quot;accountCache&quot;,condition=&quot;#userName.length() &amp;lt;= 4&quot;)// 缓存名叫 accountCache 
 public Account getAccountByName(String userName) { 
 // 方法内部实现不考虑缓存逻辑，直接实现业务
 return getFromDB(userName); 
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意其中的 condition=”#userName.length() &amp;lt;=4”，这里使用了 SpEL 表达式访问了参数 userName 对象的 length() 方法，条件表达式返回一个布尔值，true/false，当条件为true，则进行缓存操作，否则直接调用方法执行的返回结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 14. 测试方法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; s.getAccountByName(&quot;somebody&quot;);// 长度大于 4，不会被缓存
 s.getAccountByName(&quot;sbd&quot;);// 长度小于 4，会被缓存
 s.getAccountByName(&quot;somebody&quot;);// 还是查询数据库
 s.getAccountByName(&quot;sbd&quot;);// 会从缓存返回
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 15. 运行结果&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; real querying db...somebody 
 real querying db...sbd 
 real querying db...somebody
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见对长度大于 4 的账号名 (somebody) 没有缓存，每次都查询数据库。&lt;/p&gt;

&lt;p&gt;如果有多个参数，如何进行 key 的组合&lt;/p&gt;

&lt;p&gt;假设 AccountService 现在有一个需求，要求根据账号名、密码和是否发送日志查询账号信息，很明显，这里我们需要根据账号名、密码对账号对象进行缓存，而第三个参数“是否发送日志”对缓存没有任何影响。所以，我们可以利用 SpEL 表达式对缓存 key 进行设计&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 16. Account.java（增加 password 属性）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; private String password; 
 public String getPassword() { 
   return password; 
 } 
 public void setPassword(String password) { 
   this.password = password; 
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 17. AccountService.java（增加 getAccount 方法，支持组合 key）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; @Cacheable(value=&quot;accountCache&quot;,key=&quot;#userName.concat(#password)&quot;) 
 public Account getAccount(String userName,String password,boolean sendLog) { 
   // 方法内部实现不考虑缓存逻辑，直接实现业务
   return getFromDB(userName,password); 

 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上面的 key 属性，其中引用了方法的两个参数 userName 和 password，而
sendLog 属性没有考虑，因为其对缓存没有影响。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 18. Main.java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public static void main(String[] args) { 
   ApplicationContext context = new ClassPathXmlApplicationContext( 
      &quot;spring-cache-anno.xml&quot;);// 加载 spring 配置文件

   AccountService s = (AccountService) context.getBean(&quot;accountServiceBean&quot;); 
   s.getAccount(&quot;somebody&quot;, &quot;123456&quot;, true);// 应该查询数据库
   s.getAccount(&quot;somebody&quot;, &quot;123456&quot;, true);// 应该走缓存
   s.getAccount(&quot;somebody&quot;, &quot;123456&quot;, false);// 应该走缓存
   s.getAccount(&quot;somebody&quot;, &quot;654321&quot;, true);// 应该查询数据库
   s.getAccount(&quot;somebody&quot;, &quot;654321&quot;, true);// 应该走缓存
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述测试，是采用了相同的账号，不同的密码组合进行查询，那么一共有两种组合情况，所以针对数据库的查询应该只有两次。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 19. 运行结果&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; real querying db...userName=somebody password=123456 
 real querying db...userName=somebody password=654321
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和我们预期的一致。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;如何做到：既要保证方法被调用，又希望结果被缓存&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据前面的例子，我们知道，如果使用了 @Cacheable 注释，则当重复使用相同参数调用方法的时候，方法本身不会被调用执行，即方法本身被略过了，取而代之的是方法的结果直接从缓存中找到并返回了。&lt;/p&gt;

&lt;p&gt;现实中并不总是如此，有些情况下我们希望方法一定会被调用，因为其除了返回一个结果，还做了其他事情，例如记录日志，调用接口等，这个时候，我们可以用 @CachePut 注释，这个注释可以确保方法被执行，同时方法的返回值也被记录到缓存中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 20. AccountService.java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; @Cacheable(value=&quot;accountCache&quot;)// 使用了一个缓存名叫 accountCache 
 public Account getAccountByName(String userName) { 
   // 方法内部实现不考虑缓存逻辑，直接实现业务
   return getFromDB(userName); 
 } 
 &amp;lt;strong&amp;gt;@CachePut(value=&quot;accountCache&quot;,key=&quot;#account.getName()&quot;)// 更新 accountCache 缓存&amp;lt;/strong&amp;gt;
 public Account updateAccount(Account account) { 
   return updateDB(account); 
 } 
 private Account updateDB(Account account) { 
   System.out.println(&quot;real updating db...&quot;+account.getName()); 
   return account; 
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 21. Main.java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) { 
   ApplicationContext context = new ClassPathXmlApplicationContext( 
      &quot;spring-cache-anno.xml&quot;);// 加载 spring 配置文件

   AccountService s = (AccountService) context.getBean(&quot;accountServiceBean&quot;); 

   Account account = s.getAccountByName(&quot;someone&quot;); 
   account.setPassword(&quot;123&quot;); 
   s.updateAccount(account); 
   account.setPassword(&quot;321&quot;); 
   s.updateAccount(account); 
   account = s.getAccountByName(&quot;someone&quot;); 
   System.out.println(account.getPassword()); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上面的代码所示，我们首先用 getAccountByName 方法查询一个人 someone 的账号，这个时候会查询数据库一次，但是也记录到缓存中了。然后我们修改了密码，调用了 updateAccount 方法，这个时候会执行数据库的更新操作且记录到缓存，我们再次修改密码并调用 updateAccount 方法，然后通过 getAccountByName 方法查询，这个时候，由于缓存中已经有数据，所以不会查询数据库，而是直接返回最新的数据，所以打印的密码应该是“321”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 22. 运行结果&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; real querying db...someone 
 real updating db...someone 
 real updating db...someone 
 321
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和分析的一样，只查询了一次数据库，更新了两次数据库，最终的结果是最新的密码。说明 @CachePut 确实可以保证方法被执行，且结果一定会被缓存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@Cacheable、@CachePut、@CacheEvict 注释介绍&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过上面的例子，我们可以看到 spring cache 主要使用两个注释标签，即 @Cacheable、@CachePut 和 @CacheEvict，我们总结一下其作用和配置方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;表 1. @Cacheable 作用和配置方法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; class=&quot;ibm-data-table&quot; summary=&quot;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th style=&quot;vertical-align:top&quot;&gt;
                        &lt;strong&gt;@Cacheable 的作用&lt;/strong&gt;
                    &lt;/th&gt;&lt;th colspan=&quot;2&quot; style=&quot;vertical-align:top&quot;&gt;
主要针对方法配置，能够根据方法的请求参数对其结果进行缓存
&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;3&quot; style=&quot;text-align:center; vertical-align:top&quot;&gt;
                        &lt;strong&gt;@Cacheable 主要的参数&lt;/strong&gt;
                    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
 value 
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
缓存的名称，在 spring 配置文件中定义，必须指定至少一个
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
例如：&lt;br&gt;
 @Cacheable(value=”mycache”) 或者 &lt;br&gt;
 @Cacheable(value={”cache1”,”cache2”} 
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
 key 
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
例如：&lt;br&gt;
 @Cacheable(value=”testcache”,key=”#userName”) 
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
 condition 
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
例如：&lt;br&gt;
 @Cacheable(value=”testcache”,condition=”#userName.length()&amp;gt;2”) 
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;表 2. @CachePut 作用和配置方法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; class=&quot;ibm-data-table&quot; summary=&quot;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th style=&quot;vertical-align:top&quot;&gt;
                        &lt;strong&gt;@CachePut 的作用&lt;/strong&gt;
                    &lt;/th&gt;&lt;th colspan=&quot;2&quot; style=&quot;vertical-align:top&quot;&gt;
主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用
&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;3&quot; style=&quot;text-align:center; vertical-align:top&quot;&gt;
                        &lt;strong&gt;@CachePut 主要的参数&lt;/strong&gt;
                    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
 value 
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
缓存的名称，在 spring 配置文件中定义，必须指定至少一个
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
例如：&lt;br&gt;
 @Cacheable(value=”mycache”) 或者 &lt;br&gt;
 @Cacheable(value={”cache1”,”cache2”} 
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
 key 
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
例如：&lt;br&gt;
 @Cacheable(value=”testcache”,key=”#userName”) 
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
 condition 
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
例如：&lt;br&gt;
 @Cacheable(value=”testcache”,condition=”#userName.length()&amp;gt;2”) 
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;表 3. @CacheEvict 作用和配置方法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; class=&quot;ibm-data-table&quot; summary=&quot;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th style=&quot;vertical-align:top&quot;&gt;
                        &lt;strong&gt;@CachEvict 的作用&lt;/strong&gt;
                    &lt;/th&gt;&lt;th colspan=&quot;2&quot; style=&quot;vertical-align:top&quot;&gt;
主要针对方法配置，能够根据一定的条件对缓存进行清空
&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;3&quot; style=&quot;text-align:center; vertical-align:top&quot;&gt;
                        &lt;strong&gt;@CacheEvict 主要的参数&lt;/strong&gt;
                    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
 value 
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
缓存的名称，在 spring 配置文件中定义，必须指定至少一个
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
例如：&lt;br&gt;
 @CachEvict(value=”mycache”) 或者 &lt;br&gt;
 @CachEvict(value={”cache1”,”cache2”} 
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
 key 
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
例如：&lt;br&gt;
 @CachEvict(value=”testcache”,key=”#userName”) 
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
 condition 
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才清空缓存
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
例如：&lt;br&gt;
 @CachEvict(value=”testcache”,&lt;br&gt;
 condition=”#userName.length()&amp;gt;2”) 
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
 allEntries 
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
例如：&lt;br&gt;
 @CachEvict(value=”testcache”,allEntries=true) 
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
 beforeInvocation 
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存
&lt;/td&gt;&lt;td style=&quot;vertical-align:top&quot;&gt;
例如：&lt;br&gt;
 @CachEvict(value=”testcache”，beforeInvocation=true) 
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;&lt;strong&gt;基本原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;和 spring 的事务管理类似，spring cache 的关键原理就是 spring AOP，通过 spring AOP，其实现了在方法调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。我们来看一下下面这个图：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;图 2. 原始方法调用图&lt;/em&gt;&lt;/strong&gt;
&lt;a href=&quot;/assets/files/2013-03/image002.jpg&quot; title=&quot;注释驱动的 Spring cache 缓存介绍&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/image002.jpg&quot; title=&quot;注释驱动的 Spring cache 缓存介绍&quot; alt=&quot;注释驱动的 Spring cache缓存介绍&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上图显示，当客户端“Calling code”调用一个普通类 Plain Object 的 foo() 方法的时候，是直接作用在 pojo 类自身对象上的，客户端拥有的是被调用者的直接的引用。&lt;/p&gt;

&lt;p&gt;而 Spring cache 利用了 Spring AOP 的动态代理技术，即当客户端尝试调用 pojo 的 foo（）方法的时候，给他的不是 pojo 自身的引用，而是一个动态生成的代理类&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;图 3. 动态代理调用图&lt;/em&gt;&lt;/strong&gt;
&lt;a href=&quot;/assets/files/2013-03/image003.jpg&quot; title=&quot;注释驱动的 Spring cache 缓存介绍&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/image003.jpg&quot; title=&quot;注释驱动的 Spring cache 缓存介绍&quot; alt=&quot;注释驱动的 Spring cache 缓存介绍&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，这个时候，实际客户端拥有的是一个代理的引用，那么在调用 foo() 方法的时候，会首先调用 proxy 的 foo() 方法，这个时候 proxy 可以整体控制实际的 pojo.foo() 方法的入参和返回值，比如缓存结果，比如直接略过执行实际的 foo() 方法等，都是可以轻松做到的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 扩展性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;直到现在，我们已经学会了如何使用开箱即用的 spring cache，这基本能够满足一般应用对缓存的需求，但现实总是很复杂，当你的用户量上去或者性能跟不上，总需要进行扩展，这个时候你或许对其提供的内存缓存不满意了，因为其不支持高可用性，也不具备持久化数据能力，这个时候，你就需要自定义你的缓存方案了，还好，spring 也想到了这一点。&lt;/p&gt;

&lt;p&gt;我们先不考虑如何持久化缓存，毕竟这种第三方的实现方案很多，我们要考虑的是，怎么利用 spring 提供的扩展点实现我们自己的缓存，且在不改原来已有代码的情况下进行扩展。&lt;/p&gt;

&lt;p&gt;首先，我们需要提供一个 CacheManager 接口的实现，这个接口告诉 spring 有哪些 cache 实例，spring 会根据 cache 的名字查找 cache 的实例。另外还需要自己实现 Cache 接口，Cache 接口负责实际的缓存逻辑，例如增加键值对、存储、查询和清空等。利用 Cache 接口，我们可以对接任何第三方的缓存系统，例如 EHCache、OSCache，甚至一些内存数据库例如 memcache 或者 h2db 等。下面我举一个简单的例子说明如何做。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 23. MyCacheManager&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package cacheOfAnno; 

 import java.util.Collection; 

 import org.springframework.cache.support.AbstractCacheManager; 

 public class MyCacheManager extends AbstractCacheManager { 
   private Collection&amp;lt;? extends MyCache&amp;gt; caches; 

   /** 
   * Specify the collection of Cache instances to use for this CacheManager. 
   */ 
   public void setCaches(Collection&amp;lt;? extends MyCache&amp;gt; caches) { 
     this.caches = caches; 
   } 

   @Override 
   protected Collection&amp;lt;? extends MyCache&amp;gt; loadCaches() { 
     return this.caches; 
   } 

 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的自定义的 CacheManager 实际继承了 spring 内置的 AbstractCacheManager，实际上仅仅管理 MyCache 类的实例。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 24. MyCache&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; package cacheOfAnno; 

 import java.util.HashMap; 
 import java.util.Map; 

 import org.springframework.cache.Cache; 
 import org.springframework.cache.support.SimpleValueWrapper; 

 public class MyCache implements Cache { 
   private String name; 
   private Map&amp;lt;String,Account&amp;gt; store = new HashMap&amp;lt;String,Account&amp;gt;();; 

   public MyCache() { 
   } 

   public MyCache(String name) { 
     this.name = name; 
   } 

   @Override 
   public String getName() { 
     return name; 
   } 

   public void setName(String name) { 
     this.name = name; 
   } 

   @Override 
   public Object getNativeCache() { 
     return store; 
   } 

   @Override 
   public ValueWrapper get(Object key) { 
     ValueWrapper result = null; 
     Account thevalue = store.get(key); 
     if(thevalue!=null) { 
       thevalue.setPassword(&quot;from mycache:&quot;+name); 
       result = new SimpleValueWrapper(thevalue); 
     } 
     return result; 
   } 

   @Override 
   public void put(Object key, Object value) { 
     Account thevalue = (Account)value; 
     store.put((String)key, thevalue); 
   } 

   @Override 
   public void evict(Object key) { 
   } 

   @Override 
   public void clear() { 
   } 
 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的自定义缓存只实现了很简单的逻辑，但这是我们自己做的，也很令人激动是不是，主要看 get 和 put 方法，其中的 get 方法留了一个后门，即所有的从缓存查询返回的对象都将其 password 字段设置为一个特殊的值，这样我们等下就能演示“我们的缓存确实在起作用！”了。&lt;/p&gt;

&lt;p&gt;这还不够，spring 还不知道我们写了这些东西，需要通过 spring*.xml 配置文件告诉它&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 25. Spring-cache-anno.xml&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xmlns:cache=&quot;http://www.springframework.org/schema/cache&quot;
   xmlns:p=&quot;http://www.springframework.org/schema/p&quot;  
   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
   http://www.springframework.org/schema/beans/spring-beans.xsd 
     http://www.springframework.org/schema/cache 
     http://www.springframework.org/schema/cache/spring-cache.xsd&quot;&amp;gt; 

   &amp;lt;cache:annotation-driven /&amp;gt; 

   &amp;lt;bean id=&quot;accountServiceBean&quot; class=&quot;cacheOfAnno.AccountService&quot;/&amp;gt; 

    &amp;lt;!-- generic cache manager --&amp;gt; 
   &amp;lt;bean id=&quot;cacheManager&quot; class=&quot;cacheOfAnno.MyCacheManager&quot;&amp;gt;
     &amp;lt;property name=&quot;caches&quot;&amp;gt; 
       &amp;lt;set&amp;gt; 
         &amp;lt;bean 
           class=&quot;cacheOfAnno.MyCache&quot;
           p:name=&quot;accountCache&quot; /&amp;gt; 
       &amp;lt;/set&amp;gt; 
     &amp;lt;/property&amp;gt; 
   &amp;lt;/bean&amp;gt; 
&amp;lt;/beans&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上面配置文件的黑体字，这些配置说明了我们的 cacheManager 和我们自己的 cache 实例。&lt;/p&gt;

&lt;p&gt;好，什么都不说，测试！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 26. Main.java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public static void main(String[] args) { 
   ApplicationContext context = new ClassPathXmlApplicationContext( 
      &quot;spring-cache-anno.xml&quot;);// 加载 spring 配置文件

   AccountService s = (AccountService) context.getBean(&quot;accountServiceBean&quot;); 

   Account account = s.getAccountByName(&quot;someone&quot;); 
   System.out.println(&quot;passwd=&quot;+account.getPassword()); 
   account = s.getAccountByName(&quot;someone&quot;); 
   System.out.println(&quot;passwd=&quot;+account.getPassword()); 
 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的测试代码主要是先调用 getAccountByName 进行一次查询，这会调用数据库查询，然后缓存到 mycache 中，然后我打印密码，应该是空的；下面我再次查询 someone 的账号，这个时候会从 mycache 中返回缓存的实例，记得上面的后门么？我们修改了密码，所以这个时候打印的密码应该是一个特殊的值&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 27. 运行结果&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; real querying db...someone 
 passwd=null 
 passwd=from mycache:accountCache 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果符合预期，即第一次查询数据库，且密码为空，第二次打印了一个特殊的密码。说明我们的 myCache 起作用了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 注意和限制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基于 proxy 的 spring aop 带来的内部调用问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面介绍过 spring cache 的原理，即它是基于动态生成的 proxy 代理机制来对方法的调用进行切面，这里关键点是对象的引用问题，如果对象的方法是内部调用（即 this 引用）而不是外部引用，则会导致 proxy 失效，那么我们的切面就失效，也就是说上面定义的各种注释包括 @Cacheable、@CachePut 和 @CacheEvict 都会失效，我们来演示一下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 28. AccountService.java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public Account getAccountByName2(String userName) { 
   return this.getAccountByName(userName); 
 } 

 @Cacheable(value=&quot;accountCache&quot;)// 使用了一个缓存名叫 accountCache 
 public Account getAccountByName(String userName) { 
   // 方法内部实现不考虑缓存逻辑，直接实现业务
   return getFromDB(userName); 
 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面我们定义了一个新的方法 getAccountByName2，其自身调用了 getAccountByName 方法，这个时候，发生的是内部调用（this），所以没有走 proxy，导致 spring cache 失效&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 29. Main.java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public static void main(String[] args) { 
   ApplicationContext context = new ClassPathXmlApplicationContext( 
      &quot;spring-cache-anno.xml&quot;);// 加载 spring 配置文件

   AccountService s = (AccountService) context.getBean(&quot;accountServiceBean&quot;); 

   s.getAccountByName2(&quot;someone&quot;); 
   s.getAccountByName2(&quot;someone&quot;); 
   s.getAccountByName2(&quot;someone&quot;); 
 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 30. 运行结果&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; real querying db...someone 
 real querying db...someone 
 real querying db...someone 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，结果是每次都查询数据库，缓存没起作用。要避免这个问题，就是要避免对缓存方法的内部调用，或者避免使用基于 proxy 的 AOP 模式，可以使用基于 aspectJ 的 AOP 模式来解决这个问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@CacheEvict 的可靠性问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们看到，@CacheEvict 注释有一个属性 beforeInvocation，缺省为 false，即缺省情况下，都是在实际的方法执行完成后，才对缓存进行清空操作。期间如果执行方法出现异常，则会导致缓存清空不被执行。我们演示一下&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 31. AccountService.java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; @CacheEvict(value=&quot;accountCache&quot;,allEntries=true)// 清空 accountCache 缓存
 public void reload() { 
   throw new RuntimeException(); 
 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上面的代码，我们在 reload 的时候抛出了运行期异常，这会导致清空缓存失败。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 32. Main.java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public static void main(String[] args) { 
   ApplicationContext context = new ClassPathXmlApplicationContext( 
      &quot;spring-cache-anno.xml&quot;);// 加载 spring 配置文件

   AccountService s = (AccountService) context.getBean(&quot;accountServiceBean&quot;); 

   s.getAccountByName(&quot;someone&quot;); 
   s.getAccountByName(&quot;someone&quot;); 
   try { 
     s.reload(); 
   } catch (Exception e) { 
   } 
   s.getAccountByName(&quot;someone&quot;); 
 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的测试代码先查询了两次，然后reload，然后再查询一次，结果应该是只有第一次查询走了数据库，其他两次查询都从缓存，第三次也走缓存因为 reload 失败了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 33. 运行结果&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;real querying db...someone 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和预期一样。那么我们如何避免这个问题呢？我们可以用 @CacheEvict 注释提供的 beforeInvocation 属性，将其设置为true，这样，在方法执行前我们的缓存就被清空了。可以确保缓存被清空。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 34. AccountService.java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; @CacheEvict(value=&quot;accountCache&quot;,allEntries=true,beforeInvocation=true)
 // 清空 accountCache 缓存
 public void reload() { 
   throw new RuntimeException(); 
 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上面的代码，我们在 @CacheEvict 注释中加了 beforeInvocation 属性，确保缓存被清空。&lt;/p&gt;

&lt;p&gt;执行相同的测试代码&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 35. 运行结果&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; real querying db...someone 
 real querying db...someone 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，第一次和第三次都从数据库取数据了，缓存清空有效。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;非 public 方法问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;和内部调用问题类似，非 public 方法如果想实现基于注释的缓存，必须采用基于 AspectJ 的 AOP 机制，这里限于篇幅不再细述。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 其他技巧&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dummy CacheManager 的配置和作用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有的时候，我们在代码迁移、调试或者部署的时候，恰好没有 cache 容器，比如 memcache 还不具备条件，h2db 还没有装好等，如果这个时候你想调试代码，岂不是要疯掉？这里有一个办法，在不具备缓存条件的时候，在不改代码的情况下，禁用缓存。&lt;/p&gt;

&lt;p&gt;方法就是修改 spring*.xml 配置文件，设置一个找不到缓存就不做任何操作的标志位，如下&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 36. Spring-cache-anno.xml&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; 
 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xmlns:cache=&quot;http://www.springframework.org/schema/cache&quot;
   xmlns:p=&quot;http://www.springframework.org/schema/p&quot;  
   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd 
     http://www.springframework.org/schema/cache 
     http://www.springframework.org/schema/cache/spring-cache.xsd&quot;&amp;gt; 

   &amp;lt;cache:annotation-driven /&amp;gt; 

   &amp;lt;bean id=&quot;accountServiceBean&quot; class=&quot;cacheOfAnno.AccountService&quot;/&amp;gt; 

    &amp;lt;!-- generic cache manager --&amp;gt; 
   &amp;lt;bean id=&quot;simpleCacheManager&quot; 
   class=&quot;org.springframework.cache.support.SimpleCacheManager&quot;&amp;gt; 
     &amp;lt;property name=&quot;caches&quot;&amp;gt; 
       &amp;lt;set&amp;gt; 
         &amp;lt;bean 
           class=&quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&quot;
           p:name=&quot;default&quot; /&amp;gt; 
       &amp;lt;/set&amp;gt; 
     &amp;lt;/property&amp;gt; 
   &amp;lt;/bean&amp;gt; 

   &amp;lt;!-- dummy cacheManager  --&amp;gt; 
   &amp;lt;bean id=&quot;cacheManager&quot; 
   class=&quot;org.springframework.cache.support.CompositeCacheManager&quot;&amp;gt;
     &amp;lt;property name=&quot;cacheManagers&quot;&amp;gt; 
       &amp;lt;list&amp;gt; 
         &amp;lt;ref bean=&quot;simpleCacheManager&quot; /&amp;gt; 
       &amp;lt;/list&amp;gt; 
     &amp;lt;/property&amp;gt; 
     &amp;lt;property name=&quot;fallbackToNoOpCache&quot; value=&quot;true&quot; /&amp;gt; 
   &amp;lt;/bean&amp;gt; 

 &amp;lt;/beans&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意以前的 cacheManager 变为了 simpleCacheManager，且没有配置 accountCache 实例，后面的 cacheManager 的实例是一个CompositeCacheManager，他利用了前面的 simpleCacheManager 进行查询，如果查询不到，则根据标志位 fallbackToNoOpCache 来判断是否不做任何缓存操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 37. 运行结果&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; real querying db...someone 
 real querying db...someone 
 real querying db...someone 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，缓存失效。每次都查询数据库。因为我们没有配置它需要的 accountCache 实例。&lt;/p&gt;

&lt;p&gt;如果将上面 xml 配置文件的 fallbackToNoOpCache 设置为 false，再次运行，则会得到&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;清单 38. 运行结果&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: 
   Cannot find cache named [accountCache] for CacheableOperation 
     [public cacheOfAnno.Account 
     cacheOfAnno.AccountService.getAccountByName(java.lang.String)]
     caches=[accountCache] | condition='' | key=''
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，在找不到 accountCache，且没有将 fallbackToNoOpCache 设置为 true 的情况下，系统会抛出异常。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 小结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;总之，注释驱动的 spring cache 能够极大的减少我们编写常见缓存的代码量，通过少量的注释标签和配置文件，即可达到使代码具备缓存的能力。且具备很好的灵活性和扩展性。但是我们也应该看到，spring cache 由于急于 spring AOP 技术，尤其是动态的 proxy 技术，导致其不能很好的支持方法的内部调用或者非 public 方法的缓存设置，当然这都是可以解决的问题，通过学习这个技术，我们能够认识到，AOP 技术的应用还是很广泛的，如果有兴趣，我相信你也能基于 AOP 实现自己的缓存方案。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>翻译-高效的CSS</title>
   <link href="http://beango.github.com/archives/2013/03/08/efficient-css.html"/>
   <updated>2013-03-08T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/03/08/efficient-css</id>
   <content type="html">&lt;h2&gt;译言：&lt;/h2&gt;

&lt;p&gt;逛微博的时候看到 &lt;a href=&quot;http://weibo.com/u/2093492691&quot;&gt;@程序员的那些事&lt;/a&gt;推荐的一篇CSS的文章。细细看了下，写的很不错，就翻译过来，与诸前端们共享~&lt;/p&gt;

&lt;p&gt;原文地址在&lt;a href=&quot;http://csswizardry.com/2011/09/writing-efficient-css-selectors/&quot;&gt;这里&lt;/a&gt;，由于第一次翻译文章，有不准确的地方欢迎留言讨论~~&lt;/p&gt;

&lt;h2&gt;译文：&lt;/h2&gt;

&lt;p&gt;高效的CSS已经不是一个新的话题了，也不是我一个非得重拾的话题，但它却是我在Sky公司工作之时，所感兴趣的，关注已久的话题。&lt;/p&gt;

&lt;p&gt;有很多人都忘记了，或在简单的说没有意识到，CSS在我们手中，既能很高效，也可以变得很低能。这很容易被忘记，尤其是当你意识到你会的太少，CSS代码效率很低的时候。&lt;/p&gt;

&lt;p&gt;下面的规则只真正被应用到那些速度要求很高，有成百上千的DOM元素被绘制在页面上的大型网站。但是，实践出真理，这和你是在创建下一个Facebook，还是写一个本地的展示页面都没有关系，多知道一点总是好的。&lt;/p&gt;

&lt;h3&gt;CSS选择器：&lt;/h3&gt;

&lt;p&gt;对我们大多数人来说，CSS选择器并不陌生。最基本的选择器是元素选择器(比如div),ID选择器(比如#header)还有类选择器(比如.tweet)。&lt;/p&gt;

&lt;p&gt;一些的不常见的选择器包括伪类选择器(:hover)，很多复杂的CSS3和正则选择器，比如：first-child，class ^= “grid-”.&lt;/p&gt;

&lt;p&gt;CSS选择器具有高效的继承性，引用Steve Souders的话，
CSS选择器效率从高到低的排序如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ID选择器 比如#header&lt;/li&gt;
&lt;li&gt;类选择器 比如.promo&lt;/li&gt;
&lt;li&gt;元素选择器 比如 div&lt;/li&gt;
&lt;li&gt;兄弟选择器 比如 h2 + p&lt;/li&gt;
&lt;li&gt;子选择器 比如 li &gt; ul&lt;/li&gt;
&lt;li&gt;后代选择器 比如 ul a 7. 通用选择器 比如 *&lt;/li&gt;
&lt;li&gt;属性选择器 比如 type = “text”&lt;/li&gt;
&lt;li&gt;伪类/伪元素选择器 比如 a:hover&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;以上引用自&lt;a href=&quot;http://stevesouders.com/&quot;&gt;Steve Souders&lt;/a&gt;的Even Faster网站、&lt;/p&gt;

&lt;p&gt;我们不得不提的是，纵使ID选择器很快、高效，但是它也仅仅如此。从Steve Souders的CSS Test我们可以看出&lt;a href=&quot;http://stevesouders.com/efws/CSS-selectors/CSScreate.php?n=1000&amp;amp;sel=%23id&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;ID选择器&lt;/a&gt;和&lt;a href=&quot;http://stevesouders.com/efws/CSS-selectors/CSScreate.php?n=1000&amp;amp;sel=.class&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;类选择器&lt;/a&gt;在速度上的差异很小很小。&lt;/p&gt;

&lt;p&gt;在Windows系统上的Firefox 6上，我测得了一个简单类选择器的（reflow figure）重绘速度为10.9ms，而ID选择器为12.5ms，所以事实上ID比类选择器重绘要慢一点点。&lt;/p&gt;

&lt;p&gt;ID选择器和类选择器在速度上的差异基本上没有关系。&lt;/p&gt;

&lt;p&gt;在一个标签选择器(a)的测试上显示，它比类或ID选择器的速度慢了&lt;a href=&quot;http://stevesouders.com/efws/CSS-selectors/CSScreate.php?n=1000&amp;amp;sel=a&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;很多&lt;/a&gt;。在一个嵌套很深的后代选择器的测试上，显示数据为&lt;a href=&quot;http://stevesouders.com/efws/CSS-selectors/CSScreate.php?n=1000&amp;amp;sel=div+div+div+div+div+div+a&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;440左右&lt;/a&gt;！从这里我们可以看出ID/类选择器和 元素/后代选择器中间的差异较大，但是相互之间的差异较小。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;
这些数据可能在不同计算机和浏览器中间的差异较大。强烈地建议大家在自己的机子上测试一下。&lt;/p&gt;

&lt;h3&gt;组合选择器&lt;/h3&gt;

&lt;p&gt;你可以有一个标准的选择器比如#nav，来选择任何带有ID为”nav”的元素，或在你可以有一个组合选择器比如#nav a,来选择任何在ID为’nav’的元素里面的链接元素&lt;/p&gt;

&lt;p&gt;此刻，我们读这些是从左到右的方式。我们是先找到#nav，然后从它的里面找其他元素。但是浏览器解析这些不是这样的：浏览器解析选择器是从右到左的方式。&lt;/p&gt;

&lt;p&gt;在我们看来，#nav里面带了一个a，浏览器却是看到的a在#nav里面。这些细微的差异对选择器的效率有很大的影响，同时学这些差异也是很有价值的。&lt;/p&gt;

&lt;p&gt;如果想要知道更多浏览器这样解析的原因，请看&lt;a href=&quot;http://stackoverflow.com/questions/5797014/why-do-browsers-match-CSS-selectors-from-right-to-left&quot;&gt;Stack Overflow&lt;/a&gt;上的讨论&lt;/p&gt;

&lt;p&gt;浏览器从最右边的元素开始（它想要渲染的元素），然后用它的方式回溯DOM树比从DOM树的最高层开始选择向下寻找，甚至可能达不到最右边的选择器—关键的选择器要高效。&lt;/p&gt;

&lt;p&gt;这些对CSS选择器的效率有很大的影响。&lt;/p&gt;

&lt;h3&gt;关键选择器&lt;/h3&gt;

&lt;p&gt;关键选择器，正如前面讨论的一样，是一个复杂的CSS选择器中最右边部分。它是浏览器最先寻找的。&lt;/p&gt;

&lt;p&gt;现在我们回到讨论开始的地方，哪类选择器是最高效的？哪个是会影响选择器效率的关键选择器；写CSS代码的时候，关键选择器是能否高效的决定因素。
一个关键CSS选择器像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#content .intro {..}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是高效选择器比如类选择器天生就高效？浏览器会寻找.intro的实例（可能会很多），然后沿着DOM树向上查找，确定刚才找到的实例是否在一个带有ID为”content”的容器里面。&lt;/p&gt;

&lt;p&gt;但是，下面的选择器就表现的不是那么好了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#content * {..}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个选择器所做的是选择所有在页面上的单个元素（是每个单个的元素），然后去看看它们是否有一个#content的父元素。这是一个非常不高效选择器因为它的关键选择器执行开销太大了。&lt;/p&gt;

&lt;p&gt;运用这些知识我们就可以在分类和选择元素的时候做出更好的选择。&lt;/p&gt;

&lt;p&gt;假设你有一个复杂的页面，它相当巨大并且在你的一个很大很大的站点上。在那个页面上有成百上千甚至上万的a标签。它还有一个小的社交链接区域放在一个ID为#social的Ul里面。我们假设它们是Twitter，Facebook，Dribbble还有Google+的链接吧。在这个页面上我们有四个社交链接和成百上千的其他链接。
下面的这个选择器就自然的不是那么高效和合理了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#social a {…}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里发生的情况是浏览器会在定位到#social区域下的四个链接之前得到页面上所有成千上万的链接。我们的关键选择器匹配了太多我们不感兴趣的其他元素。&lt;/p&gt;

&lt;p&gt;为了补救我们可以给每个在社交链接区域的 a 增加一个更特殊、明确的选择器
.social-link ,
但是这好像有点违背我们的认知：当我们能用组合选择器的时候就不要放不必要的类标示在元素上。&lt;/p&gt;

&lt;p&gt;这就是为什么我对选择器的性能如此感兴趣的原因了：必须在web
标准最佳实践和速度之间的保持平衡。&lt;/p&gt;

&lt;p&gt;通常我们有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul id=&quot;social&quot;&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; class=&quot;twitter&quot;&amp;gt;Twitter&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; class=&quot;facebook&quot;&amp;gt;Facebook&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; class=&quot;dribble&quot;&amp;gt;Dribbble&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; class=&quot;gplus&quot;&amp;gt;Google+&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CSS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#social a {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们现在最好有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul id=&quot;social&quot;&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; class=&quot;social-link twitter&quot;&amp;gt;Twitter&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; class=&quot;social-link facebook&quot;&amp;gt;Facebook&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; class=&quot;social-link dribble&quot;&amp;gt;Dribbble&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; class=&quot;social-link gplus&quot;&amp;gt;Google+&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加上CSS：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#social .social-link {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个新的关键选择器将会匹配更少的元素，这意味着浏览器能够很快的找到它们并渲染特定的样式，然后专注于下一件事。&lt;/p&gt;

&lt;p&gt;另外，事实上我们可以用.social-link{}更清晰的选择，而不是过分限制它。阅读下一部分你会原因…&lt;/p&gt;

&lt;p&gt;简单的重述一次，你的关键选择器会决定浏览器的工作量，因此，我们应该重视一下关键选择器&lt;/p&gt;

&lt;h3&gt;过度限制选择器&lt;/h3&gt;

&lt;p&gt;现在我们知道了什么是关键选择器，还有它是大部分工作的来源，但是我们可以更乐观一点。拥有一个明确的关键选择器最大的好处就是你可以避免使用过度限制选择器。一个过度限制选择器可能像：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;html body .wrapper #content a {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的写的太多了，至少3个选择器是完全不需要的。它可以最多像这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#content a {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这会发生什么呢？ 首先第一个意味着浏览器不得不寻找所有的 a
元素，然后检查他们是否在一个ID为”content”的元素中，然后如此循环直到HTML标签。这样造成了太多的我们不太想要的花费。了解了这个，我们得到一些更现实的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#nav li a{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;变成这个：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#nav a {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们知道如果a在li里面，它也必定在#nav里面，所有我们可以马上把li从选择器组中拿掉。然后，既然我们知道在页面中只有一个ID为nav的元素，那么它依附的元素就是完全没有关系得了，我们也可以拿掉ul&lt;/p&gt;

&lt;p&gt;过度限制选择器使浏览器工作比它实际需要的更繁重，花费的时间更多。我们可以删掉不必需的限制，来使我们的选择器更简单和高效。&lt;/p&gt;

&lt;h3&gt;这些真的需要吗？&lt;/h3&gt;

&lt;p&gt;最短的答案是:或许不是。&lt;/p&gt;

&lt;p&gt;最长的答案是：它取决于你正在搭建的站点。如果你正在为你的晋升而努力，那么就好好写出简单、高效的CSS代码吧，因为你可能不会感觉到它给你带来的改变。
如果你正在搭建下一个每个页面都以毫秒计算的Amazon网站，这样有时速度会很快，但有时可能不是。&lt;/p&gt;

&lt;p&gt;浏览器将会在解析CSS的速度上变得更好，甚至在手机端。在一个网站上，你不太可能会觉察到一个低效的CSS选择器，但是….&lt;/p&gt;

&lt;h3&gt;但是&lt;/h3&gt;

&lt;p&gt;它确实发生了，浏览器还是不得不去做我们讨论的所有工作，无论它们变得多快。即使你不需要或者甚至不想实践任何一个，但是它都是我们值得学习的知识。请记住选择器可能会让你付出很大代价，你应该避免盯着一个看。这意味着如果你发现你自己在写像这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div:nth-of-type(3) ul:last-child li:nth-of-type(odd) *{ font-weight:bold }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时，你可能就做错了。&lt;/p&gt;

&lt;p&gt;现在，在高效选择器的世界我还是一个新人。所以如果我忘记了什么，或者你有需要补充的，请在评论里面留言。&lt;/p&gt;

&lt;h3&gt;更多高效选择器&lt;/h3&gt;

&lt;p&gt;我还不能完全介绍Steve Souders的网站和书籍，它们是如此之好，以至于值得你花更多时间来阅读和推荐。这个家伙只有他自己才了解自己！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Python中函数式编程，第一部分</title>
   <link href="http://beango.github.com/archives/2013/03/04/python-functional-programming-part1.html"/>
   <updated>2013-03-04T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/03/04/python-functional-programming-part1</id>
   <content type="html">&lt;p&gt;英文原文：&lt;a href=&quot;http://www.ibm.com/developerworks/linux/library/l-prog/index.html&quot;&gt;Charming Python: Functional programming in Python, Part 1&lt;/a&gt;，翻译：&lt;a href=&quot;http://www.oschina.net/translate/python-functional-programming-part1&quot;&gt;开源中国&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：虽然人们总把Python当作过程化的，面向对象的语言，但是他实际上包含了函数化编程中，你需要的任何东西。这篇文章主要讨论函数化编程的一般概念，并说明用Python来函数化编程的技术。&lt;/p&gt;

&lt;p&gt;我们最好从艰难的问题开始出发：“到底什么是函数化编程呢？”其中一个答案可能是这样的，函数化编程就是你在使用Lisp这样的语言时所做的（还有Scheme，Haskell，ML，OCAML，Mercury，Erlang和其他一些语言）。这是一个保险的回答，但是它解释得并不清晰。不幸的是对于什么是函数化编程，很难能有一个协调一致的定义，即使是从函数化变成本身出发，也很难说明。这点倒很像盲人摸象。不过，把它拿来和命令式编程（imperative programming）做比较也不错（命令式编程就像你在用C，Pascal，C++，Java，Perl，Awk，TCL和很多其他类似语言时所做的，至少大部分一样 ）。&lt;/p&gt;

&lt;p&gt;让我们回想一下功能模块的绑定类。使用该类的特性，我们可以确认在一个给定的范围块内，一个特定的名字仅仅代表了一个唯一的事物。&lt;/p&gt;

&lt;p&gt;我个人粗略总结了一下，认为函数式编程至少应该具有下列几点中的多个特点。在谓之为函数式的语言中，要做到这些就比较容易，但要做到其它一些事情不是很难就是完全不可能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;函数具有首要地位(对象)。也就是说，能对“数据”做什么事，就要能对函数本身做到那些事（比如将函数作为参数传递给另外一个函数）。&lt;/li&gt;
&lt;li&gt;将递归作为主要的控制结构。在有些函数式语言中，都不存在其它的“循环”结构。&lt;/li&gt;
&lt;li&gt;列表处理作为一个重点（例如，Lisp语言的名字）。列表往往是通过对子列表进行递归取代了循环。&lt;/li&gt;
&lt;li&gt;“纯”函数式语言会完全避免副作用。这么做就完全弃绝了命令式语言中几乎无处不在的这种做法：将第一个值赋给一个变量之后为了跟踪程序的运行状态，接着又将另外一个值赋给同一个变量。&lt;/li&gt;
&lt;li&gt;函数式编程不是不鼓励就是完全禁止使用&lt;em&gt;语句&lt;/em&gt;，而是通过对表达式(换句话说，就是函数加上参数）求值（evaluation of expressions）完成任务.
在最纯粹的情形下，一个程序就是一个表达式（再加上辅助性的定义）&lt;/li&gt;
&lt;li&gt;函数式编程中最关心的是要对&lt;em&gt;什么&lt;/em&gt;进行计算，而不是要&lt;em&gt;怎么来&lt;/em&gt;进行计算。&lt;/li&gt;
&lt;li&gt;在很多函数式&lt;a href=&quot;http://blog.jobbole.com/tag/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/&quot; title=&quot;如何选择语言和编程语言排名相关文章&quot;&gt;编程语言&lt;/a&gt;中都会用到“高阶”（higher order）函数
(换句话说，高阶函数就是对对函数进行运算的函数进行运算的函数）。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;函数式编程的倡导者们认为，所有这些特性都有助于更快地编写出更多更简洁并且更不容易出Bug的代码。而且，计算机科学、逻辑学和数学这三个领域中的高级理论家发现，函数式编程语言和程序的形式化特性在证明起来比命令式编程语言和程序要简单很多。&lt;/p&gt;

&lt;h2&gt;Python内在的函数式功能&lt;/h2&gt;

&lt;p&gt;自Python 1.0起，Python就已具有了以上所列中的绝大多数特点。但是就象Python所具有的大多数特性一样，这些特点出现在了一种混合了各种特性的语言中。 和Python的OOP（面向对象编程）特性非常象，你想用多少就用多少，剩下的都可以不管（直到你随后需要用到它们为止）。在Python 2.0中，加入了&lt;em&gt;列表解析&lt;/em&gt;（&lt;em&gt;list comprehensions&lt;/em&gt;）这个非常好用的”语法糖“。尽管列表解析没有添加什么新功能，但它让很多旧功能看起来好了&lt;em&gt;不少&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;Python中函数式编程的基本要素包括functionsmap()、reduce()、filter()和lambda算子（operator）。
在Python 1.x中，apply()函数也可以非常方便地拿来将一个函数的列表返回值直接用于另外一个函数。Python 2.0为此提供了一个改进后的语法。可能有点让人惊奇，使用如此之少的函数（以及基本的算子）几乎就足以写出任何Python程序了；更加特别的是，几乎用不着什么执行流程控制语句。&lt;/p&gt;

&lt;p&gt;所有(if,elif,else,assert,try,except,finally,for,break,continue,while,def)这些都都能通过仅仅使用函数式编程中的函数和算子就能以函数式编程的风格处理好。尽管真正地在程序中完全排除使用所有流程控制命令可能只在想参加”Python混乱编程“大赛（可将Python代码写得跟Lisp代码非常象）时才有意义，但这对理解函数式编程如何通过函数和递归表达流程控制很有价值。&lt;/p&gt;

&lt;h2&gt;剔除流程控制语句&lt;/h2&gt;

&lt;p&gt;剔除练习首先要考虑的第一件事是，实际上，Python会对布尔表达式求值进行“短路”处理。这就为我们提供了一个if/elif/else分支语句的表达式版（假设每个分支只调用一个函数，不是这种情况时也很容易组织成重新安排成这种情况）。
这里给出怎么做：&lt;/p&gt;

&lt;p&gt;对Python中的条件调用进行短路处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Normal statement-based flow control
if &amp;lt;cond1&amp;gt;:   func1()
elif &amp;lt;cond2&amp;gt;: func2()
else:         func3()

# Equivalent &quot;short circuit&quot; expression
(&amp;lt;cond1&amp;gt; and func1()) or (&amp;lt;cond2&amp;gt; and func2()) or (func3())

# Example &quot;short circuit&quot; expression
&amp;gt;&amp;gt;&amp;gt; x = 3
&amp;gt;&amp;gt;&amp;gt; def pr(s): return s
&amp;gt;&amp;gt;&amp;gt; (x==1 and pr('one')) or (x==2 and pr('two')) or (pr('other'))
'other'
&amp;gt;&amp;gt;&amp;gt; x = 2
&amp;gt;&amp;gt;&amp;gt; (x==1 and pr('one')) or (x==2 and pr('two')) or (pr('other'))
'two'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们的表达式版本的条件调用看上去可能不算什么，更象是个小把戏；然而，如果我们注意到lambda算子必须返回一个表达式，这就更值得关注了。既然如我们所示，表达式能够通过短路包含一个条件判断，那么，lambda表达式就是个完全通用的表达条件判断返回值的手段了。我们来一个例子：&lt;/p&gt;

&lt;p&gt;Python中短路的Lambda&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; pr = lambda s:s
&amp;gt;&amp;gt;&amp;gt; namenum = lambda x: (x==1 and pr(&quot;one&quot;)) \
....                  or (x==2 and pr(&quot;two&quot;)) \
....                  or (pr(&quot;other&quot;))
&amp;gt;&amp;gt;&amp;gt; namenum(1)
'one'
&amp;gt;&amp;gt;&amp;gt; namenum(2)
'two'
&amp;gt;&amp;gt;&amp;gt; namenum(3)
'other'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;将函数作为具有首要地位的对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面的例子已经表明了Python中函数具有首要地位，但有点委婉。当我们用lambda操作创建一个&lt;em&gt;函数对象&lt;/em&gt;时，我们所得到的东西是完全通用的。就其本质而言，我们可以将我们的对象同名字”pr”和”namenum”绑定到一起,以完全相同的方式，我们也也完全可以将数字23或者字符串”spam”同这些名字绑定到一起。但是，就象我们可以无需将其绑定到任何名字之上就能直接使用数字23（也就是说，它可以用作函数的参数）一样，我们也可以直接使用我们使用lambda创建的函数对象，而无需将其绑定到任何名字之上。在Python中，函数就是另外一种我们能够就像某种处理的值。&lt;/p&gt;

&lt;p&gt;我们对具有首要地位的对象做的比较多的事情就是，将它们作为参数传递给函数式编程固有的函数map()、reduce()和filter()。这三个函数接受的第一个参数都是一个函数对象。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;map()针对指定给它的一个或多个列表中每一项对应的内容，执行一次作为参数传递给它的那个函数，最后返回一个结果列表。&lt;/li&gt;
&lt;li&gt;reduce()针对每个后继项以及最后结果的累积结果，执行一次作为参数传递给它的那个函数；例如，reduce(lambdan,m:n*m,range(1,10))是求”10的阶乘”的意思（换言之，将每一项和前面所得的乘积进行相乘）&lt;/li&gt;
&lt;li&gt;filter()使用那个作为参数传递给它的函数，对一个列表中的所有项进行”求值“，返回一个由所有能够通过那个函数测试的项组成的经过遴选后的列表。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;我们经常也会把函数对象传递给我们自己定义的函数，不过一般情况下这些自定义的函数就是前文提及的内建函数的某种形式的组合。&lt;/p&gt;

&lt;p&gt;通过组合使用这三种函数式编程内建的函数，能够实现范围惊人的“执行流程”操作(全都不用语句，仅仅使用表达式实现)。&lt;/p&gt;

&lt;h2&gt; Python中的函数式循环&lt;/h2&gt;

&lt;p&gt;替换循环语言和条件状态语言块同样简单。for可以直接翻译成map()函数。正如我们的条件执行，我们会需要简化语句块成简单的函数调用（我们正在接近通常能做的）：&lt;/p&gt;

&lt;p&gt;替换循环&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for e in lst:  func(e)      # statement-based loop
map(func,lst)           # map()-based loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这种方法，对有序程序流将有一个相似的函数式方式。那就是，命令式编程几乎是由大量“做这，然后做那，之后做其它的”语句组成。map()让我们只要做这样：&lt;/p&gt;

&lt;p&gt;Map-based 动作序列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# let's create an execution utility function
do_it = lambda f: f()

# let f1, f2, f3 (etc) be functions that perform actions

map(do_it, [f1,f2,f3])   # map()-based action sequence
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常，我们的整个主要的程序都可以使用一个map表达式加上一些函数列表的执行来完成这个程序。最高级别的函数的另一个方便的特性是你可以把它们放在一个列表里。&lt;/p&gt;

&lt;p&gt;翻译while会稍稍复杂一些，但仍然可以直接地完成：&lt;/p&gt;

&lt;p&gt;Python中的函数式”while”循环&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# statement-based while loop
while &amp;lt;cond&amp;gt;:
    &amp;lt;pre-suite&amp;gt;
    if &amp;lt;break_condition&amp;gt;:
        break
    else:
        &amp;lt;suite&amp;gt;

# FP-style recursive while loop
def while_block():
    &amp;lt;pre-suite&amp;gt;
    if &amp;lt;break_condition&amp;gt;:
        return 1
    else:
        &amp;lt;suite&amp;gt;
    return 0

while_FP = lambda: (&amp;lt;cond&amp;gt; and while_block()) or while_FP()
while_FP()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在翻译while循环时，我们仍然需要使用while_block()函数，这个函数本身里面可以包含语句而不是仅仅包含表达式。但我们可能还能够对这个函数再进行更进一步的剔除过程（就像前面模版中的对if/else进行短路处理一样）。还有，&amp;lt;cond&gt;很难对普通的测试有什么用，比如while myvar==7，既然循环体（在设计上）不能对任何变量的值进行修改（当然，在while_block()中可以修改全局变量）。有一种方法可以用来为while_block()添加更有用的条件判断，让while_block()返回一个有意义的值，然后将这个返回值同循环结束条件进行比较。现在应该来看一个剔除其中语句的具体例子了：&lt;/p&gt;

&lt;p&gt;Python中’echo’循环&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# imperative version of &quot;echo()&quot;
def echo_IMP():
    while 1:
        x = raw_input(&quot;IMP -- &quot;)
        if x == 'quit':
            break
        else
            print x
echo_IMP()

# utility function for &quot;identity with side-effect&quot;
def monadic_print(x):
    print x
    return x

# FP version of &quot;echo()&quot;
echo_FP = lambda: monadic_print(raw_input(&quot;FP -- &quot;))=='quit' or echo_FP()
echo_FP()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中我们所做的，就是想办法将一个涉及I/O、循环和条件判断的小程序，表达为一个递归方式的纯粹的表达式 （确切地说，表达为一个可以在需要的情况下传递到别的地方的函数对象）。我们&lt;em&gt;的确&lt;/em&gt;仍然使用了实用函数monadic_print()，但这个函数是完全通用的，而且可以用于以后我们可能会创建的每个函数式程序的表达式中（它的代价是一次性的）。请注意，任何包含monadic_print(x)的表达式的&lt;em&gt;值&lt;/em&gt;都是一样的，好像它只是包含了一个x而已。函数式编程中（特别是在Haskell中）的函数有一种叫做”monad”（一元）的概念，这种一元函数“实际什么都不做，只是在执行过程中产生一个副作用”。&lt;/p&gt;

&lt;h2&gt; 避免副作用&lt;/h2&gt;

&lt;p&gt;在做完这些没有非常明智的理由陈述，并把晦涩的嵌套表达式代替他们之后，一个很自然的问题是“为什么要这样做？！”　我描述的函数式编程在Python中都实现了。但是最重要的特性和一个有具体用处——就是避免副作用（或至少它们阻止如monads的特殊区域）。程序错误的大部分——并且这些问题驱使程序员去debug——出现是因为在程序的运行中变量获取了非期望的值。函数式编程简单地通过从不给变量赋值而绕过了这个问题。&lt;/p&gt;

&lt;p&gt;现在让我们看一段非常普通的命令式代码。这段代码的目的是打印出乘积大于25的一对一对数字所组成的一个列表。组成每对数字的每一个数字都是取自另外的两个列表。这种事情和很多程序员在他们的编程中经常做的一些事情比较相似。命令式的解决方式有可能就象下面这样：&lt;/p&gt;

&lt;p&gt;命令式的”打印大乘积”的Python代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Nested loop procedural style for finding big products
xs = (1,2,3,4)
ys = (10,15,3,22)
bigmuls = []
# ...more stuff...
for x in xs:
    for y in ys:
        # ...more stuff...
        if x*y &amp;gt; 25:
            bigmuls.append((x,y))
            # ...more stuff...
# ...more stuff...
print bigmuls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个项目足够小了，好像没有地方会出什么差错。但有可能在这段代码中我们会嵌入一些同时完成其它任务的代码。用”more stuff”（其它代码）注释掉的部分，就是有可能存在导致出现bug的副作用的地方。在那三部分的任何一点上，变量sxs、ys、bigmuls、x、y都有可能在这段按照理想情况简化后的代码中取得一个出人意料的值。还有，这段代码执行完后，后继代码有可能需要也有可能不需要对所有这些变量中的值有所预期。显而易见，将这段代码封装到函数/实例中，小心处理变量的作用范围，就能够避免这种类型的错误。你也可以总是将使用完毕的变量del掉。但在实践中，这里指出的这种类型的错误很常见。&lt;/p&gt;

&lt;p&gt;以一种函数式的途径一举消除这些副作用所产生的错误，这样就达到了我们的目的。一种可能的代码如下：&lt;/p&gt;

&lt;p&gt;以函数式途径达到我们的目的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bigmuls = lambda xs,ys: filter(lambda (x,y):x*y &amp;gt; 25, combine(xs,ys))
combine = lambda xs,ys: map(None, xs*len(ys), dupelms(ys,len(xs)))
dupelms = lambda lst,n: reduce(lambda s,t:s+t, map(lambda l,n=n: [l]*n, lst))
print bigmuls((1,2,3,4),(10,15,3,22))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在例子中我们绑定我们的匿名（lambda）函数对象到变量名，但严格意义上讲这并不是必须的。我们可以用简单的嵌套定义来代替之。这不仅是为了代码的可读性，我们才这样做的；而且是因为combine()函数在任何地方都是一个非常好的功能函数（函数从两个输入的列表读入数据生成一个相应的pair列表）。函数dupelms()只是用来辅助函数combine()的。即使这个函数式的例子跟命令式的例子显得要累赘些，不过一旦你考虑到功能函数的重用，则新的bigmuls()中代码就会比命令式的那个要稍少些。&lt;/p&gt;

&lt;p&gt;这个函数式例子的真正优点在于：在函数中绝对没有改变变量的值。这样就&lt;strong&gt;&lt;em&gt;不可能&lt;/em&gt;&lt;/strong&gt;在之后的代码（或者从之前的代码）中产生不可预期的副作用。显然，在函数中没有副作用，并不能保证代码的正确性，但它仍然是一个优点。无论如何请注意，Python（不像很多其它的函数式语言）不会阻止名字bigmuls，combine和dupelms的再次绑定。如果combine()运行在之后的程序中意味着有所不同时，所有的预测都会失效。你可能会需要新建一个单例类来包含这个不变的绑定（也就是说，s.bigmuls之类的）；但是这一例并没有空间来做这些。&lt;/p&gt;

&lt;p&gt;一个明显值得注意的是，我们特定的目标是定制Python 2的一些特性。而不是命令式的或函数式编程的例子，最好的（也是函数式的）方法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print [(x,y) for x in (1,2,3,4) for y in (10,15,3,22) if x*y &amp;gt; 25]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt; 结束语&lt;/h2&gt;

&lt;p&gt;我已经列出了把每一个Python控制流替换成一个相等的函数式代码的方法（在程序中减少副作用）。高效翻译一个特定的程序需要一些额外的思考，但我们已经看出内置的函数式功能是全面且完善的。在接下来的文章里，我们会看到更多函数式编程的高级技巧；并且希望我们接下来能够摸索到函数式编程风格的更多优点和缺点。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/archives/2013/03/04/python-functional-programming-part1.html&quot; title=&quot;Python中函数式编程，第一部分&quot;&gt;Python中的函数式编程，第一部分&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/archives/2013/04/11/python-functional-programming-part2.html&quot; title=&quot;Python中函数式编程，第二部分&quot;&gt;Python中的函数式编程，第二部分&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/archives/2013/04/25/python-functional-programming-part3.html&quot; title=&quot;Python中的函数式编程，第三部分&quot;&gt;Python中的函数式编程，第三部分&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>每个程序员都应该了解的内存知识</title>
   <link href="http://beango.github.com/archives/2013/03/01/what-every-programmer-should-know-about-memory-part1.html"/>
   <updated>2013-03-01T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/03/01/what-every-programmer-should-know-about-memory-part1</id>
   <content type="html">&lt;p&gt;英文原文：&lt;a href=&quot;http://lwn.net/Articles/250967/&quot;&gt;lwn.net&lt;/a&gt;，翻译：&lt;a href=&quot;http://www.oschina.net/translate/what-every-programmer-should-know-about-memory-part1&quot;&gt;开源中国&lt;/a&gt;&lt;/p&gt;

&lt;p style=&quot;color:#888888;&quot;&gt;[编辑的话: Ulrich Drepper最近问我们，是不是有兴趣发表一篇他写的内存方面的长文。我们不用看太多就已经知道，LWN的读者们会喜欢这篇文章的。内存的使用常常是软件性能的决定性因子，而如何避免内存瓶颈的好文章却不好找。这篇文章应该会有所帮助。&lt;/p&gt;




&lt;p style=&quot;color:#888888;&quot;&gt;他的原文很长，超过100页。我们把它分成了7篇，每隔一到两周发表一篇。7篇发完后，Ulrich会把全文发出来。&lt;/p&gt;




&lt;p style=&quot;color:#888888;&quot;&gt;对原文重新格式化是个很有挑战性的工作，但愿结果会不错吧。为了便于网上阅读，我们把Ulrich的脚注{放在了文章里}，而互相引用的超链接(和[参考书目])要等到全文出来才能提供。&lt;/p&gt;




&lt;p style=&quot;color:#888888;&quot;&gt;非常感谢Ultich，感谢他让LWN发表这篇文章，期待大家在不久的将来都能写出内存优化很棒的软件。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;1 概述&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　早期，计算机曾经很简单。它的各种组件，比如CPU、内存、大容量存储和网络接口，都是一起开发的，所以性能差不多。举个例子来说，内存和网络接口提供数据的速度不会比CPU快多少。&lt;/p&gt;

&lt;p&gt;　　这种情况随着计算机构造的固化和各子系统的优化慢慢地发生了改变。其中一些组件的性能开始落后，成为系统的瓶颈。特别是大容量存储和内存子系统，由于代价的原因，它们的发展严重滞后了。&lt;/p&gt;

&lt;p&gt;　　大容量存储的性能问题往往靠软件来改善:
操作系统将常用(且最有可能被用)的数据放在主存中，因为后者的速度要快上几个数量级。或者将缓存加入存储设备中，这样就可以在不修改操作系统的前提下提升性能。{然而，为了在使用缓存时保证数据的完整性，仍然要作出一些修改。}这些内容不在本文的谈论范围之内，就不作赘述了。&lt;/p&gt;

&lt;p&gt;　　而解决内存的瓶颈更为困难，它与大容量存储不同，几乎每种方案都需要对硬件作出修改。目前，这些变更主要有以下这些方式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RAM的硬件设计(速度与并发度)&lt;/li&gt;
&lt;li&gt;内存控制器的设计&lt;/li&gt;
&lt;li&gt;CPU缓存&lt;/li&gt;
&lt;li&gt;设备的直接内存访问(DMA)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　本文主要关心的是CPU缓存和内存控制器的设计。在讨论这些主题的过程中，我们还会研究DMA。不过，我们首先会从当今商用硬件的设计谈起。这有助于我们理解目前在使用内存子系统时可能遇到的问题和限制。我们还会详细介绍RAM的分类，说明为什么会存在这么多不同类型的内存。&lt;/p&gt;

&lt;p&gt;　　本文不会包括所有内容，也不会包括最终性质的内容。我们的讨论范围仅止于商用硬件，而且只限于其中的一小部分。另外，本文中的许多论题，我们只会点到为止，以达到本文目标为标准。对于这些论题，大家可以阅读其它文档，获得更详细的说明。&lt;/p&gt;

&lt;p&gt;　　当本文提到操作系统特定的细节和解决方案时，针对的都是Linux。无论何时都不会包含别的操作系统的任何信息，作者无意讨论其他操作系统的情况。如果读者认为他/她不得不使用别的操作系统，那么必须去要求供应商提供其操作系统类似于本文的文档。&lt;/p&gt;

&lt;p&gt;　　在开始之前最后的一点说明，本文包含大量出现的术语“经常”和别的类似的限定词。这里讨论的技术在现实中存在于很多不同的实现，所以本文只阐述使用得最广泛最主流的版本。在阐述中很少有地方能用到绝对的限定词。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1文档结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　这个文档主要视为软件开发者而写的。本文不会涉及太多硬件细节，所以喜欢硬件的读者也许不会觉得有用。但是在我们讨论一些有用的细节之前，我们先要描述足够多的背景。&lt;/p&gt;

&lt;p&gt;　　在这个基础上，本文的第二部分将描述RAM（随机寄存器）。懂得这个部分的内容很好，但是此部分的内容并不是懂得其后内容必须部分。我们会在之后引用不少之前的部分，所以心急的读者可以跳过任何章节来读他们认为有用的部分。&lt;/p&gt;

&lt;p&gt;　　第三部分会谈到不少关于CPU缓存行为模式的内容。我们会列出一些图标，这样你们不至于觉得太枯燥。第三部分对于理解整个文章非常重要。第四部分将简短的描述虚拟内存是怎么被实现的。这也是你们需要理解全文其他部分的背景知识之一。&lt;/p&gt;

&lt;p&gt;　　第五部分会提到许多关于Non Uniform Memory Access (NUMA)系统。&lt;/p&gt;

&lt;p&gt;　　第六部分是本文的中心部分。在这个部分里面，我们将回顾其他许多部分中的信息，并且我们将给阅读本文的&lt;a href=&quot;http://blog.jobbole.com/821/&quot; title=&quot;程序员的本质&quot;&gt;程序员&lt;/a&gt;许多在各种情况下的编程建议。如果你真的很心急，那么你可以直接阅读第六部分，并且我们建议你在必要的时候回到之前的章节回顾一下必要的背景知识。&lt;/p&gt;

&lt;p&gt;　　本文的第七部分将介绍一些能够帮助程序员更好的完成任务的工具。即便在彻底理解了某一项技术的情况下，距离彻底理解在非测试环境下的程序还是很遥远的。我们需要借助一些工具。&lt;/p&gt;

&lt;p&gt;　　第八部分，我们将展望一些在未来我们可能认为好用的科技。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2 反馈问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　作者会不定期更新本文档。这些更新既包括伴随技术进步而来的更新也包含更改错误。非常欢迎有志于反馈问题的读者发送电子邮件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.3 致谢&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　我首先需要感谢Johnray Fuller尤其是Jonathan Corbet，感谢他们将作者的英语转化成为更为规范的形式。Markus Armbruster提供大量本文中对于问题和缩写有价值的建议。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.4 关于本文&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　本文题目对David Goldberg的经典文献《What Every Computer Scientist Should Know About Floating-Point Arithmetic》[goldberg]表示致敬。Goldberg的论文虽然不普及，但是对于任何有志于严格编程的人都会是一个先决条件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 商用硬件现状&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　鉴于目前专业硬件正在逐渐淡出，理解商用硬件的现状变得十分重要。现如今，人们更多的采用水平扩展，也就是说，用大量小型、互联的商用计算机代替巨大、超快(但超贵)的系统。原因在于，快速而廉价的网络硬件已经崛起。那些大型的专用系统仍然有一席之地，但已被商用硬件后来居上。2007年，Red Hat认为，未来构成数据中心的“积木”将会是拥有最多4个插槽的计算机，每个插槽插入一个四核CPU，这些CPU都是超线程的。{超线程使单个处理器核心能同时处理两个以上的任务，只需加入一点点额外硬件}。也就是说，这些数据中心中的标准系统拥有最多64个虚拟处理器。当然可以支持更大的系统，但人们认为4插槽、4核CPU是最佳配置，绝大多数的优化都针对这样的配置。在不同商用计算机之间，也存在着巨大的差异。不过，我们关注在主要的差异上，可以涵盖到超过90%以上的硬件。需要注意的是，这些技术上的细节往往日新月异，变化极快，因此大家在阅读的时候也需要注意本文的写作时间。这么多年来，个人计算机和小型服务器被标准化到了一个芯片组上，它由两部分组成:北桥和南桥，见图2.1。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/06104430_73iC.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/06104430_73iC.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot; alt=&quot;每个程序员都应该了解的内存知识&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图2.1 北桥和南桥组成的结构&lt;/center&gt;


&lt;p&gt;　　CPU通过一条通用总线(前端总线，FSB)连接到北桥。北桥主要包括内存控制器和其它一些组件，内存控制器决定了RAM芯片的类型。不同的类型，包括DRAM、Rambus和SDRAM等等，要求不同的内存控制器。为了连通其它系统设备，北桥需要与南桥通信。南桥又叫I/O桥，通过多条不同总线与设备们通信。目前，比较重要的总线有PCI、PCI Express、SATA和USB总线，除此以外，南桥还支持PATA、IEEE 1394、串行口和并行口等。比较老的系统上有连接北桥的AGP槽。那是由于南北桥间缺乏高速连接而采取的措施。现在的PCI-E都是直接连到南桥的。这种结构有一些需要注意的地方:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从某个CPU到另一个CPU的数据需要走它与北桥通信的同一条总线。&lt;/li&gt;
&lt;li&gt;与RAM的通信需要经过北桥&lt;/li&gt;
&lt;li&gt;RAM只有一个端口。{本文不会介绍多端口RAM，因为商用硬件不采用这种内存，至少程序员无法访问到。这种内存一般在路由器等专用硬件中采用。}&lt;/li&gt;
&lt;li&gt;CPU与南桥设备间的通信需要经过北桥在&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　上面这种设计中，瓶颈马上出现了。第一个瓶颈与设备对RAM的访问有关。早期，所有设备之间的通信都需要经过CPU，结果严重影响了整个系统的性能。为了解决这个问题，有些设备加入了直接内存访问(DMA)的能力。DMA允许设备在北桥的帮助下，无需CPU的干涉，直接读写RAM。到了今天，所有高性能的设备都可以使用DMA。虽然DMA大大降低了CPU的负担，却占用了北桥的带宽，与CPU形成了争用。&lt;/p&gt;

&lt;p&gt;　　第二个瓶颈来自北桥与RAM间的总线。总线的具体情况与内存的类型有关。在早期的系统上，只有一条总线，因此不能实现并行访问。近期的RAM需要两条独立总线(或者说通道，DDR2就是这么叫的，见图2.8)，可以实现带宽加倍。北桥将内存访问交错地分配到两个通道上。更新的内存技术(如FB-DRAM)甚至加入了更多的通道。由于带宽有限，我们需要以一种使延迟最小化的方式来对内存访问进行调度。我们将会看到，处理器的速度比内存要快得多，需要等待内存。如果有多个超线程核心或CPU同时访问内存，等待时间则会更长。对于DMA也是同样。除了并发以外，访问模式也会极大地影响内存子系统、特别是多通道内存子系统的性能。关于访问模式，可参见2.2节。在一些比较昂贵的系统上，北桥自己不含内存控制器，而是连接到外部的多个内存控制器上(在下例中，共有4个)。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/06104430_V9Tz.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/06104430_V9Tz.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot; alt=&quot;每个程序员都应该了解的内存知识&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图2.2 拥有外部控制器的北桥&lt;/center&gt;


&lt;p&gt;　　这种架构的好处在于，多条内存总线的存在，使得总带宽也随之增加了。而且也可以支持更多的内存。通过同时访问不同内存区，还可以降低延时。对于像图2.2中这种多处理器直连北桥的设计来说，尤其有效。而这种架构的局限在于北桥的内部带宽，非常巨大(来自Intel)。{出于完整性的考虑，还需要补充一下，这样的内存控制器布局还可以用于其它用途，比如说「内存RAID」，它可以与热插拔技术一起使用。}使用外部内存控制器并不是唯一的办法，另一个最近比较流行的方法是将控制器集成到CPU内部，将内存直连到每个CPU。这种架构的走红归功于基于AMD
Opteron处理器的SMP系统。图2.3展示了这种架构。Intel则会从Nehalem处理器开始支持通用系统接口(CSI)，基本上也是类似的思路——集成内存控制器，为每个处理器提供本地内存。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/06104431_mINo.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/06104431_mINo.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot; alt=&quot;每个程序员都应该了解的内存知识&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图2.3 集成的内存控制器&lt;/center&gt;


&lt;p&gt;　　通过采用这样的架构，系统里有几个处理器，就可以有几个内存库(memory bank)。比如，在4 CPU的计算机上，不需要一个拥有巨大带宽的复杂北桥，就可以实现4倍的内存带宽。另外，将内存控制器集成到CPU内部还有其它一些优点，这里就不赘述了。同样也有缺点。首先，系统仍然要让所有内存能被所有处理器所访问，导致内存不再是统一的资源(NUMA即得名于此)。处理器能以正常的速度访问本地内存(连接到该处理器的内存)。但它访问其它处理器的内存时，却需要使用处理器之间的互联通道。比如说，CPU 1如果要访问CPU 2的内存，则需要使用它们之间的互联通道。如果它需要访问CPU 4的内存，那么需要跨越两条互联通道。使用互联通道是有代价的。在讨论访问远端内存的代价时，我们用「NUMA因子」这个词。在图2.3中，每个CPU有两个层级:相邻的CPU，以及两个互联通道外的CPU。在更加复杂的系统中，层级也更多。甚至有些机器有不止一种连接，比如说IBM的x445和SGI的Altix系列。CPU被归入节点，节点内的内存访问时间是一致的，或者只有很小的NUMA因子。而在节点之间的连接代价很大，而且有巨大的NUMA因子。目前，已经有商用的NUMA计算机，而且它们在未来应该会扮演更加重要的角色。人们预计，从2008年底开始，每台SMP机器都会使用NUMA。每个在NUMA上运行的程序都应该认识到NUMA的代价。在第5节中，我们将讨论更多的架构，以及Linux内核为这些程序提供的一些技术。除了本节中所介绍的技术之外，还有其它一些影响RAM性能的因素。它们无法被软件所左右，所以没有放在这里。如果大家有兴趣，可以在第2.1节中看一下。介绍这些技术，仅仅是因为它们能让我们绘制的RAM技术全图更为完整，或者是可能在大家购买计算机时能够提供一些帮助。以下的两节主要介绍一些入门级的硬件知识，同时讨论内存控制器与DRAM芯片间的访问协议。这些知识解释了内存访问的原理，程序员可能会得到一些启发。不过，这部分并不是必读的，心急的读者可以直接跳到第2.2.5节。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1 RAM类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　这些年来，出现了许多不同类型的RAM，各有差异，有些甚至有非常巨大的不同。那些很古老的类型已经乏人问津，我们就不仔细研究了。我们主要专注于几类现代RAM，剖开它们的表面，研究一下内核和应用开发人员们可以看到的一些细节。第一个有趣的细节是，为什么在同一台机器中有不同的RAM？或者说得更详细一点，为什么既有静态RAM(SRAM{SRAM还可以表示「同步内存」。})，又有动态RAM(DRAM)。功能相同，前者更快。那么，为什么不全部使用SRAM？答案是，代价。无论在生产还是在使用上，SRAM都比DRAM要贵得多。生产和使用，这两个代价因子都很重要，后者则是越来越重要。为了理解这一点，我们分别看一下SRAM和DRAM一个位的存储的实现过程。在本节的余下部分，我们将讨论RAM实现的底层细节。我们将尽量控制细节的层面，比如，在「逻辑的层面」讨论信号，而不是硬件设计师那种层面，因为那毫无必要。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1.1 静态RAM&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/06104431_ys3P.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/06104431_ys3P.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图2.6 6-T静态RAM&lt;/center&gt;


&lt;p&gt;　　图2.4展示了6晶体管SRAM的一个单元。核心是4个晶体管M1-M4，它们组成两个交叉耦合的反相器。它们有两个稳定的状态，分别代表0和1。只要保持Vdd有电，状态就是稳定的。当需要访问单元的状态时，升起字访问线WL。BL和BL上就可以读取状态。如果需要覆盖状态，先将BL和BL设置为期望的值，然后升起WL。由于外部的驱动强于内部的4个晶体管，所以旧状态会被覆盖。更多详情，可以参考[sramwiki]。为了下文的讨论，需要注意以下问题:一个单元需要6个晶体管。也有采用4个晶体管的SRAM，但有缺陷。维持状态需要恒定的电源。升起WL后立即可以读取状态。信号与其它晶体管控制的信号一样，是直角的(快速在两个状态间变化)。状态稳定，不需要刷新循环。SRAM也有其它形式，不那么费电，但比较慢。由于我们需要的是快速RAM，因此不在关注范围内。这些较慢的SRAM的主要优点在于接口简单，比动态RAM更容易使&lt;/p&gt;

&lt;p&gt;2.1.2 动态RAM&lt;/p&gt;

&lt;p&gt;　　动态RAM比静态RAM要简单得多。图2.5展示了一种普通DRAM的结构。它只含有一个晶体管和一个电容器。显然，这种复杂性上的巨大差异意味着功能上的迥异。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/06104431_i8Of.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/06104431_i8Of.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot; alt=&quot;每个程序员都应该了解的内存知识&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图2.5 1-T动态RAM&lt;/center&gt;


&lt;p&gt;　　动态RAM的状态是保持在电容器C中。晶体管M用来控制访问。如果要读取状态，升起访问线AL，这时，可能会有电流流到数据线DL上，也可能没有，取决于电容器是否有电。如果要写入状态，先设置DL，然后升起AL一段时间，直到电容器充电或放电完毕。动态RAM的设计有几个复杂的地方。由于读取状态时需要对电容器放电，所以这一过程不能无限重复，不得不在某个点上对它重新充电。更糟糕的是，为了容纳大量单元(现在一般在单个芯片上容纳10的9次方以上的RAM单元)，电容器的容量必须很小(0.000000000000001法拉以下)。这样，完整充电后大约持有几万个电子。即使电容器的电阻很大(若干兆欧姆)，仍然只需很短的时间就会耗光电荷，称为「泄漏」。这种泄露就是现在的大部分DRAM芯片每隔64ms就必须进行一次刷新的原因。在刷新期间，对于该芯片的访问是不可能的，这甚至会造成半数任务的延宕。（相关内容请察看【highperfdram】一章）这个问题的另一个后果就是无法直接读取芯片单元中的信息，而必须通过信号放大器将0和1两种信号间的电势差增大。最后一个问题在于电容器的冲放电是需要时间的，这就导致了信号放大器读取的信号并不是典型的矩形信号。所以当放大器输出信号的时候就需要一个小小的延宕，相关公式如下&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/06104432_i34C.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/06104432_i34C.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot; alt=&quot;每个程序员都应该了解的内存知识&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　这就意味着需要一些时间（时间长短取决于电容C和电阻R）来对电容进行冲放电。另一个负面作用是，信号放大器的输出电流不能立即就作为信号载体使用。图2.6显示了冲放电的曲线，x轴表示的是单位时间下的R*C&lt;a href=&quot;/assets/files/2013-03/06104432_ePJr.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/06104432_ePJr.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot; alt=&quot;每个程序员都应该了解的内存知识&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　与静态RAM可以即刻读取数据不同的是，当要读取动态RAM的时候，必须花一点时间来等待电容的冲放电完全。这一点点的时间最终限制了DRAM的速度。&lt;/p&gt;

&lt;p&gt;　　当然了，这种读取方式也是有好处的。最大的好处在于缩小了规模。一个动态RAM的尺寸是小于静态RAM的。这种规模的减小不单单建立在动态RAM的简单结构之上，也是由于减少了静态RAM的各个单元独立的供电部分。以上也同时导致了动态RAM模具的简单化。&lt;/p&gt;

&lt;p&gt;　　综上所述，由于不可思议的成本差异，除了一些特殊的硬件（包括路由器什么的）之外，我们的硬件大多是使用DRAM的。这一点深深的影响了咱们这些程序员，后文将会对此进行讨论。在此之前，我们还是先了解下DRAM的更多细节。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1.3 DRAM 访问&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　一个程序选择了一个内存位置使用到了一个虚拟地址。处理器转换这个到物理地址最后将内存控制选择RAM芯片匹配了那个地址。在RAM芯片去选择单个内存单元，部分的物理地址以许多地址行的形式被传递。它单独地去处理来自于内存控制器的内存位置将完全不切实际：4G的RAM将需要2&lt;sup&gt;32&lt;/sup&gt; 地址行。地址传递DRAM芯片的这种方式首先必须被路由器解析。一个路由器的N多地址行将有2&lt;sup&gt;N&lt;/sup&gt; 输出行。这些输出行能被使用到选择内存单元。使用这个直接方法对于小容量芯片不再是个大问题但如果许多的单元生成这种方法不在适合。一个1G的芯片容量（我反感那些SI前缀，对于我一个giga-bit将总是2&lt;sup&gt;30&lt;/sup&gt; 而不是10&lt;sup&gt;9&lt;/sup&gt; 字节）将需要30地址行和2&lt;sup&gt;30&lt;/sup&gt; 选项行。一个路由器的大小及许多的输入行以指数方式递增当速度不被牺牲时。一个30地址行路由器需要一大堆芯片的真实身份另外路由器也就复杂起来了。更重要的是，传递30脉冲在地址行同步要比仅仅传递15脉冲困难的多。较少列能精确布局相同长度或恰当的时机（现代DRAM类型像DDR3能自动调整时序但这个限制能让他什么都能忍受）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/06104432_tXPs.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/06104432_tXPs.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot; alt=&quot;每个程序员都应该了解的内存知识&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　图2.7展示了一个很高级别的一个DRAM芯片，DRAM被组织在行和列里。他们能在一行中对奇但DRAM芯片需要一个大的路由器。通过阵列方法设计能被一个路由器和一个半的multiplexer获得{多路复用器（multiplexer）和路由器是一样的，这的multiplexer需要以路由器身份工作当写数据时候。那么从现在开始我们开始讨论其区别.}这在所有方面会是一个大的存储。例如地址linesa~0和~a~1~通过行地址选择路由器来选择整个行的芯片的地址列，当读的时候，所有的芯片目录能使其纵列选择路由器可用，依据地址linesa~2和~a~3~一个纵列的目录用于数据DRAM芯片的接口类型。这发生了许多次在许多DRAM芯片产生一个总记录数的字节匹配给一个宽范围的数据总线。对于写操作，内存单元的数据新值被放到了数据总线，当使用RAS和CAS方式选中内存单元时，数据是存放在内存单元内的。这是一个相当直观的设计，在现实中——很显然——会复杂得多，对于读，需要规范从发出信号到数据在数据总线上变得可读的时延。电容不会像前面章节里面描述的那样立刻自动放电，从内存单元发出的信号是如此这微弱以至于它需要被放大。对于写，必须规范从数据RAS和CAS操作完成后到数据成功的被写入内存单元的时延（当然，电容不会立刻自动充电和放电）。这些时间常量对于DRAM芯片的性能是至关重要的，我们将在下章讨论它。另一个关于伸缩性的问题是，用30根地址线连接到每一个RAM芯片是行不通的。芯片的针脚是非常珍贵的资源，以至数据必须能并行传输就并行传输（比如：64位为一组）。内存控制器必须有能力解析每一个RAM模块（RAM芯片集合）。如果因为性能的原因要求并发行访问多个RAM模块并且每个RAM模块需要自己独占的30或多个地址线，那么对于8个RAM模块，仅仅是解析地址，内存控制器就需要240+之多的针脚。在很长一段时间里，地址线被复用以解决DRAM芯片的这些次要的可扩展性问题。这意味着地址被转换成两部分。第一部分由地址位a0和a1选择行（如图2.7）。这个选择保持有效直到撤销。然后是第二部分，地址位a2和a3选择列。关键差别在于：只需要两根外部地址线。需要一些很少的线指明RAS和CAS信号有效，但是把地址线的数目减半所付出的代价更小。可是地址复用也带来自身的一些问题。我们将在2.2章中提到。&lt;strong&gt;2.1.4
总结&lt;/strong&gt;如果这章节的内容有些难以应付，不用担心。纵观这章节的重点，有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为什么不是所有的存储器都是SRAM的原因&lt;/li&gt;
&lt;li&gt;存储单元需要单独选择来使用&lt;/li&gt;
&lt;li&gt;地址线数目直接负责存储控制器，主板，DRAM模块和DRAM芯片的成本&lt;/li&gt;
&lt;li&gt;在读或写操作结果之前需要占用一段时间是可行的&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　接下来的章节会涉及更多的有关访问DRAM存储器的实际操作的细节。我们不会提到更多有关访问SRAM的具体内容，它通常是直接寻址。这里是由于速度和有限的SRAM存储器的尺寸。SRAM现在应用在CPU的高速缓存和芯片，它们的连接件很小而且完全能在CPU设计师的掌控之下。我们以后会讨论到CPU高速缓存这个主题，但我们所需要知道的是SRAM存储单元是有确定的最大速度，这取决于花在SRAM上的艰难的尝试。这速度与CPU核心相比略慢一到两个数量级。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2 DRAM访问细节&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在上文介绍DRAM的时候，我们已经看到DRAM芯片为了节约资源，对地址进行了复用。而且，访问DRAM单元是需要一些时间的，因为电容器的放电并不是瞬时的。此外，我们还看到，DRAM需要不停地刷新。在这一节里，我们将把这些因素拼合起来，看看它们是如何决定DRAM的访问过程。我们将主要关注在当前的科技上，不会再去讨论异步DRAM以及它的各种变体。如果对它感兴趣，可以去参考[highperfdram]及[arstechtwo]。我们也不会讨论Rambus DRAM(RDRAM)，虽然它并不过时，但在系统内存领域应用不广。我们将主要介绍同步DRAM(SDRAM)及其后继者双倍速DRAM(DDR)。同步DRAM，顾名思义，是参照一个时间源工作的。由内存控制器提供一个时钟，时钟的频率决定了前端总线(FSB)的速度。FSB是内存控制器提供给DRAM芯片的接口。在我写作本文的时候，FSB已经达到800MHz、1066MHz，甚至1333MHz，并且下一代的1600MHz也已经宣布。但这并不表示时钟频率有这么高。实际上，目前的总线都是双倍或四倍传输的，每个周期传输2次或4次数据。报的越高，卖的越好，所以这些厂商们喜欢把四倍传输的200MHz总线宣传为“有效的”800MHz总线。以今天的SDRAM为例，每次数据传输包含64位，即8字节。所以FSB的传输速率应该是有效总线频率乘于8字节(对于4倍传输200MHz总线而言，传输速率为6.4GB/s)。听起来很高，但要知道这只是峰值速率，实际上无法达到的最高速率。我们将会看到，与RAM模块交流的协议有大量时间是处于非工作状态，不进行数据传输。我们必须对这些非工作时间有所了解，并尽量缩短它们，才能获得最佳的性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2.1 读访问协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/06104432_0ZDH.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/06104432_0ZDH.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot; alt=&quot;每个程序员都应该了解的内存知识&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图2.8: SDRAM读访问的时序&lt;/center&gt;


&lt;p&gt;　　图2.8展示了某个DRAM模块一些连接器上的活动，可分为三个阶段，图上以不同颜色表示。按惯例，时间为从左向右流逝。这里忽略了许多细节，我们只关注时钟频率、RAS与CAS信号、地址总线和数据总线。首先，内存控制器将行地址放在地址总线上，并降低RAS信号，读周期开始。所有信号都在时钟(CLK)的上升沿读取，因此，只要信号在读取的时间点上保持稳定，就算不是标准的方波也没有关系。设置行地址会促使RAM芯片锁住指定的行。CAS信号在tRCD(RAS到CAS时延)个时钟周期后发出。内存控制器将列地址放在地址总线上，降低CAS线。这里我们可以看到，地址的两个组成部分是怎么通过同一条总线传输的。至此，寻址结束，是时候传输数据了。但RAM芯片任然需要一些准备时间，这个时间称为CAS时延(CL)。在图2.8中CL为2。这个值可大可小，它取决于内存控制器、主板和DRAM模块的质量。CL还可能是半周期。假设CL为2.5，那么数据将在蓝色区域内的第一个下降沿准备就绪。既然数据的传输需要这么多的准备工作，仅仅传输一个字显然是太浪费了。因此，DRAM模块允许内存控制指定本次传输多少数据。可以是2、4或8个字。这样，就可以一次填满高速缓存的整条线，而不需要额外的RAS/CAS序列。另外，内存控制器还可以在不重置行选择的前提下发送新的CAS信号。这样，读取或写入连续的地址就可以变得非常快，因为不需要发送RAS信号，也不需要把行置为非激活状态(见下文)。是否要将行保持为“打开”状态是内存控制器判断的事情。让它一直保持打开的话，对真正的应用会有不好的影响(参见[highperfdram])。CAS信号的发送仅与RAM模块的命令速率(Command
Rate)有关(常常记为T&lt;em&gt;x，&lt;/em&gt;其中&lt;em&gt;x&lt;/em&gt;为1或2，高性能的DRAM模块一般为1，表示在每个周期都可以接收新命令)。在上图中，SDRAM的每个周期输出一个字的数据。这是第一代的SDRAM。而DDR可以在一个周期中输出两个字。这种做法可以减少传输时间，但无法降低时延。DDR2尽管看上去不同，但在本质上也是相同的做法。对于DDR2，不需要再深入介绍了，我们只需要知道DDR2更快、更便宜、更可靠、更节能(参见[ddrtwo])就足够了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2.2 预充电与激活&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　图2.8并不完整，它只画出了访问DRAM的完整循环的一部分。在发送RAS信号之前，必须先把当前锁住的行置为非激活状态，并对新行进行预充电。在这里，我们主要讨论由于显式发送指令而触发以上行为的情况。协议本身作了一些改进，在某些情况下是可以省略这个步骤的，但预充电带来的时延还是会影响整个操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-03/06104433_y5nt.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot; alt=&quot;每个程序员都应该了解的内存知识&quot; /&gt;&lt;/p&gt;

&lt;center&gt;图2.9: SDRAM的预充电与激活&lt;/center&gt;


&lt;p&gt;　　图2.9显示的是两次CAS信号的时序图。第一次的数据在CL周期后准备就绪。图中的例子里，是在SDRAM上，用两个周期传输了两个字的数据。如果换成DDR的话，则可以传输4个字。即使是在一个命令速率为1的DRAM模块上，也无法立即发出预充电命令，而要等数据传输完成。在上图中，即为两个周期。刚好与CL相同，但只是巧合而已。预充电信号并没有专用线，某些实现是用同时降低写使能(WE)线和RAS线的方式来触发。这一组合方式本身没有特殊的意义(参见[micronddr])。发出预充电信命令后，还需等待t~RP~(行预充电时间)个周期之后才能使行被选中。在图2.9中，这个时间(紫色部分)大部分与内存传输的时间(淡蓝色部分)重合。不错。但t~RP~大于传输时间，因此下一个RAS信号只能等待一个周期。&lt;/p&gt;

&lt;p&gt;　　如果我们补充完整上图中的时间线，最后会发现下一次数据传输发生在前一次的5个周期之后。这意味着，数据总线的7个周期中只有2个周期才是真正在用的。再用它乘于FSB速度，结果就是，800MHz总线的理论速率6.4GB/s降到了1.8GB/s。真是太糟了。第6节将介绍一些技术，可以帮助我们提高总线有效速率。程序员们也需要尽自己的努力。SDRAM还有一些定时值，我们并没有谈到。在图2.9中，预充电命令仅受制于数据传输时间。除此之外，SDRAM模块在RAS信号之后，需要经过一段时间，才能进行预充电(记为t~RAS~)。它的值很大，一般达到t~RP~的2到3倍。如果在某个RAS信号之后，只有一个CAS信号，而且数据只传输很少几个周期，那么就有问题了。假设在图2.9中，第一个CAS信号是直接跟在一个RAS信号后免的，而t~RAS~为8个周期。那么预充电命令还需要被推迟一个周期，因为t~RCD~、CL和t~RP~加起来才7个周期。&lt;/p&gt;

&lt;p&gt;　　DDR模块往往用w-z-y-z-T来表示。例如，2-3-2-8-T1，意思是：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt; w 2 CAS时延(CL)&lt;br/&gt;
 x 3 RAS-to-CAS时延(t ~RCD~)&lt;br/&gt;
 y 2 RAS预充电时间(t ~RP~)&lt;br/&gt;
 z 8 激活到预充电时间(t ~RAS~)&lt;br/&gt;
 T T1 命令速率&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　当然，除以上的参数外，还有许多其它参数影响命令的发送与处理。但以上5个参数已经足以确定模块的性能。在解读计算机性能参数时，这些信息可能会派上用场。而在购买计算机时，这些信息就更有用了，因为它们与FSB/SDRAM速度一起，都是决定计算机速度的关键因素。喜欢冒险的读者们还可以利用它们来调优系统。有些计算机的BIOS可以让你修改这些参数。SDRAM模块有一些可编程寄存器，可供设置参数。BIOS一般会挑选最佳值。如果RAM模块的质量足够好，我们可以在保持系统稳定的前提下将减小以上某个时延参数。互联网上有大量超频网站提供了相关的文档。不过，这是有风险的，需要大家自己承担，可别怪我没有事先提醒哟。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2.3 重充电&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　谈到DRAM的访问时，重充电是常常被忽略的一个主题。在2.1.2中曾经介绍，DRAM必须保持刷新。……行在充电时是无法访问的。[highperfdram]的研究发现，“令人吃惊，DRAM刷新对性能有着巨大的影响”。根据JEDEC规范，DRAM单元必须保持每64ms刷新一次。对于8192行的DRAM，这意味着内存控制器平均每7.8125µs就需要发出一个刷新命令(在实际情况下，由于刷新命令可以纳入队列，因此这个时间间隔可以更大一些)。刷新命令的调度由内存控制器负责。DRAM模块会记录上一次刷新行的地址，然后在下次刷新请求时自动对这个地址进行递增。对于刷新及发出刷新命令的时间点，程序员无法施加影响。但我们在解读性能参数时有必要知道，它也是DRAM生命周期的一个部分。如果系统需要读取某个重要的字，而刚好它所在的行正在刷新，那么处理器将会被延迟很长一段时间。刷新的具体耗时取决于DRAM模块本身。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2.4 内存类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　我们有必要花一些时间来了解一下目前流行的内存，以及那些即将流行的内存。首先从SDR(单倍速)SDRAM开始，因为它们是DDR(双倍速)SDRAM的基础。SDR非常简单，内存单元和数据传输率是相等的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/06104433_JWAj.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/06104433_JWAj.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot; alt=&quot;每个程序员都应该了解的内存知识&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图2.10: SDR SDRAM的操作&lt;/center&gt;


&lt;p&gt;　　在图2.10中，DRAM单元阵列能以等同于内存总线的速率输出内容。假设DRAM单元阵列工作在100MHz上，那么总线的数据传输率可以达到100Mb/s。所有组件的频率&lt;em&gt;f&lt;/em&gt;保持相同。由于提高频率会导致耗电量增加，所以提高吞吐量需要付出很高的的代价。如果是很大规模的内存阵列，代价会非常巨大。{&lt;em&gt;功率 = 动态电容 x 电压&lt;sup&gt;2 x&lt;/sup&gt; 频率&lt;/em&gt;}。而且，提高频率还需要在保持系统稳定的情况下提高电压，这更是一个问题。因此，就有了DDR SDRAM(现在叫DDR1)，它可以在不提高频率的前提下提高吞吐量。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/06104433_A6Jf.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/06104433_A6Jf.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图2.11 DDR1 SDRAM的操作&lt;/center&gt;


&lt;p&gt;　　我们从图2.11上可以看出DDR1与SDR的不同之处，也可以从DDR1的名字里猜到那么几分，DDR1的每个周期可以传输两倍的数据，它的上升沿和下降沿都传输数据。有时又被称为“双泵(double-pumped)”总线。为了在不提升频率的前提下实现双倍传输，DDR引入了一个缓冲区。缓冲区的每条数据线都持有两位。它要求内存单元阵列的数据总线包含两条线。实现的方式很简单，用同一个列地址同时访问两个DRAM单元。对单元阵列的修改也很小。SDR DRAM是以频率来命名的(例如，对应于100MHz的称为PC100)。为了让DDR1听上去更好听，营销人员们不得不想了一种新的命名方案。这种新方案中含有DDR模块可支持的传输速率(DDR拥有64位总线):&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;100MHz x 64位 x 2 = 1600MB/s&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　于是，100MHz频率的DDR模块就被称为PC1600。由于1600 &gt;
100，营销方面的需求得到了满足，听起来非常棒，但实际上仅仅只是提升了两倍而已。{我接受两倍这个事实，但不喜欢类似的数字膨胀戏法。}&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-03/06104433_pulx.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot; alt=&quot;每个程序员都应该了解的内存知识&quot; /&gt;&lt;/p&gt;

&lt;center&gt;图2.12: DDR2 SDRAM的操作&lt;/center&gt;


&lt;p&gt;　　为了更进一步，DDR2有了更多的创新。在图2.12中，最明显的变化是，总线的频率加倍了。频率的加倍意味着带宽的加倍。如果对单元阵列的频率加倍，显然是不经济的，因此DDR2要求I/O缓冲区在每个时钟周期读取4位。也就是说，DDR2的变化仅在于使I/O缓冲区运行在更高的速度上。这是可行的，而且耗电也不会显著增加。DDR2的命名与DDR1相仿，只是将因子2替换成4(四泵总线)。图2.13显示了目前常用的一些模块的名称。&lt;/p&gt;

&lt;table style=&quot;width: 640px;&quot; border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;阵列频率&lt;/th&gt;
&lt;th&gt;总线频率&lt;/th&gt;
&lt;th&gt;数据率&lt;/th&gt;
&lt;th&gt;名称(速率)&lt;/th&gt;
&lt;th&gt;名称&lt;br&gt;
(FSB)&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;133MHz&lt;/td&gt;
&lt;td&gt;266MHz&lt;/td&gt;
&lt;td&gt;4,256MB/s&lt;/td&gt;
&lt;td&gt;PC2-4200&lt;/td&gt;
&lt;td&gt;DDR2-533&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;166MHz&lt;/td&gt;
&lt;td&gt;333MHz&lt;/td&gt;
&lt;td&gt;5,312MB/s&lt;/td&gt;
&lt;td&gt;PC2-5300&lt;/td&gt;
&lt;td&gt;DDR2-667&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;200MHz&lt;/td&gt;
&lt;td&gt;400MHz&lt;/td&gt;
&lt;td&gt;6,400MB/s&lt;/td&gt;
&lt;td&gt;PC2-6400&lt;/td&gt;
&lt;td&gt;DDR2-800&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;250MHz&lt;/td&gt;
&lt;td&gt;500MHz&lt;/td&gt;
&lt;td&gt;8,000MB/s&lt;/td&gt;
&lt;td&gt;PC2-8000&lt;/td&gt;
&lt;td&gt;DDR2-1000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;266MHz&lt;/td&gt;
&lt;td&gt;533MHz&lt;/td&gt;
&lt;td&gt;8,512MB/s&lt;/td&gt;
&lt;td&gt;PC2-8500&lt;/td&gt;
&lt;td&gt;DDR2-1066&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;&lt;strong&gt;图2.13: DDR2模块名&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在命名方面还有一个拧巴的地方。FSB速度是用有效频率来标记的，即把上升、下降沿均传输数据的因素考虑进去，因此数字被撑大了。所以，拥有266MHz总线的133MHz模块有着533MHz的FSB“频率”。DDR3要求更多的改变(这里指真正的DDR3，而不是图形卡中假冒的GDDR3)。电压从1.8V下降到1.5V。由于耗电是与电压的平方成正比，因此可以节约30%的电力。加上管芯(die)的缩小和电气方面的其它进展，DDR3可以在保持相同频率的情况下，降低一半的电力消耗。或者，在保持相同耗电的情况下，达到更高的频率。又或者，在保持相同热量排放的情况下，实现容量的翻番。DDR3模块的单元阵列将运行在内部总线的四分之一速度上，DDR3的I/O缓冲区从DDR2的4位提升到8位。见图2.14。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-03/06104433_dVKN.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot;&gt;&lt;img src=&quot;/assets/files/2013-03/06104433_dVKN.png&quot; title=&quot;每个程序员都应该了解的内存知识&quot; alt=&quot;每个程序员都应该了解的内存知识&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;图2.14: DDR3 SDRAM的操作&lt;/center&gt;


&lt;p&gt;　　一开始，DDR3可能会有较高的CAS时延，因为DDR2的技术相比之下更为成熟。由于这个原因，DDR3可能只会用于DDR2无法达到的高频率下，而且带宽比时延更重要的场景。此前，已经有讨论指出，1.3V的DDR3可以达到与DDR2相同的CAS时延。无论如何，更高速度带来的价值都会超过时延增加带来的影响。DDR3可能会有一个问题，即在1600Mb/s或更高速率下，每个通道的模块数可能会限制为1。在早期版本中，这一要求是针对所有频率的。我们希望这个要求可以提高一些，否则系统容量将会受到严重的限制。图2.15显示了我们预计中各DDR3模块的名称。JEDEC目前同意了前四种。由于Intel的45nm处理器是1600Mb/s的FSB，1866Mb/s可以用于超频市场。随着DDR3的发展，可能会有更多类型加入。&lt;/p&gt;

&lt;table style=&quot;width: 640px;&quot; border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;阵列频率&lt;/th&gt;
&lt;th&gt;总线频率&lt;/th&gt;
&lt;th&gt;数据速率&lt;/th&gt;
&lt;th&gt;名称(速率)&lt;/th&gt;
&lt;th&gt;名称&lt;br&gt;
(FSB)&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;100MHz&lt;/td&gt;
&lt;td&gt;400MHz&lt;/td&gt;
&lt;td&gt;6,400MB/s&lt;/td&gt;
&lt;td&gt;PC3-6400&lt;/td&gt;
&lt;td&gt;DDR3-800&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;133MHz&lt;/td&gt;
&lt;td&gt;533MHz&lt;/td&gt;
&lt;td&gt;8,512MB/s&lt;/td&gt;
&lt;td&gt;PC3-8500&lt;/td&gt;
&lt;td&gt;DDR3-1066&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;166MHz&lt;/td&gt;
&lt;td&gt;667MHz&lt;/td&gt;
&lt;td&gt;10,667MB/s&lt;/td&gt;
&lt;td&gt;PC3-10667&lt;/td&gt;
&lt;td&gt;DDR3-1333&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;200MHz&lt;/td&gt;
&lt;td&gt;800MHz&lt;/td&gt;
&lt;td&gt;12,800MB/s&lt;/td&gt;
&lt;td&gt;PC3-12800&lt;/td&gt;
&lt;td&gt;DDR3-1600&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;233MHz&lt;/td&gt;
&lt;td&gt;933MHz&lt;/td&gt;
&lt;td&gt;14,933MB/s&lt;/td&gt;
&lt;td&gt;PC3-14900&lt;/td&gt;
&lt;td&gt;DDR3-1866&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;&lt;strong&gt;图2.15: DDR3模块名&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　所有的DDR内存都有一个问题：不断增加的频率使得建立并行数据总线变得十分困难。一个DDR2模块有240根引脚。所有到地址和数据引脚的连线必须被布置得差不多一样长。更大的问题是，如果多于一个DDR模块通过菊花链连接在同一个总线上，每个模块所接收到的信号随着模块的增加会变得越来越扭曲。DDR2规范允许每条总线（又称通道）连接最多两个模块，DDR3在高频率下只允许每个通道连接一个模块。每条总线多达240根引脚使得单个北桥无法以合理的方式驱动两个通道。替代方案是增加外部内存控制器（如图2.2），但这会提高成本。这意味着商品主板所搭载的DDR2或DDR3模块数将被限制在最多四条，这严重限制了系统的最大内存容量。即使是老旧的32位IA-32处理器也可以使用64GB内存。即使是家庭对内存的需求也在不断增长，所以，某些事必须开始做了。一种解法是，在处理器中加入内存控制器，我们在第2节中曾经介绍过。AMD的Opteron系列和Intel的CSI技术就是采用这种方法。只要我们能把处理器要求的内存连接到处理器上，这种解法就是有效的。如果不能，按照这种思路就会引入NUMA架构，当然同时也会引入它的缺点。而在有些情况下，我们需要其它解法。Intel针对大型服务器方面的解法(至少在未来几年)，是被称为全缓冲DRAM(FB-DRAM)的技术。FB-DRAM采用与DDR2相同的器件，因此造价低廉。不同之处在于它们与内存控制器的连接方式。FB-DRAM没有用并行总线，而用了串行总线(Rambus
DRAM had this back when, too, 而SATA是PATA的继任者，就像PCI
Express是PCI/AGP的继承人一样)。串行总线可以达到更高的频率，串行化的负面影响，甚至可以增加带宽。使用串行总线后&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;每个通道可以使用更多的模块。&lt;/li&gt;
&lt;li&gt;每个北桥/内存控制器可以使用更多的通道。&lt;/li&gt;
&lt;li&gt;串行总线是全双工的(两条线)。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;　　FB-DRAM只有69个脚。通过菊花链方式连接多个FB-DRAM也很简单。FB-DRAM规范允许每个通道连接最多8个模块。在对比下双通道北桥的连接性，采用FB-DRAM后，北桥可以驱动6个通道，而且脚数更少——6×69对比2×240。每个通道的布线也更为简单，有助于降低主板的成本。全双工的并行总线过于昂贵。而换成串行线后，这不再是一个问题，因此串行总线按全双工来设计的，这也意味着，在某些情况下，仅靠这一特性，总线的理论带宽已经翻了一倍。还不止于此。由于FB-DRAM控制器可同时连接6个通道，因此可以利用它来增加某些小内存系统的带宽。对于一个双通道、4模块的DDR2系统，我们可以用一个普通FB-DRAM控制器，用4通道来实现相同的容量。串行总线的实际带宽取决于在FB-DRAM模块中所使用的DDR2(或DDR3)芯片的类型。我们可以像这样总结这些优势：&lt;/p&gt;

&lt;table style=&quot;width: 600px;&quot; border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;DDR2&lt;/th&gt;
&lt;th&gt;FB-DRAM&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;脚&lt;/td&gt;
&lt;td&gt;240&lt;/td&gt;
&lt;td&gt;69&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;通道&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每通道DIMM数&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;最大内存&lt;/td&gt;
&lt;td&gt;16GB&lt;/td&gt;
&lt;td&gt;192GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;吞吐量&lt;/td&gt;
&lt;td&gt;~10GB/s&lt;/td&gt;
&lt;td&gt;~40GB/s&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;　　如果在单个通道上使用多个DIMM，会有一些问题。信号在每个DIMM上都会有延迟(尽管很小)，也就是说，延迟是递增的。不过，如果在相同频率和相同容量上进行比较，FB-DRAM总是能快过DDR2及DDR3，因为FB-DRAM只需要在每个通道上使用一个DIMM即可。而如果说到大型内存系统，那么DDR更是没有商用组件的解决方案。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2.5 结论&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　通过本节，大家应该了解到访问DRAM的过程并不是一个快速的过程。至少与处理器的速度相比，或与处理器访问寄存器及缓存的速度相比，DRAM的访问不算快。大家还需要记住CPU和内存的频率是不同的。Intel Core 2处理器运行在2.933GHz，而1.066GHz FSB有11:1的时钟比率(注:1.066GHz的总线为四泵总线)。那么，内存总线上延迟一个周期意味着处理器延迟11个周期。绝大多数机器使用的DRAM更慢，因此延迟更大。在后续的章节中，我们需要讨论延迟这个问题时，请把以上的数字记在心里。前文中读命令的时序图表明，DRAM模块可以支持高速数据传输。每个完整行可以被毫无延迟地传输。数据总线可以100%被占。对DDR而言，意味着每个周期传输2个64位字。对于DDR2-800模块和双通道而言，意味着12.8GB/s的速率。但是，除非是特殊设计，DRAM的访问并不总是串行的。访问不连续的内存区意味着需要预充电和RAS信号。于是，各种速度开始慢下来，DRAM模块急需帮助。预充电的时间越短，数据传输所受的惩罚越小。硬件和软件的预取(参见第6.3节)可以在时序中制造更多的重叠区，降低延迟。预取还可以转移内存操作的时间，从而减少争用。我们常常遇到的问题是，在这一轮中生成的数据需要被存储，而下一轮的数据需要被读出来。通过转移读取的时间，读和写就不需要同时发出了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3 主存的其它用户&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　除了CPU外，系统中还有其它一些组件也可以访问主存。高性能网卡或大规模存储控制器是无法承受通过CPU来传输数据的，它们一般直接对内存进行读写(直接内存访问，DMA)。在图2.1中可以看到，它们可以通过南桥和北桥直接访问内存。另外，其它总线，比如USB等也需要FSB带宽，即使它们并不使用DMA，但南桥仍要通过FSB连接到北桥。DMA当然有很大的优点，但也意味着FSB带宽会有更多的竞争。在有大量DMA流量的情况下，CPU在访问内存时必然会有更大的延迟。我们可以用一些硬件来解决这个问题。例如，通过图2.3中的架构，我们可以挑选不受DMA影响的节点，让它们的内存为我们的计算服务。还可以在每个节点上连接一个南桥，将FSB的负荷均匀地分担到每个节点上。除此以外，还有许多其它方法。我们将在第6节中介绍一些技术和编程接口，它们能够帮助我们通过软件的方式改善这个问题。最后，还需要提一下某些廉价系统，它们的图形系统没有专用的显存，而是采用主存的一部分作为显存。由于对显存的访问非常频繁(例如，对于1024×768、16bpp、60Hz的显示设置来说，需要95MB/s的数据速率)，而主存并不像显卡上的显存，并没有两个端口，因此这种配置会对系统性能、尤其是时延造成一定的影响。如果大家对系统性能要求比较高，最好不要采用这种配置。这种系统带来的问题超过了本身的价值。人们在购买它们时已经做好了性能不佳的心理准备。继续阅读：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://lwn.net/Articles/252125/&quot;&gt;第2节&lt;/a&gt;: CPU的高速缓存&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lwn.net/Articles/253361/&quot;&gt;第3节&lt;/a&gt;: 虚拟内存&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lwn.net/Articles/254445/&quot;&gt;第4节&lt;/a&gt;: NUMA系统&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lwn.net/Articles/255364/&quot;&gt;第5节&lt;/a&gt;: 程序员可以做什么 –
高速缓存的优化&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lwn.net/Articles/256433/&quot;&gt;第6节&lt;/a&gt;: 程序员可以做什么 -
多线程的优化&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lwn.net/Articles/257209/&quot;&gt;第7节&lt;/a&gt;: 内存性能工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lwn.net/Articles/258154/&quot;&gt;第8节&lt;/a&gt;: 未来的技术&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lwn.net/Articles/258188/&quot;&gt;第9节&lt;/a&gt;: 附录与参考书目&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; &lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>如何成为强大的程序员？</title>
   <link href="http://beango.github.com/archives/2013/02/28/howto-strong-developer.html"/>
   <updated>2013-02-28T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/02/28/howto-strong-developer</id>
   <content type="html">&lt;p&gt;　　&lt;a href=&quot;http://www.aaronstannard.com/&quot;&gt;Aaron Stannard&lt;/a&gt; 是新创公司&lt;a href=&quot;https://markedup.com/&quot;&gt;MarkedUp&lt;/a&gt;的CEO，他最近花费大量时间雇佣、评估很多不同的程序员，并和他们一起协作。在这个过程中他发现并总结了&lt;a href=&quot;http://www.aaronstannard.com/post/2013/02/06/10-Reasons-Why-Youe28099re-Failing-to-Realize-Your-Potential-as-a-Developer.aspx&quot;&gt;十种程序员无法意识到自己潜力的原因&lt;/a&gt;，意在让更多程序员发掘出自己的潜力，从而成为强大的程序员。&lt;/p&gt;

&lt;p&gt;　　Aaron提到，他的公司中所使用的技术非常复杂，某些大型企业都很难掌握，所以对于想要加入团队的程序员来说，入门门槛非常高。因此，尽管他们非常仔细地雇佣新人，但还是很难找到足够天才的程序员。于是，他总结出十种阻碍程序员职业生涯发展的行为，并据此来帮助想要提升自身的平凡的程序员们。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;1. 太害怕学不会新的工具、语言和框架&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　一般的程序员会墨守他们最喜欢的工具，而不希望学习新的，因为他们认为，离开了那些语言和工具，多年的经验就会付诸东流。而强大的程序员会拥抱那些挑战和机会，积极地学习新的工作方式。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;2. 直到特性“完成”的时候才会提交。（但永远都不会完成！）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　他在 MarkedUp 公司中把这种行为叫做“囤积提交（commit hoarding）”。有些程序员没有足够的信心来承受团队中其他成员的批评和审查，因此会把自己的工作藏起来，直到“完成”状态才提交。&lt;/p&gt;

&lt;p&gt;　　这种开发者会损害团队中其他人员的生产力，因为团队看不到他每天的成果，而且他也不会在正常开发的过程中寻求帮助，这样就会造成很多“最后一分钟”的缺陷，从而让交付延迟。而强大的程序员会知道，代码并不是他们自己，因此会把代码经常自信地呈现在其他团队成员的眼前，获得批评和建议。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;3. 只是“知其然”会很危险&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在这里 Aaron 举了微软最近在 &lt;a href=&quot;http://www.asp.net/vnext/overview/aspnet/async-and-await&quot;&gt;C#5.0中引入的async和await关键字&lt;/a&gt;为例，这两个关键字会让创建和管理异步调用变得很容易，但是也会造成上下文切换、对共享资源进行多线程访问的成本，仅仅对此有基本了解的程序员会盲目地使用这些特性，把所有I/O调用都封装成&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.threading.tasks.task.aspx&quot;&gt;C#中的Task对象&lt;/a&gt;，这会创建出危险的、不可预测的而且非常难以测试的代码。&lt;/p&gt;

&lt;p&gt;　　好的开发者不仅“知其然”，而且会了解为什么这么做以及应该在什么样的条件下使用。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;4. 分析瘫痪（Analysis paralysis）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　分析瘫痪是指在程序开发初期进行系统分析，常因为太过执着于控制所有可能的变化和意外，而造成大量时间的浪费，裹足不前。这是一种很经典的问题，会影响很多一般的程序员。它通常是由过度分析造成的，但是Aaron认为其根本原因在于不敢做出坏的决定。一般的程序员会担心犯错，只想一次成功。&lt;/p&gt;

&lt;p&gt;　　而强大的程序员不会害怕，他们会编写很烂的代码，对其进行单元测试，如果认为无法达到目的，就会在45分钟之内把它抛弃。强大的程序员会积极地限制用来研究的时间，因为他们知道那是个陷阱——看起来是有效的，但经常都无效。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;5. 没有对工具和开发过程投入&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　如果你想要成为天才程序员，那么就需要投入时间提升技能和知识，而将你和普通的代码工人区分开来的是快速编写出生产级别代码的能力。你可以同时拥有好的代码和速度，但是你需要先对你用于构建的过程投入。&lt;/p&gt;

&lt;p&gt;　　一般的程序员不会对工具、过程和环境投入，只会使用大量的时间学习新的语言特性和API 如何工作，但那并不会改变什么。&lt;/p&gt;

&lt;p&gt;　　通常，你作为程序员所能够做出的最大改进并不是专注于你所编写的代码，而是优化你编写代码的过程。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;6. 羞于请求帮助&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　一般的程序员羞于或者不想让人知道自己不懂，所以他们装作什么都知道，但这样就有可能提交某种非常可怕的代码到库中。说“我不知道怎么做。”没什么错，强大的程序员知道这一点，所以当被问题难住的时候就会请求帮助。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;7. 不知道如何让其他程序员更容易使用你的代码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在所有技术团队中，工作很重要的一部分就是人员的并行（human parallelism），也就是多个人能够同时对同一代码库工作的能力。但是对于团队来说，能够异步工作也很重要，当你不在的时候我可以修改你的代码，反之亦然。&lt;/p&gt;

&lt;p&gt;　　一般的开发者并不这么认为，他们会开始对一项任务编写代码，认为他们会永远拥有这段代码。而强大的开发者会知道&lt;a href=&quot;http://en.wikipedia.org/wiki/Technical_debt&quot;&gt;技术债务&lt;/a&gt;的说法，从而试图通过设计代码来对其限制，让它尽可能可维护和自解释。&lt;/p&gt;

&lt;p&gt;　　编写可读的代码需要程序员改变他们的看法——你的代码要比你在组织中存在的时间长。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;8. 不知道如何阅读其他人的代码（或者不想读）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　当一位一般程序员看到用他所不熟悉的语言或框架编写的代码库时，就想立刻重写，而不考虑业务价值或者推向市场的时间。而强大的程序员会接受这样的观点，重写所导致的业务成本通常是不可接受的，所以应该避免这种行为。他们会试图坐在计算机前，理解、学习然后修改现有的代码。&lt;/p&gt;

&lt;p&gt;　　阅读代码要比编写代码还难，但是强大的程序员会投入时间来学习如何超越。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;9. 不能从最终用户的角度编码（你考虑的范围太狭窄）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　有句话说得好：作为程序员，你的工作不是解决技术问题，你之所以解决技术问题，是为了解决业务问题。&lt;/p&gt;

&lt;p&gt;　　一般的程序员只会陷在技术问题之中，而不知道最初是为什么要解决这个问题。更严重的是，一般程序员无法从头开始创建出具有业务价值的东西。当被要求基于简单的用户设计新特性的时候，他们会死板地、照着字面对故事或者说明书做出解释，这样交付的产品用户根本无法使用。因为他们不会考虑相关的用例；不会考虑最终用户的体验；并且在做面向用户的内容时，设计都会很笨重。这导致他们无法编写业务应用，只能做产品。&lt;/p&gt;

&lt;p&gt;　　好的程序员会从最终用户的角度来看他们的代码。我怎样才能让它更轻松地解决用户的问题呢？故事的文字内容之外有哪些方面会让这个特性给用户带来更多收益呢？&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;10. 无法判断任何编程任务的业务价值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　这个问题和上一个是相关的，很多技术上很强的程序员之所以无法意识到自己的潜力，是因为他们不会停下来，从业务或者组织本身的角度去看一下他们的工作。&lt;/p&gt;

&lt;p&gt;　　强大的程序员能够自我管理，对选择如何投入时间做出很好的业务决定，他们会问这样的问题：这是我现在应该做的最有价值的事情吗？我应该为之投入多少时间？离交付日期有两个星期，我现在能做什么，从而更容易满足那个日期呢？&lt;/p&gt;

&lt;p&gt;　　一般的程序员不会，他们只会拿着说明书，然后盲目地实现，直到结束，不关心他们的工作和公司的业务目标有什么关系，以及对其他团队和业务组会产生什么样的影响。这样，他们就会在业务价值很低的技术任务上浪费大量开发时间。&lt;/p&gt;

&lt;p&gt;　　Aaron在最后做出总结：如果你想要成为更好的程序员，那么就要从改变你看待代码以及编码的方式开始。你需要理解所编写的每行代码背后的业务成本；你需要从客户或者最终用户的角度来看待工作；你需要接受代码会比你在组织中存在的时间更长，所以要以其他开发者能够继承的方式来设计；最重要的，永远都不要害怕新的挑战，也不要害怕请求帮助，你无法独居一隅来提升工作效果，软件开发也是社会化的工作。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>NoSQL的现状</title>
   <link href="http://beango.github.com/archives/2013/02/27/state-of-nosql.html"/>
   <updated>2013-02-27T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/02/27/state-of-nosql</id>
   <content type="html">&lt;p&gt;译文来源：&lt;a href=&quot;http://www.infoq.com/cn/articles/State-of-NoSQL&quot;&gt;InfoQ 张卫滨&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;经过了至少4年的激烈争论，现在是对&lt;a href=&quot;http://blog.jobbole.com/1344/&quot; title=&quot;8种Nosql数据库系统对比&quot;&gt;NoSQL&lt;/a&gt;的现状做一个阶段性结论的时候了。围绕着NoSQL发生了如此之多的事情，以至于很难对其作出一个简单概括，也很难判断它达到了什么目标以及在什么方面没有达到预期。&lt;/p&gt;

&lt;p&gt;在很多领域，NoSQL不仅在行业内也在学术领域中取得了成功。大学开始认识到NoSQL必须要加入到课程中。只是反复讲解标准数据库已经不够了。当然，这不意味着深入学习关系型数据库是错误的。相反，NoSQL是很好的很重要的补充。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;发生了什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;NoSQL领域在短短的4到5年的时间里，爆炸性地产生了50到150个新的数据库。&lt;a href=&quot;http://nosql-database.org/&quot;&gt;nosql-database.org&lt;/a&gt;列出了150个这样的数据库，包括一些像对象数据库这样很古老但很强大的。当然，一些有意思的合并正在发生，如CouchDB和Membase交易产生的CouchBase。但是我们稍后会在本文中讨论每一个主要的系统。&lt;/p&gt;

&lt;p&gt;很多人都曾经假设在NoSQL领域会有一个巨大地整合。但是这并没有发生。NoSQL过去是爆炸性地增长，现在依旧如此。就像计算机科学中的所有领域一样——如&lt;a href=&quot;http://blog.jobbole.com/tag/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/&quot; title=&quot;如何选择语言和编程语言排名相关文章&quot;&gt;编程语言&lt;/a&gt;——现在有越来越多的空白领域需要大量的数据库。这是与互联网、大数据、传感器以及将来很多技术的爆炸性增长同步的，这导致了更多的数据以及对它们进行处理的不同需求。在过去的四年中，我们只看到了一个重要的系统离开了舞台：德国的Graph数据库Sones。为数众多的NoSQL依然快乐地生存着，要么在开源社区，不用考虑任何的金钱回报，要么在商业领域。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;可见性与金钱？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外一个重要的方面就是可见性与行业采用的情况。在这个方面，我们可以看到在传统的行业中——要保护投资——与新兴的行业（主要是初创公司）之间有很大的差别。几乎所有热门的基于Web的创业公司如Pinterest和Instagram都在使用混合式（SQL + NoSQL）的架构，而传统的行业依然纠结于是否采用NoSQL。但是观察显示，越来越多这样的公司正在试图将它们的一部分数据流用NoSQL方案进行处理并在以后进行分析，这样的方案包括Hadoop、MongoDB以及Cassandra等。&lt;/p&gt;

&lt;p&gt;这同时导致了对具备NoSQL知识的架构师和开发人员的需求持续增长。&lt;a href=&quot;http://servicesangle.com/blog/2011/12/29/top-10-developer-and-engineering-skills-employers-will-look-for-going-into-2012/&quot;&gt;最近的调查&lt;/a&gt;显示行业中最需要的开发人员技能如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;HTML5&lt;/li&gt;
&lt;li&gt;MongoDB&lt;/li&gt;
&lt;li&gt;iOS&lt;/li&gt;
&lt;li&gt;Android&lt;/li&gt;
&lt;li&gt;Mobile Apps&lt;/li&gt;
&lt;li&gt;Puppet&lt;/li&gt;
&lt;li&gt;Hadoop&lt;/li&gt;
&lt;li&gt;jQuery&lt;/li&gt;
&lt;li&gt;PaaS&lt;/li&gt;
&lt;li&gt;Social Media&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;在前十名的技术需求中，有两个&lt;a href=&quot;http://blog.jobbole.com/1344/&quot; title=&quot;8种Nosql数据库系统对比&quot;&gt;nosql数据库&lt;/a&gt;。有一个甚至排在了iOS前面。如果这不是对它的赞扬，那是什么呢？！&lt;/p&gt;

&lt;p&gt;但是，跟最初预计相比，对NoSQL的采用变得越来越快，越来越深入。在2011年夏天，Oracle曾经发布过一个著名白皮书，它提到NoSQL数据库感觉就像是冰淇淋的风味，但是你不应该过于依附它，因为它不会持续太长时间。但是仅仅在几个月之后，Oracle就展现了它们将Hadoop集成到大数据设备的方案。甚至，他们建立了自己的NoSQL数据库，那是对BerkeleyDB的修改。从此之后，所有的厂商在集成Hadoop方面展开了竞赛。Microsoft、Sybase、IBM、Greenplum、Pervasive以及很多的公司都已经对它有了紧密的集成。有一个模式随处可见：不能击败它，就拥抱它。&lt;/p&gt;

&lt;p&gt;但是，关于NoSQL被广泛采用的另一个很重要但不被大家关注的重要信号就是NoSQL成为了一个PaaS标准。借助于众多NoSQL数据库的易安装和管理，像Redis和MongoDB这样的数据库可以在很多的PaaS服务中看到，如Cloud Foundry、OPENSHIFT、dotCloud、Jelastic等。随着所有的事情都在往云上迁移，NoSQL会对传统的关系型数据库产生很大的压力。例如当面临选择MySQL/PostGres或MongoDB/Redis时，将会强制人们再三考虑他们的模型、需求以及随之而来的其他重要问题。&lt;/p&gt;

&lt;p&gt;另外一个很有意思的技术指示器就是ThoughtWorks的技术雷达，即便你可能不完全同意它所包含的所有事情，但它总会包含一些有意思的事情。让我们看一下他们2012年10月份的技术雷达，如图1：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-02/5fig1.jpg&quot; title=&quot;NoSQL的现状&quot;&gt;&lt;img src=&quot;/assets/files/2013-02/5fig1.jpg&quot; title=&quot;NoSQL的现状&quot; alt=&quot;NoSQL的现状&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图1：ThoughtWorks技术雷达，2012年10月——平台&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在他们的平台象限中，列出了5个数据库：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Neo4j （采用）&lt;/li&gt;
&lt;li&gt;MongoDB（试用阶段但是采用）&lt;/li&gt;
&lt;li&gt;Riak（试用）&lt;/li&gt;
&lt;li&gt;CouchBase（试用）&lt;/li&gt;
&lt;li&gt;Datomic（评估）&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;你会发现它们中至少有四个获得了很多的风险投资。如果你将NoSQL领域的所有风险投资加起来，结果肯定是在一亿和十亿美元之间！Neo4j就是一个例子，它在一系列的B类资助中得到了一千一百万美元。其他得到一千万到三千万之间资助的公司是Aerospike、Cloudera、DataStax、MongoDB以及CouchBase等。但是，让我们再看一下这个列表：Neo4j、MongoDB、Riak以及CouchBase已经在这个领域超过四年了并且在不断地证明它们是特定需求的市场领导者。第五名的数据库——Datomic——是一个令人惊讶的全新数据库，它是由一个小团队按照全新的范式编写的。这一定是很热门的东西，在后面简要讨论所有数据库的时候，我们更更深入地了解它们。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;标准&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;已经有很多人要求NoSQL标准了，但他们没有看到NoSQL涵盖了一个范围如此之大的模型和需求。所以，适用于所有主要领域的统一语言如Wide Column、Key/Value、Document和Graph数据库肯定不会持续很长时间，因为它不可能涵盖所有的领域。有一些方式，如Spring Data，试图建立一个统一层，但这取决于读者来测试这一层在构建多持久化环境时是不是一个飞跃。&lt;/p&gt;

&lt;p&gt;大多数的Graph和Document数据库在它们的领域中已经提出了标准。在Graph数据库世界，因为它的tinkerpop blueprints、Gremlin、Sparql以及Cypher使得它更为成功一些。在Document数据库领域，UnQL和jaql填补了一些位置，尽管前者缺少现实世界NoSQL数据库的支持。但是借助Hadoop的力量，很多项目正在将著名的ETL语言如Pig和Hive使用到其他NoSQL数据库中。所以标准世界是高度分裂的，但这只是因为NoSQL是一个范围很广的领域。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;格局&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;作为最好的数据库格局图之一，是由&lt;a href=&quot;http://blogs.the451group.com/information_management/2012/11/02/updated-database-landscape-graphic/&quot;&gt;451 Group的Matt Aslett在一个报告中&lt;/a&gt;给出的。最近，他更新了该图片从而能够让我们可以更好得深入理解他所提到的分类。你可以在下面的图片中看到，这个格局是高度碎片化和重叠的：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-02/7fig2small.jpg&quot; title=&quot;NoSQL的现状&quot;&gt;&lt;img src=&quot;/assets/files/2013-02/7fig2small.jpg&quot; title=&quot;NoSQL的现状&quot; alt=&quot;NoSQL的现状&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图2：Matt Aslett（451 Group）给出的数据库格局&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你可以看到在这个图片中有多个维度。关系型的以及非关系型的、分析型的以及操作型的、NoSQL类型的以及NewSQL类型的。最后的两个分类中，对于NoSQL有著名的子分类Key-Value、Document、Graph以及Big Tables，而对于NewSQL有子分类Storage-Engine、Clustering-Sharding、New Database、Cloud Service Solution。这个图有趣的地方在于，将一个数据放在一个精确的位置变得越来越难。每一个都在拼命地集成其他范围数据库中的特性。NewSQL系统实现NoSQL的核心特性，而NoSQL越来越多地试图实现“传统”数据库的特性如支持SQL或ACID，至少是可配置的持久化机制。&lt;/p&gt;

&lt;p&gt;这一切都始于众多的数据库都提供与Hadoop进行集成。但是，也有很多其他的例子，如MarkLogic开始参与JSON浪潮，所以也很难对其进行定位。另外，更多的多模型数据库开始出现，如ArangoDB、OrientDB和AlechemyDB（现在它是很有前途的Aerospike
DB的一部分）。它们允许在起始的时候只有一个数据库模型（如document/JSON模型）并在新需求出现的时候添加新的模型（Graph或key-value）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图书&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外一个证明它开始变得成熟的标志就是图书市场。在2010年和2011年两本德语书出版之后，我们看到Wiley出版了Shashank Tiwari的书。它的结构很棒并且饱含了深刻伟大的见解。在2012年，这个竞赛围绕着两本书展开。“七周七数据库”（Seven Databases in Seven Weeks）当然是一本杰作。它的特点在于新颖的编写以及实用的基于亲身体验的见解：它选取了6种著名的NoSQL数据库以及PostGreSQL。这些都使得它成为一本高度推荐的图书。另一方面，P.J.Sandalage以及Martin Fowler采取了一种更为全面的方法，涵盖了所有的特征并帮助你评估采用NoSQL的路径和决策。&lt;/p&gt;

&lt;p&gt;但是，会有更多的书出现。Manning的书出现在市场上只是个时间问题：Dan McCreary和Ann Kelly正在编写一本名为“&lt;a href=&quot;http://www.manning.com/mccreary/&quot;&gt;Making Sense of NoSQL&lt;/a&gt;”的书，首期的MEAP（指的是Manning Early Access Program——译者注）章节已经可以看到了。&lt;/p&gt;

&lt;p&gt;在介绍完理念和模式后，他们的第三章看起来保证很有吸引力：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;构建NoSQL大数据解决方案&lt;/li&gt;
&lt;li&gt;构建NoSQL搜索解决方案&lt;/li&gt;
&lt;li&gt;构建NoSQL高可用性解决方案&lt;/li&gt;
&lt;li&gt;使用NoSQL来提高敏捷性&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;只是一个全新的方式，绝对值得一读。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;领导者的现状&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;让我们快速了解一下各个NoSQL的领导者。作为市场上很明显的领导者之一，Hadoop是一个很奇怪的动物（作者使用这个词，可能是因为Hadoop的标识是一只大象——译者注）。一方面，它拥有巨大的发展势头。正如前面所说，每个传统的数据库提供商都急切地声明支持Hadoop。像Cloudera和MapR这样的公司会持续增长并且新的Hadoop扩展和继承者每周都在出现。\&lt;/p&gt;

&lt;p&gt;即便是Hive和Pig也在更好地得到接受。不过，有一个美中不足之处：公司们依然在抱怨非结构化的混乱（读取和解析文件本应该更快一些），MapReduce在批处理上做的还不够（甚至Google已经舍弃了它），管理依旧很困难，稳定性问题以及在本地很难找到培训/咨询。即便你可以解决一些上面的问题，如果Hadoop继续像现在这样发展或发生重大变化的话，它依然会是热点问题。&lt;/p&gt;

&lt;p&gt;第二位领导者，MongoDB，同样面临激烈的争论。处于领导地位的数据库会获得更多的批评，这可能是很自然的事情。不过，MongoDB经历了快速的增长，它受到的批评主要如下：&lt;/p&gt;

&lt;p&gt;a)就老版本而言或者\&lt;/p&gt;

&lt;p&gt;b)缺少怎样正确使用它的知识。尽管MongoDB在下载区域清楚地表明32位版本不能处理2GB的数据并建议使用64位版本，但这依然受到了很多近乎荒谬的抱怨。&lt;/p&gt;

&lt;p&gt;不管怎样，MongoDB合作者和资助者推动了雄心勃勃的发展路线，包含了很多热门的东西：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;行业需要的一些安全性/LDAP特性，目前正在开发&lt;/li&gt;
&lt;li&gt;全文本搜索很快会推出&lt;/li&gt;
&lt;li&gt;针对MapReduce的V8将会推出&lt;/li&gt;
&lt;li&gt;将会出现比集合级别更好的锁级别&lt;/li&gt;
&lt;li&gt;Hash分片键正在开发中&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;尤其是最后一点吸引了很多架构师的兴趣。MongoDB经常被抱怨（同时也被竞争对手）没有实现简洁一致的哈希，因为key很容易定义所以不能保证完全正确。但在将来，将会有一个对hash分片键的配置。这意味着用户可以决定使用hash
key来分片，还是需要使用自己选择分片key所带来的优势（可能很少）。&lt;/p&gt;

&lt;p&gt;Cassandra是这个领域中的另一个产品，它做的很好并且添加了更多更好的特性，如更好的查询。但是不断有传言说运行Cassandra集群并不容易，需要一些很艰难的工作。但这里最吸引人的肯定是DataStax。Cassandra的新公司——获得了两千五百万美元的C类资助——很可能要处理分析和一些操作方面的问题。尤其是分析能力使得很多人感到惊讶，因为早期的Cassandra并没有被视为强大的查询机器。但是这种现状在最近的几个版本中发生了变化，查询功能对一些现代分析来讲已经足够了。&lt;/p&gt;

&lt;p&gt;Redis的开发进度也值得关注。尽管Salvatore声明如果没有社区和Pieter Noordhuis的帮助，他做不成任何的事情，但是它依旧是相当棒的一个产品。对故障恢复的良好支持以及使用Lua的服务器端脚本语言是其最近的成就。使用Lua的决策对社区带来了一些震动，因为每个人都在集成JavaScript作为服务器端的语言。但是，Lua是一个整洁的语言并为Redis开启新的潘多拉盒子带来了可能性。&lt;/p&gt;

&lt;p&gt;CouchBase在可扩展性和其他潜在因素方面看起来也是一个很好的选择，尽管Facebook以及Zynga面临着巨大的风波。它确实不是很热门的查询机器，但如果他们能够在将来提高查询能力，那它的功能就会相当完整了。与CouchDB创立者的合并毫无疑问是很重要的一个步骤，CouchDB在CouchBase里面的影响值得关注。在每个关于数据库的会议上，听到这样的讨论也是很有意思的，那就是在Damien、Chris和Jan离开后，CouchDB会变得更好呢还是更坏呢？大家在这里只能听到极端的观点。但是，只要数据库做得好谁关心这个呢。现在看起来，它确实做的很好。&lt;/p&gt;

&lt;p&gt;最后一个需要提及的NoSQL数据库当然是Riak，在功能性和监控方面它也有了巨大的提升。在稳定性方面，它继续得到巨大的声誉：“像巨石一般稳定可靠且不显眼，并对你的睡眠有好处”。Riak
CS fork在这种技术的模块化方面看起来也很有趣。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;有意思的新加入者&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;除了市场领导者，评估新的加入者通常是很有意思的。让我们深入了解它们中的一部分。&lt;/p&gt;

&lt;p&gt;毫无疑问，Elastic Search是最热门的新NoSQL产品，在一系列的A轮资助中它刚刚获得了一千万美元，这是它热门的一个明证。作为构建在Lucene之上的高扩展性搜索引擎，它有很多的优势：a）它有一个公司提供服务并且b）利用了Lucene在过去的多年中已被充分证明的成就。它肯定会比以往更加深入得渗透到整个行业中，并在半结构化信息领域给重要的参与者带来冲击。&lt;/p&gt;

&lt;p&gt;Google在这个领域也推出了小巧但是迅速的LevelDB。在很多特殊的需求下，如压缩集成方面，它作为基础得到了很多的应用。即使是Riak都集成了LevelDB。考虑到Google的新数据库如Dremel和Spanner都有了对应的开源项目（如Apache Drill或Cloudera Impala），它依然被视为会继续存在的。&lt;/p&gt;

&lt;p&gt;另外一个技术变化当然就是在2012年初的DynamoDB。自从部署在Amazon中，他们将其视为增长最快的服务。它的可扩展性很强。新特性开发地比较慢但它关注于SSD，其潜力是很令人振奋的。&lt;/p&gt;

&lt;p&gt;多模块数据库也是值得关注的一个领域。最著名的代表者是OrientDB，它现在并不是新的加入者但它在很迅速地提高功能。可能它变化得太快了，很多使用者也许会很开心地看到OrientDB已经到达了1.0版本，希望它能更稳定一些。对Graph、Document、Key-Value的支持以及对事务和SQL的支持，使得我们有理由给它第二次表现的机会。尤其是对SQL的良好支持使得它对诸如Penthao这样的分析解决方案方面很有吸引力。这个领域另一个新的加入者是ArangoDB，它的进展很快，并不畏惧将自己与已确定地位的参与者进行比较。\&lt;/p&gt;

&lt;p&gt;但是，如果有新的需求必须要实现并且具有不同类型的新数据模型要进行持久化的话，对原生JSON和Graph的支持会省去很多的努力。&lt;/p&gt;

&lt;p&gt;到目前位置，2012年的最大惊喜来自于Datomic。它由一些摇滚明星采用Clojure语言以难以令人置信的速度开发的，它发布了一些新的范式。另外，它还进入了ThoughtWorks的技术雷达，占据了推荐关注的位置。尽管它“只是”已有数据库中一个参与者，但是它有很多的优势，如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;事务&lt;/li&gt;
&lt;li&gt;时间机器&lt;/li&gt;
&lt;li&gt;新颖且强大的查询方式&lt;/li&gt;
&lt;li&gt;新的模式方式&lt;/li&gt;
&lt;li&gt;缓存以及可扩展性的特性&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;目前，支持将DynamoDB、Riak、CouchBase、Infinispan以及SQL作为底层的存储引擎。它甚至允许你同时混合和查询不同的数据库。很多有经验的人都很惊讶于这种颠覆性的范式转变是如何可能实现的。但幸运的是它就是这样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;作为总结，我们做出三点结论：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;关于CAP理论，Eric Brewer的一些新文章应该几年前就发表。在&lt;a href=&quot;http://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed;jsessionid=05F9C1BE83D9DD1D1326298BC22A297C&quot;&gt;这篇文章中&lt;/a&gt;（&lt;a href=&quot;http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed;jsessionid=05F9C1BE83D9DD1D1326298BC22A297C&quot;&gt;这篇佳文的中文版地址&lt;/a&gt;——译者注），他指出“三选二”具有误导性，并指出了它的原因，世界为何远比简单的CP/AP更为复杂，如在ACID/BASE之间做出选择。虽然如此，近些年来有成千上万的对话和文章继续赞扬CAP理论而没有任何批评性的反思。Michael Stonebraker是NoSQL最强有力的审查者之一（NoSQL领域也对他颇多感激），他在多年前就指出了这些问题！遗憾的是，没有多少人在听。但是，既然Eric Brewer更新了他的理论，简单的CAP叙述时代肯定要结束了。在指出CAP理论的真实和多样性的观点上，请站在时代的前列。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;正如我们所了解的那样，传统关系型数据库的不足导致了NoSQL领域的产生。但这也是传统帝国发起回击的时刻。在“NewSQL”这个术语之下，我们可以看到许多新的引擎（如database.com、VoltDB、GenieDB等，见图2），它们提高了传统的解决方案、分片以及云计算方案的能力。这要感谢NoSQL运动。
但是随着众多的数据库尝试实现所有的特性，明确的边界消失了
确定使用哪种数据库比以前更为复杂了。&lt;/p&gt;

&lt;p&gt;  你必须要知道50个用例、50个数据库并要回答至少50个问题。关于后者，笔者在过去两年多的NoSQL咨询中进行了收集，可以在以下地址找到：&lt;a href=&quot;http://nosql-database.org/select-the-right-database.html&quot;&gt;选择正确的数据库&lt;/a&gt;，&lt;a href=&quot;http://www.infoq.com/presentations/Choosing-NoSQL-NewSQL;jsessionid=05F9C1BE83D9DD1D1326298BC22A297C&quot;&gt;在NoSQL和NewSQL间进行选择&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个通用的真理就是，每一项技术的变化——从客户端-服务端技术开始甚至更早——需要十倍的成本才能进行转移。例如，从大型机到客户端-服务端、客户端-服务端到SOA、SOA到WEB、RDBMS到混合型持久化之间的转换都是如此。所以可以推断出，在将NoSQL加入到他们的产品决策上，很多的公司在迟疑和纠结。但是，大家也都知道，最先采用的公司会从这个两个领域获益并且能够快速集成NoSQL，所以在将来会占据更有利的位置。就这一点而言，NoSQL解决方案会一直存在并且评估起来会是有利可图的领域。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>可伸缩系统的架构经验</title>
   <link href="http://beango.github.com/archives/2013/02/27/scalability-system-architecture-lessons.html"/>
   <updated>2013-02-27T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/02/27/scalability-system-architecture-lessons</id>
   <content type="html">&lt;p&gt;来源：&lt;a href=&quot;http://agiledon.github.com/blog/2013/02/27/scalability-system-architecture-lessons/&quot;&gt;简单文本&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最近，阅读了Will Larson的文章&lt;a href=&quot;http://lethain.com/introduction-to-architecting-systems-for-scale/&quot;&gt;Introduction to Architecting System for Scale&lt;/a&gt;，感觉很有价值。作者分享了他在Yahoo!与Digg收获的设计可伸缩系统的架构经验。在我过往的架构经验中，由于主要参与开发企业软件系统，这种面向企业内部的软件系统通常不会有太大的负载量，太多的并发量，因而对于系统的可伸缩性考虑较少。大体而言，只要在系统部署上考虑集群以及负载均衡即可。本文给了我很多启发，现把本文的主要内容摘译出来，并结合自己对此的理解。&lt;/p&gt;

&lt;p&gt;Larson首先认为，一个理想的系统，对于容量（Capacity）的增长应该与添加的硬件数是线性的关系。换言之，如果系统只有一台服务器，在增加了另一台同样的机器后，容量应该翻倍。以此类推。这种线性的容量伸缩方式，通常被称之为水平伸缩“Horizontal Scalability”。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-02/scalability.jpg&quot; title=&quot;可伸缩系统的架构经验&quot;&gt;&lt;img src=&quot;/assets/files/2013-02/scalability.jpg&quot; title=&quot;可伸缩系统的架构经验&quot; alt=&quot;可伸缩系统的架构经验&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在设计一个健壮的系统时，自然必须首要考虑失败的情况。Larson认为，一个理想的系统是当失去其中一台服务器的时候，系统不会崩溃。当然，对应而言，失去一台服务器也会导致容量的响应线性减少。这种情况通常被称为冗余“Redundancy”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;无论是水平伸缩还是冗余，都可以通过负载均衡来实现。负载均衡就好似一个协调请求的调停者，它会根据集群中机器的当前负载，合理的分配发往Web服务器的请求，以达到有效利用集群中各台机器资源的目的。显然，这种均衡器应该介于客户端与Web服务器之间，如下图所示：&lt;a href=&quot;/assets/files/2013-02/scalability01.png&quot; title=&quot;可伸缩系统的架构经验&quot;&gt;&lt;img src=&quot;/assets/files/2013-02/scalability01.png&quot; title=&quot;可伸缩系统的架构经验&quot; alt=&quot;可伸缩系统的架构经验&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文提到了实现负载均衡的几种方法。其一是Smart
Client，即将负载均衡的功能添加到数据库（以及缓存或服务）的客户端中。这是一种通过软件来实现负载均衡的方式，它的缺点是方案会比较复杂，不够健壮，也很难被重用（因为协调请求的逻辑会混杂在业务系统中）。对此，Larson在文章以排比的方式连续提出问题，以强化自己对此方案的不认可态度：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Is it attractive because it is the simplest solution? Usually, no. Is
it seductive because it is the most robust? Sadly, no. Is it alluring
because it’ll be easy to reuse? Tragically, no.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;第二种方式是采用硬件负载均衡器，例如&lt;a href=&quot;http://www.citrix.com/English/ps2/products/product.asp?contentID=21679&quot;&gt;Citrix NetScaler&lt;/a&gt;。不过，购买硬件的费用不菲，通常是一些大型公司才会考虑此方案。&lt;/p&gt;

&lt;p&gt;如果既不愿意承受Smart Client的痛苦，又不希望花费太多费用去购买硬件，那就可以采用一种混合（Hybird）的方式，称之为软件负载均衡器（Software Load Balancer）。Larson提到了&lt;a href=&quot;http://haproxy.1wt.eu/&quot;&gt;HAProxy&lt;/a&gt;。它会运行在本地，需要负载均衡的服务都会在本地中得到均衡和协调。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了减轻服务器的负载，还需要引入缓存。文章给出了常见的对缓存的分类，分别包括：预先计算结果（precalculating result，例如针对相关逻辑的前一天的访问量）、预先生成昂贵的索引（pre-generating expensive indexes，例如用户点击历史的推荐）以及在更快的后端存储频繁访问的数据的副本（例如&lt;a href=&quot;http://memcached.org/&quot;&gt;Memcached&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;应用缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;提供缓存的方式可以分为应用缓存和数据库缓存。此二者各擅胜场。应用缓存通常需要将处理缓存的代码显式地集成到应用代码中。这就有点像使用代理模式来为真实对象提供缓存。首先检查缓存中是否有需要的数据，如果有，就从缓存直接返回，否则再查询数据库。至于哪些值需要放到缓存中呢？有&lt;a href=&quot;http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used&quot;&gt;诸多算法&lt;/a&gt;，例如根据最近访问的，或者根据访问频率。使用Memcached的代码如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;key = &quot;user.%s&quot; % user_id
user_blob = memcache.get(key)
if user_blob is None:
    user = mysql.query(&quot;SELECT * FROM users WHERE user_id=\&quot;%s\&quot;&quot;, user_id)
    if user:
        memcache.set(key, json.dumps(user))
    return user
else:
    return json.loads(user_blob)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;数据库缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据库缓存对于应用代码没有污染，一些天才的DBA甚至可以在不修改任何代码的情况下，通过数据库调优来改进系统性能。例如通过配置Cassandra行缓存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内存缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了提高性能，缓存通常是存储在内存中。常见的内存缓存包括Memcached和&lt;a href=&quot;http://redis.io/&quot;&gt;Redis&lt;/a&gt;。不过采用这种方式仍然需要合理的权衡。我们不可能一股脑儿的将所有数据都存放在内存中，虽然这会极大地改善性能，但比较起磁盘存储而言，RAM的代价更昂贵，同时还会影响系统的健壮性，因为内存中的数据没有持久化，容易丢失。正如之前提到的，我们应该将需要的数据放入缓存，通常的算法是&lt;a href=&quot;http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used&quot;&gt;least recently used&lt;/a&gt;，即LRU。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CDN&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;提高性能，降低Web服务器负载的另一种常见做法是将静态媒体放入CDN（Content Distribution Network）中。如下图所示：&lt;a href=&quot;/assets/files/2013-02/scalability02.png&quot; title=&quot;可伸缩系统的架构经验&quot;&gt;&lt;img src=&quot;/assets/files/2013-02/scalability02.png&quot; title=&quot;可伸缩系统的架构经验&quot; alt=&quot;可伸缩系统的架构经验&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CDN可以有效地分担Web服务器的压力，使得应用服务器可以专心致志地处理动态页面；同时，CDN还可以通过地理分布来提高响应请求的性能。在设置了CDN后，当系统接收到请求时，首先会询问CDN以获得请求中需要的静态媒体（通常会通过HTTP Header来配置CDN能够缓存的内容）。如果请求的内容不可用，CDN会查询服务器以获得该文件，并在CDN本地进行缓存，最后再提供给请求者。如果当前网站并不大，引入CDN的效果不明显时，可以考虑暂不使用CDN，在将来可以通过使用一些轻量级的HTTP服务器如&lt;a href=&quot;http://nginx.org/&quot;&gt;Nginx&lt;/a&gt;，为静态媒体分出专门的子域名如static.domain.com来提供服务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缓存失效&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;引入缓存所带来的问题是如何保证真实数据与缓存数据之间的一致性。这一问题通常被称之为缓存失效（Cache Invalidation）。从高屋建瓴的角度来讲，解决这一问题的办法无非即使更新缓存中的数据。一种做法是直接将新值写入缓存中（通常被称为write-through cache）；另一种做法是简单地删除缓存中的值，在等到下一次读缓存值的时候再生成。&lt;/p&gt;

&lt;p&gt;整体而言，要避免缓存实效，可以依赖于数据库缓存，或者为缓存数据添加有效期，又或者在实现应用程序逻辑时，尽量考虑避免此问题。例如不直接使用DELETE FROM a WHERE…来删除数据，而是先查询符合条件的数据，再使得缓存中对应的数据失效，继而根据其主键显式地删除这些行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Off-Line处理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这篇文章还提到了Off-Line的处理方式，即通过引入消息队列的方式来处理请求。事实上，在大多数企业软件系统中，这种方式也是较为常见的做法。在我撰写的文章《&lt;a href=&quot;http://agiledon.github.com/blog/2012/12/27/distributed-architecture-based-on-message/&quot;&gt;案例分析:基于消息的分布式架构&lt;/a&gt;》中，较为详细地介绍了这种架构。在引入消息队列后，Web服务器会充当消息的发布者，而在消息队列的另一端可以根据需要提供消费者Consumer。如下图所示。对于Off-Line的任务是否执行完毕，通常可以通过轮询或回调的方式来获知。&lt;a href=&quot;/assets/files/2013-02/scalability03.png&quot; title=&quot;可伸缩系统的架构经验&quot;&gt;&lt;img src=&quot;/assets/files/2013-02/scalability03.png&quot; title=&quot;可伸缩系统的架构经验&quot; alt=&quot;可伸缩系统的架构经验&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为了更好地提高代码可读性，可以在公开的接口定义中明确地标示该任务是On-Line还是Off-Line。&lt;/p&gt;

&lt;p&gt;引入Message Queue，可以极大地缓解Web服务器的压力，因为它可以将耗时较长的任务转到专门的机器上去执行。&lt;/p&gt;

&lt;p&gt;此外，通过引入定时任务，也可以有效地利用Web服务器的空闲时间来处理后台任务。例如，通过Spring Batch Job来执行每日、每周或者每月的定时任务。如果需要多台机器去执行这些定时任务，可以引入Spring提供的&lt;a href=&quot;https://puppetlabs.com/&quot;&gt;Puppet&lt;/a&gt;来管理这些服务器。Puppet提供了可读性强的声明性语言来完成对机器的配置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Map-Reduce&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于大数据的处理，自然可以引入Map-Reduce。为整个系统专门引入一个Map-Reduce层来处理数据是有必要的。相对于使用SQL数据库作为数据中心的方式，Map-Reduce对可伸缩性的支持更好。Map-Reduce可以与任务的定时机制结合起来。如下图所示：&lt;a href=&quot;/assets/files/2013-02/scalability04.png&quot; title=&quot;可伸缩系统的架构经验&quot;&gt;&lt;img src=&quot;/assets/files/2013-02/scalability04.png&quot; title=&quot;可伸缩系统的架构经验&quot; alt=&quot;可伸缩系统的架构经验&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;平台层&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Larson认为，大多数系统都是Web应用直接与数据库通信，但如果能加入一个平台层（Platform Layer），或许会更好。&lt;a href=&quot;/assets/files/2013-02/scalability05.png&quot; title=&quot;可伸缩系统的架构经验&quot;&gt;&lt;img src=&quot;/assets/files/2013-02/scalability05.png&quot; title=&quot;可伸缩系统的架构经验&quot; alt=&quot;可伸缩系统的架构经验&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先，将平台与Web应用分离，使得它们可以独立地进行伸缩。例如需要添加一个新的API，就可以添加新的平台服务器，而无需增加Web服务器。要知道，在这样一个独立的物理分层架构中，不同层次对服务器的要求是不一样的。例如，对于数据库服务器而言，由于需要频繁地对磁盘进行I/O操作，因此应保证数据库服务器的IO性能，如尽量使用固态硬盘。而对于Web服务器而言，则对CPU的要求比较高，尽可能采用多核CPU。&lt;/p&gt;

&lt;p&gt;其次，增加一个额外的平台层，可以有效地提高系统的可重用性。例如我们可以将一些与系统共有特性以及横切关注点的内容（如对缓存的支持，对数据库的访问等功能）抽取到平台层中，作为整个系统的基础设施（Infrastructure）。尤其对于产品线系统而言，这种架构可以更好地为多产品提供服务。&lt;/p&gt;

&lt;p&gt;最后，这种架构也可能对跨团队开发带来好处。平台可以抽离出一些与产品无关的接口，从而隐藏其具体实现的细节。如果划分合理，并能设计出相对稳定的接口，就可以使得各个团队可以并行开发。例如可以专门成立平台团队，致力于对平台的实现以及优化。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>程序猿的真实生活(GIF)</title>
   <link href="http://beango.github.com/archives/2013/02/21/the-reality-of-developers-life.html"/>
   <updated>2013-02-21T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/02/21/the-reality-of-developers-life</id>
   <content type="html">&lt;p&gt;程序猿是最苦逼的一群人，究竟有多苦？今天小编就用GIF图片来告诉大家程序猿的真实生活。（图片较多，请谨慎加载！）&lt;/p&gt;

&lt;p&gt;当你往产品环境中加入一些东西时：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74ecc4cjw1e20baw7cfwg.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当你没有Google就发现问题的解决方法时：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74ecc4cjw1e20bbu4wreg.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当你没保存代码就关闭了IDE接口时：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74e55b4jw1e20bfj6lbfg.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;凌晨3点还在修Bug时：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74eed94jw1e20bcm50yrg.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当表达式返回值正如你所料时：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74ecc4cjw1e20bh0yazlg.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当老板告诉你，你开发的模型压根就没在用时 ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74e55b4jw1e20bjaaxsmg.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当你告诉老板你已经修复了Bug时：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74eed94jw1e20bj9u8e2g.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当你没测试代码就上传，结果完美运行时：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74ecc4cjw1e20bkbbc4vg.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;营销部那群“贱人”向程序猿展示销售业绩时：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74eed94jw1e20bkwqwy7g.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还记得你初次将美丽的CSS加到网页中的样子吗：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74e55b4jw1e20blhebulg.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当系统管理员开放root权限时：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74eed94jw1e20bp9pocng.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你熬了一整夜、耗了一整天，开始调试代码时：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74ecc4cjw1e20bmq6uf4g.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;周末，所有人都在加班就你一个人在休息时的感觉：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74e55b4jw1e20bqhgmzfg.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当老板在找人修复严重Bug时：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74ecc4cjw1e20bsc5yy9g.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;项目提前完成，收获意外奖励时：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74e55b4jw1e20bw1j53yg.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;尼玛，上周五还行的东西周一就挂了时：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74eed94jw1e20bt3vjubg.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当你漫无目的、无规格地开发时：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74eed94jw1e20bzt8qaeg.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;老板告诉我，“调试就是专门给不会编程的人准备的”时，你真想……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74ecc4cjw1e20c2cvts6g.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当你更新完数据库脚本，上传后发现整个数据库都被清除了……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/a74e55b4jw1e20c0wj1dbg.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;来源：&lt;a href=&quot;http://www.javacodegeeks.com/2013/02/the-reality-of-developers-life.html&quot;&gt;javacodegeeks&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java 安全模型介绍</title>
   <link href="http://beango.github.com/archives/2013/02/21/j-lo-javasecurity.html"/>
   <updated>2013-02-21T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/02/21/j-lo-javasecurity</id>
   <content type="html">&lt;p&gt;来源：&lt;a href=&quot;http://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/&quot;&gt;IBM developerworks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作为一种诞生于互联网兴起时代的语言，Java从一开始就带有安全上的考虑，如何保证通过互联网下载到本地的 Java程序是安全的，如何对 Java 程序访问本地资源权限进行有限授权，这些安全角度的考虑一开始就影响到 Java 语言的设计与实现。可以说 Java 在这些方面的探索与经验，对后来的一些语言与产品都带来了积极影响。&lt;/p&gt;

&lt;p&gt;本篇文章中将介绍 Java 中安全模型，以及如何利用安全访问控制机制来实现一些特定目的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java 中的安全模型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在 Java 中将执行程序分成本地和远程两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的 Java 实现中，安全依赖于沙箱 (Sandbox) 机制。沙箱机制就是将 Java
代码限定在虚拟机 (JVM) 特定的运行范围中，并且严格限制代码对本地系统的资源访问，通过这样的措施来保证对远程代码的有效隔离，防止对本地系统造成破坏。如图 1 所示，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 1.JDK1.0 安全模型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-01/java-security-strategy-01.gif&quot; title=&quot;Java 安全模型介绍&quot;&gt;&lt;img src=&quot;/assets/files/2013-01/java-security-strategy-01.gif&quot; title=&quot;Java 安全模型介绍&quot; alt=&quot;Java安全模型介绍&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的Java1.1版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如图 2 所示，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 2.JDK1.1 安全模型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-01/java-security-strategy-02.gif&quot; title=&quot;Java 安全模型介绍&quot;&gt;&lt;img src=&quot;/assets/files/2013-01/java-security-strategy-02.gif&quot; title=&quot;Java 安全模型介绍&quot; alt=&quot;Java安全模型介绍&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在 Java1.2 版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如图 3 所示，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 3.JDK1.2 安全模型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-01/java-security-strategy-03.gif&quot; title=&quot;Java 安全模型介绍&quot;&gt;&lt;img src=&quot;/assets/files/2013-01/java-security-strategy-03.gif&quot; title=&quot;Java 安全模型介绍&quot; alt=&quot;Java安全模型介绍&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当前最新的安全机制实现，则引入了域 (Domain) 的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域(Protected Domain)，对应不一样的权限(Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如图 4 所示：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 4. 最新安全模型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2013-01/java-security-strategy-04.gif&quot; title=&quot;Java 安全模型介绍&quot;&gt;&lt;img src=&quot;/assets/files/2013-01/java-security-strategy-04.gif&quot; title=&quot;Java 安全模型介绍&quot; alt=&quot;Java安全模型介绍&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以上提到的都是基本的 Java 安全模型概念，在应用开发中还有一些关于安全的复杂用法，其中最常用到的 API 就是 doPrivileged。doPrivileged 方法能够使一段受信任代码获得更大的权限，甚至比调用它的应用程序还要多，可做到临时访问更多的资源。有时候这是非常必要的，可以应付一些特殊的应用场景。例如，应用程序可能无法直接访问某些系统资源，但这样的应用程序必须得到这些资源才能够完成功能。针对这种情况，Java SDK 给域提供了 doPrivileged 方法，让程序突破当前域权限限制，临时扩大访问权限。下面内容会详细讲解一下安全相关的方法使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java 安全控制实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java SDK 中与安全相关的类和接口都放在 java.security 包中，其中既包括访问控制配置及细粒度访问控制框架的实现，还包括签名和加解密的实现。本文中涉及到的安全访问控制主要与安全包中访问控制框架相关，这里面最常用的就是 AccessContorller 类。通过下图的描述，您可以了解 ACC(Access Contorller) 机制是如何运作的。&lt;/p&gt;

&lt;p&gt;在某一个线程的调用栈中，当 AccessController 的 checkPermission 方法被最近的调用程序（例如 A 类中的方法）调用时，对于程序要求的所有访问权限，ACC 决定是否授权的基本算法如下：&lt;/p&gt;

&lt;p&gt;​1. 如果调用链中的某个调用程序没有所需的权限，将抛出AccessControlException；&lt;/p&gt;

&lt;p&gt;​2. 若是满足以下情况即被授予权限：&lt;/p&gt;

&lt;p&gt;​a. 调用程序访问另一个有该权限域里程序的方法，并且此方法标记为有访问“特权”；&lt;/p&gt;

&lt;p&gt;​b. 调用程序所调用（直接或间接）的后续对象都有上述权限。&lt;/p&gt;

&lt;p&gt;在上面例子的调用链中，假定 E 域和 F 域不具备 X 权限 (permission)，而在 C.class 对应的 G 域具有 X 权限，同时 C 使用 X 权限的对外接口 Y 方法是通过 doPrivilege 方式实现。那么，B.class A.class 调用 Y 方法就都具备 X 权限。如果 Y 方法没有标注 doPrivilege，那么对 Y 方法的调用就不具备 X 权限。&lt;/p&gt;

&lt;p&gt;还有一种特殊的情况，就是访问控制上下文的继承问题。当一个线程创建另一个新线程时，会同时创建新的堆栈。如果创建新线程时没有保留当前的安全上下文，也就是线程相关的安全信息，则新线程调用AccessController.checkPermission检验权限时，安全访问控制机制只会根据新线程的上下文来决定安全性问题，而不会考虑其父线程的相应权限。这个清除堆栈的做法本身并不会给系统带来安全隐患，但它会使源代码，尤其是系统代码的编写容易出现错误。例如，对安全框架实现不熟悉编程人员可能会很自然地认为，子线程执行的信任代码继承了父线程执行的不可信任代码的安全限制特性。当从子线程内访问受控制的资源时，如果父线程的安全上下文信息并未保存，就会导致意外的安全漏洞。因为丢失的父线程中安全限制数据会使子线程将资源传递给一些不可信任的代码。因此，在创建新线程时，必须确保利用父线程创建，或利用其他形式创建代码。总之，要保证让子线程自动继承父线程的安全性上下文，这样子线程中的后续 AccessController.checkPermission 调用就会考虑所继承的父线程的安全特性。&lt;/p&gt;

&lt;p&gt;需要注意是 AccessController 类的 checkPermission
方法将在当前执行线程的上下文，包括继承的上下文中进行安全检查。当这种安全检查只能在不同的上下文中进行时就会出现问题。意即，本应在一个线程上下文内部进行的安全检查，有时却需要在不同上下文中进行。例如，当一个线程将某个事件传给另一个线程时，如果所请求的事件服务要求访问某种安全受控资源，则为其请求事件服务的第二个线程将没有事件产生源线程相应的上下文来完成所需的访问控制决策。为解决这样的问题，Java 在 AccessController 类中提供了 getContext 方法和 AccessControlContext 对象。通过 getContext 方法可获取当前调用上下文的“快照(snapshot)”，然后将其存放到返回的 AccessControlContext 对象中。调用的样例程序如下所示：AccessControlContext acc = AccessController.getContext();&lt;/p&gt;

&lt;p&gt;getContext方法将当前上下文的快照信息捕获，然后执行程序就可以通过检查前后不同上下文中的信息，即比较快照上下文信息与本上下文信息，然后来做出对受控资源访问控制的决策。上面问题就可以如下方式来解决，当前一个线程把某个请求事件传给第二个线程时，同时捕获其上下文信息并将这些信息提供给后一个线程。略有不同的是，AccessControlContext 类本身的 checkPermission 方法可根据它自身携带的上下文信息来决定访问控制，而不是根据当前正在执行的线程上下文。因此必要时，后一个线程可直接通过调用前一个线程上下文快照本身的权限检查方法来执行相应的安全检查。如下，acc.checkPermission(permission)，上述方法调用等同于在前一个线程的上下文中执行相同的安全检查，尽管访问控制检查实际上是在后一个线程中完成的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安全控制使用的代码实例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面关于安全控制使用的描述还是比较晦涩，下面将通过一个代码示例进行说明。&lt;/p&gt;

&lt;p&gt;在 Eclipse 开发环境中建立两个不同工程：projectX 和 projectY。我们会给 projectX 工程中的 bin 目录赋予写文件的权限，换句话说就是允许所有存在于此目录中的 class 文件可以自由的在 bin 目录中进行文件写操作。然后，我们会在 projectY
工程中调用 projectX 工程中的一个文件操作工具类。这个工具类提供两种类型接口，一种是特权访问方式，另外一种是普通访问方式。由于在 projectY 工程中的文件是不具备在 projectX 工程中 bin 目录的任何写权限，所以通过三种不同访问方式的调用结果，我们就可以很清楚地了解到 Java 中安全控制该如何使用。&lt;/p&gt;

&lt;p&gt;假定 ProjectX 的项目路径为 D:\workspace\projectX\&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; package learn.java.security; 

 import java.io.File; 
 import java.io.IOException; 
 import java.security.AccessControlException; 
 import java.security.AccessController; 
 import java.security.PrivilegedAction; 

 public class FileUtil { 
    // 工程 A 执行文件的路径   
    private final static String FOLDER_PATH = &quot;D:\\workspace\\projectX\\bin&quot;; 

    public static void makeFile(String fileName) { 
        try { 
            // 尝试在工程 A 执行文件的路径中创建一个新文件
            File fs = new File(FOLDER_PATH + &quot;\\&quot; + fileName); 
            fs.createNewFile(); 
        } catch (AccessControlException e) { 
            e.printStackTrace(); 
        } catch (IOException e) { 
            e.printStackTrace(); 
        } 
    } 

    public static void doPrivilegedAction(final String fileName) { 
        // 用特权访问方式创建文件
        AccessController.doPrivileged(new PrivilegedAction&amp;lt;String&amp;gt;() { 
            @Override 
            public String run() { 
                makeFile(fileName); 
                return null; 
            } 
        }); 
    } 
 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假定 ProjectY 的项目路径为 D:\workspace\projectY\&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; package demo.security; 

 import java.io.File; 
 import java.io.IOException; 
 import java.security.AccessControlException; 

 import learn.java.security.FileUtil; 

 public class DemoDoPrivilege { 

    public static void main(String[] args) { 
        System.out.println(&quot;***************************************&quot;); 
        System.out.println(&quot;I will show AccessControl functionality...&quot;); 

        System.out.println(&quot;Preparation step : turn on system permission check...&quot;); 
        // 打开系统安全权限检查开关
        System.setSecurityManager(new SecurityManager()); 
        System.out.println(); 

        System.out.println(&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;); 
        System.out.println(&quot;
        Create a new file named temp1.txt via privileged action ...&quot;); 
        // 用特权访问方式在工程 A 执行文件路径中创建 temp1.txt 文件
        FileUtil.doPrivilegedAction(&quot;temp1.txt&quot;); 
        System.out.println(&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;); 
        System.out.println(); 

        System.out.println(&quot;/////////////////////////////////////////&quot;); 
        System.out.println(&quot;Create a new file named temp2.txt via File ...&quot;); 
        try { 
            // 用普通文件操作方式在工程 A 执行文件路径中创建 temp2.txt 文件
            File fs = new File( 
                    &quot;D:\\workspace\\projectX\\bin\\temp2.txt&quot;); 
            fs.createNewFile(); 
        } catch (IOException e) { 
            e.printStackTrace(); 
        } catch (AccessControlException e1) { 
            e1.printStackTrace(); 
        } 
        System.out.println(&quot;/////////////////////////////////////////&quot;); 
        System.out.println(); 

        System.out.println(&quot;-----------------------------------------&quot;); 
        System.out.println(&quot;create a new file named temp3.txt via FileUtil ...&quot;); 
        // 直接调用普通接口方式在工程 A 执行文件路径中创建 temp3.txt 文件
        FileUtil.makeFile(&quot;temp3.txt&quot;); 
        System.out.println(&quot;-----------------------------------------&quot;); 
        System.out.println(); 

        System.out.println(&quot;***************************************&quot;); 
    } 
 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用的安全访问控制策略文件 (MyPolicy.txt) 如下 , 假定安全策略文件放于 projectY 工程的根目录下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; // 授权工程 A 执行文件路径中文件在本目录中的写文件权限
 grant codebase &quot;file:/D:/workspace/projectX/bin&quot;
 { 
  permission java.io.FilePermission 
    &quot;D:\\workspace\\projectX\\bin\\*&quot;, &quot;write&quot;; 
 }; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面就可以运行程序了，您可以选择在 Eclipse 开发环境中直接运行，也可以通过命令行来执行。命令行执行如下所示，假定当前执行目录就是 projectY 的根目录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; java -Djava.security.policy=.\\MyPolicy.txt -classpath 
 D:\workspace\projectY\bin;D:\workspace\projectX\bin demo.security.DemoDoPrivilege
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; *************************************** 
 I will show AccessControl functionality... 
 Preparation step : turn on system permission check... 

 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 Create a new file named temp1.txt via privileged action ... 
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

 //////////////////////////////////////// 
 Create a new file named temp2.txt via File ... 
 java.security.AccessControlException: Access denied (java.io.FilePermission 
      D:\workspace\projectX\bin\temp2.txt write) 
     at java.security.AccessController.checkPermission(AccessController.java:108) 
     at java.lang.SecurityManager.checkPermission(SecurityManager.java:533) 
     at java.lang.SecurityManager.checkWrite(SecurityManager.java:963) 
     at java.io.File.createNewFile(File.java:882) 
     at demo.security.DemoDoPrivilege.main(DemoDoPrivilege.java:32) 
 //////////////////////////////////////// 

 ---------------------------------------- 
 create a new file named temp3.txt via FileUtil ... 
 java.security.AccessControlException: Access denied (java.io.FilePermission 
     D:\workspace\projectX\bin\temp3.txt write) 
     at java.security.AccessController.checkPermission(AccessController.java:108) 
     at java.lang.SecurityManager.checkPermission(SecurityManager.java:533) 
     at java.lang.SecurityManager.checkWrite(SecurityManager.java:963) 
     at java.io.File.createNewFile(File.java:882) 
     at learn.java.security.FileUtil.makeFile(FileUtil.java:16) 
     at demo.security.DemoDoPrivilege.main(DemoDoPrivilege.java:43) 
 ---------------------------------------- 

 *************************************** 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过程序打印结果来看，当往 projectX 工程中 bin 目录创建temp1.txt，temp2.txt，temp3.txt文件时候，除了通过特权访问方式可以创建成功外，通过普通接口访问或者直接文件操作方式都会失败，失败的原因都是没有通过权限检查。对照前文所描述的权限检查规则，用一句话总结就是想访问安全资源，要么调用链上权限齐全，要么就要用特权。特权访问机制实际上就是给应用开后门的使用上需要小心，所以这也给代码实现带来新的考虑，开放范围一定要限定好，否则可能留下安全隐患。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>计算机是如何启动的？</title>
   <link href="http://beango.github.com/archives/2013/02/18/booting.html"/>
   <updated>2013-02-18T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/02/18/booting</id>
   <content type="html">&lt;p&gt;从打开电源到开始操作，计算机的启动是一个非常复杂的过程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/bg2013021501.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我一直搞不清楚，这个过程到底是怎么回事，只看见屏幕快速滚动各种提示......
这几天，我查了一些资料，试图搞懂它。下面就是我整理的笔记。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;零、boot的含义&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先问一个问题，&quot;启动&quot;用英语怎么说？&lt;/p&gt;

&lt;p&gt;回答是boot。可是，boot原来的意思是靴子，&quot;启动&quot;与靴子有什么关系呢？
原来，这里的boot是bootstrap（鞋带）的缩写，它来自一句谚语：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;pull oneself up by one's bootstraps&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字面意思是&quot;拽着鞋带把自己拉起来&quot;，这当然是不可能的事情。最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！&lt;/p&gt;

&lt;p&gt;早期真的是这样，必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。所以，工程师们把这个过程叫做&quot;拉鞋带&quot;，久而久之就简称为boot了。&lt;/p&gt;

&lt;p&gt;计算机的整个启动过程分成四个阶段。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、第一阶段：BIOS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上个世纪70年代初，&quot;只读内存&quot;（read-only
memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/bg2013021502.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这块芯片里的程序叫做&quot;基本輸出輸入系統&quot;（Basic Input/Output
System），简称为&lt;a href=&quot;http://en.wikipedia.org/wiki/BIOS&quot;&gt;BIOS&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1 硬件自检&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做&quot;硬件自检&quot;（Power-On
Self-Test），缩写为&lt;a href=&quot;http://en.wikipedia.org/wiki/Power-on_self-test&quot;&gt;POST&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果硬件出现问题，主板会发出不同含义的&lt;a href=&quot;http://en.wikipedia.org/wiki/Power-on_self-test#Original_IBM_POST_beep_codes&quot;&gt;蜂鸣&lt;/a&gt;，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/bg2013021503.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2 启动顺序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。&lt;/p&gt;

&lt;p&gt;这时，BIOS需要知道，&quot;下一阶段的启动程序&quot;具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做&quot;启动顺序&quot;（Boot
Sequence）。&lt;/p&gt;

&lt;p&gt;打开BIOS的操作界面，里面有一项就是&quot;设定启动顺序&quot;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/bg2013021504.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、第二阶段：主引导记录&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;BIOS按照&quot;启动顺序&quot;，把控制权转交给排在第一位的储存设备。&lt;/p&gt;

&lt;p&gt;这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给&quot;启动顺序&quot;中的下一个设备。&lt;/p&gt;

&lt;p&gt;这最前面的512个字节，就叫做&lt;a href=&quot;http://en.wikipedia.org/wiki/Master_boot_record&quot;&gt;&quot;主引导记录&quot;&lt;/a&gt;（Master
boot record，缩写为MBR）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1 主引导记录的结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&quot;主引导记录&quot;只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。&lt;/p&gt;

&lt;p&gt;主引导记录由三个部分组成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;（1） 第1-446字节：调用操作系统的机器码。
（2） 第447-510字节：分区表（Partition table）。
（3） 第511-512字节：主引导记录签名（0x55和0xAA）。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，第二部分&quot;分区表&quot;的作用，是将硬盘分成若干个区。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2 分区表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;硬盘分区有很多&lt;a href=&quot;http://en.wikipedia.org/wiki/Disk_partitioning#Benefits_of_multiple_partitions&quot;&gt;好处&lt;/a&gt;。考虑到每个区可以安装不同的操作系统，&quot;主引导记录&quot;因此必须知道将控制权转交给哪个区。&lt;/p&gt;

&lt;p&gt;分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做&quot;主分区&quot;。&lt;/p&gt;

&lt;p&gt;每个主分区的16个字节，由6个部分组成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;（1）第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。
（2）第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。
（3）第5个字节：[主分区类型](http://en.wikipedia.org/wiki/Partition_type)。
（4） 第6-8个字节：主分区最后一个扇区的物理位置。
（5） 第9-12字节：该主分区第一个扇区的逻辑地址。
（6） 第13-16字节：主分区的扇区总数。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后的四个字节（&quot;主分区的扇区总数&quot;），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。&lt;/p&gt;

&lt;p&gt;如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是&lt;a href=&quot;http://en.wikipedia.org/wiki/GUID_Partition_Table&quot;&gt;增加扇区总数&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、第三阶段：硬盘启动&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1 情况A：卷引导记录&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上一节提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做&lt;a href=&quot;http://en.wikipedia.org/wiki/Volume_Boot_Record&quot;&gt;&quot;卷引导记录&lt;/a&gt;&quot;（Volume
boot record，缩写为VBR）。&lt;/p&gt;

&lt;p&gt;&quot;卷引导记录&quot;的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2 情况B：扩展分区和逻辑分区&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成&quot;扩展分区&quot;（Extended
partition）。&lt;/p&gt;

&lt;p&gt;所谓&quot;扩展分区&quot;，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做&quot;逻辑分区&quot;（logical
partition）。&lt;/p&gt;

&lt;p&gt;计算机先读取扩展分区的第一个扇区，叫做&lt;a href=&quot;http://en.wikipedia.org/wiki/Extended_partition&quot;&gt;&quot;扩展引导记录&quot;&lt;/a&gt;（Extended
boot
record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。&lt;/p&gt;

&lt;p&gt;计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。&lt;/p&gt;

&lt;p&gt;但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3 情况C：启动管理器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在这种情况下，计算机读取&quot;主引导记录&quot;前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的&lt;a href=&quot;http://en.wikipedia.org/wiki/Boot_loader#Modern_boot_loaders&quot;&gt;&quot;启动管理器&quot;&lt;/a&gt;（boot
loader），由用户选择启动哪一个操作系统。&lt;/p&gt;

&lt;p&gt;Linux环境中，目前最流行的启动管理器是&lt;a href=&quot;http://en.wikipedia.org/wiki/GNU_GRUB&quot;&gt;Grub&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/bg2013021505.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、第四阶段：操作系统&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;控制权转交给操作系统后，操作系统的内核首先被载入内存。&lt;/p&gt;

&lt;p&gt;以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。&lt;/p&gt;

&lt;p&gt;然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。&lt;/p&gt;

&lt;p&gt;至此，全部启动过程完成。&lt;/p&gt;

&lt;p&gt;（完）&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Redis监控技巧</title>
   <link href="http://beango.github.com/archives/2013/01/22/redis-masterclass-part-two-monitoring-redis.html"/>
   <updated>2013-01-22T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/01/22/redis-masterclass-part-two-monitoring-redis</id>
   <content type="html">&lt;p&gt;本文来自 &lt;a href=&quot;https://bugsnag.com/&quot;&gt;Bugsnag&lt;/a&gt; 的联合创始人 &lt;a href=&quot;https://twitter.com/snmaynard/&quot;&gt;Simon Maynard&lt;/a&gt; 的系列文章，作者根据几年来对
&lt;a href=&quot;http://blog.nosqlfan.com/tags/redis&quot; title=&quot;查看 Redis 的全部文章&quot;&gt;Redis&lt;/a&gt;的使用经历，对 Redis&lt;a href=&quot;http://blog.nosqlfan.com/tags/%e7%9b%91%e6%8e%a7&quot; title=&quot;查看 监控 的全部文章&quot;&gt;监控&lt;/a&gt;方法进行了系统性的总结，干货很多，值得一看。&lt;/p&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;http://snmaynard.com/2013/01/22/redis-masterclass-part-two-monitoring-redis/&quot;&gt;Redis Masterclass – Part 2, Monitoring&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Redis 监控最直接的方法当然就是使用系统提供的 info
命令来做了，你只需要执行下面一条命令，就能获得 Redis 系统的状态报告。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis-cli info
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;内存使用&lt;/h2&gt;

&lt;p&gt;如果 Redis 使用的内存超出了可用的物理内存大小，那么 Redis 很可能系统会被
&lt;a href=&quot;http://linux-mm.org/OOM_Killer&quot;&gt;OOM Killer&lt;/a&gt; 杀掉。针对这一点，你可以通过
info 命令对 &lt;em&gt;used_memory&lt;/em&gt; 和 &lt;em&gt;used_memory_peak&lt;/em&gt;
进行监控，为使用内存量设定阈值，并设定相应的报警机制。当然，报警只是手段，重要的是你得预先计划好，当内存使用量过大后，你应该做些什么，是清除一些没用的冷数据，还是把
Redis 迁移到更强大的机器上去。&lt;/p&gt;

&lt;h2&gt;持久化&lt;/h2&gt;

&lt;p&gt;如果因为你的机器或 Redis 本身的问题导致 Redis
崩溃了，那么你唯一的救命稻草可能就是 dump 出来的 rdb文件了，所以，对 Redis
dump 文件进行监控也是很重要的。你可以通过对 &lt;em&gt;rdb_last_save_time&lt;/em&gt;
进行监控，了解你最近一次 dump 数据操作的时间，还可以通过对
&lt;em&gt;rdb_changes_since_last_save&lt;/em&gt;
进行监控来知道如果这时候出现故障，你会丢失多少数据。&lt;/p&gt;

&lt;h2&gt;主从复制&lt;/h2&gt;

&lt;p&gt;如果你设置了主从复制模式，那么你最好对复制的情况是否正常做一些监控，主要是对
info 输出中的 &lt;em&gt;master_link_status&lt;/em&gt; 进行监控，如果这个值是
up，那么说明同步正常，如果是
down，那么你就要注意一下输出的其它一些诊断信息了。比如下面这些：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;role:slave
master_host:192.168.1.128
master_port:6379
master_link_status:down
master_last_io_seconds_ago:-1
master_sync_in_progress:0
master_link_down_since_seconds:1356900595
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Fork 性能&lt;/h2&gt;

&lt;p&gt;当 Redis 持久化数据到磁盘上时，它会进行一次 fork 操作，通过 fork 对内存的
copy on write 机制最廉价的实现内存镜像。但是虽然内存是 copy on write
的，但是虚拟内存表是在 fork 的瞬间就需要分配，所以 fork
会造成主线程短时间的卡顿（停止所有读写操作），这个卡顿时间和当前 Redis
的内存使用量有关。通常 GB 量级的 Redis 进行 fork
操作的时间在毫秒级。你可以通过对 info 输出的 &lt;em&gt;latest_fork_usec&lt;/em&gt;
进行监控来了解最近一次 fork 操作导致了多少时间的卡顿。&lt;/p&gt;

&lt;h2&gt;配置一致&lt;/h2&gt;

&lt;p&gt;Redis 支持使用 &lt;a href=&quot;http://redis.io/commands/config-set&quot;&gt;CONFIG SET&lt;/a&gt;操作来实现运行实的配置修改，这很方便，但同时也会导致一个问题。就是通过这个命令动态修改的配置，是不会同步到你的配置文件中去的。所以当你因为某些原因重启Redis 时，你使用 CONFIG SET做的配置修改就会丢失掉，所以我们最好保证在每次使用 CONFIG SET修改配置时，也把配置文件一起相应地改掉。为了防止人为的失误，所以我们最好对配置进行监控，使用&lt;a href=&quot;http://redis.io/commands/config-get&quot;&gt;CONFIG GET&lt;/a&gt;命令来获取当前运行时的配置，并与 redis.conf中的配置值进行对比，如果发现两边对不上，就启动报警。&lt;/p&gt;

&lt;h2&gt;慢日志&lt;/h2&gt;

&lt;p&gt;Redis 提供了 &lt;a href=&quot;http://redis.io/commands/slowlog&quot;&gt;SLOWLOG&lt;/a&gt;指令来获取最近的慢日志，Redis的慢日志是直接存在内存中的，所以它的慢日志开销并不大，在实际应用中，我们通过crontab 任务执行 SLOWLOG 命令来获取慢日志，然后将慢日志存到文件中，并用&lt;a href=&quot;http://kibana.org/&quot;&gt;Kibana&lt;/a&gt; 生成实时的性能图表来实现性能监控。&lt;/p&gt;

&lt;p&gt;值得一提的是，Redis 的慢日志记录的时间，仅仅包括 Redis自身对一条命令的执行时间，不包括 IO 的时间，比如接收客户端数据和发送客户端数据这些时间。另外，Redis的慢日志和其它数据库的慢日志有一点不同，其它数据库偶尔出现 100ms的慢日志可能都比较正常，因为一般数据库都是多线程并发执行，某个线程执行某个命令的性能可能并不能代表整体性能，但是对Redis来说，它是单线程的，一旦出现慢日志，可能就需要马上得到重视，最好去查一下具体是什么原因了。&lt;/p&gt;

&lt;h2&gt;监控服务&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;-Sentinel&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://redis.io/topics/sentinel&quot;&gt;Sentinel&lt;/a&gt; 是 Redis 自带的工具，它可以对Redis主从复制进行监控，并实现主挂掉之后的自动故障转移。在转移的过程中，它还可以被配置去执行一个用户自定义的脚本，在脚本中我们就能够实现报警通知等功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-Redis Live&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.nkrode.com/article/real-time-dashboard-for-redis&quot;&gt;Redis Live&lt;/a&gt;
是一个更通用的 Redis 监控方案，它的原理是定时在 Redis 上执行&lt;a href=&quot;http://redis.io/commands/monitor&quot;&gt;MONITOR&lt;/a&gt; 命令，来获取当前 Redis 当前正在执行的命令，并通过统计分析，生成web页面的可视化分析报表。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-Redis Faina&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://instagram-engineering.tumblr.com/post/23132009381/redis-faina-a-query-analysis-tool-for-redis&quot;&gt;Redis Faina&lt;/a&gt;
是由著名的图片分享应用 instagram 开发的 Redis 监控服务，其原理和 Redis Live 类似，都是对通过&lt;a href=&quot;http://blog.nosqlfan.com/tags/monitor&quot; title=&quot;查看 MONITOR 的全部文章&quot;&gt;MONITOR&lt;/a&gt;来做的。&lt;/p&gt;

&lt;h2&gt;数据分布&lt;/h2&gt;

&lt;p&gt;弄清 Redis 中数据存储分布是一件很难的是，比如你想知道哪类型的 key
值占用内存最多。下面是一些工具，可以帮助你对 Redis 的数据集进行分析。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-Redis-sampler&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/antirez/redis-sampler&quot;&gt;Redis-sampler&lt;/a&gt; 是 Redis作者开发的工具，它通过采样的方法，能够让你了解到当前 Redis 中的数据的大致类型，数据及分布状况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-Redis-audit&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/snmaynard/redis-audit&quot;&gt;Redis-audit&lt;/a&gt;
是一个脚本，通过它，我们可以知道每一类 key
对内存的使用量。它可以提供的数据有：某一类 key
值的访问频率如何，有多少值设置了过期时间，某一类 key
值使用内存的大小，这很方便让我们能排查哪些 key 不常用或者压根不用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-Redis-rdb-tools&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/sripathikrishnan/redis-rdb-tools&quot;&gt;Redis-rdb-tools&lt;/a&gt;
跟 Redis-audit 功能类似，不同的是它是通过对 rdb
文件进行分析来取得统计数据的。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>BSON特性探讨及基于其特性的MongoDB优化</title>
   <link href="http://beango.github.com/archives/2013/01/12/bson-and-data-interchange.html"/>
   <updated>2013-01-12T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/01/12/bson-and-data-interchange</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://bsonspec.org/&quot;&gt;BSON&lt;/a&gt;是由10gen开发的一个数据格式，目前主要用于&lt;a href=&quot;http://blog.nosqlfan.com/tags/mongodb&quot; title=&quot;查看 MongoDB 的全部文章&quot;&gt;MongoDB&lt;/a&gt;中，是MongoDB的数据存储格式。BSON基于JSON格式，选择JSON进行改造的原因主要是JSON的通用性及JSON的schemaless的特性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-01/UIQZU.gif&quot; title=&quot;BSON&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;BSON主要会实现以下三点目标：&lt;/p&gt;

&lt;h3&gt;1.更快的遍历速度&lt;/h3&gt;

&lt;p&gt;对JSON格式来说，太大的JSON结构会导致数据遍历非常慢。在JSON中，要跳过一个文档进行数据读取，需要对此文档进行扫描才行，需要进行麻烦的数据结构匹配，比如括号的匹配，而BSON对JSON的一大改进就是，它会将JSON的每一个元素的长度存在元素的头部，这样你只需要读取到元素长度就能直接seek到指定的点上进行读取了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MongoDB优化&lt;/strong&gt;：对于MongoDB来说，由于采用了MMAP来做内存与数据文件的映射，在更新或者获取Document的某一个字段时，如果需要先读取其前面的所有字段，会导致物理内存由于读操作被加载到不必要的字段上，导致资源的不合理分配。而采用BSON只需要读到相应的位置然后跨过无用内容读取需要内容即可。&lt;/p&gt;

&lt;h3&gt;2.操作更简易&lt;/h3&gt;

&lt;p&gt;对JSON来说，数据存储是无类型的，比如你要修改基本一个值，从9到10，由于从一个字符变成了两个，所以可能其后面的所有内容都需要往后移一位才可以。而使用BSON，你可以指定这个列为数字列，那么无论数字从9长到10还是100，我们都只是在存储数字的那一位上进行修改，不会导致数据总长变大。当然，在MongoDB中，如果数字从整形增大到长整型，还是会导致数据总长变大的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MongoDB优化&lt;/strong&gt;：所以使用MongoDB的一个技巧是将长度可能变化的字段尽量命名靠后（MongoDB在update操作后会将字段按key值按字母顺序重排，所以靠后的意思是按a－z的顺序取名）。这样在更新的时候如果导致数字变长，不需要移动大量数据。一个典型的例子是如果用二进制类型存储文件时，如果文件名或者文件描述可能会变长，那么尽量将这个字段取名靠后是一个明智的选择，否则在文件名或文件描述字段变化时，会导致移动很长的二进制数据，造成不必要的浪费。&lt;/p&gt;

&lt;h3&gt;3.增加了额外的数据类型&lt;/h3&gt;

&lt;p&gt;JSON是一个很方便的数据交换格式，但是其类型比较有限。BSON在其基础上增加了“byte
array”数据类型。这使得二进制的存储不再需要先base64转换后再存成JSON。大大减少了计算开销和数据大小。&lt;/p&gt;

&lt;p&gt;当然，在有的时候，BSON相对JSON来说也并没有空间上的优势，比如对{“field”:7}，在JSON的存储上7只使用了一个字节，而如果用BSON，那就是至少4个字节（32位）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MongoDB优化&lt;/strong&gt;：在MongoDB中，如果你的字段是数字型，并且涉及到数据加减操作的，那么建议存在int型，但如果是一个固定不变的数字，并且在四位以下的话，可以考虑存成字符串类型。这样会节省空间。&lt;/p&gt;

&lt;p&gt;目前在10gen的努力下，BSON已经有了针对多种语言的编码解码包。并且都是Apache 2 license下开源的。并且还在随着MongoDB进一步地发展。关于BSON，你可以在其官方网站 &lt;a href=&quot;http://bsonspec.org/&quot;&gt;bsonspec.org&lt;/a&gt;上获取更多信息。&lt;/p&gt;

&lt;p&gt;来源：&lt;a href=&quot;http://blog.mongodb.org/post/9333386434/bson-and-data-interchange&quot;&gt;blog.mongodb.org&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>编写高效的JavaScript程序</title>
   <link href="http://beango.github.com/archives/2013/01/11/writing-fast-memory-efficient-javascript.html"/>
   <updated>2013-01-11T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/01/11/writing-fast-memory-efficient-javascript</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;英文原文：&lt;/strong&gt;&lt;a href=&quot;http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/&quot; title=&quot;Read 'Writing Fast, Memory-Efficient JavaScript'&quot;&gt;Writing Fast, Memory-Efficient JavaScript&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Addy Osmani是谷歌公司Chrome团队中的一名程序开发工程师。他是一位JavaScript爱好者，曾经编写过一本开放源码方面的书籍《&lt;a href=&quot;http://addyosmani.com/resources/essentialjsdesignpatterns/book/&quot;&gt;Learning
JavaScript Design Patterns&lt;/a&gt;》以及《Developing Backbone
Applications》。为Modernizr和jQuery社区贡献了开源项目，目前正在从事‘Yeoman’项目，旨在为开发者提供一系列健壮的工具、程序库和工作流，帮助他们快速构建出漂亮、引人注目的Web应用。本文作者将带领大家探索高效编写代码的测试验证方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;文章内容如下：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　JavaScript引擎包括Google
V8（Chrome，Node）都是专为快速执行大型JavaScript程序而设计的。在开发过程中，如果你在乎内存使用率和性能情况，那么你应该会关心在用户的浏览器中JavaScript引擎背后是怎么样的。无论是V8、SpiderMonkey
(Firefox)、Carakan (Opera)、Chakra (IE)
还是其他，有了它们可以帮助你更好的优化应用程序。&lt;/p&gt;

&lt;p&gt;　　我们应该时不时地询问自己：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我还能做些什么使代码更加有效？&lt;/li&gt;
&lt;li&gt;主流的JavaScript引擎做了哪些优化？&lt;/li&gt;
&lt;li&gt;什么是引擎无法优化的，我能期待利用垃圾回收进行清洁吗？&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/assets/files/2013-01/30222814-d81e4caabffe4608b364814a05d30152.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　快速的加载Web网页就如同汽车一样，需要使用特殊工具。&lt;/p&gt;

&lt;p&gt;　　当涉及到编写高效的内存和快速创建代码时总会出现一些常见的弊端，在这篇文章中我们将探索高效编写代码的测试验证方法。&lt;/p&gt;

&lt;h2&gt;一、JavaScript如何在V8中工作？&lt;/h2&gt;

&lt;p&gt;　　如果你对JS引擎没有较深的了解，开发一个大型Web应用也没啥问题，就好比会开车的人也只是看过引擎盖而没有看过车盖内的引擎一样（这里将Web网页比如成汽车）。Chrome浏览器是我的优先选择，这里我将谈下V8的核心组件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一个基本的编译器&lt;/strong&gt;，在代码执行前分析JavaScript、生成本地机器代码而非执行字节代码或是简单的解释，该段代码之初不是高度优化的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;V8用对象模型“表述”对象。&lt;/strong&gt;在JavaScript中，对象是一个关联数组，但是V8中，对象被“表述”为隐藏类，这种隐藏类是V8的内部类型，用于优化后的查找。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行时分析器&lt;/strong&gt;监视正在运行的系统并优化“hot”（活跃）函数。（比如，终结运行已久的代码）&lt;/li&gt;
&lt;li&gt;通过运行时分析器把&lt;strong&gt;优化编译器&lt;/strong&gt;重新编译和被运行时分析器标识为“hot”的代码
，这是一种有效的编译优化技术,（例如用被调用者的主体替换函数调用的位置）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;V8支持去优化&lt;/strong&gt;，也就是说当你发现一些假设的优化代码太过乐观，优化编译器可以退出已生成的代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;垃圾回收&lt;/strong&gt;，了解它是如何工作的，如同优化JavaScript一样同等重要。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;二、垃圾回收&lt;/h2&gt;

&lt;p&gt;　　垃圾回收是内存管理的一种形式，它试图通过将不再使用的对象修复从而释放内存占用率。垃圾回收语言（比如JavaScript）是指在JavaScript这种垃圾回收语言中，应用程序中仍在被引用的对象不会被清除。手动消除对象引用在大多数情况下是没有必要的。通过简单地把变量放在需要它们的地方（理想情况下，尽可能是局部作用域，即它们被使用的函数里而不是函数外层），一切将运作地很好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-01/30222814-1daecc2610464207ace4ff0b55bf6478.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;div style=&quot;text-align:center;&quot;&gt;垃圾回收清除内存&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;　　在JavaScript中强制执行垃圾回收是不可取的，当然，你也不会想这么做，因为垃圾回收进程被运行时控制着，它知道什么时候才是适合清理代码的最好时机。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. “消除引用”的误解（De-Referencing Misconceptions）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在JavaScript中回收内存在网上引发了许多争论，虽然它可以被用来删除对象（map）中的属性（key），但有部分开发者认为它可以用来强制“消除引用”。建议尽可能避免使用delete，在下面的例子中delete
o.x 的弊大于利，因为它改变了o的隐藏类，使它成为通用的慢对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var o = { x: 1 };       
    delete o.x; // true     
    o.x; // undefined 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　目的是为了在运行时避免修改活跃对象的结构，JavaScript引擎可以删除类似“hot”对象，并试图对其进行优化。如果该对象的结果没有太大改变，超过生命周期，删除可能会导致其改变。&lt;/p&gt;

&lt;p&gt;　　对于null是如何工作也是有误解的。将一个对象引用设置为null，并没有使对象变“空”，只是将它的引用设置为空而已。使用o.x=null比使用delete会更好些，但可能也不是很必要。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var o = { x: 1 };      
    o = null;       
    o; // null     
    o.x // TypeError      
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　如果这个引用是最后一个引用对象，那么该对象可进行垃圾回收；倘若不是，那么此方法不可行。注意，无论您的网页打开多久，全局变量不能被垃圾回收清理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myGlobalNamespace = {}; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;当你刷新新页面时，或导航到不同的页面，关闭标签页或是退出浏览器，才可进行全局清理；当作用域不存在这个函数作用域变量时，这个变量才会被清理，即该函数被退出或是没有被调用时，变量才能被清理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;经验法则：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　为了给垃圾回收创造机会，尽可能早的收集对象，尽量不要隐藏不使用的对象。这一点主要是自动发生，这里有几点需要谨记：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;正如之前我们提到的，手动引用在合适的范围内使用变量是个更好的选择，而不是将全局变量清空，只需使用不再需要的局部函数变量。也就是说我们不要为清洁代码而担心。&lt;/li&gt;
&lt;li&gt;确保移除不再需要的事件侦听器，尤其是当DOM对象将要被移除时。&lt;/li&gt;
&lt;li&gt;如果你正在使用本地数据缓存，请务必清洁该缓存或使用老化机制来避免存储那些不再使用的大量数据。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;2. 函数（Functions）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　正如我们前面提到的垃圾回收的工作原理是对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。下面的例子能够更好的说明这一点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function foo() {     
        var bar = new LargeObject();      
        bar.someCall();       
    }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　当foo返回时，bar自动指向垃圾回收对象，这是因为没被调用，这里我们将做个对比：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function foo() {       
        var bar = new LargeObject();      
        bar.someCall();     
    　　return bar;      
    }  
    // somewhere else      
    var b = foo();      
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　这里有个调用对象且被一直调用着直到这个调用交给b（或是超出b范围）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 闭包（Closures）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　当你看到一个函数返回到内部函数，该内部函数可以访问外部函数，即使外部函数正在被执行。这基本上是一个封闭的，可以在特定的范围内设置变量的表达式。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function sum (x) {  
        function sumIt(y) {  
            return x + y;  
        };  
        return sumIt;  
    }  
    // Usage  
    var sumA = sum(4);  
    var sumB = sumA(3);  
    console.log(sumB); // Returns 7 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　在sum调用上下文中生成的函数对象（sumIt）是无法被回收的，它被全局变量（sumA）所引用，并且可以通过sumA(n)调用。&lt;/p&gt;

&lt;p&gt;　　这里有个示例演示如何访问largeStr？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var a = function () {  
        var largeStr = new Array(1000000).join('x');  
        return function () {  
            return largeStr;  
        };  
    }();  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我们可以通过a()：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var a = function () {  
        var smallStr = 'x';  
        var largeStr = new Array(1000000).join('x');  
        return function (n) {  
            return smallStr;  
        };  
    }();  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　此时，我们不能访问了，因为它是垃圾回收的候选者。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 计时器（Timers）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　最糟糕的莫过于在循环中泄露，或者在setTimeout()/setInterval()中，但这却是常见的问题之一。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var myObj = {  
        callMeMaybe: function () {  
            var myRef = this;  
            var val = setTimeout(function () {  
                console.log('Time is running out!');  
                myRef.callMeMaybe();  
            }, 1000);  
        }  
    };  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　如果我们运行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myObj.callMeMaybe(); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　在计时器开始前，我们看到每一秒“时间已经不多了”，这时，我们将运行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myObj = null; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;三、当心性能陷阱&lt;/h2&gt;

&lt;p&gt;　　除非你真正需要，否则永远不要优化代码。在V8中你能轻易的看到一些细微的基准测试显示比如N比M更佳，但是在真实的模块代码中或是在实际的应用程序中测试，这些优化所带来的影响要比你想象中要小的多。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-01/30222814-7d1a23445e9e4a0e9f526ecc058d3327.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建一个模块，这里有三点：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;采用本地的数据源包含ID数值&lt;/li&gt;
&lt;li&gt;绘制一个包含这些数据的表格&lt;/li&gt;
&lt;li&gt;添加事件处理程序，当用户点击的任何单元格时切换单元格的css class&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;　　如何存储数据？如何高效的绘制表格并追加到DOM？怎样处理表单上的事件？&lt;/p&gt;

&lt;p&gt;　　注意：下面的这段代码，千万不能做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var moduleA = function () {  
        return {  
            data: dataArrayObject,  
            init: function () {  
                this.addTable();  
                this.addEvents();  
            },  
            addTable: function () {  
                for (var i = 0; i &amp;lt; rows; i++) {  
                    $tr = $('&amp;lt;tr&amp;gt;&amp;lt;/tr&amp;gt;');  
                    for (var j = 0; j &amp;lt; this.data.length; j++) {  
                        $tr.append('&amp;lt;td&amp;gt;' + this.data[j]['id'] + '&amp;lt;/td&amp;gt;');  
                    }  
                    $tr.appendTo($tbody);  
                }  
            },  
            addEvents: function () {  
                $('table td').on('click', function () {  
                    $(this).toggleClass('active');  
                });  
            }  
        };  
    }();  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　很简单，但是却能把工作完成的很好。&lt;/p&gt;

&lt;p&gt; 　　请注意，直接使用DocumentFragment和本地DOM方法生成表格比使用jQuery更佳，事件委托通常比单独绑定每个td更具备高性能。jQuery一般在内部使用DocumentFragment，但是在这个例子中，通过内循环调用代码append()
，因此，无法在这个例子中进行优化，但愿这不是一个诟病，但请务必将代码进行基准测试。&lt;/p&gt;

&lt;p&gt;　　这里，我们通过opting for
documentFragment提高性能，事件代理对简单的绑定是一种改进，可选的DocumentFragment也起到了助推作用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var moduleD = function () {        
        return {       
            data: dataArray,         
            init: function () {  
                this.addTable();  
                this.addEvents();  
            },  
            addTable: function () {  
                var td, tr;  
                var frag = document.createDocumentFragment();  
                var frag2 = document.createDocumentFragment();  
                for (var i = 0; i &amp;lt; rows; i++) {  
                    tr = document.createElement('tr');  
                    for (var j = 0; j &amp;lt; this.data.length; j++) {  
                        td = document.createElement('td');  
                        td.appendChild(document.createTextNode(this.data[j]));  
                        frag2.appendChild(td);  
                    }  
                    tr.appendChild(frag2);  
                    frag.appendChild(tr);  
                }  
                tbody.appendChild(frag);  
            },  
            addEvents: function () {  
                $('table').on('click', 'td', function () {  
                    $(this).toggleClass('active');  
                });  
            }         
        };         
    }();  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我们不妨看看其他提供性能的方法，也许你曾读过使用原型模式或是使用JavaScript模板框架进行高度优化。但是使用这些仅针对可读的代码。此外，还有预编译。我们一起来实践下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    moduleG = function () {};         
    moduleG.prototype.data = dataArray;  
    moduleG.prototype.init = function () {  
        this.addTable();  
        this.addEvents();  
    };  
    moduleG.prototype.addTable = function () {  
        var template = _.template($('#template').text());  
        var html = template({'data' : this.data});  
        $tbody.append(html);  
    };  
    moduleG.prototype.addEvents = function () {  
       $('table').on('click', 'td', function () {  
           $(this).toggleClass('active');  
       });  
    };  
    var modG = new moduleG();  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　事实证明，选择模板和原型并没有给我们带来多大好处。&lt;/p&gt;

&lt;h2&gt;四、V8引擎优化技巧：&lt;/h2&gt;

&lt;p&gt;　　特定的模式会导致V8优化产生故障。很多函数无法得到优化，你可以在V8平台使用–trace-opt
file.js搭配d8实用程序。&lt;/p&gt;

&lt;p&gt;　　如果你关心速度，那么尽最大努力确保单态函数(functions
monomorphic)，确保变量（包括属性，数组和函数参数）只适应同样的隐藏类包含的对象。&lt;/p&gt;

&lt;p&gt;　　下面的代码演示了，我们不可这么做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function add(x, y) {  
       return x+y;  
    }  
    add(1, 2);  
    add('a','b');  
    add(my_custom_object, undefined);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;未初始化时不要加载和执行删除操作，因为它们并没有输出差异，这样做反而会使程序变得更慢。不要编写大量函数，函数越多越难优化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Objects使用技巧：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　适应构造函数来创建对象。这将确保所创建的所有对象具备相同的隐藏类并有帮助避免更改这些类。&lt;/p&gt;

&lt;p&gt;　　在程序或者复杂性上不要限制多种对象类型。（原因：长原型链中倾向于伤害，只有极少数的对象属性得到一个特殊的委托）对于活跃对象保持短原型链以及低字段计数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 对象克隆（Object Cloning）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　对象克隆对于应用开发者来说是一种常见的现象。虽然在V8中这是实现各种类型问题的基准，但是当你进行复制时，一定要当心。当复制较大的程序时通常很会慢，因此，尽量不要这么做。在JavaScript循环中此举是非常糟糕的。这里有个最快的技巧方案，你不妨学习下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function clone(original) {  
      this.foo = original.foo;  
      this.bar = original.bar;  
    }  
    var copy = new clone(original);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3. 模块模式中的缓存功能&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在模块模式中使用缓存功能也许在性能方面会有所提升。请参阅下面的例子，通过jsPerf
test测试。注，使用这种方法比依靠原型模式更佳。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-01/30222814-2290aec479784183a360e757fbc3677c.png&quot; title=&quot;Performance Improvements When Using The Module And Prototypal Patterns&quot; alt=&quot;Performance improvements&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　推荐：&lt;a href=&quot;http://jsperf.com/prototypal-performance/12&quot;&gt;这是测试原型与模块模式性能代码&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  // Prototypal pattern  
  Klass1 = function () {}  
  Klass1.prototype.foo = function () {  
      log('foo');  
  }  
  Klass1.prototype.bar = function () {  
      log('bar');  
  }  
  // Module pattern  
  Klass2 = function () {  
      var foo = function () {  
          log('foo');  
      },  
      bar = function () {  
          log('bar');  
      };  
      return {  
          foo: foo,  
          bar: bar  
      }  
  }  
  // Module pattern with cached functions  
  var FooFunction = function () {  
      log('foo');  
  };  
  var BarFunction = function () {  
      log('bar');  
  };  
   Klass3 = function () {  
      return {  
          foo: FooFunction,  
          bar: BarFunction  
      }  
  }  
  // Iteration tests  
  // Prototypal  
  var i = 1000,  
      objs = [];  
  while (i--) {  
      var o = new Klass1()  
      objs.push(new Klass1());  
      o.bar;  
      o.foo;  
  }  
  // Module pattern  
  var i = 1000,  
      objs = [];  
  while (i--) {  
      var o = Klass2()  
      objs.push(Klass2());  
      o.bar;  
      o.foo;  
  }  
  // Module pattern with cached functions  
  var i = 1000,  
      objs = [];  
  while (i--) {  
      var o = Klass3()  
      objs.push(Klass3());  
      o.bar;  
      o.foo;  
  }  
  // See the test for full details
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4. 数组使用技巧：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　一般情况下，我们不要删除数组元素。它是使数组过渡到较慢的内部表现形式。当密钥集变得稀疏时，V8最终将切换到字典模式，这是变慢的原因之一。&lt;/p&gt;

&lt;h2&gt;五、应用优化技巧&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;　　在Web应用领域里，速度就是一切。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　没有用户希望在启动电子表格时需要等上几秒钟，或者花上几分钟时间来整理信息。这也是为什么在性能方面，需要格外注意的一点，有人甚至将编码阶段称为至关重要的一部分。&lt;/p&gt;

&lt;p&gt;　　理解和提升性能方面是非常有用的，但它也有一定的难度。这里推荐几个步骤来帮你解决：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;测试：在应用程序中找到慢的节点 (~45%)&lt;/li&gt;
&lt;li&gt;理解：查找问题所在(~45%)&lt;/li&gt;
&lt;li&gt;修复:(~10%)&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;　　当然，还有许多工具或是技术方案帮助解决以上这些问题：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 基准测试。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在JavaScript上有许多方法可进行基准测试。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.剖析。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　Chrome开发工具能够很好的支持JavaScript分析器。你可以使用这些性能进行检测，哪些功能占用的时间比较长，然后对其进行优化。最重要的是，即使是很小的改变也能影响整体的表现。关于这款&lt;a href=&quot;http://coding.smashingmagazine.com/2012/06/12/javascript-profiling-chrome-developer-tools/&quot;&gt;分析工具&lt;/a&gt;，&lt;a href=&quot;http://coding.smashingmagazine.com/2012/06/12/javascript-profiling-chrome-developer-tools/&quot;&gt;这里&lt;/a&gt;有份详细的介绍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.避免内存泄露-3快照技术。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　谷歌开发团队通常会使用Chrome开发工具包括Gmail来帮助他们发现和修复内存泄露；此外，[&lt;strong&gt;3snapshot&lt;/strong&gt;][]也是不错的选择。该技术允许在程序中记录一些行为、强制垃圾回收、查询，如果DOM节点无法返回预期的基线上，3snapshot帮助分析确定是否存在内存泄露。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.单页面程序上的内存管理。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　当你在编写单页程序时（比如，AngularJS，Backbone，Ember)），内存管理非常重要，他们从未得到刷新。这就意味着内存泄露很明显。在移动单页程序上存在着巨大的陷阱，因为内存有限，长期运行的程序比如email客户端或者社交网络应用。因此，它肩负着巨大的责任。&lt;/p&gt;

&lt;p&gt;　　Derick发表了这篇《&lt;a href=&quot;http://lostechies.com/derickbailey/2012/03/19/backbone-js-and-javascript-garbage-collection/&quot;&gt;memory
pitfalls&lt;/a&gt;》教您如何使用Backbone.js以及如何进行修复。Felix
Geisendörfer的这篇&lt;a href=&quot;http://lostechies.com/derickbailey/2012/03/19/backbone-js-and-javascript-garbage-collection/&quot;&gt;在Node中调试内存泄露&lt;/a&gt;也值得一读。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.最小化回流&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;http://stackoverflow.com/questions/510213/when-does-reflow-happen-in-a-dom-environment&quot;&gt;回流&lt;/a&gt;是指在浏览器中用户阻止此操作，所以它是有助于理解如何提高回流时间，你可以使用&lt;a href=&quot;http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-B63ED1A3&quot;&gt;DocumentFragment&lt;/a&gt;一个轻量级的文档对象来处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. Javascript内存泄露检测器&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;　　由Marja Hölttä和Jochen Eisinger两人开发的&lt;a href=&quot;http://google-opensource.blogspot.de/2012/08/leak-finder-new-tool-for-javascript.html&quot;&gt;这款&lt;/a&gt;工具，你不妨试试。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7. V8 flags调试优化和内存回收&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;　　Chrome支持通过flags和js-flags flag获取更详细的输出：&lt;/p&gt;

&lt;p&gt;　　例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;/Applications/Google Chrome/Google Chrome&quot; --js-flags=&quot;--trace-opt --trace-deopt&quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　Windows用户运行chrome.exe –js-flags=“–trace-opt –trace-deopt”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当开发应用时，可以使用下面的V8 flags：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;trace-opt –日志名称的优化功能，显示优化跳过的代码&lt;/li&gt;
&lt;li&gt;trace-deopt –记录运行时将要“去优化”的代码。&lt;/li&gt;
&lt;li&gt;trace-gc – 对每次垃圾回收时进行跟踪&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;结束语：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　正如上面提到的，在JavaScript引擎中有许多隐藏的陷阱，世界上没有什么好的银弹能够帮助你提高性能，只有通过在测试环境中进行优化，实现最大的性能收益。因此，了解引擎如何输出和优化代码可以帮助你调整应用程序。&lt;/p&gt;

&lt;p&gt;　　因此，测试它、理解它、修复它，如此往复！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>趣解HTTP状态码</title>
   <link href="http://beango.github.com/archives/2013/01/09/interesting-solution-http-status-code.html"/>
   <updated>2013-01-09T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/01/09/interesting-solution-http-status-code</id>
   <content type="html">&lt;p&gt;　　前两天，在豆瓣上看到一个讲解HTTP状态码的文章，觉得很搞笑。虽说我也是搞IT的，也经常见到服务器返回的各种HTTP状态码，但是真没认真去了解过这个东东。借此机会，我也搜集了一下HTTP状态码的相关资料，和大家分享一下。&lt;/p&gt;

&lt;p&gt;　　HTTP状态码（HTTP Status
Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC2616
规范定义的，并得到RFC2518、RFC2817、RFC2295、RFC2774、RFC2918等规范扩展。&lt;/p&gt;

&lt;p&gt;　　HTTP状态码一共分为五类。状态码的第一个数字代表了响应的五种状态之一。分类如下：&lt;/p&gt;

&lt;table style=&quot;width: 98%;&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;&lt;caption&gt;HTTP状态码分类&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;col&quot; width=&quot;52&quot;&gt;分类&lt;/th&gt;&lt;th scope=&quot;col&quot; width=&quot;833&quot;&gt;含义&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot; width=&quot;52&quot;&gt;1XX&lt;/th&gt;
&lt;td width=&quot;833&quot;&gt;表示消息。这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot; width=&quot;52&quot;&gt;2XX&lt;/th&gt;
&lt;td width=&quot;833&quot;&gt;表示成功。这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot; width=&quot;52&quot;&gt;3XX&lt;/th&gt;
&lt;td width=&quot;833&quot;&gt;表示重定向。这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot; width=&quot;52&quot;&gt;4XX&lt;/th&gt;
&lt;td width=&quot;833&quot;&gt;表示请求错误。这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot; width=&quot;52&quot;&gt;5XX&lt;/th&gt;
&lt;td width=&quot;833&quot;&gt;表示服务器错误。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;　　下面，我们就开始趣解HTTP状态码。（少儿不宜，十八岁以下禁止观看啊。哈哈…）&lt;/p&gt;

&lt;table style=&quot;width: 98%;&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;&lt;caption&gt;趣解HTTP状态码&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;col&quot; width=&quot;52&quot;&gt;状态码&lt;/th&gt;&lt;th scope=&quot;col&quot; width=&quot;230&quot;&gt;英/中双解&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;汉语解释&lt;/th&gt;&lt;th scope=&quot;col&quot; width=&quot;150&quot;&gt;趣解&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot; colspan=&quot;4&quot;&gt;1XX—表示消息。这一类型的状态码，代表请求已被接受，需要继续处理。&lt;/th&gt;&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;100&lt;/th&gt;
&lt;td&gt;Continue/继续&lt;/td&gt;
&lt;td&gt;客户端应当继续发送请求。&lt;/td&gt;
&lt;td&gt;人家... 还要...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;101&lt;/th&gt;
&lt;td&gt;Switching Protocols/转换协议&lt;/td&gt;
&lt;td&gt;服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。&lt;/td&gt;
&lt;td&gt;服务姬傲娇中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;102&lt;/th&gt;
&lt;td&gt;Processing&lt;/td&gt;
&lt;td&gt;由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。&lt;/td&gt;
&lt;td&gt;造人中…&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot; colspan=&quot;4&quot;&gt;2XX—表示成功。代表请求已成功被服务器接收、理解、并接受。&lt;/th&gt;&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;200&lt;/th&gt;
&lt;td&gt;OK/正常&lt;/td&gt;
&lt;td&gt;请求已成功，请求所希望的响应头或数据体将随此响应返回。&lt;/td&gt;
&lt;td&gt;欢迎回来, 主人&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;201&lt;/th&gt;
&lt;td&gt;Created/已创建&lt;/td&gt;
&lt;td&gt;表示服务器在请求的响应中建立了新文档；应在定位头信息中给出它的URL。&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;202&lt;/th&gt;
&lt;td&gt;Accepted/接受&lt;/td&gt;
&lt;td&gt;服务器已接受请求，但尚未处理完。&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;203&lt;/th&gt;
&lt;td&gt;Non-Authoritative Information/非官方信息&lt;/td&gt;
&lt;td&gt;表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确。&lt;/td&gt;
&lt;td&gt;俺是小三&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;204&lt;/th&gt;
&lt;td&gt;No Content/无内容&lt;/td&gt;
&lt;td&gt;表示服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。在并没有新文档的情况下，确保浏览器继续显示先前的文档。&lt;/td&gt;
&lt;td&gt;小姐呢？！怎么没有？&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;205&lt;/th&gt;
&lt;td&gt;Reset Content/重置内容&lt;/td&gt;
&lt;td&gt;意思是虽然没有新文档但浏览器要重置文档显示。这个状态码用于强迫浏览器清除表单域。&lt;/td&gt;
&lt;td&gt;先生，给你换个小姐？&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;206&lt;/th&gt;
&lt;td&gt;Partial Content/局部内容&lt;/td&gt;
&lt;td&gt;该请求必须包含Range头信息来指示客户端希望得到的内容范围，并且可能包含If-Range来作为请求条件。&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;207&lt;/th&gt;
&lt;td&gt;&lt;em&gt;Multi-Status/多种状态&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。&lt;/td&gt;
&lt;td&gt;搞个NP。嘿嘿…&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot; colspan=&quot;4&quot;&gt;3xx—表示重定向。代表需要客户端采取进一步的操作才能完成请求。&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;300&lt;/th&gt;
&lt;td&gt;Multiple Choices/多重选择&lt;/td&gt;
&lt;td&gt;表示被请求的文档可以在多个地方找到，并将在返回的文档中列出来。&lt;/td&gt;
&lt;td&gt;先生，请点菜。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;301&lt;/th&gt;
&lt;td&gt;&lt;em&gt;Moved Permanently/永久迁移&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;指所请求的文档在别的地方；文档新的URL会在定位响应头信息中给出。浏览器会自动连接到新的URL。&lt;/td&gt;
&lt;td&gt;人家搬家了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;302&lt;/th&gt;
&lt;td&gt;Found/找到&lt;/td&gt;
&lt;td&gt;与301有些类似，只是定位头信息中所给的URL应被理解为临时交换地址而不是永久的。&lt;/td&gt;
&lt;td&gt;亲，先等下啦，人家先去洗白白嘛。。。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;303&lt;/th&gt;
&lt;td&gt;See Other/参见其他信息&lt;/td&gt;
&lt;td&gt;和 301、302 相似，只是如果最初的请求是 POST，那么新文档（在定位头信息中给出）药用 GET 找回。&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;304&lt;/th&gt;
&lt;td&gt;Not Modified/没有修改&lt;/td&gt;
&lt;td&gt;如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。&lt;/td&gt;
&lt;td&gt;好久不见，还是风味犹存啊。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;305&lt;/th&gt;
&lt;td&gt;Use Proxy/使用代理&lt;/td&gt;
&lt;td&gt;表示所请求的文档要通过定位头信息中的代理服务器获得。&lt;/td&gt;
&lt;td&gt;泡妞是需要拉皮条的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;306&lt;/th&gt;
&lt;td&gt;&lt;em&gt;Switch Proxy/切换代理&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;在最新版的规范中，306状态码已经不再被使用。&lt;/td&gt;
&lt;td&gt;这店里的鸡太差了，换个。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;307&lt;/th&gt;
&lt;td&gt;Temporary Redirect/临时重定向&lt;/td&gt;
&lt;td&gt;在响应为303时按照GET和POST请求转向；而在307响应时则按照GET请求转向而不是POST请求。&lt;/td&gt;
&lt;td&gt;不是这里, 换个地方啦&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot; colspan=&quot;4&quot;&gt;4xx—表示请求错误。代表客户端可能发生了错误，妨碍服务器的处理。&lt;/th&gt;&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;400&lt;/th&gt;
&lt;td&gt;Bad Request/错误请求&lt;/td&gt;
&lt;td&gt;指出客户端请求中的语法错误。&lt;/td&gt;
&lt;td&gt;不要把奇怪的东西给人家嘛&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;401&lt;/th&gt;
&lt;td&gt;Unauthorized/未授权&lt;/td&gt;
&lt;td&gt;表示客户端在授权头信息中没有有效的身份信息时访问受到密码保护的页面。&lt;/td&gt;
&lt;td&gt;对上对联，才让进洞房。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;403&lt;/th&gt;
&lt;td&gt;Forbidden/禁止&lt;/td&gt;
&lt;td&gt;表示除非拥有授权否则服务器拒绝提供所请求的资源。&lt;/td&gt;
&lt;td&gt;这里不可以啦!&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;404&lt;/th&gt;
&lt;td&gt;Not Found/未找到&lt;/td&gt;
&lt;td&gt;告诉客户端所给的地址无法找到任何资源。&lt;/td&gt;
&lt;td&gt;这里什么都没有 --- 人家是平的啦&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;405&lt;/th&gt;
&lt;td&gt;Method Not Allowed/方法未允许&lt;/td&gt;
&lt;td&gt;表示请求方法(GET, POST, HEAD, PUT, DELETE, 等)对某些特定的资源不允许使用。&lt;/td&gt;
&lt;td&gt;打开方式不对&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;406&lt;/th&gt;
&lt;td&gt;Not Acceptable/无法访问&lt;/td&gt;
&lt;td&gt;表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。&lt;/td&gt;
&lt;td&gt;啊啊啊,慢着!!好疼&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;407&lt;/th&gt;
&lt;td&gt;Proxy Authentication Required/代理服务器认证要求&lt;/td&gt;
&lt;td&gt;该状态指出客户端必须通过代理服务器的认证。&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;408&lt;/th&gt;
&lt;td&gt;Request Timeout/请求超时&lt;/td&gt;
&lt;td&gt;指服务端等待客户端发送请求的时间过长。&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;409&lt;/th&gt;
&lt;td&gt;Conflict/冲突&lt;/td&gt;
&lt;td&gt;该状态通常与PUT请求一同使用，409 状态常被用于试图上传版本不正确的文件时。&lt;/td&gt;
&lt;td&gt;找 小 姐找到了自己媳妇，然后…&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;410&lt;/th&gt;
&lt;td&gt;Gone/已经不存在&lt;/td&gt;
&lt;td&gt;告诉客户端所请求的文档已经不存在并且没有更新的地址。410状态不同于404，410是在指导文档已被移走的情况下使用，而404则用于未知原因的无法访问。&lt;/td&gt;
&lt;td&gt;那个，你是个好人……&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;411&lt;/th&gt;
&lt;td&gt;Length Required/需要数据长度&lt;/td&gt;
&lt;td&gt;表示服务器不能处理请求，除非客户端发送Content-Length头信息指出发送给服务器的数据的大小。&lt;/td&gt;
&lt;td&gt;太长了…进不去&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;412&lt;/th&gt;
&lt;td&gt;Precondition Failed/先决条件错误&lt;/td&gt;
&lt;td&gt;指出请求头信息中的某些先决条件是错误的。&lt;/td&gt;
&lt;td&gt;先买房，然后才能结婚。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;413&lt;/th&gt;
&lt;td&gt;Request Entity Too Large/请求实体过大&lt;/td&gt;
&lt;td&gt;告诉客户端现在所请求的文档比服务器现在想要处理的要大。&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;414&lt;/th&gt;
&lt;td&gt;Request URI Too Long/请求URI过长&lt;/td&gt;
&lt;td&gt;用于在URI过长的情况时。这里所指的&quot;URI&quot;是指URL中主机、域名及端口号之后的内容。&lt;/td&gt;
&lt;td&gt;这... 太长了啦&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;415&lt;/th&gt;
&lt;td&gt;Unsupported Media Type/不支持的媒体格式&lt;/td&gt;
&lt;td&gt;意味着请求所带的附件的格式类型服务器不知道如何处理。&lt;/td&gt;
&lt;td&gt;石女&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;416&lt;/th&gt;
&lt;td&gt;Requested Range Not Satisfiable/请求范围无法满足&lt;/td&gt;
&lt;td&gt;表示客户端包含了一个服务器无法满足的Range头信息的请求。&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;417&lt;/th&gt;
&lt;td&gt;Expectation Failed/期望失败&lt;/td&gt;
&lt;td&gt;表示在请求头Expect中指定的预期内容无法被服务器满足。&lt;/td&gt;
&lt;td&gt;没房，只能分手了。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;418&lt;/th&gt;
&lt;td&gt;&lt;em&gt;I'm a teapot/我是杯具&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;本操作码是在1998年作为IETF的传统愚人节笑话,并不需要在真实的HTTP服务器中定义。&lt;/td&gt;
&lt;td&gt;我就是个杯具啊&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;421&lt;/th&gt;
&lt;td&gt;&lt;em&gt;There are too many connections from your internet address/该IP发起的链接过多。&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;422&lt;/th&gt;
&lt;td&gt;&lt;em&gt;Unprocessable Entity/错误实体&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;请求格式正确，但是由于含有语义错误，无法响应。&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;423&lt;/th&gt;
&lt;td&gt;&lt;em&gt;Locked/锁定&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;当前资源被锁定。&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;424&lt;/th&gt;
&lt;td&gt;&lt;em&gt;Failed Dependency/错误关联&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;由于之前的某个请求发生的错误，导致当前请求失败。&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;425&lt;/th&gt;
&lt;td&gt;&lt;em&gt;Unordered Collection/乱序集合&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;在WebDav Advanced Collections草案中定义，但是未出现在《WebDAV顺序集协议》（RFC 3658）中。&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;426&lt;/th&gt;
&lt;td&gt;&lt;em&gt;Upgrade Required/升级要求&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;客户端应当切换到TLS/1.0。&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;428&lt;/th&gt;
&lt;td&gt;Precondition Required/要求先决条件&lt;/td&gt;
&lt;td&gt;先决条件是客户端发送 HTTP 请求时，如果想要请求能成功必须满足一些预设的条件。&lt;/td&gt;
&lt;td&gt;主人~~不要这么快么~人家还没湿呢。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;429&lt;/th&gt;
&lt;td&gt;Too Many Requests /太多请求&lt;/td&gt;
&lt;td&gt;当你需要限制客户端请求某个服务数量时，该状态码就很有用，也就是请求速度限制。&lt;/td&gt;
&lt;td&gt;主人~~我快要受不了了~&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;431&lt;/th&gt;
&lt;td&gt;Request Header Fields Too Large /请求头字段太大&lt;/td&gt;
&lt;td&gt;某些情况下，客户端发送 HTTP 请求头会变得很大，那么服务器可发送 431状态码 来指明该问题。&lt;/td&gt;
&lt;td&gt;主人~~这么大方不进去的~~&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;449&lt;/th&gt;
&lt;td&gt;&lt;em&gt;Retry With/稍后重试&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;由微软扩展，代表请求应当在执行完适当的操作后进行重试。&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;451&lt;/th&gt;
&lt;td&gt;Unavailable for Legal Reasons/正被审查&lt;/td&gt;
&lt;td&gt;代表那些因为法律原因而倒下的网站。&lt;/td&gt;
&lt;td&gt;不要啦我们还没领证呀&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot; colspan=&quot;4&quot;&gt;5XX—表示服务器错误。代表服务器在处理请求的过程中异常状态发生。&lt;/th&gt;&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;500&lt;/th&gt;
&lt;td&gt;Internal Server Error/内部服务器错误&lt;/td&gt;
&lt;td&gt;服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。&lt;/td&gt;
&lt;td&gt;糟了,身体变得有点奇怪了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;501&lt;/th&gt;
&lt;td&gt;Not Implemented/未实现&lt;/td&gt;
&lt;td&gt;服务器不支持当前请求所需要的某个功能。&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;502&lt;/th&gt;
&lt;td&gt;Bad Gateway/错误的网关&lt;/td&gt;
&lt;td&gt;作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。&lt;/td&gt;
&lt;td&gt;进错了吗？&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;503&lt;/th&gt;
&lt;td&gt;Service Unavailable/服务无法获得&lt;/td&gt;
&lt;td&gt;表示服务器由于在维护或已经超载而无法响应。&lt;/td&gt;
&lt;td&gt;不要...人家还没准备好啦&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;504&lt;/th&gt;
&lt;td&gt;Gateway Timeout/网关超时&lt;/td&gt;
&lt;td&gt;指出接收服务器没有从远端服务器得到及时的响应。&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;505&lt;/th&gt;
&lt;td&gt;HTTP Version Not Supported/不支持的 HTTP 版本&lt;/td&gt;
&lt;td&gt;表示服务器并不支持在请求中所标明 HTTP 版本。&lt;/td&gt;
&lt;td&gt;放开我,放开我,不要中出啊,会怀孕的(但其实是男生,不会怀孕)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;506&lt;/th&gt;
&lt;td&gt;Variant Also Negotiates&lt;/td&gt;
&lt;td&gt;代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;507&lt;/th&gt;
&lt;td&gt;Insufficient Storage&lt;/td&gt;
&lt;td&gt;服务器无法存储完成请求所必须的内容。&lt;/td&gt;
&lt;td&gt;都流出来了…&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;509&lt;/th&gt;
&lt;td&gt;Bandwidth Limit Exceeded&lt;/td&gt;
&lt;td&gt;服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。&lt;/td&gt;
&lt;td&gt;今天不接客了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;510&lt;/th&gt;
&lt;td&gt;Not Extended&lt;/td&gt;
&lt;td&gt;获取资源所需要的策略并没有没满足。&lt;/td&gt;
&lt;td&gt;没车没钱还想泡妞？&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;background-color: rgb(233, 238, 244);&quot;&gt;&lt;th scope=&quot;row&quot;&gt;511&lt;/th&gt;
&lt;td&gt;Network Authentication Required /要求网络认证&lt;/td&gt;
&lt;td&gt;在你想使用web服务的时候需要重定向到认证页面，在走HTTP通信中都是这么做的，&lt;/td&gt;
&lt;td&gt;主人~~不要蒙住我的眼睛~会好兴奋的！~&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;注：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;RFC-Request For Comments是由Internet
Society（ISOC）赞助发行，用于定义基本的互联网通信协议的一些列文件。文中所用的RFC文件地址如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RFC2295：&lt;a href=&quot;http://tools.ietf.org/html/rfc2295&quot;&gt;http://tools.ietf.org/html/rfc2295&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;RFC2518：&lt;a href=&quot;http://tools.ietf.org/html/rfc2518&quot;&gt;http://tools.ietf.org/html/rfc2518&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;RFC2612：&lt;a href=&quot;http://tools.ietf.org/html/rfc2612&quot;&gt;http://tools.ietf.org/html/rfc2612&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;RFC2817：&lt;a href=&quot;http://tools.ietf.org/html/rfc2817&quot;&gt;http://tools.ietf.org/html/rfc2817&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;RFC2774：&lt;a href=&quot;http://tools.ietf.org/html/rfc2774&quot;&gt;http://tools.ietf.org/html/rfc2774&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;RFC2918：&lt;a href=&quot;http://tools.ietf.org/html/rfc2918&quot;&gt;http://tools.ietf.org/html/rfc2918&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;RFC6585：&lt;a href=&quot;http://tools.ietf.org/html/rfc6585&quot;&gt;http://tools.ietf.org/html/rfc6585&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;表格中，斜体字的&quot;中英双解&quot;是我自己翻译的。如果不正确，请留指正。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;428、429、431以及511是2012年4月发布的 RFC6585手册中新增的4个状态码。
详见：&lt;a href=&quot;http://www.oschina.net/news/28660/new-http-status-codes&quot;&gt;http://www.oschina.net/news/28660/new-http-status-codes&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;451是XML标准发明人之一、Android开发人员Tim
Bray提议设立一个新的HTTP错误代码。这个还没有成为正式标准。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;详见：&lt;a href=&quot;http://news.mydrivers.com/1/231/231669.htm&quot;&gt;http://news.mydrivers.com/1/231/231669.htm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;参考资料&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.douban.com/note/224620321/&quot;&gt;豆瓣：HTTP 状态码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/zh/HTTP%E7%8A%B6%E6%80%81%E7%A0%81&quot;&gt;维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/lxinxuan/archive/2009/10/22/1588053.html&quot;&gt;HTTP状态码大全&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Mongodb安全性初探</title>
   <link href="http://beango.github.com/archives/2013/01/05/mongodb-secuirty-anaylze.html"/>
   <updated>2013-01-05T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2013/01/05/mongodb-secuirty-anaylze</id>
   <content type="html">&lt;p&gt;Mongodb，这么火的玩意其实早就想好好研究一下了。之前一直没空仔细学学新的东西，总是感觉精力不足。这次趁着买了一本书，就零零散散地在VPS上搭建、测试、看实现代码。感觉也蛮有意思的一个数据库。虽然感觉它非常简单，尤其是看代码的时候更是感觉如此。但这不也是另一个KISS的典范么，还是简单但是实用的东西最能流行。&lt;/p&gt;

&lt;p&gt;既然都看了其实现，也不能不产出点什么。正好多年没更新博文，就简单分析一下mongodb的安全性，凑个数先。&lt;/p&gt;

&lt;h2&gt;默认配置的安全情况&lt;/h2&gt;

&lt;p&gt;在默认情况下，mongod是监听在0.0.0.0之上的。而任何客户端都可以直接连接27017，且没有认证。好处是，开发人员或dba可以即时上手，不用担心被一堆配置弄的心烦意乱。坏处是，显而易见，如果你直接在公网服务器上如此搭建mongodb，那么所有人都可以直接访问并修改你的数据库数据了。&lt;/p&gt;

&lt;p&gt;默认情况下，mongod也是没有管理员账户的。因此除非你在admin数据库中使用db.addUser()命令添加了管理员帐号，且使用--auth参数启动mongod，否则在数据库中任何人都可以无需认证执行所有命令。包括delete和shutdown。&lt;/p&gt;

&lt;p&gt;此外，mongod还会默认监听28017端口，同样是绑定所有ip。这是&lt;a href=&quot;http://www.mongodb.org/display/DOCS/Http+Interface&quot;&gt;一个mongod自带的web监控界面&lt;/a&gt;。从中可以获取到数据库当前连接、log、状态、运行系统等信息。如果你开启了--rest参数，甚至可以直接通过web界面查询数据，执行mongod命令。&lt;/p&gt;

&lt;p&gt;我试着花了一个晚上扫描了国内一个B段，国外一个B段。结果是国外开了78个mongodb，而国内有60台。其中我随意挑选了10台尝试连接，而只有一台机器加了管理员账户做了认证，其他则全都是不设防的城市。可见其问题还是比较严重的。&lt;/p&gt;

&lt;p&gt;其实Mongodb本身有非常&lt;a href=&quot;http://www.mongodb.org/display/DOCS/Security+and+Authentication&quot;&gt;详细的安全配置准则&lt;/a&gt;，显然他也是想到了，然而他是将安全的任务推给用户去解决，这本身的策略就是偏向易用性的，对于安全性，则得靠边站了。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;用户信息保存及认证过程&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;
&lt;/strong&gt;类似MySQL将系统用户信息保存在mysql.user表。mongodb也将系统用户的username、pwd保存在admin.system.users集合中。其中&lt;a href=&quot;https://github.com/mongodb/mongo/blob/r1.9.1/shell/db.js#L71&quot;&gt;pwd
= md5(username + &quot;:mongo:&quot; +
real_password)&lt;/a&gt;。这本身并没有什么问题。username和:mongo:相当于对原密码加了一个salt值，即使攻击者获取了数据库中保存的md5
hash，也没法简单的从彩虹表中查出原始密码。&lt;/p&gt;

&lt;p&gt;我们再来看看mongodb对客户端的认证交互是如何实现的。mongo
client和server交互都是基于明文的，因此很容易被网络嗅探等方式抓取。这里我们使用数据库自带的&lt;a href=&quot;http://www.mongodb.org/display/DOCS/mongosniff&quot;&gt;mongosniff&lt;/a&gt;，可以直接dump出客户端和服务端的所有交互数据包：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@localhost&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# ./mongosniff --source NET lo&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sniffing&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;27017&lt;/span&gt; 

 &lt;span class=&quot;sr&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;省略开头的数据包，直接看看认证流程。以下就是当用户输入&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;auth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;real_passwd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;后发生的交互。&lt;/span&gt;

&lt;span class=&quot;mf&quot;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;34142&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;--&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;27017&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;admin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$cmd&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;62&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;id:8&lt;/span&gt;        &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;query:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getnonce:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;ntoreturn:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ntoskip:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;mf&quot;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;27017&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;--&lt;/span&gt;  &lt;span class=&quot;mf&quot;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;34142&lt;/span&gt;   &lt;span class=&quot;mi&quot;&gt;81&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;id:7&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;reply&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n:1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cursorId:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonce:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;df97182fb47bd6d0&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;mf&quot;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;34142&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;--&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;27017&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;admin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$cmd&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;152&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;id:9&lt;/span&gt;       &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;query:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;authenticate:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;admin&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonce:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;df97182fb47bd6d0&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;3d839522b547931057284b6e1cd3a567&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;ntoreturn:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ntoskip:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;mf&quot;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;27017&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;--&lt;/span&gt;  &lt;span class=&quot;mf&quot;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;34142&lt;/span&gt;   &lt;span class=&quot;mi&quot;&gt;53&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;id:8&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;reply&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n:1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cursorId:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;第一步，client向server发送一个命令getnonce，向server申请一个随机值nonce。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;server返回一个16位的nonce。这里每次返回的值都不相同。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二步，client将用户输入的明文密码通过算法生成一个key，即 &lt;a href=&quot;https://github.com/mongodb/mongo/blob/r1.9.1/shell/db.js#L90&quot;&gt;key = md5(nonce + username + md5(username + &quot;:mongo:&quot; + real_passwd))&lt;/a&gt;，并将之连同用户名、nonce一起返回给server&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;server收到数据，首先比对nonce是否为上次生成的nonce，然后比对key == md5(nonce + username + pwd)。如果相同，则&lt;a href=&quot;https://github.com/mongodb/mongo/blob/r1.9.1/db/security_commands.cpp#L71&quot;&gt;验证通过&lt;/a&gt;。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;由于至始至终没有密码hash在网络上传输，而是使用了类似挑战的机制，且每一次nonce的值都不同，因此即使攻击者截取到key的值，也没用办法通过重放攻击通过认证。&lt;/p&gt;

&lt;p&gt;然而当攻击者获取了数据库中保存的pwd
hash，则认证机制就不会起到作用了。即使攻击者没有破解出pwd
hash对应的密码原文。但是仍然可以通过发送md5(nonce + username +
pwd)的方式直接通过server认证。这里实际上server是将用户的pwd
hash当作了真正的密码去验证，并没有基于原文密码验证。在这点上和我之前分析的&lt;a href=&quot;http://www.phpweblog.net/GaRY/archive/2010/08/20/mysql_client_to_server_auth_method.html&quot;&gt;mysql的认证机制&lt;/a&gt;其实没什么本质区别。当然或许这个也不算是认证机制的弱点，但是毕竟要获取mongodb的username和pwd的可能性会更大一些。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-01/mongodb.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然而在Web的监控界面的认证中则有一些不同。当client来源不是localhost，这里的用户认证过程是基于HTTP
401的。其过程与mongo认证大同小异。但是一个主要区别是：这里的nonce并没有随机化，而是&lt;a href=&quot;https://github.com/mongodb/mongo/blob/r1.9.2/db/dbwebserver.cpp#L130&quot;&gt;每次都是默认为&quot;abc&quot;&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;利用这个特点，如果攻击者抓取了管理员一次成功的登录，那么他就可以重放这个数据包，直接进入Web监控页面。&lt;/p&gt;

&lt;p&gt;同样，攻击者还可以通过此接口直接暴力破解mongo的用户名密码。实际上27017和28017都没有对密码猜解做限制，但Web由于无需每次获取nonce，因此将会更为简便。&lt;/p&gt;

&lt;h2&gt;JavaScript的执行与保护&lt;/h2&gt;

&lt;p&gt;Mongodb本身最大的特点之一，就是他是使用javascript语言作为命令驱动的。黑客会比较关注这一点，因为其命令的支持程度，就是获取mongodb权限之后是否能进一步渗透的关键。&lt;/p&gt;

&lt;p&gt;Javascript本身的标准库其实相当弱。无论是spidermonkey或者是v8引擎，其实都没有系统操作、文件操作相关的支持。对此，&lt;a href=&quot;https://github.com/mongodb/mongo/blob/r1.9.1/shell/shell_utils.cpp#L890&quot;&gt;mongodb做了一定的扩展&lt;/a&gt;。可以看到，ls/cat/cd/hostname甚至runProgram都已经在Javascript的上下文中有实现。看到这里是不是已经迫不及待了？mongo
shell中试一下输入ls(&quot;./&quot;)，看看返回。&lt;/p&gt;

&lt;p&gt;等等？结果怎么这么熟悉？哈哈，没错，其实这些api都是在client的上下文中实现的。一个小小玩笑:)&lt;/p&gt;

&lt;p&gt;那么在server端是否可以执行js呢？答案是肯定的。利用db.eval(code)——实际上底层执行的是db.$cmd.findOne({$eval:
code})——可以在server端执行我们的js代码。&lt;/p&gt;

&lt;p&gt;当然在&lt;a href=&quot;https://github.com/mongodb/mongo/blob/r1.9.2/scripting/utils.cpp#L67&quot;&gt;server端也有js的上下文扩展&lt;/a&gt;。显然mongod考虑到了安全问题（也可能是其他原因），因此在这里并没有提供client中这么强大的功能。当然mongodb还在不断更新，长期关注这个list，说不定以后就有类似load_file/exec之类的实现。&lt;/p&gt;

&lt;p&gt;一劳永逸解决服务端js执行带来的问题可以使用&lt;a href=&quot;http://www.mongodb.org/display/DOCS/Command+Line+Parameters&quot;&gt;noscripting&lt;/a&gt;参数。直接禁止server-side的js代码执行功能。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>.Net垃圾回收机制原理（二）</title>
   <link href="http://beango.github.com/archives/2012/12/25/dot-net-gc-2.html"/>
   <updated>2012-12-25T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/12/25/dot-net-gc-2</id>
   <content type="html">&lt;p&gt;英文原文：&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/magazine/bb985011(en-us).aspx&quot;&gt;Jeffrey Richter&lt;/a&gt;，编译：&lt;a href=&quot;http://www.cnblogs.com/yukaizhao/archive/2011/11/25/dot_net_GC_2.html&quot;&gt;赵玉开&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/archives/2012/12/13/dot-net-gc-1.html&quot;&gt;上一篇文章&lt;/a&gt;介绍了.Net垃圾回收的基本原理和垃圾回收执行Finalize方法的内部机制；这一篇我们看下弱引用对象，代，多线程垃圾回收，大对象处理以及和垃圾回收相关的性能计数器。&lt;/p&gt;

&lt;p&gt;让我们从弱引用对象说起，弱引用对象可以减轻大对象带来的内存压力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;弱引用（Weak References）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当程序的根对象指向一个对象时，这个对象是可达的，垃圾回收器不能回收它，这称为对对象的强引用。和强引用相对的是弱引用，当一个对象上存在弱引用时，垃圾回收器可以回收此对象，但是也允许程序访问这个对象。这是怎么回事儿呢？请往下看。&lt;/p&gt;

&lt;p&gt;如果一个对象上仅存在弱引用，并且垃圾回收器在运行，这个对象就会被回收，之后如果程序中要访问这个对象，访问就会失败。另一方面，要使用弱引用的对象，程序必须先对这个对象进行强引用，如果程序在垃圾回收器回收这个对象之前对对象进行了强引用，这样（有了强引用之后）垃圾回收器就不能回收此对象了。这有点绕，让我们用一段代码来说明一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void Method() {
    //创建对象的强引用
    Object o = new Object(); 
    // 用一个短弱引用对象弱引用o.
    WeakReference wr = new WeakReference(o);

    o = null; // 移除对象的强引用

    o = wr.Target; //尝试从弱引用对象中获得对象的强引用
    if (o == null) {
        // 如果对象为空说明对象已经被垃圾回收器回收掉了
    } else {
        // 如果垃圾回收器还没有回收此对象就可以继续使用对象了
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么需要弱对象呢？因为，有一些数据创建起来很容易，但是却需要很多内存。例如：你有一个程序，这个程序需要访问用户硬盘上的所有文件夹和文件名；你可以在程序第一次需要这个数据时访问用户磁盘生成一次数据，数据生成之后你就可以访问内存中的数据来得到用户文件数据，而不是每次都去读磁盘获得数据，这样做可以提升程序的性能。&lt;/p&gt;

&lt;p&gt;问题是这个数据可能相当大，需要相当大的内存。如果用户去操作程序的另外一部分功能了，这块相当大的内存就没有占用的必要了。你可以通过代码删除这些数据，但是如果用户马上切换到需要这块数据的功能上，你就必须重新从用户的磁盘上构建这个数据。弱引用为这种场景提供了一种简单有效的方案。&lt;/p&gt;

&lt;p&gt;当用户切换到其他功能时，你可以为这个数据创建一个弱引用对象，并把对这个数据的强引用解除掉。这样如果程序占用的内存很低，垃圾回收操作就不会触发，弱引用对象就不会被回收掉；这样当程序需要使用这块数据时就可以通过一个强引用来获得数据，如果成功得到了对象引用，程序就没有必要再次读取用户的磁盘了。&lt;/p&gt;

&lt;p&gt;WeakReference类型提供了两个构造函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WeakReference(object target);
WeakReference(object target, bool trackResurrection);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;target参数显然就是弱引用要跟踪的对象了。trackResurrection参数表示当对象的Finalize方法执行之后是否还要跟踪这个对象。默认这个参数是false。有关对象的复活请参考&lt;a href=&quot;http://blog.jobbole.com/31443/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;方便起见，不跟踪复活对象的弱引用称为“短弱引用”；而要跟踪复活对象的的弱引用称为“长弱引用”。如果对象没有实现Finalize方法，那么长弱引用和短弱引用是完全一样的。强烈建议你尽量避免使用长弱引用。长弱引用允许你使用复活的对象，而复活对象的行为可能是不可以预知的。&lt;/p&gt;

&lt;p&gt;一旦你使用WeakReference引用了一个对象，建议你将这个对象的所有强用都设置为null；如果强引用存在的话，垃圾回收器是永远都不可能回收弱引用指向的对象的。&lt;/p&gt;

&lt;p&gt;当你要使用弱引用目标对象时，你必须为目标对象创建一个强引用，这很简单，只要用object a = weekRefer.Target;就可以了，然后你必须判断a是否为空，弱不为空才可以继续使用，弱为空就表示对象已经被垃圾回收器回收了，得通过其他方法重新获得此对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;弱引用的内部实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从前文中的描述中我们可以推断出弱引用对象肯定和一般对象的处理是不一样的。一般情况下如果一个对象引用了另一个对象就是强引用，垃圾回收器就不能回收被引用的对象，而WeakReference对象却不是这样子，它引用的对象是有可能被回收的。&lt;/p&gt;

&lt;p&gt;要完全理解弱对象是如何工作的，我们还需要看一下托管堆。托管堆上有两个内部数据结构他们的唯一作用是管理弱引用：我们可以把它们称作长弱引用表和短弱引用表；这两个表存放托管堆上的弱引用目标对象指针。&lt;/p&gt;

&lt;p&gt;程序运行之初，这两个表都是空的。当你创建一个WeakReference对象时，这个对象并不是分配到托管堆上的，而是在弱对象表中创建一个空槽（Empty Slot）。短弱引用对象被放在短弱对象表中，长弱引用对象被放在长弱引用表中。&lt;/p&gt;

&lt;p&gt;一旦发现空槽，空槽的值会被设置成弱引用目标对象的地址；显然长短弱对象表中的对象是不会当作应用程序的根对象的。垃圾回收器不会回收长短弱对象表中的数据。&lt;/p&gt;

&lt;p&gt;让我们来看下垃圾回收执行时发生了什么：&lt;/p&gt;

&lt;p&gt;​1.垃圾回收器构建一个可达对象图，构建步骤请&lt;a href=&quot;http://blog.jobbole.com/31443/&quot;&gt;参考上文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;​2.垃圾回收器扫描短弱对象表，如果弱对象表中指向的对像没有在可达对象图中，那么这个对像就被标识为垃圾对象，然后短对象表中的对象指针被设置为空&lt;/p&gt;

&lt;p&gt;​3.垃圾回收器扫描终结队列（&lt;a href=&quot;http://blog.jobbole.com/31443/&quot;&gt;参考上文&lt;/a&gt;），如果队列中的对象不在可达对象图中，这个对象从终结队列中移动到Freachable队列中，这时候，这个对象又被标识为可达对象，不再是垃圾了&lt;/p&gt;

&lt;p&gt;​4.垃圾回收器扫描长弱引用表。如果表中的对象不在可达对象图中（可达对象图中包括在Freachable队列中对象），将长引用对象表中对应的对象指针设置为null&lt;/p&gt;

&lt;p&gt;​5. 垃圾回收器移动可达对象&lt;/p&gt;

&lt;p&gt;一旦你理解了垃圾回收器的工作过程，就很容易理解弱引用是如何起作用了。访问WeakReference的Target属性导致系统返回弱对象表中的目标对象指针，如果是null，表示对象已经被回收了。&lt;/p&gt;

&lt;p&gt;短弱引用不跟踪复活，这意味着垃圾回收器可以在扫描终结队列之前检查弱引用表中指向的对象是否是垃圾对象。&lt;/p&gt;

&lt;p&gt;而长弱引用跟踪复活对象，这意味着垃圾回收器必须在确认对象回收之后才可以将弱引用表中的指针设置为null。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;提起.Net的垃圾回收，c++或者c&lt;a href=&quot;http://blog.jobbole.com/821/&quot; title=&quot;程序员的本质&quot;&gt;程序员&lt;/a&gt;可能就会想，这么管理内存会不会出现性能问题呢。GC的开发人员一直在调整垃圾回收器提升它的性能。代就是一种为了降低垃圾回收对性能影响的机制。垃圾回收器在工作时会假定如下说法是成立的：&lt;/p&gt;

&lt;p&gt;​1. 一个对象越新，那么这个对象的生命周期就越短&lt;/p&gt;

&lt;p&gt;​2. 一个对象越老，那么这个对象的生命周期就越长&lt;/p&gt;

&lt;p&gt;​3. 新对象之间通常更可能和新对象之间存在引用关系&lt;/p&gt;

&lt;p&gt;​4. 压缩堆的一部分要比压缩整个堆要快&lt;/p&gt;

&lt;p&gt;当然大量研究证明以上几个假设在很多程序上是成立的。那就让我们来谈谈这几个假设是如何影响垃圾回收器工作的吧。&lt;/p&gt;

&lt;p&gt;在程序初始化时，托管堆上没有对象。这时候新添到托管堆上的对象是的代是0.如下图所示，0代对象是最年轻的对象，他们从来没有经过垃圾回收器的检查。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2011-11/NET-GC-07.gif&quot; title=&quot;.Net 垃圾回收机制原理（二）&quot;&gt;&lt;img src=&quot;/assets/files/2011-11/NET-GC-07.gif&quot; title=&quot;.Net 垃圾回收机制原理（二）&quot; alt=&quot;.Net垃圾回收机制原理（二）&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图1 托管堆上的0代对象&lt;/p&gt;

&lt;p&gt;现在如果堆上添加了更多的对象，堆填满时就会触发垃圾回收。当垃圾回收器分析托管堆时，会构建一个垃圾对象（图2中浅紫色块）和非垃圾对象的图。所有没有被回收的对象会被移动压缩到堆的最底端。这些没有被回收掉的对象就成为了1代对象，如图2所示&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2011-11/NET-GC-08.gif&quot; title=&quot;.Net 垃圾回收机制原理（二）&quot;&gt;&lt;img src=&quot;/assets/files/2011-11/NET-GC-08.gif&quot; title=&quot;.Net 垃圾回收机制原理（二）&quot; alt=&quot;.Net垃圾回收机制原理（二）&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图2 托管堆上的0代1代对象&lt;/p&gt;

&lt;p&gt;当堆上分配了更多的对象时，新对象被放在了0代区。如果0代堆填满了，就会触发一次垃圾回收。这时候活下来的对象成为1代对象被移动到堆的底部；再此发生垃圾回收后1代对象中存活下来的对象会提升为2代对象并被移动压缩。如图3所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2011-11/NET-GC-09.gif&quot; title=&quot;.Net 垃圾回收机制原理（二）&quot;&gt;&lt;img src=&quot;/assets/files/2011-11/NET-GC-09.gif&quot; title=&quot;.Net 垃圾回收机制原理（二）&quot; alt=&quot;.Net
垃圾回收机制原理（二）&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图3 托管堆上的0、1、2代对象&lt;/p&gt;

&lt;p&gt;2代对象是目前垃圾回收器的最高代，当再次垃圾回收时，没有回收的对象的代数依然保持2.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;垃圾回收分代为什么可以优化性能&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如前所述，分代回收可以提高性能。当堆填满之后会触发垃圾回收，垃圾回收器可以只选择0代上的对象进行回收，而忽略更高代堆上的对象。然而，由于越年轻的对象生命周期越短，因此，回收0代堆可以回收相当多的内存，而且回收所耗的性能也比回收所有代对象要少得多。&lt;/p&gt;

&lt;p&gt;这是分代垃圾回收的最简单优化。分代回收不需要便利整个托管堆，如果一个根对象引用了一个高代对象，那么垃圾回收器可以忽略高代对象和其引用对象的遍历，这会大大减少构建可达对象图的时间。&lt;/p&gt;

&lt;p&gt;如果回收0代对象没有释放出足够的内存，垃圾回收器会尝试回收1代和0代堆；如果仍然没有获得足够的内存，那么垃圾回收器会尝试回收2，1，0代堆。具体会回收那一代对象的算法不是确定的，微软会持续做算法优化。&lt;/p&gt;

&lt;p&gt;多数堆（像c-runtime堆）只要找到足够的空闲内存就分配给对象。因此，如果我连续分配多个对象时，这些对象的地址空间可能会相差几M。然而在托管堆上，连续分配的对象的内存地址是连续的。&lt;/p&gt;

&lt;p&gt;前面的假设中还提到，新对象之间更可能存在相互引用关系。因此新对象分配到连续的内存上，你可以获得就近引用的性能优化（you gain performance from locality of reference）。这样的话很可能你的对象都在CPU的缓存中，这样CPU的很多操作就不需要去存取内存了。&lt;/p&gt;

&lt;p&gt;微软的性能测试显示托管堆的分配速度比标准的win32 HeapAlloc方法还要快。这些测试也显示了200MHz的Pentium的CPU做一次0代回收时间可以小于1毫秒。微软的优化目的是让垃圾回收耗用的时间小于一次普通的页面错误。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用System.GC类控制垃圾回收&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;类型System.GC运行开发人员直接控制垃圾回收器。你可以通过GC.MaxGeneration属性获得GC的最高代数，目前最高代是定值2.&lt;/p&gt;

&lt;p&gt;你可以调用GC.Collect()方法强制垃圾回收器做垃圾回收，Collect方法有两个重载：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void GC.Collect(Int32 generation)

void GC.Collect()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个方法允许你指定要回收那一代。你可以传0到GC.MaxGeneration的数字做参数，传0只做0代堆的回收，传1会回收1代和0代堆，而传2会回收整个托管堆。而无参数的方法调用GC.Collect(GC.MaxGeneration)相当于整个回收。&lt;/p&gt;

&lt;p&gt;在通常情况下，不应该去调用GC.Collect方法；最好让垃圾回收器按照自己的算法判断什么时候该调用Collect方法。尽管如此，如果你确信比运行时更了解什么时候该做垃圾回收，你就可以调用Collect方法去做回收。比如说程序可以在保存数据文件之后做一次垃圾回收。比如你的程序刚刚用完一个长度为10000的大数组，你不再需要他了，就可以把它设置为null然后执行垃圾回收，缓解内存的压力。&lt;/p&gt;

&lt;p&gt;GC还提供了WaitForPendingFinalizers方法。这个方法简单的挂起执行线程，知道Freachable队列中的清空之后，执行完所有队列中的Finalize方法之后才继续执行。&lt;/p&gt;

&lt;p&gt;GC还提供了两个方法用来返回某个对象是几代对象，他们是&lt;/p&gt;

&lt;p&gt;Int32 GC.GetGeneration(object o);&lt;/p&gt;

&lt;p&gt;Int32 GC.GetGeneration(WeakReference wr)&lt;/p&gt;

&lt;p&gt;第一个方法返回普通对象是几代，第二个方法返回弱引用对象的代数。&lt;/p&gt;

&lt;p&gt;下面的代码可以帮助你理解代的意义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static void GenerationDemo() {
  // Let's see how many generations the GCH supports (we know it's 2)
  Display(&quot;Maximum GC generations: &quot; + GC.MaxGeneration);

  // Create a new BaseObj in the heap
  GenObj obj = new GenObj(&quot;Generation&quot;);

  // Since this object is newly created, it should be in generation 0
  obj.DisplayGeneration(); // Displays 0

  // Performing a garbage collection promotes the object's generation
  GC.Collect();
  obj.DisplayGeneration(); // Displays 1

  GC.Collect();
  obj.DisplayGeneration(); // Displays 2

  GC.Collect();
  obj.DisplayGeneration(); // Displays 2 (max generation)

  obj = null; // Destroy the strong reference to this object

  GC.Collect(0); // Collect objects in generation 0
  GC.WaitForPendingFinalizers(); // We should see nothing

  GC.Collect(1); // Collect objects in generation 1
  GC.WaitForPendingFinalizers(); // We should see nothing

  GC.Collect(2); // Same as Collect()
  GC.WaitForPendingFinalizers(); // Now, we should see the Finalize 
  // method run

  Display(-1, &quot;Demo stop: Understanding Generations.&quot;, 0);
}
class GenObj{
  public void DisplayGeneration(){
    Console.WriteLine(“my generation is ” + GC.GetGeneration(this));
  }

  ~GenObj(){
    Console.WriteLine(“My Finalize method called”);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;垃圾回收机制的多线程性能优化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在前面的部分，我解释了GC的算法和优化，然后讨论的前提都是在单线程情况下的。而在真实的程序中，很可能是多个线程一起工作，多个线程一起操纵托管堆上的对象。当一个线程触发了垃圾回收，其他所有的线程都应该暂停访问任何引用对象（包括他们自己栈上引用的对象），因为垃圾回收器有可能要移动对象，修改对象的内存地址。&lt;/p&gt;

&lt;p&gt;因此当垃圾回收器开始回收时，所有执行托管代码的线程必须挂起。运行时有几种不同的机制可以安全的挂起线程来执行垃圾回收。这一块的内部机制我不打算详细说明。但是微软会持续修改垃圾回收的机制来降低垃圾回收带来的性能损耗。&lt;/p&gt;

&lt;p&gt;下面几段描述了垃圾回收器在多线程情况下是如何工作的：&lt;/p&gt;

&lt;p&gt;完全中断代码执行：当垃圾回收开始执行时，挂起所有应用程序线程。垃圾回收器随后将线程挂起的位置记录到一个just-in-time(JIT)编译器生成的表中，垃圾回收器负责将线程挂起的位置记录在表中，记录当前正在访问的对象，以及对象存放的位置（变量中，CPU寄存器中，等等）&lt;/p&gt;

&lt;p&gt;劫持：垃圾回收器可以修改线程的栈让返回地址指向一个特殊的方法，当当前执行的方法返回时，这个特殊的方法将会执行，挂起线程，这种改变线程执行路径的方式称为劫持线程。当垃圾回收完成之后，线程会重新返回到之前执行的方法上。&lt;/p&gt;

&lt;p&gt;安全点：
当JIT编译器编译一个方法时，可以在某个点插入一段代码判断GC是否挂起，如果是，线程就挂起等待垃圾回收完成，然后线程重新开始执行。JIT编译器插入检查GC代码的位置被称作“安全点”&lt;/p&gt;

&lt;p&gt;请注意，线程劫持允许正在执行非托管代码的线程在垃圾回收过程中执行。如果非托管代码不访问托管堆上的对象时这是没有问题的。如果这个线程当前执行非托管代码然后返回执行托管代码，这个线程将会被劫持，直到垃圾回收完成之后再继续执行。&lt;/p&gt;

&lt;p&gt;除了我刚提到的集中机制之外，垃圾回收器还有其他改进来增强多线程程序中的对象内存分配和回收。&lt;/p&gt;

&lt;p&gt;同步释放分配（Synchronization-free Allocations）：在一个多线程系统中，0代堆被分成几个区域，一个线程使用一个区域。这允许多线程同时分配对象，并不需要一个线程独占堆。&lt;/p&gt;

&lt;p&gt;可伸缩回收(Scalable Collections)：在多线程系统中运行执行引擎的服务器版本（MXSorSvr.dll）.托管堆会被分成几个不同的区域，一个CPU一个区域。当回收初始化时，每个CPU执行一个回收线程，各个线程回收各自的区域。而工作站版本的执行引擎（MXCorWks.dll）不支持这个功能。&lt;/p&gt;

&lt;p&gt;大对象回收&lt;/p&gt;

&lt;p&gt;这一块就不翻译了，有一篇&lt;a href=&quot;http://blog.jobbole.com/31459/&quot;&gt;专门的文章&lt;/a&gt;谈这件事儿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;监视垃圾回收&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果你安装了.Net framework你的性能计数器（开始菜单—管理工具—性能
进入）中就会有.Net CLR
Memory一项，你可以从实例列表中选择某个程序进行观察，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2011-11/NET-GC-10.gif&quot; title=&quot;.Net 垃圾回收机制原理（二）&quot;&gt;&lt;img src=&quot;/assets/files/2011-11/NET-GC-10.gif&quot; title=&quot;.Net 垃圾回收机制原理（二）&quot; alt=&quot;.Net 垃圾回收机制原理（二）&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这些性能指标的具体含义如下：&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;性能计数器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;# Bytes in all Heaps&lt;/strong&gt;&lt;strong&gt;（所有堆中的字节数）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示以下计数器值的总和：“第 0 级堆大小”计数器、“第 1 级堆大小”计数器、“第 2 级堆大小”计数器和“大对象堆大小”计数器。此计数器指示在垃圾回收堆上分配的当前内存（以字节为单位）。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;# GC Handles&lt;/strong&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;GC&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;处理数目）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示正在使用的垃圾回收处理的当前数目。垃圾回收处理是对公共语言运行库和托管环境外部的资源的处理。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;# Gen 0 Collections&lt;/strong&gt;&lt;strong&gt;（第&lt;/strong&gt;&lt;strong&gt;&amp;nbsp;2&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;级回收次数）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示自应用程序启动后第 0 级对象（即最年轻、最近分配的对象）被垃圾回收的次数。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;当第 0 级中的可用内存不足以满足分配请求时发生第 0 级垃圾回收。此计数器在第 0 级垃圾回收结束时递增。较高级的垃圾回收包括所有较低级的垃圾回收。当较高级（第 1 级或第 2 级）垃圾回收发生时此计数器被显式递增。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;此计数器显示最近的观察所得值。&lt;strong&gt;_Global_&lt;/strong&gt;&amp;nbsp;计数器值不准确，应该忽略。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;# Gen 1 Collections&lt;/strong&gt;&lt;strong&gt;（第&lt;/strong&gt;&lt;strong&gt;&amp;nbsp;2&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;级回收次数）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示自应用程序启动后对第 1 级对象进行垃圾回收的次数。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;此计数器在第 1 级垃圾回收结束时递增。较高级的垃圾回收包括所有较低级的垃圾回收。当较高级（第 2 级）垃圾回收发生时此计数器被显式递增。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;此计数器显示最近的观察所得值。&lt;strong&gt;_Global_&lt;/strong&gt;&amp;nbsp;计数器值不准确，应该忽略。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;# Gen 2 Collections&lt;/strong&gt;&lt;strong&gt;（第&lt;/strong&gt;&lt;strong&gt;&amp;nbsp;2&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;级回收次数）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示自应用程序启动后对第 2 级对象进行垃圾回收的次数。此计数器在第 2 级垃圾回收（也称作完整垃圾回收）结束时递增。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;此计数器显示最近的观察所得值。&lt;strong&gt;_Global_&lt;/strong&gt;&amp;nbsp;计数器值不准确，应该忽略。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;# Induced GC&lt;/strong&gt;&lt;strong&gt;（引发的&lt;/strong&gt;&lt;strong&gt;&amp;nbsp;GC&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;的数目）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示由于对&amp;nbsp;&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/library/system.gc.collect(v=vs.80).aspx&quot; onclick=&quot;javascript:_gaq.push(['_trackEvent','outbound-article','http://msdn.microsoft.com']);&quot;&gt;GC.Collect&lt;/a&gt;&amp;nbsp;的显式调用而执行的垃圾回收的峰值次数。让垃圾回收器对其回收的频率进行微调是切实可行的。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;# of Pinned Objects&lt;/strong&gt;&lt;strong&gt;（钉住的对象的数目）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示上次垃圾回收中遇到的钉住的对象的数目。钉住的对象是垃圾回收器不能移入内存的对象。此计数器只跟踪被进行垃圾回收的堆中的钉住的对象。例如，第 0 级垃圾回收导致仅枚举第 0 级堆中钉住的对象。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;# of Sink Blocks in use&lt;/strong&gt;&lt;strong&gt;（正在使用的接收块的数目）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示正在使用的同步块的当前数目。同步块是为存储同步信息分配的基于对象的数据结构。同步块保留对托管对象的弱引用并且必须由垃圾回收器扫描。同步块不局限于只存储同步信息；它们还可以存储 COM interop 元数据。该计数器指示与同步基元的过度使用有关的性能问题。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;# Total committed Bytes&lt;/strong&gt;&lt;strong&gt;（提交字节的总数）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示垃圾回收器当前提交的虚拟内存量（以字节为单位）。提交的内存是在磁盘页面文件中保留的空间的物理内存。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;# Total reserved Bytes&lt;/strong&gt;&lt;strong&gt;（保留字节的总数）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示垃圾回收器当前保留的虚拟内存量（以字节为单位）。保留内存是为应用程序保留（但尚未使用任何磁盘或主内存页）的虚拟内存空间。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;% Time in GC&lt;/strong&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;GC&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;中时间的百分比）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示自上次垃圾回收周期后执行垃圾回收所用运行时间的百分比。此计数器通常指示垃圾回收器代表该应用程序为收集和压缩内存而执行的工作。只在每次垃圾回收结束时更新此计数器。此计数器不是一个平均值；它的值反映了最近观察所得值。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Allocated Bytes/second&lt;/strong&gt;&lt;strong&gt;（每秒分配的字节数）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示每秒在垃圾回收堆上分配的字节数。此计数器在每次垃圾回收结束时（而不是在每次分配时）进行更新。此计数器不是一段时间内的平均值；它显示最近两个样本中观测的值的差除以取样间隔时间所得的结果。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Finalization Survivors&lt;/strong&gt;&lt;strong&gt;（完成时存留对象数目）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示因正等待完成而从回收后保留下来的进行垃圾回收的对象的数目。如果这些对象保留对其他对象的引用，则那些对象也保留下来，但此计数器不对它们计数。“从第 0 级提升的完成内存”和“从第 1 级提升的完成内存”计数器表示因完成而保留下来的所有内存。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;此计数器不是累积计数器；它在每次垃圾回收结束时由仅在该特定回收期间存留对象的计数更新。此计数器指示由于完成应用程序可能导致系统开销过高。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Gen 0 heap size&lt;/strong&gt;&lt;strong&gt;（第&lt;/strong&gt;&lt;strong&gt;&amp;nbsp;2&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;级堆大小）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示在第 0 级中可以分配的最大字节数；它不指示在第 0 级中当前分配的字节数。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;当自最近回收后的分配超出此大小时发生第 0 级垃圾回收。第 0 级大小由垃圾回收器进行微调并且可在应用程序执行期间更改。在第 0 级回收结束时，第 0 级堆的大小是 0 字节。此计数器显示调用下一个第 0 级垃圾回收的分配的大小（以字节为单位）。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;此计数器在垃圾回收结束时（而不是在每次分配时）进行更新。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Gen 0 Promoted Bytes/Sec&lt;/strong&gt;&lt;strong&gt;（从第&lt;/strong&gt;&lt;strong&gt;&amp;nbsp;1&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;级提升的字节数&lt;/strong&gt;&lt;strong&gt;/&lt;/strong&gt;&lt;strong&gt;秒）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示每秒从第 0 级提升到第 1 级的字节数。内存在从垃圾回收保留下来后被提升。此计数器是每秒创建的在相当长时间保留下来的对象的指示符。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;此计数器显示在最后两个样本（以取样间隔持续时间来划分）中观察到的值之间的差异。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Gen 1 heap size&lt;/strong&gt;&lt;strong&gt;（第&lt;/strong&gt;&lt;strong&gt;&amp;nbsp;2&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;级堆大小）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示第 1 级中的当前字节数；此计数器不显示第 1 级的最大大小。不直接在此代中分配对象；这些对象是从前面的第 0 级垃圾回收提升的。此计数器在垃圾回收结束时（而不是在每次分配时）进行更新。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Gen 1 Promoted Bytes/Sec&lt;/strong&gt;&lt;strong&gt;（从第&lt;/strong&gt;&lt;strong&gt;&amp;nbsp;1&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;级提升的字节数&lt;/strong&gt;&lt;strong&gt;/&lt;/strong&gt;&lt;strong&gt;秒）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示每秒从第 1 级提升到第 2 级的字节数。在此计数器中不包括只因正等待完成而被提升的对象。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;内存在从垃圾回收保留下来后被提升。不会从第 2 级进行任何提升，因为它是最旧的一级。此计数器是每秒创建的非常长时间保留下来的对象的指示符。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;此计数器显示在最后两个样本（以取样间隔持续时间来划分）中观察到的值之间的差异。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Gen 2 heap size&lt;/strong&gt;&lt;strong&gt;（第&lt;/strong&gt;&lt;strong&gt;&amp;nbsp;2&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;级堆大小）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示第 2 级中当前字节数。不直接在此代中分配对象；这些对象是在以前的第 1 级垃圾回收期间从第 1 级提升的。此计数器在垃圾回收结束时（而不是在每次分配时）进行更新。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Large Object Heap size&lt;/strong&gt;&lt;strong&gt;（大对象堆大小）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示大对象堆的当前大小（以字节为单位）。垃圾回收器将大于 20 KB 的对象视作大对象并且直接在特殊堆中分配大对象；它们不是通过这些级别提升的。此计数器在垃圾回收结束时（而不是在每次分配时）进行更新。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Promoted Finalization-Memory from Gen 0&lt;/strong&gt;&lt;strong&gt;（从第&lt;/strong&gt;&lt;strong&gt;&amp;nbsp;1&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;级提升的完成内存）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示只因等待完成而从第 0 级提升到第 1 级的内存的字节数。此计数器不是累积计数器；它显示在最后一次垃圾回收结束时观察到的值。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Promoted Finalization-Memory from Gen 1&lt;/strong&gt;&lt;strong&gt;（从第&lt;/strong&gt;&lt;strong&gt;&amp;nbsp;1&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;级提升的完成内存）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示只因等待完成而从第 1 级提升到第 2 级的内存的字节数。此计数器不是累积计数器；它显示在最后一次垃圾回收结束时观察到的值。如果最后一次垃圾回收就是第 0 级回收，此计数器则重置为 0。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Promoted Memory from Gen 0&lt;/strong&gt;&lt;strong&gt;（从第&lt;/strong&gt;&lt;strong&gt;&amp;nbsp;1&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;级提升的内存）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示在垃圾回收后保留下来并且从第 0 级提升到第 1 级的内存的字节数。此计数器中不包括那些只因等待完成而提升的对象。此计数器不是累积计数器；它显示在最后一次垃圾回收结束时观察到的值。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Promoted Memory from Gen 1&lt;/strong&gt;&lt;strong&gt;（从第&lt;/strong&gt;&lt;strong&gt;&amp;nbsp;1&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;级提升的内存）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;显示在垃圾回收后保留下来并且从第 1 级提升到第 2 级的内存的字节数。此计数器中不包括那些只因等待完成而提升的对象。此计数器不是累积计数器；它显示在最后一次垃圾回收结束时观察到的值。如果最后一次垃圾回收就是第 0 级回收，此计数器则重置为 0。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;这个表来自&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/library/x2tyfybc(v=vs.80&quot;&gt;MSDN&lt;/a&gt;.aspx)&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>HTTP协议之代理</title>
   <link href="http://beango.github.com/archives/2012/12/15/http-protocol-proxy.html"/>
   <updated>2012-12-15T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/12/15/http-protocol-proxy</id>
   <content type="html">&lt;h3&gt;阅读目录&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#chapter1&quot;&gt;什么是代理服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chapter2&quot;&gt;Fiddler就是个典型的代理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chapter3&quot;&gt;代理作用一：翻墙&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chapter4&quot;&gt;代理作用二：匿名访问&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chapter5&quot;&gt;代理作用三：通过代理上网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chapter6&quot;&gt;代理作用四：通过代理缓存，加快上网速度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chapter7&quot;&gt;代理作用五：儿童过滤器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chapter8&quot;&gt;IE代理设置：手动设置代理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chapter9&quot;&gt;IE代理设置：使用自动配置脚本(PAC)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chapter10&quot;&gt;IE代理设置：自动探测设置(WPAD)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chapter11&quot;&gt;代理认证，407状态码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chapter12&quot;&gt;使用代理服务器的安全问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chapter13&quot;&gt;如何搭建代理服务器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3 id=&quot;chapter1&quot;&gt;什么是代理服务器&lt;/h3&gt;


&lt;p&gt;Web代理（proxy）服务器是网络的中间实体。
代理位于Web客户端和Web服务器之间，扮演“中间人”的角色。&lt;/p&gt;

&lt;p&gt;HTTP的代理服务器即是Web服务器又是Web客户端。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/2012120511054068.png&quot; alt=&quot;&quot; class=&quot;Pic&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;chapter2&quot;&gt;Fiddler就是个典型的代理&lt;/h3&gt;


&lt;p&gt;Fiddler 是以代理web服务器的形式工作的,它使用代理地址:127.0.0.1,
端口:8888. 当Fiddler退出的时候它会自动注销代理，这样就不会影响别的程序。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/2012020409075327.png&quot; alt=&quot;&quot; class=&quot;Pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/2012020409081574.png&quot; alt=&quot;&quot; class=&quot;Pic&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;chapter3&quot;&gt;代理的作用一， 翻墙&lt;/h3&gt;


&lt;p&gt;很多人都喜欢用Facebook， 看youTube。但是我们在天朝，天朝有The Great of
Wall(长城防火墙)，屏蔽了这些好网站。  怎么办?&lt;br/&gt;
通过代理来跳墙，就可以访问了。&lt;/p&gt;

&lt;p&gt;自己去寻找代理服务器很麻烦， 一般都是用翻墙软件来自动发现代理服务器的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/2012120519345158.png&quot; alt=&quot;&quot; class=&quot;Pic&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;chapter4&quot;&gt;代理的作用二， 匿名访问&lt;/h3&gt;


&lt;p&gt;经常听新闻，说”某某某“在网络上发布帖子，被跨省追缉了。&lt;br/&gt;
假如他使用匿名的代理服务器，就不容易暴露自己的身份了。&lt;/p&gt;

&lt;p&gt;http代理服务器的匿名性是指：
HTTP代理服务器通过删除HTTP报文中的身份特性（比如客户端的IP地址，
或cookie,或URI的会话ID），
从而对远端服务器隐藏原始用户的IP地址以及其他细节。
&lt;span style=&quot;background-color: #ffff00;&quot;&gt;同时HTTP代理服务器上也不会记录原始用户访问记录的log(否则也会被查到)&lt;/span&gt;。&lt;/p&gt;

&lt;h3 id=&quot;chapter5&quot;&gt;代理的作用三， 通过代理上网&lt;/h3&gt;


&lt;p&gt;比如局域网不能上网， 只能通过局域网内的一台代理服务器上网。&lt;/p&gt;

&lt;h3 id=&quot;chapter6&quot;&gt;代理的作用四， 通过代理缓存，加快上网速度&lt;/h3&gt;


&lt;p&gt;大部分代理服务器都具有缓存的功能，就好像一个大的cache，
它有很大的存储空间，它不断将新取得数据存储到它本地的存储器上，
如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传给用户的浏览器，这样就能显著提高浏览速度。&lt;/p&gt;

&lt;h3 id=&quot;chapter7&quot;&gt;代理的作用五：儿童过滤器&lt;/h3&gt;


&lt;p&gt;很多教育机构， 会利用过滤器代理来阻止学生访问成人内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/2012120516393239.png&quot; alt=&quot;&quot; class=&quot;Pic&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;chapter8&quot;&gt;IE代理设置：手动设置代理&lt;/h3&gt;


&lt;p&gt;IE浏览器可以手动设置代理， 很简单，指定一个IP地址和端口就可以了。 如下图。&lt;/p&gt;

&lt;p&gt;工具 -＞ Internet选项 -&gt; 连接 -&gt; 局域网设置 （快捷键）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/2012120519480694.png&quot; alt=&quot;&quot; class=&quot;Pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假如代理服务器的IP地址改变了，或者端口号改变了。
难道要几百个客户端的浏览器去修改浏览器设置？ Impossable  这太难维护了。  下面还有一种更高级点的方法。&lt;/p&gt;

&lt;h3 id=&quot;chapter9&quot;&gt;IE代理设置：使用自动配置脚本（PAC）&lt;/h3&gt;


&lt;p&gt; 手动配置代理很简单，但是不灵活。 只能指定一个代理服务器，而且不支持故障转移。&lt;/p&gt;

&lt;p&gt;在大公司里一般都使用PAC文件来配置。只需要指定PAC文件的URL就可以了， 如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/2012120519531553.png&quot; alt=&quot;&quot; class=&quot;Pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PAC（Proxy Auto Config）文件是一个小型的JavaScript程序的文本文件，后缀为.dat。&lt;/p&gt;

&lt;p&gt;当浏览器访问网络的时候，会根据PAC文件中的JavaScript函数来选择恰当的代理服务器。&lt;/p&gt;

&lt;p&gt;sample_pac.dat文件的内容&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FindProxyForURL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;substring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;http:&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;sr&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;应该使用指定的代理&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;PROXY proxy:80&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;substring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;ftp:&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;PROXY fproxy:80&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;substring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;gopher:&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;PROXY gproxy&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;substring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;https:&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;PROXY secproxy:8080&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;sr&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;直连，不经过任何代理&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;DIRECT&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;




&lt;h3 id=&quot;chapter10&quot;&gt;IE代理设置：自动探测设置（WPAD）&lt;/h3&gt;


&lt;p&gt; 浏览器只要选中“自动检测设置”， 就可以使用WPAD协议， WPAD会自动找到PAC文件的URL。  WPAD会使用一系列的资源发现技术（DHCP,DNS等）去寻找PAC文件。
&lt;img src=&quot;/assets/files/2012-12/2012120519553441.png&quot; alt=&quot;&quot; class=&quot;Pic&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;chapter11&quot;&gt;代理认证，和407状态码&lt;/h3&gt;


&lt;p&gt;代理服务器也可以需要权限认证， HTTP定义了一种名为代理认证（Proxy authentication）的机制。 这种机制可以阻止对内容的请求。&lt;/p&gt;

&lt;p&gt;当浏览器访问需要认证的代理时， 代理服务器会返回407 Authorization Required,告诉浏览器输入用户名和密码。&lt;/p&gt;

&lt;p&gt;代理认证跟HTTP基本认证是一样的机制， 如需了解代理认证的机制，请看&lt;a href=&quot;&quot;&gt;HTTP协议基本认证&lt;/a&gt;
&lt;img src=&quot;/assets/files/2012-12/2012120609374853.png&quot; alt=&quot;&quot; class=&quot;Pic&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;chapter12&quot;&gt;使用代理服务器的安全问题&lt;/h3&gt;


&lt;p&gt;代理服务器和抓包工具（比如Fiddler）都能看到http request中的数据。 如果我们发送的request中有敏感数据，比如用户名，密码，信用卡号码。这些信息都会被代理服务器看到。所以非常危险。 所以我们一般都是用HTTPS来加密Http request.  这样代理服务器就看不到里面的数据了。&lt;/p&gt;

&lt;h3 id=&quot;chapter13&quot;&gt;如何搭建代理服务器&lt;/h3&gt;


&lt;p&gt;可以使用CCproxy, 和Squid 来搭建代理服务器。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>.Net垃圾回收机制原理（一）</title>
   <link href="http://beango.github.com/archives/2012/12/13/dot-net-gc-1.html"/>
   <updated>2012-12-13T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/12/13/dot-net-gc-1</id>
   <content type="html">&lt;p&gt;英文原文：&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/magazine/bb985010(en-us).aspx&quot;&gt;Jeffrey Richter&lt;/a&gt; ，编译：&lt;a href=&quot;http://www.cnblogs.com/yukaizhao/archive/2011/11/23/dot_net_GC_1.html&quot;&gt;赵玉开&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;有了Microsoft.Net clr中的垃圾回收机制&lt;a href=&quot;http://blog.jobbole.com/821/&quot; title=&quot;程序员的本质&quot;&gt;程序员&lt;/a&gt;不需要再关注什么时候释放内存，释放内存这件事儿完全由GC做了，对程序员来说是透明的。尽管如此，作为一个.Net程序员很有必要理解垃圾回收是如何工作的。这篇文章我们就来看下.Net是如何分配和管理托管内存的，之后再一步一步描述垃圾回收器工作的算法机制。&lt;/p&gt;

&lt;p&gt;为程序设计一个适当的内存管理策略是困难的也是乏味的，这个工作还会影响你专注于解决程序本身要解决的问题。有没有一种内置的方法可以帮助开发人员解决内存管理的问题呢？当然有了，在.Net中就是GC，垃圾回收。&lt;/p&gt;

&lt;p&gt;让我们想一下，每一个程序都要使用内存资源：例如屏幕显示，网络连接，数据库资源等等。实际上，在一个面向对象环境中，每一种类型都需要占用一点内存资源来存放他的数据，对象需要按照如下的步骤使用内存：&lt;/p&gt;

&lt;p&gt;​1. 为类型分配内存空间&lt;/p&gt;

&lt;p&gt;​2. 初始化内存，将内存设置为可用状态&lt;/p&gt;

&lt;p&gt;​3. 存取对象的成员&lt;/p&gt;

&lt;p&gt;​4. 销毁对象，使内存变成清空状态&lt;/p&gt;

&lt;p&gt;​5. 释放内存&lt;/p&gt;

&lt;p&gt;这种貌似简单的内存使用模式导致过很多的程序问题，有时候程序员可能会忘记释放不再使用的对象，有时候又会试图访问已经释放的对象。这两种bug通常都有一定的隐藏性，不容易发现，他们不像逻辑错误，发现了就可以修改掉。他们可能会在程序运行一段时间之后内存泄漏导致意外的崩溃。事实上，有很多工具可以帮助开发人员检测内存问题，比如：任务管理器，System Monitor AcitvieX Control, 以及Rational的Purify。&lt;/p&gt;

&lt;p&gt;而GC可以完全不需要开发人员去关注什么时候释放内存。然而，垃圾回收器并不是可以管理内存中的所有资源。有些资源垃圾回收器不知道该如何回收他们，这部分资源就需要开发人员自己写代码实现回收。在.Net framework中，开发人员通常会把清理这类资源的代码写到Close、Dispose或者Finalize方法中，稍后我们会看下Finalize方法，这个方法垃圾回收器会自动调用。&lt;/p&gt;

&lt;p&gt;不过，有很多对象是不需要自己实现释放资源的代码的，比如：Rectangle，清空它只需要清空它的left，right，width，height字段就可以了，这垃圾回收器完全可以做。下面让我们来看下内存是如何分配给对象使用的。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对象分配：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;.Net
clr把所有的引用对象都分配到托管堆上。这一点很像c-runtime堆，不过你不需要关注什么时候释放对象，对象会在不用时自动释放。这样，就出现一个问题，垃圾回收器是怎么知道一个对象不再使用该回收了呢？我们稍后解释这个问题。&lt;/p&gt;

&lt;p&gt;现在有几种垃圾回收算法，每一种算法都为一种特定的环境做了性能优化，这篇文章我们关注的是clr的垃圾回收算法。让我们从一个基础概念谈起。&lt;/p&gt;

&lt;p&gt;当一个进程初始化之后，运行时会保留一段连续的空白内存空间，这块内存空间就是托管堆。托管堆会记录一个指针，我们叫它NextObjPtr，这个指针指向下一个对象的分配地址，最初的时候，这个指针指向托管堆的起始位置。&lt;/p&gt;

&lt;p&gt;应用程序使用new操作符创建一个新对象，这个操作符首先要确认托管堆剩余空间能放得下这个对象，如果能放得下，就把NextObjPtr指针指向这个对象，然后调用对象的构造函数，new操作符返回对象的地址。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2011-11/Net-GC-01.gif&quot; title=&quot;.Net 垃圾回收机制原理（一）&quot;&gt;&lt;img src=&quot;/assets/files/2011-11/Net-GC-01.gif&quot; title=&quot;.Net 垃圾回收机制原理（一）&quot; alt=&quot;.Net
垃圾回收机制原理（一）&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图1托管堆&lt;/p&gt;

&lt;p&gt;这时候，NextObjPtr指向托管堆上下一个对象分配的位置，图1显示一个托管堆中有三个对象A、B和C。下一个对象会放在NextObjPtr指向的位置（紧挨着C对象）&lt;/p&gt;

&lt;p&gt;现在让我们再看一下c-runtime堆如何分配内存。在c-runtime堆，分配内存需要遍历一个链表的数据结构，直到找到一个足够大的内存块，这个内存块有可能会被拆分，拆分后链表中的指针要指向剩余内存空间，要确保链表的完好。对于托管堆，分配一个对象只是修改NextObjPtr指针的指向，这个速度是非常快的。事实上，在托管堆上分配一个对象和在线程栈上分配内存的速度很接近。&lt;/p&gt;

&lt;p&gt;到目前为止，托管堆上分配内存的速度似乎比在c-runtime堆上的更快，实现上也更简单一些。当然，托管堆获得这个优势是因为做了一个假设：地址空间是无限的。很显然这个假设是错误的。必须有一种机制保证这个假设成立。这个机制就是垃圾回收器。让我们看下它如何工作。&lt;/p&gt;

&lt;p&gt;当应用程序调用new操作符创建对象时，有可能已经没有内存来存放这个对象了。托管堆可以检测到NextObjPtr指向的空间是否超过了堆的大小，如果超过了就说明托管堆满了，就需要做一次垃圾回收了。&lt;/p&gt;

&lt;p&gt;在现实中，在0代堆满了之后就会触发一次垃圾回收。“代”是垃圾回收器提升性能的一种实现机制。“代”的意思是：新创建的对象是年轻一代，而在回收操作发生之前没有被回收掉的对象是较老的对象。将对象分成几代可以允许垃圾回收器只回收某一代的对象，而不是回收所有对象。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;垃圾回收算法：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;垃圾回收器检查看是否存在应用程序不再使用的对象。如果这样的对象存在，那么这些对象占用的空间就可以被回收（如果堆上没有足够的内存可用，那么new操作符就会抛出OutofMemoryException）。你可能会问垃圾回收器是怎样判断一个对象是否还在用呢？这个问题不太容易得到答案。&lt;/p&gt;

&lt;p&gt;每个应用程序都有一组根对象，根是一些存储位置，他们可能指向托管堆上的某个地址，也可能是null。例如，所有的全局和静态对象指针是应用程序的根对象，另外在线程栈上的局部变量/参数也是应用程序的根对象，还有CPU寄存器中的指向托管堆的对象也是根对象。存活的根对象列表由JIT（just-in-time）编译器和clr维护，垃圾回收器可以访问这些根对象的。&lt;/p&gt;

&lt;p&gt;当垃圾回收器开始运行，它会假设托管堆上的所有对象都是垃圾。也就是说，假定没有根对象，也没有根对象引用的对象。然后垃圾回收器开始遍历根对象并构建一个由所有和根对象之间有引用关系对象构成的图。&lt;/p&gt;

&lt;p&gt;图2显示，托管堆上应用程序的根对象是A，C，D和F，这几个对象就是图的一部分，然后对象D引用了对象H，那么对象H也被添加到图中；垃圾回收器会循环遍历所有可达对象。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2011-11/Net-GC-02.gif&quot; title=&quot;.Net 垃圾回收机制原理（一）&quot;&gt;&lt;img src=&quot;/assets/files/2011-11/Net-GC-02.gif&quot; title=&quot;.Net 垃圾回收机制原理（一）&quot; alt=&quot;.Net垃圾回收机制原理（一）&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图2 托管堆上的对象&lt;/p&gt;

&lt;p&gt;垃圾回收器会挨个遍历根对象和引用对象。如果垃圾回收器发现一个对象已经在图中就会换一个路径继续遍历。这样做有两个目的：一是提高性能，二是避免无限循环。&lt;/p&gt;

&lt;p&gt;所有的根对象都检查完之后，垃圾回收器的图中就有了应用程序中所有的可达对象。托管堆上所有不在这个图上的对象就是要做回收的垃圾对象了。构建好可达对象图之后垃圾回收器开始线性的遍历托管堆，找到连续垃圾对象块（可以认为是空闲内存）。然后垃圾回收器将非垃圾对象移动到一起（使用c语言中的memcpy函数），覆盖所有的内存碎片。当然，移动对象时要禁用所有对象的指针（因为他们都可能是错误的了）。因此垃圾回收器必须修改应用程序的根对象使他们指向对象的新内存地址。此外，如果某个对象包含另一个对象的指针，垃圾回收器也要负责修改引用。图3显示了一次回收之后的托管堆。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2011-11/Net-GC-03.gif&quot; title=&quot;.Net 垃圾回收机制原理（一）&quot;&gt;&lt;img src=&quot;/assets/files/2011-11/Net-GC-03.gif&quot; title=&quot;.Net 垃圾回收机制原理（一）&quot; alt=&quot;.Net垃圾回收机制原理（一）&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图3 回收之后的托管堆&lt;/p&gt;

&lt;p&gt;如图3所示在回收之后，所有的垃圾对象都被标识出来，而所有的非垃圾对象被移动到一起。所有的非垃圾对象的指针也被修改成移动后的内存地址，NextObjPtr指向最后一个非垃圾对象的后面。这时候new操作符就可以继续成功的创建对象了。&lt;/p&gt;

&lt;p&gt;如你看到的，垃圾回收会有显著的性能损失，这是使用托管堆的一个明显的缺点。
不过，要记着内存回收操作旨在托管堆慢了之后才会执行。在满之前托管堆的性能比c-runtime堆的性能好要好。运行时垃圾回收器还会做一些性能优化，我们在下一篇文章中谈论这个。&lt;/p&gt;

&lt;p&gt;下面的代码说明了对象是如何被创建管理的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Application {
    public static int Main(String[] args) {

      // ArrayList object created in heap, myArray is now a root
      ArrayList myArray = new ArrayList();

      // Create 10000 objects in the heap
      for (int x = 0; x &amp;lt; 10000; x++) {
         myArray.Add(new Object());    // Object object created in heap
      }

      // Right now, myArray is a root (on the thread's stack). So, 
      // myArray is reachable and the 10000 objects it points to are also 
      // reachable.
      Console.WriteLine(a.Length);

      // After the last reference to myArray in the code, myArray is not 
      // a root.
      // Note that the method doesn't have to return, the JIT compiler 
      // knows
      // to make myArray not a root after the last reference to it in the 
      // code.

      // Since myArray is not a root, all 10001 objects are not reachable
      // and are considered garbage.  However, the objects are not 
      // collected until a GC is performed.
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也许你会问，GC这么好，为什么ANSI C++中没有它呢？
原因是垃圾回收器必须能找到应用程序的根对象列表，必须找到对象的指针。而在C++中对象的指针之间是可以相互转换的，没有办法知道指针指向的是一个什么对象的指针。在CLR中，托管堆知道对象的实际类型。而元数据（metadata）信息可以用来判断对象引用了什么成员对象。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;垃圾回收和Finalization&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;垃圾回收器提供了一个额外的功能，它可以在对象被标识为垃圾后自动调用其Finalize方法（前提是对象重写了object的Finalize方法）。&lt;/p&gt;

&lt;p&gt;Finalize方法是object对象的一个虚方法，如果需要你可以重写这个方法，但是这个方法只能通过类似c++析构函数的方式重写。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    ~Foo(){
        Console.WriteLine(“Foo Finalize”);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里用过C++的程序员要特别注意，Finalize方法的写法和C++的析构函数完全一样，但是，.Net中的Finalize方法和析构函数的却是不一样的，托管对象是不能被析构的，只能通过垃圾回收回收。&lt;/p&gt;

&lt;p&gt;当你设计一个类时，最好避免重写Finalize方法，原因如下：&lt;/p&gt;

&lt;p&gt;​1.实现Finalize的对象会被提升到更老的“代”，这会增加内存压力，使对象和此对象的关联对象不能在成为垃圾的第一时间回收掉。&lt;/p&gt;

&lt;p&gt;​2. 这些对象分配时间会更长&lt;/p&gt;

&lt;p&gt;​3.让垃圾回收器执行Finalize方法会明显的损耗性能。请记住，每一个实现了Finalize方法的对象都需要执行Finalize方法，如果有一个长度为10000的数组对象，每个对象都需要执行Finalize方法&lt;/p&gt;

&lt;p&gt;​4. 重写Finalize方法的对象可能会引用其他没有实现Finalize方法的对象，这些对象也会延迟回收&lt;/p&gt;

&lt;p&gt;​5.
你没有办法控制什么时候执行Finalize方法。如果要在Finalize方法中释放类似数据库连接之类的资源，就有可能导致数据库资源在时候后很久才得以释放&lt;/p&gt;

&lt;p&gt;​6.当程序崩溃时，一些对象还被引用，他们的Finalize方法就没有机会执行了。这种情况会在后台线程使用对象，或者对象在程序退出时，或者AppDomain卸载时。另外，默认情况下，当应用程序被强制结束时Finalize方法也不会执行。当然所有的操作系统资源会被回收；但是在托管堆上的对象不会回收。你可以通过调用GC的RequestFinalizeOnShutdown方法改变这种行为。&lt;/p&gt;

&lt;p&gt;​7.运行时不能控制多个对象Finalize方法执行的顺序。而有时候对象的销毁可能有顺序性&lt;/p&gt;

&lt;p&gt;如果你定义的对象必须实现Finalize方法，那么要确保Finalize方法尽可能快的执行，要避免所有可能引起阻塞的操作，包括任何线程同步操作。另外，要确保Finalize方法不会引起任何异常，如果有异常垃圾回收器会继续执行其他对象的Finalize方法直接忽略掉异常。&lt;/p&gt;

&lt;p&gt;当编译器生成代码时会自动在构造函数上调用基类的构造函数。同样C++的编译器也会为析构函数自动添加基类析构函数的调用。但是，.Net中的Finalize函数不是这样子，编译器不会对Finalize方法做特殊处理。如果你想在Finalize方法中调用父类的Finalize方法，必须自己显示添加调用代码。&lt;/p&gt;

&lt;p&gt;请注意在C#中Finalize方法的写法和c++中的析构函数一样，但是C#不支持析构函数，不要让这种写法欺骗你。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GC调用Finalize方法的内部实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;表面看，垃圾回收器嗲用Finalize方法很简单，你创建一个对象，当对象回收时调用它的Finalize方法。但是事实上要复杂一些。&lt;/p&gt;

&lt;p&gt;当应用程序创建一个新对象时，new操作符在堆上分配内存。如果对象实现了Finalize方法。对象的指针会放到终结队列中。终结队列是由垃圾回收器控制的内部数据结构。在队列中每一个对象在回收时都需要调用它们的Finalize方法。&lt;/p&gt;

&lt;p&gt;下图显示的堆上包含几个对象，其中一些对象是跟对象，一些对象不是。当对象C、E、F、I和J创建时，系统会检测这些对象实现了Finalize方法，并将它们的指针放到终结队列中。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2011-11/Net-GC-04.gif&quot; title=&quot;.Net 垃圾回收机制原理（一）&quot;&gt;&lt;img src=&quot;/assets/files/2011-11/Net-GC-04.gif&quot; title=&quot;.Net 垃圾回收机制原理（一）&quot; alt=&quot;.Net垃圾回收机制原理（一）&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Finalize方法要做的事情通常是回收垃圾回收器不能回收的资源，例如文件句柄，数据库连接等等。&lt;/p&gt;

&lt;p&gt;当垃圾回收时，对象B、E、G、H、I和J被标记为垃圾。垃圾回收器扫描终结队列找到这些对象的指针。当发现对象指针时，指针会被移动到Freachable队列。Freachable队列是另一个由垃圾回收器控制的内部数据结构。在Freachable队列中的每一个对象的Finalize方法将执行。&lt;/p&gt;

&lt;p&gt;垃圾回收之后，托管堆如图6所示。你可以看到对象B、G、H已经被回收了，因为这几个对象没有Finalize方法。然而对象E、I、J还没有被回收掉，因为他们的Finalize方法还没有执行。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2011-11/Net-GC-05.gif&quot; title=&quot;.Net 垃圾回收机制原理（一）&quot;&gt;&lt;img src=&quot;/assets/files/2011-11/Net-GC-05.gif&quot; title=&quot;.Net 垃圾回收机制原理（一）&quot; alt=&quot;.Net垃圾回收机制原理（一）&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图5 垃圾回收后的托管堆&lt;/p&gt;

&lt;p&gt;程序运行时会有一个专门的线程负责调用Freachable队列中对象的Finalize方法。当Freachable队列为空时，这个线程会休眠，当队列中有对象时，线程被唤醒，移除队列中的对象，并调用它们的Finalize方法。因此在执行Finalize方法时不要企图访问线程的local storage。&lt;/p&gt;

&lt;p&gt;终结队列（finalization queue）和Freachable队列之间的交互很巧妙。首先让我告诉你freachable的名字是怎么来的。F显然是finalization；在此队列中的每一个对象都在等待执行他们的Finalize方法；reachable意思是这些对象来了。另一种说法，Freachable队列中的对象被认为是跟对象，就像是全局变量或静态变量。因此，如果一个对象在freachable队列中，那么这个对象就不是垃圾。&lt;/p&gt;

&lt;p&gt;简短点说，当一个对象是不可达的，垃圾回收器会认为这个对象是垃圾。那么，当垃圾回收器将对象从终结队列移动到Freachable队列中，这些对象就不再是垃圾了，它们的内存也不会回收。从这一点上来讲，垃圾回收器已经完成标识垃圾，一些对象被标识成垃圾又被重新认为成非垃圾对象。垃圾回收器回收压缩内存，清空freachable队列，执行队列中每一个对象的Finalize方法。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2011-11/Net-GC-06.gif&quot; title=&quot;.Net 垃圾回收机制原理（一）&quot;&gt;&lt;img src=&quot;/assets/files/2011-11/Net-GC-06.gif&quot; title=&quot;.Net 垃圾回收机制原理（一）&quot; alt=&quot;.Net垃圾回收机制原理（一）&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图6 再次执行垃圾回收后的托管堆&lt;/p&gt;

&lt;p&gt;再次出发垃圾回收之后，实现Finalize方法的对象才被真正的回收。这些对象的Finalize方法已经执行过了，Freachable队列清空了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;垃圾回收让对象复活&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在前面部分我们已经说了，当程序不使用某个对象时，这个对象会被回收。然而，如果对象实现了Finalize方法，只有当对象的Finalize方法执行之后才会认为这个对象是可回收对象并真正回收其内存。换句话说，这类对象会先被标识为垃圾，然后放到freachable队列中复活，然后执行Finalize之后才被回收。正是Finalize方法的调用，让这种对象有机会复活，我们可以在Finalize方法中让某个对象强引用这个对象；那么垃圾回收器就认为这个对象不再是垃圾了，对象就复活了。&lt;/p&gt;

&lt;p&gt;如下复活演示代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Foo {
  ~Foo(){
  Application.ObjHolder = this;
  }
}

class Application{
  static public Object ObjHolder = null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这种情况下，当对象的Finalize方法执行之后，对象被Application的静态字段ObjHolder强引用，成为根对象。这个对象就复活了，而这个对象引用的对象也就复活了，但是这些对象的Finalize方法可能已经执行过了，可能会有意想不到的错误发生。&lt;/p&gt;

&lt;p&gt;事实上，当你设计自己的类型时，对象的终结和复活有可能完全不可控制。这不是一个好现象；处理这种情况的常用做法是在类中定义一个bool变量来表示对象是否执行过了Finalize方法，如果执行过Finalize方法，再执行其他方法时就抛出异常。&lt;/p&gt;

&lt;p&gt;现在，如果有其他的代码片段又将Application.ObjHolder设置为null，这个对象变成不可达对象。最终垃圾回收器会把对象当成垃圾并回收对象内存。请注意这一次对象不会出现在finalization队列中，它的Finalize方法也不会再执行了。&lt;/p&gt;

&lt;p&gt;复活只有有限的几种用处，你应该尽可能避免使用复活。尽管如此，当使用复活时，最好重新将对象添加到终结队列中，GC提供了静态方法ReRegisterForFinalize方法做这件事：
 如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Foo{
  ~Foo(){
  Application.ObjHolder = this;
  GC.ReRegisterForFinalize(this);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当对象复活时，重新将对象添加到复活队列中。需要注意的时如果一个对象已经在终结队列中，然后又调用了GC.ReRegisterForFinalize(obj)方法会导致此对象的Finalize方法重复执行。&lt;/p&gt;

&lt;p&gt;垃圾回收机制的目的是为开发人员简化内存管理。&lt;/p&gt;

&lt;p&gt;下一篇我们谈一下弱引用的作用，垃圾回收中的“代”，多线程中的垃圾回收和与垃圾回收相关的性能计数器。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MongoDB Sharding 机制分析</title>
   <link href="http://beango.github.com/archives/2012/12/09/mongodb-sharding-analysis.html"/>
   <updated>2012-12-09T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/12/09/mongodb-sharding-analysis</id>
   <content type="html">&lt;p&gt;转载请注明出处：&lt;a href=&quot;http://xiezhenye.com/2012/12/mongodb-sharding-%e6%9c%ba%e5%88%b6%e5%88%86%e6%9e%90.html&quot; title=&quot;MongoDB Sharding 机制分析&quot;&gt;http://xiezhenye.com/2012/12/mongodb-sharding-%e6%9c%ba%e5%88%b6%e5%88%86%e6%9e%90.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;MongoDB 是一种流行的非关系型数据库。作为一种文档型数据库，除了有无 schema 的灵活的数据结构，支持复杂、丰富的查询功能外，MongoDB 还自带了相当强大的 sharding 功能。&lt;/p&gt;

&lt;p&gt;要说 MongoDB 的 sharding，首先说说什么是 sharding。所谓 sharding 就是将数据水平切分到不同的物理节点。这里着重点有两个，一个是水平切分，另一个是物理节点。一般我们说数据库的分库分表有两种类型。一种是水平划分，比如按用户 id 取模，按余数划分用户的数据，如博客文章等；另一种是垂直划分，比如把用户信息放一个节点，把文章放另一个节点，甚至可以把文章标题基本信息放一个节点，正文放另一个节点。sharding指的是前一种。而物理节点，主要是和如 mysql等提供的表分区区分。表分区虽然也对数据进行了划分，但是这些分区仍然是在同一个物理节点上。&lt;/p&gt;

&lt;p&gt;那么，为什么要使用 sharding 呢？sharding解决了什么问题，带来了什么好处呢？不少人都经历过自己的网站、应用由小到大，用户越来越多，访问量越来越大，数据量也越来越大。这当然是好事。但是，以前一个服务器就可以抗下的数据库现在不行了。开始还可以做做优化，再加个缓存。但是再后来，无论如何都不是一个服务器能承受了。数据量也会很快超过服务器的硬盘容量。这时候，就不得不进行拆分，做
sharding 了。这里，sharding可以利用上更多的硬件资源来解决了单机性能极限的问题。此外，将数据进行水平切分后，还会减小每个索引的体积。由于一般数据库的索引都是B树结构，索引体积减小后，索引深度也会随之减小，索引查找的速度也会随之提高。对于一些比较费时的统计查询，还可以由此把计算量分摊到多个机器上同时运算，通过分布式来提高速度。&lt;/p&gt;

&lt;p&gt;虽然 sharding 有很多好处，但是传统数据库做 sharding会遇到很多麻烦事。首先是扩容和初始化的问题。比如，原来按用户 id 模 5，分了5个节点，后来随着数据增长，这 5 个也不够用了，需要再增加。这时候如果改成10个，则至少要挪动一半数据。如果不是整倍数，比如扩展到7个节点，那绝大部分数据都会被挪一遍。对于已经做了sharding的大规模数据库来说，这是一件相当可怕的事情。而且在数据迁移期间，通常都无法继续提供服务，这将造成很长时间的服务中断。对从一个未做sharding的数据库开始创建也是同样。如果使用虚拟节点，比如将数据划分成1000个虚拟节点，然后通过映射关系来找到对应的物理节点，可以有所改善。但仍然无法避免迁移过程中的服务中断。另一个麻烦事是数据路由。数据拆分以后，应用程序就需要去定位数据位于哪个节点。还需要将涉及多个节点的查询的结果合并起来。这个工作如果没有使用数据库中间件的话，就需要花不少功夫自己实现，即使使用了中间件，也很难做到透明。由于关系型数据库功能的复杂性，很多功能在sharding上将无法正常使用。比如join、事务等。因此会造成应用层的大量修改测试工作。&lt;/p&gt;

&lt;p&gt;sharding 会有这许多麻烦事，那么 MongoDB 的 sharding 又如何呢？&lt;/p&gt;

&lt;p&gt;MongoDB 的 sharding的特色就是自动化。具体体现为可以动态扩容、自动平衡数据、以及透明的使用接口。可以从一个普通的replica set，或者单个实例平滑升级，可以动态增加删除节点，响应数据快速增长。可以自动在节点间平衡数据量，避免负载集中在少数节点，而在这期间不影响数据库读写访问。对客户端，可以使用完全相同的驱动，大部分功能可用，基本不需要更改任何代码。&lt;/p&gt;

&lt;p&gt;MongoDB 的 sharding 有如此强大的功能，它的实现机制是怎样的呢？下图就是 MongoDB sharding 的结构图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/1.png&quot; title=&quot;1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可以看出，MongoDB sharding 主要分为 3 大部分。shard 节点、config节点和 config 节点。对客户端来说，直接访问的是 图中绿色的 mongos 节点。背后的 config 节点和 shard 节点是客户端不能直接访问的。mongos的主要作用是数据路由。从元数据中定位数据位置，合并查询结果。另外，mongos节点还负责数据迁移和数据自动平衡，并作为 sharding 集群的管理节点。它对外的接口就和普通的 mongod 一样。因此，可以使用标准 mongodb 客户端和驱动进行访问。mongos节点是无状态的，本身不保存任何数据和元数据，因此可以任意水平扩展，这样任意一个节点发生故障都可以很容易的进行故障转移，不会造成严重影响。&lt;/p&gt;

&lt;p&gt;其中蓝色的 shard 节点就是实际存放数据的数据节点。每个 shard 节点可以是单个 mongod 实例，也可以使一个 replica set 。通常在使用 sharding 的时候，都会同时使用 replica set来实现高可用，以免集群内有单个节点出故障的时候影响服务，造成数据丢失。同时，可以进一步通过读写分离来分担负载。对于每个开启 sharding 的 db 来说，都会有一个 默认 shard 。初始时，第一个 chunk 就会在那里建立。新数据也就会先插入到那个 shard 节点中去。&lt;/p&gt;

&lt;p&gt;图中紫色的 config 节点存储了元数据，包括数据的位置，即哪些数据位于哪些节点，以及集群配置信息。config节点也是普通的 mongod 。如图所示，一组 config 节点由 3 个组成。这 3 个 config 节点并非是一个 replica set。它们的数据同步是由 mongos 执行两阶段提交来保证的。这样是为了避免复制延迟造成的元数据不同步。config节点一定程度上实现了高可用。在一个或两个节点发生故障时，config集群会变成只读。但此时，整个 sharding 集群仍然可以正常读写数据。只是无法进行数据迁移和自动均衡而已。&lt;/p&gt;

&lt;p&gt;config 节点里存放的元数据都有些啥呢？连上 mongos 后，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use config; show collections
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;settings
shards
databases
collections
chunks
mongos
changelog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以进一步查看这些东西的数据。这个 config 库就是后端 config 节点上的数据的映射，提供了一个方便的读取元数据的入口。这些 collection 里面都是什么呢？ settings 里是 sharding 的配置信息，比如数据块大小，是否开启自动平衡。shards 里存放的是后端 shard 节点的信息，包括 ip，端口等。databases 里存放的是数据库的信息，是否开启sharding，默认 shard 等。collections 中则是哪些 collection 启用了sharding，已经用了什么 shard key。chunks 里是数据的位置，已经每个 chunk 的范围等。mongos 里是关于 mongos 的信息，changelog 是一个 capped collection，保存了最近的 10m 元数据变化记录。&lt;/p&gt;

&lt;p&gt;mongodb sharding 的搭建也很容易。简单的几步就能完成。&lt;/p&gt;

&lt;p&gt;先启动若干 shard 节点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongod --shardsvr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动 3 个 config 节点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongod --configsvr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动 mongos&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongos --configdb=192.168.1.100, 192.168.1.101, 192.168.1.102
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，–shardsvr 参数只起到修改默认端口为 27018 作用，–configsvr则修改默认端口为 27019 以及默认路径为/data/configdb。此外并没有什么直接作用。实际使用时，也可以自己指定端口和数据路径。此外，这两个参数的另一个作用就是对进程进行标记，这样在ps aux 的进程列表里，就很容易确定进程的身份。–configdb 参数就是 config 节点的地址。如果更改了默认端口，则需要在这里加上。&lt;/p&gt;

&lt;p&gt;然后我们把数据节点加入集群：在 mongos 上运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use admin
sh.addShard(’ [hostname]:[port]’)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用的事 replicaSet，则是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use admin
sh.addShard(’replicaSetName/,,’)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着就是启用 sharding 了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sh.enableSharding(dbname)
sh.shardCollection(fullName, key, unique)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以了。还是很简单的吧。如果 collection 里有数据，则会自动进行数据平衡。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/2.png&quot; title=&quot;2&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之前说过，mongodb 的 sharding 把数据分成了数据块（chunk）来进行管理。现在来看看 chunk 究竟是怎么回事。在mongodb sharding 中，chunk是数据迁移的基本单位。每个节点中的数据都被划分成若干个 chunk 。一个 chunk 本质上是 shard key 的一个连续区间。chunk实际上是一个逻辑划分而非物理划分。sharding 的后端就是普通的 mongod 或者replica set，并不会因为是 sharding 就对数据做特殊处理。一个 chunk 并不是实际存储的一个页或者一个文件之类，而是仅仅在 config 节点中的元数据中体现。mongodb 的sharding 策略实际上就是一个 range 模式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/3.png&quot; title=&quot;3&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图，第一个 chunk 的范围就是 uid 从 -∞ 到 12000 范围内的数据。第二个就是 12000 到 58000 。以此类推。对于一个刚配置为 sharding 的 collection，最开始只有一个 chunk，范围是从 -∞ 到 +∞。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/4.png&quot; title=&quot;4&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;随着数据的增长，其中的数据大小超过了配置的 chunk size，默认是 64M 则这个 chunk 就会分裂成两个。因为 chunk 是逻辑单元，所以分裂操作只涉及到元数据的操作。数据的增长会让 chunk 分裂得越来越多。这时候，各个 shard 上的 chunk 数量就会不平衡。这时候，mongos 中的一个组件 balancer 就会执行自动平衡。把 chunk 从 chunk 数量最多的 shard 节点挪动到数量最少的节点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/5.png&quot; title=&quot;5&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/6.png&quot; title=&quot;6&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后，各个 shard 节点上的 chunk 数量就会趋于平衡。当然，balance不一定会使数据完全平均，因为移动数据本身有一定成本，同时为了避免极端情况下早晨数据来回迁移，只有在两个 shard 的 chunk 数量之差达到一定阈值时才会进行。默认阈值是 8 个。也就是说，默认情况下，只有当两个节点的数据量差异达到 64M * 8 == 256M 的时候才会进行。这样就不用对刚建好的 sharding，插入了不少数据，为什么还是都在一个节点里感到奇怪了。那只是因为数据还不够多到需要迁移而已。&lt;/p&gt;

&lt;p&gt;在数据迁移的过程中，仍然可以进行数据读写，并不会因此而影响可用性。那么mongodb是怎么做到的呢？在数据迁移过程中，数据读写操作首先在源数据节点中进行。待迁移完毕后，再将这期间的更新操作同步到新节点中去。最后再更新config节点，标记数据已经在新的地方，完成迁移。只有在最后同步迁移期间的操作的时候，需要锁定数据更新。这样就讲锁定时间尽可能缩小，大大降低数据迁移对服务的影响。&lt;/p&gt;

&lt;p&gt;mongodb 的 sharding 和传统 sharding 的最大区别就在于引入了元数据。看似增加了复杂度，并增加了一些额外的存储，但是由此带来的灵活性却是显而易见的。传统的 sharding 本质上是对数据的静态映射，所有那些数据迁移的困难都是由此而来。而引入元数据以后，就变静态映射为动态映射。数据迁移就不再是难事了。从而从根本上解决了问题。另一方面，用元数据实现 chunk 则降低了实现难度，后端节点仍然可以使用原有的技术。同时，因为不需要对后端数据进行变动，也使部署迁移变得更容易，只需要另外加上 mongos 节点和 config 节点即可。&lt;/p&gt;

&lt;p&gt;再说说数据路由功能。mongos的最主要功能就是作为数据路由，找到数据的位置，合并查询结果。来看看它是如何处理的。如果查询的条件是shard key ，那么 mongos 就能从元数据直接定位到 chunk 的位置，从目标节点找到数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/7.png&quot; title=&quot;7&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果查询条件是 shard key 的范围，由于 chunk 是按 shard key的范围来划分的，所以 mongos 也可以找到数据对应 chunk 的位置，并把各个节点返回的数据合并。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/8.png&quot; title=&quot;8&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果查询的条件不是任何一个索引，原来的全 collection 遍历仍然不可避免。但是会分发到所有节点进行。所以，还是可以起到分担负载的作用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/9.png&quot; title=&quot;9&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果查询的条件是一个索引，但不是 shard key，查询也会被分发到所有节点，不过在每个节点上索引仍然有效。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/10.png&quot; title=&quot;10&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果是按查询 shard key 进行排序，同样由于 chunk 是一个 shard key 的范围，则会依次查询各 chunk 所在节点，而无需返回所有数据再排序。如果不是按 shard key 排序，则会在每个节点上执行排序操作，然后由 mongos 进行归并排序。由于是对已排序结果的归并排序，所以在 mongos 上不会有多少压力，查询结果的游标也会变成在每个节点上的游标。并不需要把所有数据都吐出来。&lt;/p&gt;

&lt;p&gt;从上面可以看到，对 sharding 集群来说，shard key 的选择是至关重要的。shard key 其实就相当于数据库的聚簇索引，所以选择聚簇索引的原则和选择 shard key的原则是差不多的。同样， shard key一旦设定就无法再更改，所以，选择的时候就要谨慎。shard key的选择主要就这么几点。&lt;/p&gt;

&lt;p&gt;首先，shard key的值要是固定的，不会被更改的。因为一旦这个值被更改，就有可能会从一个节点被挪动到另一个节点，从而带来很大的开销。&lt;/p&gt;

&lt;p&gt;第二，shard key 要有足够的区分度。同样因为 chunk 是一个 shard key 的范围，所以 shard key 相同的值只能位于同一个 chunk 。如果 shard key 相同的值很大，致使一个 chunk 的大小超过了 chunk size，也无法对 chunk 进行分裂，数据均衡。同时，和一般的数据库索引一样，更好的区分度也能提高查询性能。&lt;/p&gt;

&lt;p&gt;第三，shard key 还要有一定的随机性而不是单向增长。单向增长的 shard key 会导致新插入的数据都位于一个 chunk 中，在在某一个 shard 节点中产生集中的写压力。所以，最好避免直接使用 _id ，时间戳这种单向增长的值作为 shard key。&lt;/p&gt;

&lt;p&gt;mongodb 的 sharding 有很多优势，但是也同样有其局限性。&lt;/p&gt;

&lt;p&gt;首先，mongodb 只提供了 range 模式的 sharding。这种模式虽然可以对按 shard key进行 range 查询、排序进行优化，但是也会造成使用单向增长的值时，写入集中的结果。&lt;/p&gt;

&lt;p&gt;第二，启用了 sharding 之后，就无法保证除 shard key 以为其他的索引的唯一性。即使设为unique，也只是保证在每个节点中唯一。有一个办法是，把索引设为 {&amp;lt;shard_key&gt;:1, &amp;lt;unique_key&gt;:1}。但是这样并不一定满足业务逻辑需求。&lt;/p&gt;

&lt;p&gt;第三，启用 sharding 后，无法直接使用 group() 。但是可以用 map reduce 功能作为替代。&lt;/p&gt;

&lt;p&gt;第四，虽然数据迁移操作对读写影响很小，但是这个过程需要先把数据从磁盘中换入内存才能进行，所以可能会破坏热数据缓存。此外，数据迁移也还是会增大 io 压力，所以可以考虑平时关闭自动平衡，在凌晨压力小的时候再进行。&lt;/p&gt;

&lt;p&gt;最后，config 节点的元数据同步对时钟准确性要求比较高，一旦各 config 时钟误差大了，就会出现无法上锁，从而无法更改，导致数据集中。因此 ntp 时钟同步时必不可少的。&lt;/p&gt;

&lt;p&gt;在这里再说一下 sharding 集群的备份问题。由于后端数据节点仍然是普通的 mongod 或 replica set，所以备份其实和原先差不多。只是需要注意的是，备份前需要停止自动平衡，保证备份期间 sharding 的元数据不会变动，然后备份 shard 节点和 config 节点数据即可。&lt;/p&gt;

&lt;p&gt;P.S. 这篇东西是十月份我在 &lt;a href=&quot;http://www.thinkinlamp.com/&quot;&gt;thinkinlamp&lt;/a&gt;第三届数据库大会上的 topic 的内容的整理。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>缓存、缓存算法和缓存框架简介</title>
   <link href="http://beango.github.com/archives/2012/12/04/cache-algorithm.html"/>
   <updated>2012-12-04T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/12/04/cache-algorithm</id>
   <content type="html">&lt;p&gt;英文原文：&lt;a href=&quot;http://www.jtraining.com/component/content/article/35-jtraining-blog/98.html&quot;&gt;jtraining&lt;/a&gt;，译文：&lt;a href=&quot;http://www.leexiang.com/cache-algorithm&quot;&gt;Lixiang&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们都听过
cache，当你问他们是什么是缓存的时候，他们会给你一个完美的答案，可是他们不知道缓存是怎么构建的，或者没有告诉你应该采用什么标准去选择缓存框架。在这边文章，我们会去讨论缓存，缓存算法，缓存框架以及哪个缓存框架会更好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;面试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;“缓存就是存贮数据（使用频繁的数据）的临时地方，因为取原始数据的代价太大了，所以我可以取得快一些。”&lt;/p&gt;

&lt;p&gt;这就是 programmer one （programmer one
是一个面试者）在面试中的回答（一个月前，他向公司提交了简历，想要应聘要求在缓存，缓存框架，大规模数据操作有着丰富经验的
java 开发职位）。&lt;/p&gt;

&lt;p&gt;programmer one 通过 hash table
实现了他自己的缓存，但是他知道的只是他的缓存和他那存储着150条记录的 hash
table，这就是他认为的大规模数据（缓存 = hashtable，只需要在 hash table
查找就好了），所以，让我们来看看面试的过程吧。&lt;/p&gt;

&lt;p&gt;面试官：你选择的缓存方案，是基于什么标准的？&lt;/p&gt;

&lt;p&gt;programmer one：呃，（想了5分钟）嗯，基于，基于，基于数据（咳嗽……）&lt;/p&gt;

&lt;p&gt;面试官：excese me ! 能不能重复一下？&lt;/p&gt;

&lt;p&gt;programmer one：数据？！&lt;/p&gt;

&lt;p&gt;面试官：好的。说说几种缓存算法以及它们的作用&lt;/p&gt;

&lt;p&gt;programmer
one：（凝视着面试官，脸上露出了很奇怪的表情，没有人知道原来人类可以做出这种表情 
）&lt;/p&gt;

&lt;p&gt;面试官：好吧，那我换个说法，当缓存达到容量时，会怎么做？&lt;/p&gt;

&lt;p&gt;programmer one：容量？嗯（思考……hash table
的容量时没有限制的，我能任意增加条目，它会自动扩充容量的）（这是 programmer
one 的想法，但是他没有说出来）&lt;/p&gt;

&lt;p&gt;面试官对 programmer one
表示感谢（面试过程持续了10分钟），之后一个女士走过来说：谢谢你的时间，我们会给你打电话的，祝你好心情。这是
programmer one
最糟糕的面试（他没有看到招聘对求职者有丰富的缓存经验背景要求，实际上，他只看到了丰厚的报酬 
）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说到做到&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;programmer one
离开之后，他想要知道这个面试者说的问题和答案，所以他上网去查，programmer
one 对缓存一无所知，除了：当我需要缓存的时候，我就会用 hash table。&lt;/p&gt;

&lt;p&gt;在他使用了他最爱的搜索引擎搜索之后，他找到了一篇很不错的关于缓存文章，并且开始去阅读……&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么我们需要缓存？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;很久很久以前，在还没有缓存的时候……用户经常是去请求一个对象，而这个对象是从数据库去取，然后，这个对象变得越来越大，这个用户每次的请求时间也越来越长了，这也把数据库弄得很痛苦，他无时不刻不在工作。所以，这个事情就把用户和数据库弄得很生气，接着就有可能发生下面两件事情：&lt;/p&gt;

&lt;p&gt;１.用户很烦，在抱怨，甚至不去用这个应用了（这是大多数情况下都会发生的）&lt;/p&gt;

&lt;p&gt;２.数据库为打包回家，离开这个应用，然后，就出现了大麻烦（没地方去存储数据了）（发生在极少数情况下）&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;上帝派来了缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在几年之后，IBM（60年代）的研究人员引进了一个新概念，它叫“缓存”。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;什么是缓存？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;正如开篇所讲，缓存是“存贮数据（使用频繁的数据）的临时地方，因为取原始数据的代价太大了，所以我可以取得快一些。”&lt;/p&gt;

&lt;p&gt;缓存可以认为是数据的池，这些数据是从数据库里的真实数据复制出来的，并且为了能别取回，被标上了标签（键
ID）。太棒了&lt;/p&gt;

&lt;p&gt;programmer one 已经知道这点了，但是他还不知道下面的缓存术语。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.jobbole.com/wp-content/uploads/2012/12/caching.jpg&quot; title=&quot;缓存、缓存算法和缓存框架简介&quot;&gt;&lt;img src=&quot;/assets/files/2012-12/caching.jpg&quot; title=&quot;缓存、缓存算法和缓存框架简介&quot; alt=&quot;缓存、缓存算法和缓存框架简介&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;命中：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当客户发起一个请求（我们说他想要查看一个产品信息），我们的应用接受这个请求，并且如果是在第一次检查缓存的时候，需要去数据库读取产品信息。&lt;/p&gt;

&lt;p&gt;如果在缓存中，一个条目通过一个标记被找到了，这个条目就会被使用、我们就叫它缓存命中。所以，命中率也就不难理解了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cache Miss：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;但是这里需要注意两点：&lt;/p&gt;

&lt;p&gt;１.　如果还有缓存的空间，那么，没有命中的对象会被存储到缓存中来。&lt;/p&gt;

&lt;p&gt;２.　如果缓存慢了，而又没有命中缓存，那么就会按照某一种策略，把缓存中的旧对象踢出，而把新的对象加入缓存池。而这些策略统称为替代策略（缓存算法），这些策略会决定到底应该提出哪些对象。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;存储成本：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当没有命中时，我们会从数据库取出数据，然后放入缓存。而把这个数据放入缓存所需要的时间和空间，就是存储成本。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;索引成本：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;和存储成本相仿。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;失效：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当存在缓存中的数据需要更新时，就意味着缓存中的这个数据失效了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;替代策略：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当缓存没有命中时，并且缓存容量已经满了，就需要在缓存中踢出一个老的条目，加入一条新的条目，而到底应该踢出什么条目，就由替代策略决定。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最优替代策略：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最优的替代策略就是想把缓存中最没用的条目给踢出去，但是未来是不能够被预知的，所以这种策略是不可能实现的。但是有很多策略，都是朝着这个目前去努力。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java 街恶梦：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当 programmer one
在读这篇文章的时候，他睡着了，并且做了个恶梦（每个人都有做恶梦的时候）。&lt;/p&gt;

&lt;p&gt;programmer one：nihahha，我要把你弄失效！（疯狂的状态）&lt;/p&gt;

&lt;p&gt;缓存对象：别别，让我活着，他们还需要我，我还有孩子。&lt;/p&gt;

&lt;p&gt;programmer
one：每个缓存对象在失效之前都会那样说。你从什么时候开始有孩子的？不用担心，现在就永远消失吧！&lt;/p&gt;

&lt;p&gt;哈哈哈哈哈……programmer one 恐怖的笑着，但是警笛打破了沉静，警察把
programmer one
抓了起来，并且控告他杀死了（失效）一个仍需被使用的缓存对象，他被押到了监狱。&lt;/p&gt;

&lt;p&gt;programmer one
突然醒了，他被吓到了，浑身是汗，他开始环顾四周，发现这确实是个梦，然后赶紧继续阅读这篇文章，努力的消除自己的恐慌。&lt;/p&gt;

&lt;p&gt;在programmer one 醒来之后，他又开始阅读文章了。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缓存算法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;没有人能说清哪种缓存算法优于其他的缓存算法&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Least Frequently Used（LFU）：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;大家好，我是
LFU，我会计算为每个缓存对象计算他们被使用的频率。我会把最不常用的缓存对象踢走。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Least Recently User（LRU）：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我是 LRU 缓存算法，我把最近最少使用的缓存对象给踢走。&lt;/p&gt;

&lt;p&gt;我总是需要去了解在什么时候，用了哪个缓存对象。如果有人想要了解我为什么总能把最近最少使用的对象踢掉，是非常困难的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.jobbole.com/12749/&quot; title=&quot;浏览器&quot;&gt;浏览器&lt;/a&gt;就是使用了我（LRU）作为缓存算法。新的对象会被放在缓存的顶部，当缓存达到了容量极限，我会把底部的对象踢走，而技巧就是：我会把最新被访问的缓存对象，放到缓存池的顶部。&lt;/p&gt;

&lt;p&gt;所以，经常被读取的缓存对象就会一直呆在缓存池中。有两种方法可以实现我，array
或者是 linked list。&lt;/p&gt;

&lt;p&gt;我的速度很快，我也可以被数据访问模式适配。我有一个大家庭，他们都可以完善我，甚至做的比我更好（我确实有时会嫉妒，但是没关系）。我家庭的一些成员包括
LRU2 和 2Q，他们就是为了完善 LRU 而存在的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Least Recently Used 2（LRU2）：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我是 Least Recently Used 2，有人叫我最近最少使用
twice，我更喜欢这个叫法。我会把被两次访问过的对象放入缓存池，当缓存池满了之后，我会把有两次最少使用的缓存对象踢走。因为需要跟踪对象2次，访问负载就会随着缓存池的增加而增加。如果把我用在大容量的缓存池中，就会有问题。另外，我还需要跟踪那么不在缓存的对象，因为他们还没有被第二次读取。我比LRU好，而且是
adoptive to access 模式 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Two Queues（2Q）：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我是 Two Queues；我把被访问的数据放到 LRU
的缓存中，如果这个对象再一次被访问，我就把他转移到第二个、更大的 LRU
缓存。&lt;/p&gt;

&lt;p&gt;我踢走缓存对象是为了保持第一个缓存池是第二个缓存池的1/3。当缓存的访问负载是固定的时候，把
LRU 换成 LRU2，就比增加缓存的容量更好。这种机制使得我比 LRU2 更好，我也是
LRU 家族中的一员，而且是 adoptive to access 模式 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Adaptive Replacement Cache（ARC）：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我是 ARC，有人说我是介于 LRU 和 LFU 之间，为了提高效果，我是由2个 LRU
组成，第一个，也就是 L1，包含的条目是最近只被使用过一次的，而第二个
LRU，也就是 L2，包含的是最近被使用过两次的条目。因此， L1 放的是新的对象，而
L2 放的是常用的对象。所以，别人才会认为我是介于 LRU 和 LFU
之间的，不过没关系，我不介意。&lt;/p&gt;

&lt;p&gt;我被认为是性能最好的缓存算法之一，能够自调，并且是低负载的。我也保存着历史对象，这样，我就可以记住那些被移除的对象，同时，也让我可以看到被移除的对象是否可以留下，取而代之的是踢走别的对象。我的记忆力很差，但是我很快，适用性也强。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Most Recently Used（MRU）：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我是 MRU，和 LRU
是对应的。我会移除最近最多被使用的对象，你一定会问我为什么。好吧，让我告诉你，当一次访问过来的时候，有些事情是无法预测的，并且在缓存系统中找出最少最近使用的对象是一项时间复杂度非常高的运算，这就是为什么我是最好的选择。&lt;/p&gt;

&lt;p&gt;我是数据库内存缓存中是多么的常见！每当一次缓存记录的使用，我会把它放到栈的顶端。当栈满了的时候，你猜怎么着？我会把栈顶的对象给换成新进来的对象！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;First in First out（FIFO）：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我是先进先出，我是一个低负载的算法，并且对缓存对象的管理要求不高。我通过一个队列去跟踪所有的缓存对象，最近最常用的缓存对象放在后面，而更早的缓存对象放在前面，当缓存容量满时，排在前面的缓存对象会被踢走，然后把新的缓存对象加进去。我很快，但是我并不适用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Second Chance：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;大家好，我是 second chance，我是通过 FIFO 修改而来的，被大家叫做 second
chance 缓存算法，我比 FIFO 好的地方是我改善了 FIFO 的成本。我是 FIFO
一样也是在观察队列的前端，但是很FIFO的立刻踢出不同，我会检查即将要被踢出的对象有没有之前被使用过的标志（1一个
bit
表示），没有没有被使用过，我就把他踢出；否则，我会把这个标志位清除，然后把这个缓存对象当做新增缓存对象加入队列。你可以想象就这就像一个环队列。当我再一次在队头碰到这个对象时，由于他已经没有这个标志位了，所以我立刻就把他踢开了。我在速度上比
FIFO 快。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CLock：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我是 Clock，一个更好的 FIFO，也比 second chance 更好。因为我不会像 second
chance 那样把有标志的缓存对象放到队列的尾部，但是也可以达到 second chance
的效果。&lt;/p&gt;

&lt;p&gt;我持有一个装有缓存对象的环形列表，头指针指向列表中最老的缓存对象。当缓存
miss
发生并且没有新的缓存空间时，我会问问指针指向的缓存对象的标志位去决定我应该怎么做。如果标志是0，我会直接用新的缓存对象替代这个缓存对象；如果标志位是1，我会把头指针递增，然后重复这个过程，知道新的缓存对象能够被放入。我比
second chance 更快。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Simple time-based：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我是 simple time-based
缓存算法，我通过绝对的时间周期去失效那些缓存对象。对于新增的对象，我会保存特定的时间。我很快，但是我并不适用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Extended time-based expiration：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我是 extended time-based expiration
缓存算法，我是通过相对时间去失效缓存对象的；对于新增的缓存对象，我会保存特定的时间，比如是每5分钟，每天的12点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sliding time-based expiration：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我是 sliding time-based
expiration，与前面不同的是，被我管理的缓存对象的生命起点是在这个缓存的最后被访问时间算起的。我很快，但是我也不太适用。&lt;/p&gt;

&lt;p&gt;其他的缓存算法还考虑到了下面几点：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;成本&lt;/strong&gt;：如果缓存对象有不同的成本，应该把那些难以获得的对象保存下来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;容量&lt;/strong&gt;：如果缓存对象有不同的大小，应该把那些大的缓存对象清除，这样就可以让更多的小缓存对象进来了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;时间&lt;/strong&gt;：一些缓存还保存着缓存的过期时间。电脑会失效他们，因为他们已经过期了。&lt;/p&gt;

&lt;p&gt;根据缓存对象的大小而不管其他的缓存算法可能是有必要的。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;电子邮件！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在读完这篇文章之后，programmer one
想了一会儿，然后决定给作者发封邮件，他感觉作者的名字在哪听过，但是已经想不起来了。不管怎样，他还是把邮件发送出来了，他询问了作者在分布式环境中，缓存是怎么样工作的。&lt;/p&gt;

&lt;p&gt;文章的作者收到了邮件，具有讽刺意味的是，这个作者就是面试 programmer one
的人  ，作者回复了……&lt;/p&gt;

&lt;p&gt;在这一部分中，我们来看看如何实现这些著名的缓存算法。以下的代码只是示例用的，如果你想自己实现缓存算法，可能自己还得加上一些额外的工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LeftOver 机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在 programmer one
阅读了文章之后，他接着看了文章的评论，其中有一篇评论提到了 leftover
机制——random cache。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Random Cache&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我是随机缓存，我随意的替换缓存实体，没人敢抱怨。你可以说那个被替换的实体很倒霉。通过这些行为，我随意的去处缓存实体。我比
FIFO 机制好，在某些情况下，我甚至比 LRU 好，但是，通常LRU都会比我好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;现在是评论时间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当 programmer one
继续阅读评论的时候，他发现有个评论非常有趣，这个评论实现了一些缓存算法，应该说这个评论做了一个链向评论者网站的链接，programmer
one顺着链接到了那个网站，接着阅读。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;看看缓存元素（缓存实体）&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt; &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CacheElement&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hitCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;　&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// getters and setters&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;这个缓存实体拥有缓存的key和value，这个实体的数据结构会被以下所有缓存算法用到。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缓存算法的公用代码&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// get the entry from the table&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// If we have the entry already in our table&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// then get it and replace only its value.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
 
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;｝&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;上面的代码会被所有的缓存算法实现用到。这段代码是用来检查缓存元素是否在缓存中了，如果是，我们就替换它，但是如果我们找不到这个
key 对应的缓存，我们会怎么做呢？那我们就来深入的看看会发生什么吧！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;现场访问&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;今天的专题很特殊，因为我们有特殊的客人，事实上他们是我们想要听的与会者，但是首先，先介绍一下我们的客人：Random
Cache，FIFO Cache。让我们从 Random Cache开始。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;看看随机缓存的实现&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// Just replace the value.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// If we haven&amp;#39;t filled the cache yet, put it at the end.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isFull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Otherwise, replace a random entry.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nextFloat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;看看FIFO缓存算法的实现&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Objectkey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Just replace the value.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// If we haven&amp;#39;t filled the cache yet, put it at the end.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isFull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Otherwise, replace the current pointer,&lt;/span&gt;
           &lt;span class=&quot;c1&quot;&gt;// entry with the new one.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// in order to make Circular FIFO&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;看看LFU缓存算法的实现&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setHitCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getHitCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Just replace the value.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isFull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removeLfuElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeLfuElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getElementsFromTable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leastElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leastHit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leastElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;leastHit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lowestElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lowestElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;lowestElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getHitCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lowestElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getHitCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;lowestElement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lowestElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;今天的专题很特殊，因为我们有特殊的客人，事实上他们是我们想要听的与会者，但是首先，先介绍一下我们的客人：Random
Cache, FIFO Cache。让我们从 Random Cache开始。&lt;/p&gt;

&lt;p&gt;最重点的代码，就应该是 leastHit 这个方法，这段代码就是把\
 hitCount 最低的元素找出来，然后删除，给新进的缓存元素留位置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;看看LRU缓存算法实现&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;moveToFront&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;nextIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;prevIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Only the head has a prev entry that is an invalid index&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// so we don&amp;#39;t check.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prevIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Make sure index is valid. If it isn&amp;#39;t, we&amp;#39;re at the tail&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// and don&amp;#39;t set prev[next].&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Just replace the value, but move it to the front.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CacheElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;moveToFront&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// If we haven&amp;#39;t filled the cache yet, place in next available&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// spot and move to front.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isFull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_numEntries&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;moveToFront&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numEntries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// We replace the tail of the list.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;moveToFront&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setObjectKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;这段代码的逻辑如 LRU算法
的描述一样，把再次用到的缓存提取到最前面，而每次删除的都是最后面的元素。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们已经看到 LFU缓存算法 和
LRU缓存算法的实现方式，至于如何实现，采用数组还是
LinkedHashMap，都由你决定，不够我一般是小的缓存容量用数组，大的用
LinkedHashMap。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MongoDB 集群</title>
   <link href="http://beango.github.com/archives/2012/12/03/mongodb-cluster.html"/>
   <updated>2012-12-03T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/12/03/mongodb-cluster</id>
   <content type="html">&lt;p&gt;本文是一篇转载文章，作者对&lt;a href=&quot;http://blog.nosqlfan.com/tags/mongodb&quot; title=&quot;查看 MongoDB 的全部文章&quot;&gt;MongoDB&lt;/a&gt;&lt;a href=&quot;http://blog.nosqlfan.com/tags/%e9%9b%86%e7%be%a4&quot; title=&quot;查看 集群 的全部文章&quot;&gt;集群&lt;/a&gt;结构，集群中各个角色的功能和基本原理做了详细地图文并茂地讲解，值得一看。&lt;/p&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;http://www.javabloger.com/article/mongodb-http://www.javabloger.com/article/mongodb-cluster.html&quot;&gt;http://www.javabloger.com/article/mongodb-cluster.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;MongoDB 集群中包含一个自动分片模块
(“&lt;a href=&quot;http://blog.nosqlfan.com/tags/mongos&quot; title=&quot;查看 mongos 的全部文章&quot;&gt;mongos&lt;/a&gt;”).
自动分片可以用于构建一个大规模的可扩展的数据库集群,这个集群可以并入动态增加的机器。自动建立一个水平扩展的数据库集群系统，将数据库分表存储在&lt;a href=&quot;http://blog.nosqlfan.com/tags/sharding&quot; title=&quot;查看 sharding 的全部文章&quot;&gt;sharding&lt;/a&gt;的各个节点上。在一个mongodb的集群中包括一些shards(mongod进程)，mongos的路由进程，一个或多个config服务器。sharding是一种对大规模数据存储的一种策略，关于sharding的详细信息可以查看&lt;a href=&quot;http://en.wikipedia.org/wiki/Shard&quot;&gt;这里&lt;/a&gt;。也许有人会问，为什么需要做这种策略，因为在一个大型系统中最后的瓶颈会落在网络的带宽和磁盘的读写上，如果将数据分布在多个机器上的多个磁盘上，将会系统数据的处理能有所提高。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MongoDB 集群的结构&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;下图中Shard是指每个节点的shard有一个或更多的服务器和存储数据的mongod进程，而mongod是MongoDB数据的核心进程。&lt;/p&gt;

&lt;p&gt;每台机器上的mongod从配置获取服务器(元数据&lt;a href=&quot;http://blog.nosqlfan.com/tags/metadata&quot; title=&quot;查看 metadata 的全部文章&quot;&gt;metadata&lt;/a&gt;
)，然后，当收到客户端请求时，它请求路由到相应的服务器组和编译结果发送回客户端。&lt;/p&gt;

&lt;p&gt;mongos进行可以被看作是一个路由和协调的过程，因为他可以使得每个单一的各个节点组成一个集群系统。
另外还需要强调一点mongos进程没有持久状态，每个实例都需要一定的数据存储的内存空间。&lt;/p&gt;

&lt;p&gt;换而言之，所谓MongoDB 集群也就是
MongoDB做了一个数据库路由的策略，而且保证跨库操作的数据库事务，而MongoDB
集群中的关键部分Sharding不是一门新技术，而是一种策略，关键还是看应用场景和案例提供的可用性，因为Sharding不仅仅是MongoDB
集群中所提到的分布在不同的机器上，还可以分表，分区，分数据，等等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/machines-cluster.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MongoDB 集群的工作原理：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其中有一个服务器上存储着集群的metadata信息，包括每个服务器，每个shard的基本信息和chunk信息Config
Server
主要存储的是chunk信息。每一个config服务器都复制了完整的chunk信息，就是下图中左边黄色的部分。&lt;/p&gt;

&lt;p&gt;如果客户端对集群的MongoDB插入一条数据，客户端并不知道刚刚插入的数据被分配到具体哪个MongoDB节点上了，因为当一条数据被传入
MongoDB集群中通过mongos路由，所以我们并感觉不到是数据存放在哪个shard的
chunk上，但是通过后台的Sharding的管理命令可以看到插入的数据存放在哪个节点上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-12/mongodb_cluster_sharding.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;配置MongoDB集群&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;模拟2个shard服务、一个config服务、一个mongos
process,全部运行在一个测试的服务器上，具体配置步骤如下：&lt;br/&gt;
 口水： –shardsvr
是表示以sharding模式启动Mongodb服务器，Mongodb数据同步方式参见我写的另外一篇文章“&lt;a href=&quot;http://www.javabloger.com/article/mongodb-master-slave-replication.html&quot;&gt;MongoDB
主(Master)/从(Slave)数据同步&lt;/a&gt;”&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/data/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/data/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/data/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;mongod&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shardsvr&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dbpath&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/data/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/a –port 10000 &amp;gt; /&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sharda&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/tmp/s&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;harda&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;mongod&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shardsvr&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dbpath&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/data/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/b –port 10001 &amp;gt; /&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shardb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/tmp/s&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hardb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;mongod&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;configsvr&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dbpath&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/data/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/config –port 20000 &amp;gt; /&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;configdb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/tmp/co&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nfigdb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;mongos&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;configdb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;localhost:20000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/tmp/mo&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ngos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/tmp/mo&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ngos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;we&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;connect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mongos&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;mongo&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;MongoDB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.1.0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;url:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;connecting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;help&amp;quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;help&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;admin&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;switched&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;admin&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runCommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addshard&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;localhost:10000&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allowLocal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;ok&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;added&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;localhost:10000&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runCommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addshard&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;localhost:10001&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allowLocal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;ok&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;added&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;localhost:10001&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;localhost:20000&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getSisterDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;config&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getSisterDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runCommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enablesharding&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;test&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;ok&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runCommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shardcollection&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;test.people&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;ok&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runCommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listshards:1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;servers&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;_id&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;ObjectId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;4a9d40c981ba1487ccfaa634&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;host&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;localhost:10000&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;_id&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;ObjectId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;4a9d40df81ba1487ccfaa635&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;host&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;localhost:10001&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&amp;quot;ok&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;BTW：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MongoDB是一个介于关系数据库和非关系数据库之间的产品，MongoDB的数据结构非常松散，他的数据格式类似json的bjson格式，因此可以存储比较复杂的数据类型。&lt;/p&gt;

&lt;p&gt;另外，Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。&lt;/p&gt;

&lt;p&gt;Mongo还可以解决海量数据的查询效率，根据官方文档，当数据量达到50GB以上数据时，Mongo数据库访问速度是MySQL10
倍以上。对于这点我将来会去做些试验来进行证明。&lt;/p&gt;

&lt;p&gt;每个节点上都是单点的，不知道MongoDB Sharding+Replication是什么效果，因为被散列的服务器还是存在着单点的现象，如果其中一个散列的节点坏点那么数据就不存在了。下面还要试试这2种方式的结合。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关文章：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; &lt;a href=&quot;http://www.javabloger.com/article/mongodb-master-slave-replication.html&quot;&gt;MongoDB主(Master)/从(Slave)数据同步&lt;/a&gt;&lt;br/&gt;
 &lt;a href=&quot;http://www.javabloger.com/article/mongodb-java.html&quot;&gt;Java操作 MongoDBNoSQL数据库&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MongoDB的Python接口PyMongo</title>
   <link href="http://beango.github.com/archives/2012/11/23/pymongo-python-mongodb.html"/>
   <updated>2012-11-23T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/11/23/pymongo-python-mongodb</id>
   <content type="html">&lt;ul&gt;
&lt;li&gt;创建Connection时，指定host及port参数&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pymongo&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pymongo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;127.0.0.1&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;27017&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;连接数据库&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ChatRoom&lt;/span&gt;  
&lt;span class=&quot;err&quot;&gt;或&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;ChatRoom&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;连接聚集&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;account&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;  
&lt;span class=&quot;err&quot;&gt;或&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;account&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Account&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;查看全部聚集名称&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;collection_names&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;查看聚集的一条记录&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find_one&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find_one&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;UserName&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;keyword&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;查看聚集的字段&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find_one&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({},{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;UserName&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Email&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;u&amp;#39;UserName&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;u&amp;#39;libing&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;u&amp;#39;_id&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ObjectId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;4ded95c3b7780a774a099b7c&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;u&amp;#39;Email&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;u&amp;#39;libing@35.cn&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find_one&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({},{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;UserName&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Email&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;_id&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;u&amp;#39;UserName&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;u&amp;#39;libing&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;u&amp;#39;Email&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;u&amp;#39;libing@35.cn&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;查看聚集的多条记录&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;UserName&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;libing&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}):&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;UserName&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;查看聚集的记录统计&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;UserName&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;keyword&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;聚集查询结果排序&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;UserName&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;默认为升序&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;UserName&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pymongo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ASCENDING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;升序&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;UserName&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pymongo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DESCENDING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;降序&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;聚集查询结果多列排序&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;UserName&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pymongo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ASCENDING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Email&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pymongo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DESCENDING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;添加记录&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;AccountID&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;UserName&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;libing&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;修改记录&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;UserName&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;libing&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;$set&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Email&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;xx@126.com&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Password&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;123&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;删除记录&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;全部删除&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;UserName&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;keyword&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;删除数据库&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;切换数据库&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dropDatabase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;删除当前库&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;



</content>
 </entry>
 
 <entry>
   <title>nginx性能优化</title>
   <link href="http://beango.github.com/archives/2012/11/20/nginx-performance-optimization.html"/>
   <updated>2012-11-20T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/11/20/nginx-performance-optimization</id>
   <content type="html">&lt;p&gt;作者：&lt;a href=&quot;http://www.dbasky.net&quot;&gt;Mike.Xu&lt;/a&gt; 发表于: December 28, 2009 9:09 PM&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://creativecommons.org/licenses/by/2.5/cn/&quot;&gt;&lt;/a&gt;转载时请务必以超链接形式标明文章&lt;a href=&quot;http://www.dbasky.net/archives/2009/12/nginx.html&quot;&gt;原始出处&lt;/a&gt;和作者信息及&lt;a href=&quot;http://www.dbasky.net/archives/2009/12/nginx.html&quot;&gt;本版权声明&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;链接：&lt;a href=&quot;http://www.dbasky.net/archives/2009/12/nginx.html&quot;&gt;http://www.dbasky.net/archives/2009/12/nginx.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;操作系统&lt;/strong&gt;：CentOS 5.3&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nginx&lt;/strong&gt;的安装就不详细介绍了,请大家移步到我以前写的二篇文章&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.dbasky.net/archives/2009/03/nginphp-web.html&quot;&gt;Ngin＋php搭建高性能web服务器&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.dbasky.net/archives/2009/08/nginx-python-django-memcached-mysql-fastcgi.html&quot;&gt;搭建nginx + python + django +memcached+ mysql +fastcgi环境&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1.编译安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure --with-poll_module --with-http_ssl_module
--with-http_gzip_static_module --with-http_perl_module
--with-md5=/usr/include --with-md5-asm --with-sha1=/usr/include
--with-sha1-asm
make
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.制作SSL证书&lt;/p&gt;

&lt;p&gt;生成CA证书&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl req -days 3650 -nodes -new -x509 -keyout ca.key -out ca.pem -config OpenSSL.cnf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成自签名ssl证书&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl req -days 3650 -nodes -new -keyout cert.key -out cert.pem -config OpenSSL.cnf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对证书进行签名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl ca -days 3650 -out cert.pem -in cert.pem -extensions server -config OpenSSL.cnf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.配置优化&lt;/p&gt;

&lt;p&gt;修改nginx.conf,工作进程10个，使用epoll事件模型，并发连接使用默认的1024个，启用gzip动态和静态压缩。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;worker_processes 10;

events {
  use epoll;
  worker_connections 1024;
}

http {
    gzip  on;
    gzip_static on;

    gzip_comp_level     9;
    gzip_min_length     1k;
    gzip_proxied        any;
    gzip_types          text/plain text/xml application/xml application/xml+rss;
    #gzip_disable        &quot;MSIE [1-6] \.&quot;;
    #gzip_vary           on;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复制cert.key和cert.pem到conf目录，去掉HTTPS server下面的注释，启用SSL。&lt;/p&gt;

&lt;p&gt;4.启用php
下载安装spawn-fcgi，建立/tmp/php-fcgi.sock的连接，并添加nginx配置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location ~ \.php$ {
    root           html;
    fastcgi_pass   unix:/tmp/php-fcgi.sock;
    fastcgi_index  index.php;
    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
    fastcgi_param  PATH_INFO        $fastcgi_path_info;
    fastcgi_param  PATH_TRANSLATED  $document_root$fastcgi_path_info;
    include        fastcgi_params;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载安装APC、eAccelerator为php加速。&lt;/p&gt;

&lt;p&gt;建立缓存目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir /var/tmp/eaccelerator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eAccelerator配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[eAccelerator]
zend_extension_ts = &quot;/usr/lib/php5/ext/eAccelerator.so&quot;
eaccelerator.shm_size = &quot;16&quot;
eaccelerator.cache_dir = &quot;/var/tmp/eaccelerator&quot;
eaccelerator.enable = &quot;1&quot;
eaccelerator.optimizer = &quot;1&quot;
eaccelerator.check_mtime = &quot;1&quot;
eaccelerator.debug = &quot;0&quot;
eaccelerator.filter = &quot;&quot;
eaccelerator.shm_max = &quot;0&quot;
eaccelerator.shm_ttl = &quot;0&quot;
eaccelerator.shm_prune_period = &quot;0&quot;
eaccelerator.shm_only = &quot;0&quot;
eaccelerator.compress = &quot;1&quot;
eaccelerator.compress_level = &quot;9&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.启动nginx&lt;/p&gt;

&lt;p&gt;运行命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo spawn-fcgi -f /usr/bin/php-cgi -s /tmp/php-fcgi.sock -F 2 -u nobody
sudo /usr/local/nginx/sbin/nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了方便管理，使用如下脚本，保存为nginx，放到/etc/init.d目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! /bin/sh
#
# nginx daemon script
#

PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
DAEMON=/usr/local/nginx/sbin/nginx
NAME=nginx
PIDFILE=/usr/local/nginx/logs/$NAME.pid
PHPSOCKET=/tmp/php-fcgi.sock
PHPPIDFILE=/tmp/run/php-fcgi.pid
PHPSPAWN=&quot;spawn-fcgi -f /usr/bin/php-cgi -s $PHPSOCKET -P $PHPPIDFILE -F 2 -u nobody&quot;

test -x $DAEMON || exit 0

set -e

case &quot;$1&quot; in
  start)
echo &quot;Starting $NAME.&quot;
$DAEMON
$PHPSPAWN
;;

  stop)
echo &quot;Stopping $NAME.&quot;
$DAEMON -s stop
kill `cat $PHPPIDFILE`
rm -f $PHPSOCKET $PHPPIDFILE
;;

  restart)
echo &quot;Restarting $NAME.&quot;
$DAEMON -s reopen
kill `cat $PHPPIDFILE`
rm -f $PHPSOCKET $PHPPIDFILE
$PHPSPAWN
;;

  reload)
    if [ ! -f $PIDFILE ]; then
      echo &quot;nginx not started.&quot;
      exit 1
    fi
    echo &quot;Reloading $NAME.&quot;
    $DAEMON -s reload
    ;;

  test)
    $DAEMON -t
    ;;

  *)
N=/etc/init.d/$NAME
echo &quot;Usage: $N start|stop|restart|reload|test&quot; &amp;gt;&amp;amp;2
exit 1
;;
esac

exit 0 
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>RabbitMQ安装及使用</title>
   <link href="http://beango.github.com/archives/2012/10/09/rabbitmq-install.html"/>
   <updated>2012-10-09T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/10/09/rabbitmq-install</id>
   <content type="html">

&lt;h3 id=&quot;blockquote&quot;&gt;介绍：&lt;/h3&gt;


&lt;p&gt;rabbitMQ是一个在AMQP协议标准基础上完整的，可服用的企业消息系统。他遵循Mozilla Public License开源协议。采用 Erlang 实现的工业级的消息队列(MQ)服务器。&lt;/p&gt;

&lt;p&gt;RabbitMQ的官方站：&lt;a href=&quot;http://www.rabbitmq.com/&quot;&gt;http://www.rabbitmq.com/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;blockquote&quot;&gt;RabbitMQ安装（windows）&lt;/h3&gt;


&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先需要下载erlang运行时环境(Windows binary): &lt;a href=&quot;http://erlang.org/download.html&quot;&gt;http://erlang.org/download.html&lt;/a&gt;
下面设置一下环境变量：变量名：ERLANG_HOME，变量值：安装路径&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接着下载RabbitMQ Server（目前最新版本为2.8.7），链接如下：&lt;a href=&quot;http://www.rabbitmq.com/server.html&quot;&gt;http://www.rabbitmq.com/server.html&lt;/a&gt;
安装并启动服务。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3 id=&quot;blockquote&quot;&gt;RabbitMQ安装（CentOS）&lt;/h3&gt;


&lt;ul&gt;
&lt;li&gt;安装erlang：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar zxvf otp_src_R15B02.tar.gz  
cd otp_src_R15B02  
./configure  
make  
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;安装rabbitmq-server，可以直接下载Binary(rabbitmq-server-generic-unix-2.8.7.tar.gz)，解压并运行sbin/rabbitmq-server即可&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar zxvf rabbitmq-server-generic-unix-2.8.7.tar.gz  
ln -s /usr/local/rabbitmq/sbin/* /usr/local/bin/ 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;安装管理插件，访问地址：&lt;a href=&quot;http://localhost:55672/mgmt&quot;&gt;http://localhost:55672/mgmt&lt;/a&gt;用户名guest，密码guest&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rabbitmq-plugins enable rabbitmq_management
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;修改或创建rabbitmq-env.conf&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh  
# I am a complete /etc/rabbitmq/rabbitmq-env.conf file.  
# Comment lines start with a hash character.  
# This is a /bin/sh script file - use ordinary envt var syntax  
NODENAME=beango  
RABBIT_HOME=/usr/local/rabbitmq  
MNESIA_BASE=/usr/local/rabbitmq/data  
LOG_BASE=/usr/local/rabbitmq/log  
CONFIG_FILE=/usr/local/rabbitmq/etc/rabbitmq/rabbitmq  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;修改或创建/usr/local/rabbitmq/etc/rabbitmq/rabbitmq.config&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{rabbit,  
    [  
        {vm_memory_limit,0.6},  
        {disk_free_limit,100000000}  
    ]}  
].
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;启动与关闭服务&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;启动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nohup rabbitmq-server start &amp;gt; /usr/local/rabbitmq/log/system.log \ 2&amp;gt;/usr/local/rabbitmq/log/system.log &amp;amp;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rabbitmqctl stop
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;blockquote&quot;&gt;RabbitMQ配置&lt;/h3&gt;


&lt;ul&gt;
&lt;li&gt;首先创建vhosts，命令如下：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;添加创建虚拟主机&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D:\rabbitmq\sbin&amp;gt;rabbitmqctl add_vhost dnt_mq  #删除 rabbitmqctl delete_vhost vhostpath
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用下面指定就可以显示出所有虚拟主机信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D:\rabbitmq\sbin&amp;gt;rabbitmqctl list_vhosts  
Listing vhosts ...  
/   （根目录）  
dnt_mq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面添加用户和密码(用户名admin, 密码：111111)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D:\rabbitmq\sbin&amp;gt;rabbitmqctl add_user admin 111111  
//修改用户密码：rabbitmqctl change_password username newpassword
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;绑定用户权限：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D:\rabbitmq\sbin&amp;gt;rabbitmqctl set_permissions -p dnt_mq admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;  
Setting permissions for user &quot;admin&quot; in vhost &quot;dnt_mq&quot; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列出用户权限：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D:\rabbitmq\sbin&amp;gt;rabbitmqctl list_user_permissions daizhj  
//清除用户权限 rabbitmqctl clear_permissions [-p vhostpath] username
Listing permissions for user &quot;daizhj&quot; ...
dnt_mq  .*      .*      .*      client
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;blockquote&quot;&gt;RabbitMQ使用&lt;/h3&gt;


&lt;ul&gt;
&lt;li&gt;Main&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private const string exchange = &quot;dnt_mq&quot;;  
private const string queuename = &quot;com.iuwebs.queue1&quot;;  

public static int Main(string[] args1)  
{  
    ConnectionFactory cf = new ConnectionFactory();  
    cf.Uri = &quot;amqp://192.168.1.121:5672&quot;;  
    int msgCount = 10;  
    using (IConnection conn = cf.CreateConnection())  
    {  
        using (IModel ch = conn.CreateModel())  
        {  
            ensureQueue(ch);  

            sendMessages(ch, queuename, 2 * msgCount);  
            using (Subscription sub = new Subscription(ch, queuename,false))//创建订阅，不会自动ack响应  
            {  
                enumeratingReceiveMessages(sub, msgCount);  
            }  
        }  
    }  
    return 0;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ensureQueue&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static void ensureQueue(IModel ch)  
{  
    ch.ExchangeDeclare(&quot;dnt_mq&quot;, &quot;direct&quot;);  
    //durable:是否持久化消息队列，即服务器重启后，这个queue及其中的消息是否存在  
    //exclusive:排他性队列（Exclusive Queue)，只对首次声明它的连接（Connection）可见；会在其连接断开的时候自动删除。  
    //autoDelete:这个queue不再使用的时候会被删除  
    ch.QueueDeclare(queuename, true, false, false, null);  
    ch.QueueBind(queuename, exchange, queuename, null);  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;sendMessages&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static void sendMessages(IModel ch, string queueName, long msgCount)  
{  
    var basicPro = ch.CreateBasicProperties();  
    basicPro.DeliveryMode = 2;//是否持久化消息，1不是，2是  
    while (msgCount-- &amp;gt; 0)  
    {  
        ch.BasicPublish(exchange, queueName, basicPro, Encoding.UTF8.GetBytes(&quot;Welcome to Caerbannog!-持久化&quot;));  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;enumeratingReceiveMessages&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static void enumeratingReceiveMessages(Subscription sub, long msgCount)  
{  
    foreach (BasicDeliverEventArgs ev in sub)  
    {  
        Console.WriteLine(&quot;Message {0}: {1}&quot;, i, Encoding.UTF8.GetString(ev.Body));  
        sub.Ack(ev); //发回响应，否则消息队列还将存在  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>常见的nginx的配置选项</title>
   <link href="http://beango.github.com/archives/2012/10/05/commong-nginx-configuration-options.html"/>
   <updated>2012-10-05T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/10/05/commong-nginx-configuration-options</id>
   <content type="html">&lt;p&gt;英文原文：&lt;a href=&quot;http://agiletesting.blogspot.jp/2010/06/commong-nginx-configuration-options.html&quot;&gt;agiletesting.blogspot.jp&lt;/a&gt;，编译：&lt;a href=&quot;http://www.php-oa.com/2012/04/01/commong-nginx-configuration-options.html&quot;&gt;扶凯&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于想学  Nginx 的新人，这是一个非常不错的简明指导。&lt;/p&gt;

&lt;p&gt;Google 上有丰富的 Nginx 的教程和样本配置文件，但很多时候时候，配置这些是需要一些技巧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Include 文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不要在您的主 nginx.conf文件中配置所有的东西,你需要分成几个较小的文件。您的同事会很感激你的。比如我的结构,我定义我的upstream 的 pool 的为一个文件，和一个文件定义 location 处理服务器上其它的应用。&lt;/p&gt;

&lt;p&gt;例子：
 upstreams.conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;upstream cluster1 {
 fair;
 server app01:7060;
 server app01:7061;
 server app02:7060;
 server app02:7061;
}
upstream cluster2 {
 fair;
 server app01:7071;
 server app01:7072;
 server app02:7071;
 server app02:7072;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;locations.conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location / {
 root /var/www;
 include cache-control.conf;
 index index.html index.htm;
}
location /services/service1 {
 proxy_pass_header Server;
 proxy_set_header Host $http_host;
 proxy_redirect off;
 proxy_set_header X-Real-IP $remote_addr;
 proxy_set_header X-Scheme $scheme;
 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
 add_header Pragma &quot;no-cache&quot;;
 proxy_pass http://cluster1/;
}
location /services/service2 {
 proxy_pass_header Server;
 proxy_set_header Host $http_host;
 proxy_redirect off;
 proxy_set_header X-Real-IP $remote_addr;
 proxy_set_header X-Scheme $scheme;
 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
 add_header Pragma &quot;no-cache&quot;;
 proxy_pass http://cluster2/service2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;servers.conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
 listen 80;
 include locations.conf;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，你的nginx.conf看起来非常的干净和简单（仍然可以分开更多,来更包括文件，比如分离gzip的配置选项)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nginx.conf

worker_processes 4;
worker_rlimit_nofile 10240;
events {
  worker_connections 10240;
  use epoll;
}
http {
  include upstreams.conf;
  include mime.types;
  default_type application/octet-stream;
  log_format custom '$remote_addr - $remote_user [$time_local] '
  '&quot;$request&quot; $status $bytes_sent '
  '&quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; $request_time';
  access_log /usr/local/nginx/logs/access.log custom;
  proxy_buffering off;
  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;
  gzip on;
  gzip_min_length 10240;
  gzip_proxied expired no-cache no-store private auth;
  gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml application/xml+rss image/svg+xml application/x-font-ttf application/vnd.ms-fontobject;
  gzip_disable &quot;MSIE [1-6]\.&quot;;
  # proxy cache config
  proxy_cache_path /mnt/nginx_cache levels=1:2
  keys_zone=one:10m
  inactive=7d max_size=10g;
  proxy_temp_path /var/tmp/nginx_temp;
  proxy_next_upstream error;
  include servers.conf;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这 nginx.conf 文件是使用了一些不太常见的配置选项，它值得指出其中一些重要的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多个 worker 的配置(进程)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果你的 Nginx 是多个 CPU 和多核,需要配置成多核的数量比较好:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;worker_processes 4;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;增加打开的文件句柄&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果Nginx服务很大的流量,增加最大可以打开的文件句柄还是很有用的,因为默认只有1024个.可以使用 ‘ulimit -n’ 看到当前系统中的设置.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;worker_rlimit_nofile 10240;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;定制的日志&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以看看 log_format 和 access_log 二个选项的设置.通常我们有几个参数最常使用,象 “\$http_x_forwarded_for” 可以见到 load balancer 的设备之前的 IP, 还有 “\$request_time” 可以见到 Nginx 来处理这个主动所花的时间.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;压缩&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;压缩对于文本非常非常的有用.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gzip on;
gzip_min_length 10240;
gzip_proxied expired no-cache no-store private auth;
gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml application/xml+rss image/svg+xml application/x-font-ttf application/vnd.ms-fontobject;
gzip_disable &quot;MSIE [1-6]\.&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;代理的选项&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这些选项可以在每个 location 中设置.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;proxy_pass_header Server;
proxy_set_header Host $http_host;
proxy_redirect off;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Scheme $scheme;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
add_header Pragma &quot;no-cache&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个中加了一个定制的参数,就是 ‘no-cache’,这样就不会使用 cache 的内容了.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代理的 Cache&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用 Nginx 可以给一些文件来 cache 到本地来当 Cache 的服务器,需要设置 proxy_cache_path 和 proxy_temp_path 在你的 HTTP 的 directive 中.在 location 中配置.如果有你想 cache 的内容的话.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;proxy_cache_path /mnt/nginx_cache levels=1:2
keys_zone=one:10m
inactive=7d max_size=10g;
proxy_temp_path /var/tmp/nginx_temp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这可能还想增加一些其它的参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;proxy_cache one;
proxy_cache_key mylocation.$request_uri;
proxy_cache_valid 200 302 304 10m;
proxy_cache_valid 301 1h;
proxy_cache_valid any 1m;
proxy_cache_use_stale error timeout invalid_header http_500 http_502 http_503 http_504 http_404;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;HTTP caching options&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有时你想使用其它的东西来做 Cache ,你可能需要指定怎么样 cache. 你可以给 cache 的信息的文件 include 到你的 root 的 location 中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location / {
 root /var/www;
 include cache-control.conf;
 index index.html index.htm;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以指定不同的头到于不同的文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# default cache 1 day
expires +1d;
if ($request_uri ~* &quot;^/services/.*$&quot;) {
 expires +0d;
 add_header Pragma &quot;no-cache&quot;;
}
if ($request_uri ~* &quot;^/(index.html)?$&quot;) {
 expires +1h;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;SSL&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果你要配置 ssl 的连接的话&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
 server_name www.example.com;
 listen 443;
 ssl on;
 ssl_certificate /usr/local/nginx/ssl/cert.pem;
 ssl_certificate_key /usr/local/nginx/ssl/cert.key;
 include locations.conf;
}
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>解析 Nginx 负载均衡</title>
   <link href="http://beango.github.com/archives/2012/09/21/nginx-load-balancing.html"/>
   <updated>2012-09-21T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/09/21/nginx-load-balancing</id>
   <content type="html">&lt;p&gt;来源：&lt;a href=&quot;http://stblog.baidu-tech.com/?p=2027&quot;&gt;百度搜索研发部&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：对于一个大型网站来说，负载均衡是永恒的话题。随着硬件技术的迅猛发展，越来越多的负载均衡硬件设备涌现出来，如F5 BIG-IP、Citrix NetScaler、Radware等等，虽然可以解决问题，但其高昂的价格却往往令人望而却步，因此负载均衡软件仍然是大部分公司的不二之选。nginx作为webserver的后起之秀，其优秀的反向代理功能和灵活的负载均衡策略受到了业界广泛的关注。本文将以工业生产为背景，从设计实现和具体应用等方面详细介绍nginx负载均衡策略。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：nginx 负载均衡 反向代理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.前言&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;随着互联网信息的爆炸性增长，负载均衡（load balance）已经不再是一个很陌生的话题，顾名思义，负载均衡即是将负载分摊到不同的服务单元，既保证服务的可用性，又保证响应足够快，给用户很好的体验。快速增长的访问量和数据流量催生了各式各样的负载均衡产品，很多专业的负载均衡硬件提供了很好的功能，但却价格不菲，这使得负载均衡软件大受欢迎，nginx就是其中的一个。&lt;/p&gt;

&lt;p&gt;nginx第一个公开版本发布于2004年，2011年发布了1.0版本。它的特点是稳定性高、功能强大、资源消耗低，从其目前的市场占有而言，nginx大有与apache抢市场的势头。其中不得不提到的一个特性就是其负载均衡功能，这也成了很多公司选择它的主要原因。本文将从源码的角度介绍nginx的内置负载均衡策略和扩展负载均衡策略，以实际的工业生产为案例，对比各负载均衡策略，为nginx使用者提供参考。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.源码剖析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;nginx的负载均衡策略可以划分为两大类：内置策略和扩展策略。内置策略包含加权轮询和ip hash，在默认情况下这两种策略会编译进nginx内核，只需在nginx配置中指明参数即可。扩展策略有很多，如fair、通用hash、consistent hash等，默认不编译进nginx内核。由于在nginx版本升级中负载均衡的代码没有本质性的变化，因此下面将以nginx1.0.15稳定版为例，从源码角度分析各个策略。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1. 加权轮询（weighted round robin）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;轮询的原理很简单，首先我们介绍一下轮询的基本流程。如下是处理一次请求的流程图：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-09/Parse-nginx-load-balancing1.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot;&gt;&lt;img src=&quot;/assets/files/2012-09/Parse-nginx-load-balancing1.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot; alt=&quot;解析 Nginx负载均衡&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图中有两点需要注意，第一，如果可以把加权轮询算法分为先深搜索和先广搜索，那么nginx采用的是先深搜索算法，即将首先将请求都分给高权重的机器，直到该机器的权值降到了比其他机器低，才开始将请求分给下一个高权重的机器；第二，当所有后端机器都down掉时，nginx会立即将所有机器的标志位清成初始状态，以避免造成所有的机器都处在timeout的状态，从而导致整个前端被夯住。&lt;/p&gt;

&lt;p&gt;接下来看下源码。nginx源码的目录结构很清晰，加权轮询所在路径为nginx-1.0.15/src/http/ngx_http_upstream_round_robin.[c|h]，在源码的基础上，针对重要的、不易理解的地方我加了注释。首先看下ngx_http_upstream_round_robin.h中的重要声明：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-09/Parse-nginx-load-balancing2.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot;&gt;&lt;img src=&quot;/assets/files/2012-09/Parse-nginx-load-balancing2.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot; alt=&quot;解析 Nginx负载均衡&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从变量命名中，我们就可以大致猜出其作用。其中，current_weight和weight的区别主要是前者为权重排序的值，随着处理请求会动态的变化，后者是配置值，用于恢复初始状态。&lt;/p&gt;

&lt;p&gt;接下来看下轮询的创建过程，代码如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-09/Parse-nginx-load-balancing3.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot;&gt;&lt;img src=&quot;/assets/files/2012-09/Parse-nginx-load-balancing3.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot; alt=&quot;解析 Nginx负载均衡&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里有个tried变量需要做些说明。tried中记录了服务器当前是否被尝试连接过。他是一个位图。如果服务器数量小于32，则只需在一个int中即可记录下所有服务器状态。如果服务器数量大于32，则需在内存池中申请内存来存储。对该位图数组的使用可参考如下代码：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-09/Parse-nginx-load-balancing4.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot;&gt;&lt;img src=&quot;/assets/files/2012-09/Parse-nginx-load-balancing4.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot; alt=&quot;解析 Nginx负载均衡&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最后是实际的策略代码，逻辑很简单，代码实现也只有30行，直接上代码。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-09/Parse-nginx-load-balancing5.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot;&gt;&lt;img src=&quot;/assets/files/2012-09/Parse-nginx-load-balancing5.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot; alt=&quot;解析 Nginx负载均衡&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2. ip hash&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ip hash是nginx内置的另一个负载均衡的策略，流程和轮询很类似，只是其中的算法和具体的策略有些变化，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-09/Parse-nginx-load-balancing6.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot;&gt;&lt;img src=&quot;/assets/files/2012-09/Parse-nginx-load-balancing6.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot; alt=&quot;解析 Nginx负载均衡&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ip hash算法的核心实现如下图：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-09/Parse-nginx-load-balancing7.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot;&gt;&lt;img src=&quot;/assets/files/2012-09/Parse-nginx-load-balancing7.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot; alt=&quot;解析 Nginx负载均衡&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从代码中可以看出，hash值既与ip有关又与后端机器的数量有关。经过测试，上述算法可以连续产生1045个互异的value，这是该算法的硬限制。对此nginx使用了保护机制，当经过20次hash仍然找不到可用的机器时，算法退化成轮询。因此，从本质上说，ip hash算法是一种变相的轮询算法，如果两个ip的初始hash值恰好相同，那么来自这两个ip的请求将永远落在同一台服务器上，这为均衡性埋下了很深的隐患。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3. fair&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;fair策略是扩展策略，默认不被编译进nginx内核。其原理是根据后端服务器的响应时间判断负载情况，从中选出负载最轻的机器进行分流。这种策略具有很强的自适应性，但是实际的网络环境往往不是那么简单，因此要慎用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.4. 通用hash、一致性hash&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这两种也是扩展策略，在具体的实现上有些差别，通用hash比较简单，可以以nginx内置的变量为key进行hash，一致性hash采用了nginx内置的一致性hash环，可以支持memcache。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.对比测试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本测试主要为了对比各个策略的均衡性、一致性、容灾性等，从而分析出其中的差异性，并据此给出各自的适用场景。为了能够全面、客观的测试nginx的负载均衡策略，我们采用了两个测试工具、在不同场景下做测试，以此来降低环境对测试结果造成的影响。首先简单介绍测试工具、测试网络拓扑和基本的测试流程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1. 测试工具&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1.1 easyABC&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;easyABC是公司内部开发的性能测试工具，采用epool模型实现，简单易上手，可以模拟GET/POST请求，极限情况下可以提供上万的压力，在公司内部得到了广泛的使用。由于被测试对象为反向代理服务器，因此需要在其后端搭建桩服务器，这里用nginx作为桩webserver，提供最基本的静态文件服务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1.2 polygraph&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;polygraph是一款免费的性能测试工具，以对缓存服务、代理、交换机等方面的测试见长。它有规范的配置语言PGL（Polygraph Language），为软件提供了强大的灵活性。其工作原理如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-09/Parse-nginx-load-balancing8.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot;&gt;&lt;img src=&quot;/assets/files/2012-09/Parse-nginx-load-balancing8.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot; alt=&quot;解析 Nginx负载均衡&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;polygraph提供client端和server端，将测试目标nginx放在二者之间，三者之间的网络交互均走http协议，只需配置ip+port即可。client端可以配置虚拟robot的个数以及每个robot发请求的速率，并向代理服务器发起随机的静态文件请求，server端将按照请求的url生成随机大小的静态文件做响应。这也是选用这个测试软件的一个&lt;strong&gt;主要原因&lt;/strong&gt;：可以产生随机的url作为nginx各种hash策略的key。&lt;/p&gt;

&lt;p&gt;另外，polygraph还提供了日志分析工具，功能比较丰富，感兴趣的同学可以参考附录中的相关材料。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2. 测试环境&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本测试运行在5台物理机上，其中被测对象单独搭在一台8核机器上，另外四台4核机器分别搭建了easyABC、webserver桩和polygraph，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-09/Parse-nginx-load-balancing9.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot;&gt;&lt;img src=&quot;/assets/files/2012-09/Parse-nginx-load-balancing9.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot; alt=&quot;解析 Nginx负载均衡&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3. 测试方案&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先介绍下关键的测试指标：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;均衡性&lt;/strong&gt;：是否能够将请求均匀的发送给后端&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一致性&lt;/strong&gt;：同一个key的请求，是否能落到同一台机器&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;容灾性&lt;/strong&gt;：当部分后端机器挂掉时，是否能够正常工作&lt;/p&gt;

&lt;p&gt;以上述指标为指导，我们针对如下四个测试场景分别用easyABC和polygraph进行测试：&lt;/p&gt;

&lt;p&gt;场景1      server_*均正常提供服务；&lt;/p&gt;

&lt;p&gt;场景2      server_4挂掉，其他正常；&lt;/p&gt;

&lt;p&gt;场景3      server_3、server_4挂掉，其他正常；&lt;/p&gt;

&lt;p&gt;场景4      server_*均恢复正常服务。&lt;/p&gt;

&lt;p&gt;上述四个场景将按照时间顺序进行，每个场景将建立在上一个场景基础上，被测试对象无需做任何操作，以最大程度模拟实际情况。另外，考虑到测试工具自身的特点，在easyabc上的测试压力在17000左右，polygraph上的测试压力在4000左右。以上测试均保证被测试对象可以正常工作，且无任何notice级别以上（alert/error/warn）的日志出现，在每个场景中记录下server_*的qps用于最后的策略分析。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.4. 测试结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;表1和图1是轮询策略在两种测试工具下的负载情况。对比在两种测试工具下的测试结果会发现，结果完全一致，因此可以排除测试工具的影响。从图表中可以看出，轮询策略对于均衡性和容灾性都可以做到很好的满足。&lt;/p&gt;

&lt;p&gt; &lt;a href=&quot;/assets/files/2012-09/Parse-nginx-load-balancing10.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot;&gt;&lt;img src=&quot;/assets/files/2012-09/Parse-nginx-load-balancing10.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot; alt=&quot;解析 Nginx负载均衡&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-09/Parse-nginx-load-balancing11.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot;&gt;&lt;img src=&quot;/assets/files/2012-09/Parse-nginx-load-balancing11.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot; alt=&quot;解析 Nginx负载均衡&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;表2和图2是fair策略在两种测试工具下的负载情况。fair策略受环境影响非常大，在排除了测试工具的干扰之后，结果仍然有非常大的抖动。从直观上讲，这完全不满足均衡性。但是从另一个角度出发，恰恰是由于这种自适应性确保了在复杂的网络环境中能够物尽所用。因此，在应用到工业生产中之前，需要在具体的环境中做好测试工作。&lt;/p&gt;

&lt;p&gt; &lt;a href=&quot;/assets/files/2012-09/Parse-nginx-load-balancing12.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot;&gt;&lt;img src=&quot;/assets/files/2012-09/Parse-nginx-load-balancing12.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot; alt=&quot;解析 Nginx负载均衡&quot; /&gt;&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-09/Parse-nginx-load-balancing13.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot;&gt;&lt;img src=&quot;/assets/files/2012-09/Parse-nginx-load-balancing13.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot; alt=&quot;解析 Nginx负载均衡&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以下图表是各种hash策略，所不同的仅仅是hash key或者是具体的算法实现，因此一起做对比。实际测试中发现，通用hash和一致性hash均存在一个问题：当某台后端的机器挂掉时，原有落到这台机器上的流量会丢失，但是在ip hash中就不存在这样的问题。正如上文中对ip hash源码的分析，当ip hash失效时，会退化为轮询策略，因此不会有丢失流量的情况。从这个层面上说，ip hash也可以看成是轮询的升级版。&lt;/p&gt;

&lt;p&gt; &lt;a href=&quot;/assets/files/2012-09/Parse-nginx-load-balancing14.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot;&gt;&lt;img src=&quot;/assets/files/2012-09/Parse-nginx-load-balancing14.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot; alt=&quot;解析 Nginx 负载均衡&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图5为ip hash策略，ip hash是nginx内置策略，可以看做是前两种策略的特例：以来源ip为key。由于测试工具不便于模拟海量ip下的请求，因此这里截取线上实际的情况加以分析，如下图所示：&lt;/p&gt;

&lt;p&gt; &lt;a href=&quot;/assets/files/2012-09/Parse-nginx-load-balancing16.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot;&gt;&lt;img src=&quot;/assets/files/2012-09/Parse-nginx-load-balancing16.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot; alt=&quot;解析 Nginx负载均衡&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;/assets/files/2012-09/Parse-nginx-load-balancing15.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图5 ip hash策略&lt;/p&gt;

&lt;p&gt;图中前1/3使用轮询策略，中间段使用ip
hash策略，后1/3仍然是轮询策略。可以明显的看出，ip
hash的均衡性存在着很大的问题。原因并不难分析，在实际的网络环境中，有大量的高校出口路由器ip、企业出口路由器ip等网络节点，这些节点带来的流量往往是普通用户的成百上千倍，而ip
hash策略恰恰是按照ip来划分流量，因此造成上述后果也就自然而然了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 总结与展望&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过实际的对比测试，我们对nginx各个负载均衡策略进行了验证。下面从均衡性、一致性、容灾性以及适用场景等角度对比各种策略。(点击图片查看大图)&lt;/p&gt;

&lt;p&gt; &lt;a href=&quot;/assets/files/2012-09/Parse-nginx-load-balancing17.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot;&gt;&lt;img src=&quot;/assets/files/2012-09/Parse-nginx-load-balancing17.jpg&quot; title=&quot;解析 Nginx 负载均衡&quot; alt=&quot;解析 Nginx负载均衡&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以上从源码和实际的测试数据角度分析说明了nginx负载均衡的策略，并给出了各种策略适合的应用场景。通过本文的分析不难发现，无论哪种策略都不是万金油，在具体的场景下应该选择哪种策略一定程度上依赖于使用者对这些策略的熟悉程度。希望本文的分析和测试数据能够对读者有所帮助，更希望有越来越多、越来越好的负载均衡策略产出。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Centos搭建PHP5.3.8+Nginx1.0.9+Mysql5.5.17</title>
   <link href="http://beango.github.com/archives/2012/09/10/centos-php-nginx-mysql.html"/>
   <updated>2012-09-10T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/09/10/centos-php-nginx-mysql</id>
   <content type="html">&lt;h3&gt;操作环境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;操作系统:Win7旗舰版&lt;/li&gt;
&lt;li&gt;虚拟主机:Oracle VM VirtualBox&lt;/li&gt;
&lt;li&gt;虚拟系统:Centos 6.3&lt;/li&gt;
&lt;li&gt;操作用户:Root&lt;/li&gt;
&lt;li&gt;实现目的:搭建LNMP环境.&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;安装依赖库和开发环境&lt;/h3&gt;

&lt;p&gt;&lt;li&gt;依赖库和开发工具&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum -y install gcc gcc-c++ autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel libidn libidn-devel openssl openssl-devel openldap openldap-devel nss_ldap openldap-clients openldap-servers  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;Nginx&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum -y install pcre-devel  zlib-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;Php&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum -y install gd-devel libjpeg-devel libpng-devel freetype-devel libxml2-devel curl-devel freetype-devel  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;Mysql&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum -y install bison gcc gcc-c++ autoconf automake zlib\* libxml\* ncurses-devel libtool-ltdl-devel\* mysql-devel  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;下载软件包&lt;/h3&gt;

&lt;p&gt;&lt;li&gt;创建目录&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir /web  
cd /web 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;PHP5.3.7&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://cn.php.net/distributions/php-5.3.8.tar.bz2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;PHP库文件&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://ncu.dl.sourceforge.net/project/mcrypt/MCrypt/2.6.8/mcrypt-2.6.8.tar.gz  
wget http://ncu.dl.sourceforge.net/project/mhash/mhash/0.9.9.9/mhash-0.9.9.9.tar.gz  
wget http://ncu.dl.sourceforge.net/project/mcrypt/Libmcrypt/2.5.8/libmcrypt-2.5.8.tar.gz  
wget http://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.14.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;Nginx1.0.9&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://www.nginx.org/download/nginx-1.0.9.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;Nginx(pcre)&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.13.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;Mysql5.5.17&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://dev.mysql.com/get/Downloads/MySQL-5.5/mysql-5.5.17.tar.gz/from/http://mysql.ntu.edu.tw/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;Mysql(cmake1)&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://www.cmake.org/files/v2.8/cmake-2.8.6.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;安装Mysql&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装cmake&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zxvf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmake&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.8.6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gz&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmake&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.8.6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;configure&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;gmake&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gmake&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;../&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;添加mysql用户&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;sr&quot;&gt;/usr/s&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;groupadd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;  
&lt;span class=&quot;sr&quot;&gt;/usr/s&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;useradd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;  
&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/data/m&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ysql&lt;/span&gt;  
&lt;span class=&quot;nb&quot;&gt;chown&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql:mysql&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/data/m&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ysql&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;安装Mysql&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zxvf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;5.5.27&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gz&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;5.5.27&lt;/span&gt;  
&lt;span class=&quot;c1&quot;&gt;# 便于粘贴运行 START  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmake&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DCMAKE_INSTALL_PREFIX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/opt/m&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ysql&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DMYSQL_DATADIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/opt/m&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ysql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DMYSQL_USER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DDEFAULT_CHARSET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DDEFAULT_COLLATION&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf8_general_ci&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DWITH_EXTRA_CHARSETS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DWITH_READLINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DWITH_SSL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;system&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DWITH_EMBEDDED_SERVER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DWITH_ZLIB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;system&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DWITH_LIBWRAP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DWITH_INNOBASE_STORAFE_ENGINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DENABLE_LOCAL_INFILE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;  
&lt;span class=&quot;c1&quot;&gt;# 便于粘贴运行 END  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cmake&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DCMAKE_INSTALL_PREFIX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/opt/m&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ysql&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#指定安装目录  &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DMYSQL_DATADIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/opt/m&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ysql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#指定data目录  &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DMYSQL_USER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#指定运行mysqld的用户，默认就是mysql，所以此配置可忽略，但记得添加mysql用户  &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DDEFAULT_CHARSET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#指定默认字符集  &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DDEFAULT_COLLATION&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf8_general_ci&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#指定默认连接校对字符集  &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DWITH_EXTRA_CHARSETS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#安装所有字符集  &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DWITH_READLINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DWITH_SSL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;system&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DWITH_EMBEDDED_SERVER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DWITH_ZLIB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;system&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DWITH_LIBWRAP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DWITH_INNOBASE_STORAFE_ENGINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#开启INNODB引擎，MyISAM MERGE MEMORY CSV是默认安装的  &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DENABLE_LOCAL_INFILE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#开启 LOAD DATA INFILE，就是从文件导入数据库  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;设置Mysql&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;c1&quot;&gt;#在support-files目录中有五个配置信息文件：  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#my-small.cnf (内存&amp;lt;=64M)  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#my-medium.cnf (内存 128M)  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#my-large.cnf (内存 512M)  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#my-huge.cnf (内存 1G-2G)  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#my-innodb-heavy-4G.cnf (内存 4GB)  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/support-files/m&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;medium&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnf&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/etc/m&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnf&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;vi&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/etc/m&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnf&lt;/span&gt;  
&lt;span class=&quot;c1&quot;&gt;#在 [mysqld] 段增加  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;datadir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/data/m&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ysql&lt;/span&gt;  
&lt;span class=&quot;nb&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;max_connections&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;512&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;storage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyISAM&lt;/span&gt;  
&lt;span class=&quot;c1&quot;&gt;#在 [mysqld] 段修改  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;max_allowed_packet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;生成授权表&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/scripts/m&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ysql_install_db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;更改密码&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/mysql/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysqladmin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;password&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123456&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;开启mysql&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/mysql/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysqld_safe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;测试连接mysql&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/mysql/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123456&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;databases&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;设置开机启动&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;vi&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/etc/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;  
&lt;span class=&quot;c1&quot;&gt;#加入  &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/mysql/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysqld_safe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;允许远程访问&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;update&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;%&amp;#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;用户名&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;（如果写成&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localhost&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;那此用户就不具有远程访问权限）&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FLUSH&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PRIVILEGES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;h3&gt;安装PHP&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zxvf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;libiconv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.14&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;libiconv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.14&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/configure --prefix=/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;../&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;2&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zxvf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;libmcrypt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.5.8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;libmcrypt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.5.8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;configure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt;  
&lt;span class=&quot;sr&quot;&gt;/sbin/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ldconfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;libltdl&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/ &amp;amp;&amp;amp; ./co&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nfigure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ltdl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;install&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;../&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;3&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zxvf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mhash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.9.9.9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mhash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.9.9.9&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/ &amp;amp;&amp;amp; ./co&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nfigure&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;../&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;4&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/lib/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmcrypt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;la&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmcrypt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;la&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/lib/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmcrypt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;so&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmcrypt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;so&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/lib/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmcrypt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;so&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;.4&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmcrypt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;so&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;.4&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/lib/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmcrypt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;so&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;.4.4.8&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmcrypt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;so&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;.4.4.8&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/lib/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmhash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmhash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/lib/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmhash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;la&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmhash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;la&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/lib/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmhash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;so&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmhash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;so&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/lib/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmhash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;so&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;.2&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmhash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;so&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;.2&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/lib/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmhash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;so&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;.2.0.1&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmhash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;so&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;.2.0.1&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/bin/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmcrypt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libmcrypt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;5&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zxvf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mcrypt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.6.8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mcrypt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.6.8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;  
&lt;span class=&quot;sr&quot;&gt;/sbin/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ldconfig&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;configure&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;../&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;6&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xjvf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;5.3.8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bz2&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;5.3.8&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/configure --prefix=/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/local/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;php&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/php/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;etc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iconv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freetype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysqli&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/mysql/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mysql_config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jpeg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;png&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zlib&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mhash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sockets&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ftp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libxml&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;disable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rpath&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;safe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bcmath&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shmop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sysvsem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inline&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optimization&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curlwrappers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mbregex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mbstring&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mcrypt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;native&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ttf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;openssl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mhash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pcntl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sockets&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ldap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ldap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sasl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fpm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xmlrpc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;soap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;without&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pear&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  

&lt;span class=&quot;n&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ZEND_EXTRA_LIBS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;-liconv&amp;#39;&lt;/span&gt;  

&lt;span class=&quot;c1&quot;&gt;#注意这里容易出现 make: *** [ext/phar/phar.php] 错误 127  &lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;#出现mysql client解决方法  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#ln -s /usr/local/mysql/lib/libmysqlclient.so /usr/lib/  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#ln -s /usr/local/mysql/lib/libmysqlclient.so.18 /usr/lib/libmysqlclient.so.18  &lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;#或者chmod: 无法访问 “ext/phar/phar.phar”: 没有那个文件或目录  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#make: [ext/phar/phar.phar] 错误 1 (忽略)  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#解决方法在编译的时候加--without-pear参数  &lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;#如果还不行,make的时候不添加 ZEND_EXTRA_LIBS=&amp;#39;-liconv&amp;#39; 参数  &lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt;  

&lt;span class=&quot;c1&quot;&gt;#选择PHP.ini配置文件  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ini&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;production&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/php/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;etc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ini&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;更改PHP-FPM&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;c1&quot;&gt;#添加WWW用户  &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;/usr/s&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/groupadd www &amp;amp;&amp;amp; /&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/sbin/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;useradd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;www&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;www&lt;/span&gt;  
&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/var/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/nginx &amp;amp;&amp;amp; chmod +w /&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/log/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nginx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chown&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;www:www&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/var/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nginx&lt;/span&gt;  
&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/data/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;www&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;chmod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/data/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;www&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;chown&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;www:www&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/data/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;www&lt;/span&gt;  

&lt;span class=&quot;n&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/php/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;etc&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/php-fpm.conf.default /&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/local/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/etc/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fpm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conf&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;vi&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/php/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;etc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fpm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conf&lt;/span&gt;  

&lt;span class=&quot;c1&quot;&gt;#去掉/更改配置文件中的;  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_children&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;pm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start_servers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;pm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min_spare_servers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;pm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_spare_servers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;35&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;pm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_requests&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;www&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;www&lt;/span&gt;   

&lt;span class=&quot;c1&quot;&gt;#检查语法是否正确  &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/php/s&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fpm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;  
&lt;span class=&quot;c1&quot;&gt;#出现NOTICE: configuration file /usr/local/php/etc/php-fpm.conf test is successful 测试成功  &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/php/s&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fpm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;  
&lt;span class=&quot;c1&quot;&gt;#设置开机启动  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;vi&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/etc/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;  
&lt;span class=&quot;c1&quot;&gt;#在行末加入  &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/php/s&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fpm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;  

&lt;span class=&quot;c1&quot;&gt;#返回安装包目录   &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;web&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;h3&gt;安装Nginx&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装pcre库&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zxvf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pcre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;8.13&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pcre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;8.13&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/ &amp;amp;&amp;amp; ./co&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nfigure&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;../&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;安装Nginx&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zxvf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nginx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0.9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nginx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0.9&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;configure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;www&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;www&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nginx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sbin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/nginx/s&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nginx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/nginx/co&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nginx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http_stub_status_module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http_ssl_module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pcre&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/var/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nginx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/var/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nginx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;  

&lt;span class=&quot;n&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;../&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;更改配置&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;vi&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/nginx/co&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nginx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conf&lt;/span&gt;      

&lt;span class=&quot;c1&quot;&gt;#修改一些参数,别直接替换文件,这只是一部分     &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;www&lt;/span&gt;  

&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;worker_connections&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  

&lt;span class=&quot;n&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;\.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;fastcgi_pass&lt;/span&gt;   &lt;span class=&quot;mf&quot;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;fastcgi_index&lt;/span&gt;  &lt;span class=&quot;nb&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;fastcgi_param&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;SCRIPT_FILENAME&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;$document_root$fastcgi_script_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;include&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;fastcgi_params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  

&lt;span class=&quot;c1&quot;&gt;#注意这里  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#$document_root$fastcgi_script_name;  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#检测配置文件  &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/nginx/s&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nginx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;  

&lt;span class=&quot;c1&quot;&gt;#提示表示成功  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful  &lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;#开启Nginx  &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/nginx/s&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nginx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;  
&lt;span class=&quot;c1&quot;&gt;#平滑重启Nginx  &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/nginx/s&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nginx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reload&lt;/span&gt;  

&lt;span class=&quot;c1&quot;&gt;#添加开机启动  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;vi&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/etc/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;  
&lt;span class=&quot;c1&quot;&gt;#最后移行加入  &lt;/span&gt;
&lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/nginx/s&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nginx&lt;/span&gt;  

&lt;span class=&quot;c1&quot;&gt;#测试  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/nginx/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;touch&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;php&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;vi&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/usr/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/nginx/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;php&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;php&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;phpinfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>Java编码易疏忽的十个问题</title>
   <link href="http://beango.github.com/archives/2012/09/07/10-java-questions-easy-to-ignore.html"/>
   <updated>2012-09-07T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/09/07/10-java-questions-easy-to-ignore</id>
   <content type="html">&lt;p&gt;在Java编码中，我们容易犯一些错误，也容易疏忽一些问题，因此笔者对日常编码中曾遇到的一些经典情形归纳整理成文，以共同探讨。&lt;/p&gt;

&lt;h2&gt;1. 纠结的同名&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;现象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;很多类的命名相同（例如：常见于异常、常量、日志等类），导致在import时，有时候张冠李戴，这种错误有时候很隐蔽。因为往往同名的类功能也类似，所以IDE不会提示warn。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;写完代码时，扫视下import部分，看看有没有不熟悉的。替换成正确导入后，要注意下注释是否也作相应修改。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;启示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;命名尽量避开重复名，特别要避开与JDK中的类重名，否则容易导入错，同时存在大量重名类，在查找时，也需要更多的辨别时间。&lt;/p&gt;

&lt;h2&gt;2. 想当然的API&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;现象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有时候调用API时，会想当然的通过名字直接自信满满地调用，导致很惊讶的一些错误：&lt;/p&gt;

&lt;p&gt;示例一：flag是true？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;boolean flag = Boolean.getBoolean(&quot;true&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能老是false。&lt;/p&gt;

&lt;p&gt;示例二：这是去年的今天吗（今年是2012年，不考虑闰年）？结果还是2012年：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Calendar calendar = GregorianCalendar.getInstance();
calendar.roll(Calendar.DAY_OF_YEAR, -365);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的才是去年：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;calendar.add(Calendar.DAY_OF_YEAR, -365); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;问自己几个问题，这个方法我很熟悉吗？有没有类似的API?区别是什么？就示例一而言，需要区别的如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Boolean.valueOf(b) VS Boolean.parseBoolean(b) VS Boolean.getBoolean(b);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;启示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;名字起的更详细点，注释更清楚点，不要不经了解、测试就想当然的用一些API，如果时间有限，用自己最为熟悉的API。&lt;/p&gt;

&lt;h2&gt;3. 有时候溢出并不难&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;现象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有时候溢出并不难，虽然不常复现：&lt;/p&gt;

&lt;p&gt;示例一：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;long x=Integer.MAX_VALUE+1;
System.out.println(x);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;x是多少？竟然是-2147483648，明明加上1之后还是long的范围。类似的经常出现在时间计算：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;数字1×数字2×数字3… 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例二：&lt;/p&gt;

&lt;p&gt;在检查是否为正数的参数校验中，为了避免重载，选用参数number,于是下面代码结果小于0，也是因为溢出导致：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Number i=Long.MAX_VALUE;
System.out.println(i.intValue()&amp;gt;0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;让第一个操作数是long型，例如加上L或者l（不建议小写字母l，因为和数字1太相似了）；&lt;/li&gt;
&lt;li&gt;不确定时，还是使用重载吧，即使用doubleValue()，当参数是BigDecimal参数时，也不能解决问题。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;启示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对数字运用要保持敏感：涉及数字计算就要考虑溢出；涉及除法就要考虑被除数是0；实在容纳不下了可以考虑BigDecimal之类。&lt;/p&gt;

&lt;h2&gt;4. 日志跑哪了？&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;现象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有时候觉得log都打了，怎么找不到？&lt;/p&gt;

&lt;p&gt;示例一：没有stack trace！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; } catch (Exception ex) {
    log.error(ex);
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例二：找不到log！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;} catch (ConfigurationException e) {
    e.printStackTrace();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;替换成log.error(ex.getMessage(),ex);&lt;/li&gt;
&lt;li&gt;换成普通的log4j吧，而不是System.out。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;启示&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;API定义应该避免让人犯错，如果多加个重载的log.error(Exception)自然没有错误发生&lt;/li&gt;
&lt;li&gt;在产品代码中，使用的一些方法要考虑是否有效，使用e.printStackTrace()要想下终端(Console)在哪。&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;5. 遗忘的volatile&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;现象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在DCL模式中，总是忘记加一个Volatile。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static CacheImpl instance;  //lose volatile
public static CacheImpl getInstance() {
    if (instance == null) {
        synchronized (CacheImpl.class) {
            if (instance == null) {
                instance = new CacheImpl (); 
            }
        }
    }
    return instance;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;毋庸置疑，加上一个吧，synchronized锁的是一块代码（整个方法或某个代码块），保证的是这”块“代码的可见性及原子性，但是instance == null第一次判断时不再范围内的。所以可能读出的是过期的null。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;启示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们总是觉得某些低概率的事件很难发生，例如某个时间并发的可能性、某个异常抛出的可能性，所以不加控制，但是如果可以，还是按照前人的“最佳实践”来写代码吧。至少不用过多解释为啥另辟蹊径。&lt;/p&gt;

&lt;h2&gt;6. 不要影响彼此&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;现象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在释放多个IO资源时，都会抛出IOException ，于是可能为了省事如此写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void inputToOutput(InputStream is, OutputStream os,
           boolean isClose) throws IOException {
    BufferedInputStream bis = new BufferedInputStream(is, 1024);
    BufferedOutputStream bos = new BufferedOutputStream(os, 1024);  
    ….
    if (isClose) {
       bos.close();
       bis.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设bos关闭失败，bis还能关闭吗？当然不能！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;虽然抛出的是同一个异常，但是还是各自捕获各的为好。否则第一个失败，后一个面就没有机会去释放资源了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;启示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;代码/模块之间可能存在依赖，要充分识别对相互的依赖。&lt;/p&gt;

&lt;h2&gt;7. 用断言取代参数校验&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;现象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如题所提，作为防御式编程常用的方式：断言，写在产品代码中做参数校验等。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void send(List&amp;lt; Event&amp;gt; eventList)  {
    assert eventList != null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;换成正常的统一的参数校验方法。因为断言默认是关闭的，所以起不起作用完全在于配置，如果采用默认配置，经历了eventList != null结果还没有起到作用，徒劳无功。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;启示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有的时候，代码起不起作用，不仅在于用例，还在于配置，例如断言是否启用、log级别等，要结合真实环境做有用编码。&lt;/p&gt;

&lt;h2&gt;8. 用户认知负担有时候很重&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;现象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先来比较三组例子，看看那些看着更顺畅？&lt;/p&gt;

&lt;p&gt;示例一：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void caller(int a, String b, float c, String d) {
    methodOne(d, z, b);
    methodTwo(b, c, d);
}
public void methodOne(String d, float z, String b)  
public void methodTwo(String b, float c, String d)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例二：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public boolean remove(String key, long timeout) {
             Future&amp;lt; Boolean&amp;gt; future = memcachedClient.delete(key);
public boolean delete(String key, long timeout) {
             Future&amp;lt; Boolean&amp;gt; future = memcachedClient.delete(key);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例三：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static String getDigest(String filePath, DigestAlgorithm algorithm)
public static String getDigest(String filePath, DigestAlgorithm digestAlgorithm)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;保持参数传递顺序；&lt;/li&gt;
&lt;li&gt;remove变成了delete，显得突兀了点， 统一表达更好；&lt;/li&gt;
&lt;li&gt;保持表达，少缩写也会看起来流畅点。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;启示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在编码过程中，不管是参数的顺序还是命名都尽量统一，这样用户的认知负担会很少，不要要用户容易犯错或迷惑。例如用枚举代替string从而不让用户迷惑到底传什么string,诸如此类。&lt;/p&gt;

&lt;h2&gt;9. 忽视日志记录时机、级别&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;现象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;存在下面两则示例：&lt;/p&gt;

&lt;p&gt;示例一：该不该记录日志？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;catch (SocketException e)
{
    LOG.error(&quot;server error&quot;, e);
    throw new ConnectionException(e.getMessage(), e);
}   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例二：记什么级别日志？&lt;/p&gt;

&lt;p&gt;在用户登录系统中，每次失败登录：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LOG.warn(&quot;Failed to login by &quot;+username+&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;移除日志记录：在遇到需要re-throw的异常时，如果每个人都按照先记录后throw的方式去处理，那么对一个错误会记录太多的日志，所以不推荐如此做；但是如果re-throw出去的exception没有带完整的trace(即cause)，那么最好还是记录下。&lt;/li&gt;
&lt;li&gt;如果恶意登录，那系统内部会出现太多WARN，从而让管理员误以为是代码错误。可以反馈用户以错误，但是不要记录用户错误的行为，除非想达到控制的目的。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;启示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;日志改不改记？记成什么级别？如何记？这些都是问题，一定要根据具体情况，需要考虑：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;是用户行为错误还是代码错误？&lt;/li&gt;
&lt;li&gt;记录下来的日志，能否能给别人在不造成过多的干扰前提下提供有用的信息以快速定位问题。&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;10. 忘设初始容量&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;现象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在JAVA中，我们常用Collection中的Map做Cache,但是我们经常会遗忘设置初始容量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cache = new LRULinkedHashMap&amp;lt; K, V&amp;gt;(maxCapacity);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;初始容量的影响有多大？拿LinkedHashMap来说，初始容量如果不设置默认是16，超过16×LOAD_FACTOR,会resize(2* table.length),扩大2倍：采用 Entry[] newTable = new Entry[newCapacity];transfer(newTable)，即整个数组Copy，那么对于一个需要做大容量CACHE来说，从16变成一个很大的数量，需要做多少次数组复制可想而知。如果初始容量就设置很大，自然会减少resize,不过可能会担心，初始容量设置很大时，没有Cache内容仍然会占用过大体积。其实可以参考以下表格简单计算下,初始时还没有cache内容, 每个对象仅仅是4字节引用而已。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;memory for reference fields (4 bytes each);&lt;/li&gt;
&lt;li&gt;memory for primitive fields&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;laleb /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;----------- ----------------
Java type   Bytes required
boolean     1
byte         
char        2
short        
int         4
float        
long        8
double       
----------- ----------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;启示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不仅是map,还有stringBuffer等，都有容量resize的过程，如果数据量很大，就不能忽视初始容量可以考虑设置下，否则不仅有频繁的resize还容易浪费容量。&lt;/p&gt;

&lt;p&gt;在Java编程中，除了上面枚举的一些容易忽视的问题，日常实践中还存在很多。相信通过不断的总结和努力，可以将我们的程序完美呈现给读者。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>rabbitmq集群-1 介绍</title>
   <link href="http://beango.github.com/archives/2012/08/21/rabbitmq-cluster.html"/>
   <updated>2012-08-21T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/08/21/rabbitmq-cluster</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://www.rabbitmq.com/clustering.html#auto-config&quot;&gt;http://www.rabbitmq.com/clustering.html#auto-config&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Clustering overview&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A RabbitMQ broker is a logical grouping of one or several Erlang nodes, each running the RabbitMQ application and sharing users, virtual hosts, queues, exchanges, etc. Sometimes we refer to the collection of nodes as a cluster.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个rabbitmq集群中可以共享 user，vhost，queue，exchange等&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;All data/state required for the operation of a RabbitMQ broker is replicated across all nodes, for reliability and scaling, with full ACID properties. An exception to this are message queues, which currently only reside on the node that created them, though they are visible and reachable from all nodes. Future releases of RabbitMQ will introduce migration and replication of message queues.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所有的数据和状态都是必须在所有节点上复制的，一个例外是，那些当前只属于创建它的节点的消息队列，尽管它们可见且可被所有节点读取&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The easiest way to set up a cluster is by auto configuration using a default cluster config file. See the clustering transcripts for an example.
The composition of a cluster can be altered dynamically. All RabbitMQ brokers start out as running on a single node. These nodes can be joined into clusters, and subsequently turned back into individual brokers again.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;rabbitmq节点可以动态的加入到集群中，一个节点它可以加入到集群中，也可以从集群环境退出&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RabbitMQ brokers tolerate the failure of individual nodes. Nodes can be started and stopped at will.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;允许个别的节点失败&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The list of currently active cluster connection points is returned in the known_hosts field of AMQP's connection.open_ok method, as a comma-separated list of addresses where each address is an IP address or a DNS name, optionally followed by a colon and a port number.&lt;/p&gt;

&lt;p&gt;Nodes in a cluster perform some basic load balancing by responding to client connection attempts with AMQP's connection.redirectinsist flag in the connection.open method. method as appropriate, unless the client suppressed redirects by setting the insist flag in the connection.open method.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;集群会进行一个基本的负载均衡&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A node can be a RAM node or a disk node. RAM nodes keep their state only in memory (with the exception of the persistent contents of durable queues which are still stored safely on disc). Disk nodes keep state in memory and on disk. As RAM nodes don't have to write to disk as much as disk nodes, they can perform better. Because state is replicated across all nodes in the cluster, it is sufficient to have just one disk node within a cluster, to store the state of the cluster safely. Beware, however, that RabbitMQ will not stop you from creating a cluster with only RAM nodes. Should you do this, and suffer a power failure to the entire cluster, the entire state of the cluster, including all messages, will be lost.&lt;br/&gt;
&lt;strong&gt;集群中有两种节点：&lt;br/&gt;
内存节点：只保存状态到内存（一个例外的情况是：持久的queue的持久内容将被保存到disk）&lt;br/&gt;
磁盘节点：保存状态到内存和磁盘&lt;br/&gt;
内存节点虽然不写入磁盘，但是它执行比磁盘节点要好&lt;br/&gt;
集群中，只需要一个磁盘节点来保存状态就足够了&lt;br/&gt;
如果集群中只有内存节点，那么不能停止它们，否则所有的状态，消息等都会丢失&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>我为什么向后端工程师推荐Node.js</title>
   <link href="http://beango.github.com/archives/2012/08/12/why-recommend-nodejs.html"/>
   <updated>2012-08-12T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/08/12/why-recommend-nodejs</id>
   <content type="html">&lt;p&gt;来源：&lt;a href=&quot;http://www.infoq.com/cn/articles/why-recommend-nodejs&quot;&gt;李穆&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;科普文一则，说说我对&lt;a href=&quot;http://blog.jobbole.com/1254/&quot; title=&quot;Node.js 究竟是什么？&quot;&gt;Node.js&lt;/a&gt;的一些认识，以及我作为前端工程师为什么会向后端工程师推荐Node.js。&lt;/p&gt;

&lt;p&gt;“Node.js 是服务器端的JavaScript运行环境，它具有无阻塞(non-blocking)和事件驱动(event-driven)等的特色，Node.js采用V8引擎，同样，Node.js实现了类似 Apache 和 nginx 的web服务，让你可以通过它来搭建基于 JavaScript的Web App。”&lt;/p&gt;

&lt;p&gt;我想不仅仅是Node.js，当我们要引入任何一种新技术前都必须要搞清楚几个问题:&lt;/p&gt;

&lt;p&gt;​1. 我们遇到了什么问题？&lt;/p&gt;

&lt;p&gt;​2. 这项新技术解决什么问题，是否契合我们遇到的问题？&lt;/p&gt;

&lt;p&gt;​3. 我们遇到问题的多种解决方案中，当前这项新技术的优势体现在哪儿？&lt;/p&gt;

&lt;p&gt;​4. 使用新技术，带来哪些新问题，严重么，我们能否解决掉？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们的问题：Server端阻塞&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Node.js被设计用来解决服务端阻塞问题.下面通过一段简单的代码解释何为阻塞：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//根据ID，在数据库中Persons表中查出Name
 var name = db.query(&quot;select name from persons where id=1&quot;);
 //进程等待数据查询完毕，然后使用查询结果。
 output(&quot;name&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码的问题是在上面两个语句之间，在整个数据查询的过程中，当前程序进程往往只是在等待结果的返回.这就造成了进程的阻塞.对于高并发，I/O密集行的网络应用中，一方面进程很长时间处于等待状态，另一方面为了应付新的请求不断的增加新的进程.这样的浪费会导致系统支持QPS远远小于后端数据服务能够支撑的QPS，成为了系统的瓶颈.而且这样的系统也特别容易被慢链接攻击(客户端故意不接收或减缓接收数据，加长进程等待时间)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何解决阻塞问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以引入事件处理机制解决这个问题。在查询请求发起之前注册数据加载事件的响应函数，请求发出之后立即将进程交出，而当数据返回后再触发这个事件并在预定好的事件响应函数中继续处理数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//定义如何后续数据处理函数
function onDataLoad(name){
   output(&quot;name&quot;);
}
//发起数据请求，同时指定数据返回后的回调函数
db.query(&quot;select name from persons where id=1&quot;,onDataLoad);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到若按照这个思路解决阻塞问题，首先我们要提供一套高效的异步事件调度机制.而主要用于处理&lt;a href=&quot;http://blog.jobbole.com/12749/&quot; title=&quot;浏览器&quot;&gt;浏览器&lt;/a&gt;端的各种交互事件的JavaScript。相对于其他语言，至少有两个关键点特别适合完成这个任务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么JS适合解决阻塞问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先JavaScript是一种函数式&lt;a href=&quot;http://blog.jobbole.com/tag/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/&quot; title=&quot;如何选择语言和编程语言排名相关文章&quot;&gt;编程语言&lt;/a&gt;，函数编程语言最重要的数学基础是λ演算(lambda calculus) — 即函数对象可以作为其他函数对象的输入(参数)和输出(返回值)。&lt;/p&gt;

&lt;p&gt;这个特性使得为事件指定回调函数变得很容易。特别是JavaScript还支持匿名函数。通过匿名函数的辅助，之前的代码可以进行简写如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.query(&quot;select name from persons where id=1&quot;,function(name){
    output(name);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有另一个关键问题是，异步回调的运行上下文保持(本文暂称其为”状态保持”)。我们先来看一段代码来说明何为状态保持：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//传统同步写法：将查询和结果打印抽象为一个方法
function main(){
    var id = &quot;1&quot;;
    var name = db.query(&quot;select name from persons where id=&quot; + id);
    output(&quot;person id:&quot; + id + &quot;, name:&quot; + name);
}
main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面的写法在传统的阻塞是编程中非常常见，但接下来进行异步改写时会遇到一些困扰：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//异步写法：
function main(){
    var id = &quot;1&quot;;
    db.query(&quot;select name from persons where id=&quot; + id,function(name){
        output(&quot;person id:&quot; + id + &quot;, name:&quot; + name);//n秒后数据返回后执行回调
    });
}
main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;细心的朋友可能已经注意到，当等待了n秒数据查询结果返回后执行回调时。回调函数中却仍然使用了main函数的局部变量”id”，而”id”似乎应该在n秒前走出其作用域。为什么此时”id”仍然可以访问呢，这是因为JavaScript的另外一个重要语言特性：闭包(Closures)。接下来我来详解闭包的原委。&lt;/p&gt;

&lt;p&gt;在复杂的应用中，我们一定会遇到这类场景。即在函数运行时需要访问函数定义时的上下文数据(注意：一定要区分函数定义时和函数运行时两个不同的时刻)。特别是在异步编程模型中，函数的定义和运行又分处不同的时间段，那么保持上下文的问题变得更加突出了。因为我们在任务执行一半时把资源交出去没有问题，但当任务需要再次继续时我们必须还原现场。&lt;/p&gt;

&lt;p&gt;在这个例子中，db.query作为一个公共的数据库查询方法，把”id”这个业务数据传入给db.query，交由其保存是不太合适的。但我们可以稍作抽象，让db.query再支持一个需要保持状态的数据对象传入，当数据查询完毕后可以把这些状态数据原封不动的回传。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function main(){
    var id = &quot;1&quot;;
    var currentState = new Object();
    currentState.person_id = id;
    db.query(&quot;select name from persons where id=&quot; + id, function(name,state){
        output(&quot;person id:&quot; + state.person_id + &quot;, name:&quot; + name);
    },currentState);//注意currentState是db.query的第三个参数
}
main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;记住这种重要的思路，我们再看看是否还能进一步的抽象？可以的，不过接下的动作之前，我们还要了解在JavaScript中一个函数也是一个对象。
一个函数实例fn除了函数体的定义之外，我们仍然可以在这个函数对象实例之本身扩展其他属性，如fn.a=1;受到这个启发我们尝试把需要保持的状态直接绑定到函数实例上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function main(){
    var id = &quot;1&quot;;
    var currentState = new Object();
    currentState.person_id = id;
    function onDataLoad(name){
        output(&quot;person id:&quot; + onDataLoad.state.person_id + &quot;, name:&quot; + name);
    }
    onDataLoad.state = currentState ;//为函数指定state属性，用于保持状态
    db.query(&quot;select name from persons where id=&quot; + id, onDataLoad);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们做了什么？生成了currentState对象，然后在函数onDataLoad定义时，将currentState绑定给onDataLoad这个函数实例。那么在onDataLoad运行时，就可以拿到定义时的state对象了。JavaScript的闭包特性就是内置了这个过程而已。&lt;/p&gt;

&lt;p&gt;在每个JavaScript函数运行时，都有一个运行时内部对象称为Execution Context，它包含如下Variable Object(VO,变量对象)， Scope Chain(作用域链)和”this” Value三部分。如图:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-08/why-recommend-nodejs.jpg&quot; title=&quot;why recommend nodejs&quot;&gt;&lt;img src=&quot;/assets/files/2012-08/why-recommend-nodejs.jpg&quot; title=&quot;why recommend nodejs&quot; alt=&quot;我为什么向后端工程师推荐Node.js&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图片来自&lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/javascript-the-core/#execution-context&quot;&gt;ECMA-262 JavaScript .The Core&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中变量对象VO，包含了所有局部变量的引用。对于main函数，局部变量”id”存储在VO.id内。看起来用VO来代替我们的currentSate最合适了。但main函数还可能嵌套在其他函数之内，所以我们需要ScopeChain，它是一个包含当前运行函数VO和其所有父函数scope的数组。&lt;/p&gt;

&lt;p&gt;所以在这个例子中，在onDataLoad函数定义时，就为默认为其绑定了一个[[scope]]属性指向其父函数的ExecutionContext的ScopeChain。而当函数onDataLoad执行时，就可以通过[[scope]]属性来访问父函数的VO对象来找到id，如果父函数的VO中没有id这个属性，就再继续向上查找其祖先的VO对象，直到找到id这个属性或到达最外层返回undefined。也正是因为这个引用，造成VO的引用计数不为0，在走出作用域时，才不会被垃圾回收。&lt;/p&gt;

&lt;p&gt;很多朋友觉得闭包较难理解，其实我们只要能明确的区分函数定义和函数运行两个时机，那么闭包就是让函数在运行时能够访问到函数定义时的所处作用域内的所有变量，或者说函数定义时能访问到什么变量，那么在函数运行时通过相同的变量名一样能访问到。&lt;/p&gt;

&lt;p&gt;关于状态保持是本文的重点，在我看到的多数Node.js的介绍文章中并没有详解这里，我们只是知道了要解决阻塞问题，但是JavaScript解决阻塞问题的优势到底在哪里，作为一名前端工程师，我想有必要花一些篇幅详细解释一下。&lt;/p&gt;

&lt;p&gt;而之所以我叫它”状态保持”因为还有一个非常相似的场景可以类比：&lt;/p&gt;

&lt;p&gt;用户从A页面提交表单到B页面，如果提交数据校验不通过，则需要返回A页面，同时保持用户在A页面填写的内容并提示用户修改不对的地方。从提交到校验出错再返回继续填写是一个包含网络交互的异步过程，这相当于填写表单这个任务过会儿再继续。&lt;/p&gt;

&lt;p&gt;在传统网页开发中，用户的状态通过请求传递到服务端，交由后端状态保持(类似交给db.query的currentSate)。而使用Ajax的网页，因为并未离开原页面，那么服务端只要负责校验用户提交的数据是否正确即可，发送错误，返回错误处相关信息即可，这就是所谓前端状态保持。可以看到这个场景里边服务端做的事情变少了，变纯粹了。正如我们的例子中db.query不再存储转发第三个state参数，变得更在轻量。&lt;/p&gt;

&lt;p&gt;我们看到通过JavaScript函数式语言特性，匿名函数支持和闭包很漂亮的解决了同步编程到异步编程转化过程中遇到的一系列最重要的问题。但JavaScript是否就是最好的？这就要回答我们引用新技术时需要考虑的最后一个问题了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用Node.js是否带来额外的困扰，如何解决？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Node.js性能真的是最好么？不用比较我们也可以得到结论，Node.js做无阻塞编程性能较难做到极致。何为极致？处理一个请求需要占用多少内存，多少cpu资源，多少带宽，有丁点浪费就不是极致。阻塞式编程浪费了大量进程资源只是在等待，导致大量内存和cpu的浪费。在这方面Node.js好很多，但也正是因为一些闭包等JavaScript内建机制也会导致资源的浪费，看下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function main(){
    var id = &quot;1&quot;;
    var str = &quot;...&quot;; //这里局部变量str存储一个2M的字符串
    db.query(&quot;select name from persons where id=&quot; + id,function(name){
        output(&quot;person id:&quot; + id + &quot;, name:&quot; + name);//n秒后数据返回后执行回调
    });
}
main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至少整个数据查询过程中，变量str所使用的2M内存并不会被释放，而str保持下去可能并没有意义。前面已经解释过闭包的原理，闭包并没有智能到只包起来今后可能被访问到的对象。即使不了解闭包的原理，也可以通过一段简单脚本验证这点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function main(){
    var id = &quot;1&quot;;
    var str = &quot;...&quot;; //这里存储一个2M的字符串
    window.setTimeout(function(){
        debugger; //我们在这里设置断点
    },10000)
}
main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在回调函数当中只设置一个断点，并不指明我们要访问哪个变量。然后我们在控制台监视一下，id和str都是可以拿到的。&lt;/p&gt;

&lt;p&gt;所以我来猜想一下，性能极端苛刻的场景，无阻塞是未来，但无阻塞发展下去，或者有更轻量的脚本引擎产生，或者JavaScript引擎可能要调整可以disable闭包，或者我们要通过给JS开发静态编译器在代码发布前自动优化我们的代码。&lt;/p&gt;

&lt;p&gt;静态编译是如今JavaScript技术领域的又一个热点，我们都知道JavaScript是解释型脚本语言，在运行时自动编译。但是运行时编译只是将代码转为机器码执行，却并未覆盖传统编译型语言在编译阶段所做的任务。比如，语法检查，接口校验，全局性能优化等等。&lt;/p&gt;

&lt;p&gt;最常见的JavaScript静态编译就是脚本压缩工具，在代码发布到线上之前，我们通过各种压缩工具，将代码压缩，达到减少网络传输量的问题。而在这个时间点，已经有越来越多的事情可做，比如：Google利用ClouserComplier提供的系列编译指令，让JavaScript更好的实现OO编程。也有GWT，CoffeeScript这样的项目，将其他语言编译为JavaScript。在淘宝我们在代码静态编译阶段来解决因JavaScript细粒度模块化改造引入各种性能问题，也用来对第三方提供JavaScript代码进行一定的安全检查。&lt;/p&gt;

&lt;p&gt;我们期待前面的代码经过静态编译器编译后变成如下结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function main(){
    var id = &quot;1&quot;;
    var str = &quot;...&quot;; //这里局部变量str存储一个2M的字符串
    db.query(&quot;select name from persons where id=&quot; + id,function(name){
        output(&quot;person id:&quot; + id + &quot;, name:&quot; + name);
    });
    str = &quot;&quot;; //通过这一行，及时释放不必要的内存占用。
}
main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了性能方面的担忧，使用Node.js进行编程增加了代码编写的复杂度。因为我们习惯于阻塞式编程的写法，切换到异步模式编程，往往对于太多多层次的callback函数嵌套弄得不知所措。老赵最近开发了项目&lt;a href=&quot;https://github.com/JeffreyZhao/jscex&quot;&gt;JSCEX&lt;/a&gt;正是要解决这个问题，它让大家在遵守一些小的约定后，能够仍然保持同步编程的写法进行代码开发。写完的代码同样通过静态编译器编译成异步回调式模式的代码再交给JavaScript引擎执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Node.js还要解决什么问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;说了这么多，无阻塞编程要做的还远不止这些。首先需要一个高效的JS引擎，高效的事件池和线程池。另外几乎所有和Node.js交互的传统模块如文件系统，数据访问，HTTP解析，DNS解析都是阻塞式的，都需要额外改造。&lt;/p&gt;

&lt;p&gt;Node.js作者极其团队，正是认清问题所在以及JS解决这些问题方面的优势。基于Google开源的高效JavaScript引擎V8，贡献了大量的智慧和精力解决上述大部分问题后才有Node.js横空出世。&lt;/p&gt;

&lt;p&gt;当前Node社区如此火热，千余开源的&lt;a href=&quot;https://github.com/joyent/node/wiki/modules&quot;&gt;Node.js模块&lt;/a&gt;，活跃在WebFramework，WebSocket，RPC，模板引擎，数据抓取服务，图形图像几乎所有工程领域。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;后记&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本文主要的信息来自Node.js作者在&lt;a href=&quot;http://s3.amazonaws.com/four.livejournal/20091117/jsconf.pdf&quot;&gt;JSConf09&lt;/a&gt;，&lt;a href=&quot;http://nodejs.org/jsconf2010.pdf&quot;&gt;JSConf10&lt;/a&gt;上的分享。而作为前端开发，着重讲了函数式编程，闭包对于无阻塞开发的重要意义。我期待这篇文章能够给前端和后端工程师都带来收获。&lt;/p&gt;

&lt;p&gt;同样作为前端开发，不得不再插几句，说说服务端JS能够解决的另一个问题：当前的Web开发前后端使用不同的语言，很多相同的业务逻辑要前后端分别用不同语言重复实现。比如越来越多重度依赖JavaScript的胖客户端应用，当客户浏览器禁用JavaScript时，则需要使用服务端语言将主业务流程再实现一次，这即是前端常说的”渐进增强”。&lt;/p&gt;

&lt;p&gt;当我们拥有了服务端JavaScript语言，我们自然就会想到能否利用Node.js做到”一次开发，渐进增强”。解决掉这个为小量用户，浪费大量时间的恼人的问题。这方面的实践，YAHOO仍然是先驱，早在一年多前开始YAHOO通过&lt;a href=&quot;https://github.com/davglass/nodejs-yui3&quot;&gt;nodejs-yui3&lt;/a&gt;项目做了很多卓越的贡献，而淘宝自主开发的前端框架&lt;a href=&quot;http://ued.taobao.com/blog/2010/11/04/nodejs-kissy/&quot;&gt;Kissy&lt;/a&gt;也有服务端运行的相关尝试。&lt;/p&gt;

&lt;p&gt;JavaScript在诞生之时就不仅仅是浏览器端工具，如今JavaScript能够再一次回到服务端展示拳脚，感谢V8，感谢NodeJS作者，团队和社区的诸多贡献者，祝Node好运，JavaScript好运。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于作者&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;李穆，前端工程师，就职于淘宝广告技术部架构组，淘宝花名：李牧，专注淘宝广告引擎和业务系统前端开发。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>不可忽略的缓存重建</title>
   <link href="http://beango.github.com/archives/2012/08/11/cache-reconstruction-can-not-be-ignored.html"/>
   <updated>2012-08-11T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/08/11/cache-reconstruction-can-not-be-ignored</id>
   <content type="html">&lt;p&gt;　　本文的主要内容来源于&lt;a href=&quot;http://blog.nosqlfan.com/tags/mongodb&quot; title=&quot;查看 MongoDB 的全部文章&quot;&gt;MongoDB&lt;/a&gt;官方博客，由NoSQLFan补充说明，本文对传统的分布式Cache系统进行了分析，指出了其在&lt;a href=&quot;http://blog.nosqlfan.com/tags/%e7%bc%93%e5%ad%98&quot; title=&quot;查看 缓存 的全部文章&quot;&gt;缓存&lt;/a&gt;&lt;a href=&quot;http://blog.nosqlfan.com/tags/%e9%87%8d%e5%bb%ba&quot; title=&quot;查看 重建 的全部文章&quot;&gt;重建&lt;/a&gt;中会对数据库产生巨大压力的问题。并分析了MongoDB的mmap方案是如何规避这一问题的。&lt;/p&gt;

&lt;p&gt;　　如下图的架构，在数据库前端加上分布式的Cache（比如我们常用的Memcached），让客户端在访问时先查找Cache，Cache不命中再读数据库并将结构缓存在Cache中。这是目前比较常用的一种分担读压力的方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-08/zraqX.png&quot; title=&quot;cache&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　但是这个方法存在一个问题，如果前端的Cache挂掉，或者比较极端的整个机房断电了，那么在机器重启后，原来Cache机器在内存中的缓存会全部清空，在客户端访问过程中，会百分之百的不命中，这样数据库会在瞬间接受巨大的读压力。&lt;/p&gt;

&lt;p&gt;　　试想如果一个64GB的缓存&lt;a href=&quot;http://blog.nosqlfan.com/tags/%e5%a4%b1%e6%95%88&quot; title=&quot;查看 失效 的全部文章&quot;&gt;失效&lt;/a&gt;了，在其重建时，假设与数据库连接的千兆网卡，假设其以极限速度100M每秒从数据库取数据过来重建缓存，那么也需要10分钟才能建完。更何况这是理想情况，对于客户端触发式的随机缓存重建，可能会花掉更长的时间。这还是在数据库能提供100M每秒的数据读请求的前提下。&lt;/p&gt;

&lt;p&gt;　　我们经常看到一些网站挂掉后又恢复，恢复后又挂掉，如此反复几次才能真正恢复，原因就在于其第一次Cache倒了，数据库无法承受相应的读压力，在缓存重建了一小部分后被压死。相当于数据库每重启一次，可以恢复部分缓存，直到缓存的非命中率到达数据库可承受的压力时，才能够真正恢复服务。&lt;/p&gt;

&lt;p&gt;　　这个问题可以用一些可以提供持久化功能的缓存来实现，比如&lt;a href=&quot;http://blog.nosqlfan.com/tags/redis&quot; title=&quot;查看 Redis 的全部文章&quot;&gt;Redis&lt;/a&gt;，在未开启aof的情况下，其定期dump出来的rdb文件出能自动恢复出绝大部分数据，当然，在有的时候这可能导致缓存和数据库数据不一致的情况，需要根据应用场景选择性的使用。&lt;/p&gt;

&lt;p&gt;　　上面是对分布式Cache的问题，而对于很多数据库存储，实际上也几乎都是将热数据尽量放在内存中的。但很多数据库在实现上是自己在内存中实现了Cache机制，这样在数据库重启（非操作系统重启）时，这些Cache可能也就随之被清空了，对于数据库来说，也需要重建缓存，而数据库这时所有的操作可能都落在磁盘IO上，带来了同样的问题。&lt;/p&gt;

&lt;p&gt;　　而MongoDB与上面的方式不太一样，MongoDB采用mmap来将数据文件映射到内存中，所以当MongoDB重启时，这些映射的内存并不会清掉，因为它们是由操作系统维护的（所以当操作系统重启时，MongoDB才会有相同问题）。相对于其它一些自己维护Cache的数据库，MongoDB在重启后并不需要进行缓存重建与预热。&lt;/p&gt;

&lt;p&gt;　　另外，新浪微博的timyang也曾经提出过一种缓存重建加锁的方式，也能部分解决此问题。简单来说就是缓存重建时，当多个客户端对同一个缓存数据发起请求时，会在客户端采用加锁等待的方式，对同一个Cache的重建需要获取到相应的锁才行，只有一个客户端能拿到锁，并且只有拿到锁的客户端才能访问数据库重建缓存，其它的客户端都需要等待这个拿到锁的客户端重建好缓存后直接读缓存，其结果是对同一个缓存数据，只进行一次数据库重建访问。但是如果访问分散比较严重，还是会瞬间对数据库造成非常大的压力。&lt;/p&gt;

&lt;p&gt;下面是几点比较实用的知识：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无论使用哪个存储，都最好先搞清楚其缓存重建的过程，如果一次重启就可能导致数据库崩溃，还是小心为好，最好把重启时间选在访问量比较小的时候。&lt;/li&gt;
&lt;li&gt;重启MongoDB不会导致MongoDB的缓存失效（除非重启服务器）&lt;/li&gt;
&lt;li&gt;当你重新mount磁盘时，文件系统的缓存会失效，这和重启机器时一样，MongoDB也无法避免&lt;/li&gt;
&lt;li&gt;一个使用MongoDB的小技巧，当MongoDB服务器刚启动时，你可以将其所有文件copy到/dev/null中，这会触发操作系统对这些文件的读操作，从而在内存允许的条件下，会将尽可能多的MongoDB数据文件映射到物理内存中。当然，如果在MongoDB运行过程中，你能够判断哪些文件保存的数据是热数据，也可以将这些文件copy到/dev/null来为其争取更多的物理内存。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;参考源：&lt;a href=&quot;http://blog.mongodb.org/post/10407828262/cache-reheating-not-to-be-ignored&quot;&gt;blog.mongodb.org&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>利用Jekyll搭建个人博客</title>
   <link href="http://beango.github.com/archives/2012/07/25/jekyll-introduction.html"/>
   <updated>2012-07-25T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/07/25/jekyll-introduction</id>
   <content type="html">&lt;p&gt;Jekyll是一个静态网站生成器，用ruby编写而成，结合了markdown、Liquid等技术，简化了静态网站的构建过程，配合disqus等技术，可以方便的生成具有简单动态功能的网站。&lt;/p&gt;

&lt;h3&gt;准备工作&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装&lt;a href=&quot;http://rubyinstaller.org/downloads/&quot;&gt;RubyInstaller&lt;/a&gt;（笔者１.９.３版本）&lt;/li&gt;
&lt;li&gt;安装&lt;a href=&quot;http://rubyinstaller.org/downloads/&quot;&gt;DevKit&lt;/a&gt;（Ruby 1.8.6 to 1.9.3使用 tdm-32-4.5.2）&lt;/li&gt;
&lt;li&gt;在DevKit目录找到msys.bat运行并安装Jekyll和rdiscount：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install jekyll -v 0.11.2
$ gem install rdiscount -v 1.6.8
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;安装&lt;a href=&quot;http://www.python.org/getit/&quot;&gt;Python&lt;/a&gt;（推荐Python 2.7.2）&lt;/li&gt;
&lt;li&gt;安装Python &lt;a href=&quot;http://pypi.python.org/pypi/setuptools&quot;&gt;setuptools&lt;/a&gt;，找对应的exe文件下载安装。&lt;/li&gt;
&lt;li&gt;添加 C:\Python27\Scripts（假设你的Python安装在C盘根目录下）到你的path&lt;/li&gt;
&lt;li&gt;转到Python27\Scripts目录下安装pygments:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ easy_install pygments
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;安装windows下的Git——&lt;a href=&quot;http://msysgit.github.com/&quot;&gt;msysGit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在Github上创建一个账户。Github会引导你如何进行简单的设置，如果你没用过Git，没关系，只管照做。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;3分钟搭建Jekyll Blog&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;创建一个新的个版本库&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　登陆你的&lt;a href=&quot;https://github.com/&quot;&gt;Github&lt;/a&gt;账户，创建一个新的版本库，命名为USERNAME.github.com&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安装Jekyll引导程序（Jekyll-Bootstrap）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.com  
$ cd USERNAME.github.com  
$ git remote set-url origin git@github.com:USERNAME/USERNAME.github.com.git  
$ git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;enjoy&lt;br/&gt;
两分钟后你的Blog神奇的出现在&lt;a href=&quot;http://username.github.com/&quot;&gt;http://USERNAME.github.com&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果你安装了Jekyll，你可以在本地预览你的Blog:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/plusjade/jekyll-bootstrap.git  
$ cd jekyll-bootstrap  
$ jekyll --server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　在浏览器预览&lt;a href=&quot;http://localhost:4000/&quot;&gt;http://localhost:4000&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://jekyllbootstrap.com/lessons/jekyll-introduction.html&quot;&gt;更多介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;快速开始&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;本地运行Jekyll&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　假设你已经安装好了jekyll-bootstrap，以及其他一些基本运行环境和工具，首先启动你本地的WEBrick服务器（Ruby自带的）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd USERNAME.github.com  
$ jekyll --server  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　别忘了把USERNAME换成你的GitHub用户名。&lt;br/&gt;
　　你的Blog在这预览: &lt;a href=&quot;http://localhost:4000/&quot;&gt;http://localhost:4000/&lt;/a&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建第一篇博文&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rake post title=&quot;Hello World&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　情况下rake命令会在你的_posts目录下创建一个名为[年-月-日-posttitle.md]的文件，例如2012-05-04-Hello-World.md，名称中的空格会转换成“-”，时间为当前系统时间。当然这些都是可配置的。&lt;br/&gt;
　　rake命令默认不会覆盖掉相同名称的文件。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建第一个页面&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 根目录下创建页面  
$ rake page name=&quot;about.md&quot;

# 自定义目录下创建页面  
$ rake page name=&quot;pages/about.md&quot;

# 创建类似./pages/about/index.html目录结构的页面  
$ rake page name=&quot;pages/about&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　发布&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;完成一篇博文或者做一些修改之后可以用简单的git命令提交到远程的Github版本库。同时Github可以将md文件解析成html文件，通过USERNAME.github.com就可以访问刚才提交的博文。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add .  
$ git commit -m &quot;Add new content&quot;  
$ git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　至此你就可以写自己的blog like a hacker。&lt;/p&gt;

&lt;p&gt;　　当然你还可以运用一些预置的主题，做一些自定义的配置，以及自己定义主题增加模板配置文件、增加Blog挂件、加入Google Analytics、Disqus等等，同样可以将一个静态网站做的栩栩如生。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;另外网站默认是托管在Github服务器（实际上是RackSpace的云服务器）上的，你还可以考虑免费的Heroku，至于GAE、EC2（免费一年），显然有些大材小用了。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;遇到的问题&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;本地post中出现中文不能正常编译&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　由于windows下的git控制台MinGW默认不支持中文编码，需要将其设置为UTF-8，有两种解决方案：&lt;br/&gt;
　　临时：控制台输入以下语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ export LC_ALL=en_US.UTF-8  
$ export LANG=en_US.UTF-8  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　永久：添加两个用户自定义的环境变量，LC_ALL=en_US.UTF-8 和 LANG=en_US.UTF-8（你想的没错，就是修改windows环境变量）&lt;/p&gt;

&lt;p&gt;　　另外Jekyll默认的Markdown引擎markup对中文的解析不是很好，建议换成rdiscount。在_config.yml文件中pygments: true上一行添加markdown: rdiscount。在此之前你必须首先安装Rdiscount。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install rdiscount
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Liquid error: No such file or directory - pygmentize&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　没有安装Pygments的缘故，如果你安装了python，只需要easy install。&lt;/p&gt;

&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ easy_install Pygments
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Liquid error: bad file descriptor&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　我的电脑上同时装了python2.7和python3.2，我想是这个原因。需要给albino.rb文件打个补丁，假设你的Ruby安装在D:\Program\，并且你已经把&lt;a href=&quot;https://gist.github.com/2592525&quot;&gt;albino-windows-refactor.patch&lt;/a&gt;补丁文件copy到了下边的目录：&lt;/p&gt;

&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd D:\Program\Ruby193\lib\ruby\gems\1.9.1\gems\albino-1.3.3\lib  
$ patch &amp;lt; albino-windows-refactor.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;侧边栏二级目录的链接不起作用&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　这个问题花了不少时间，最终还是未能找到问题所在，无奈，只有自己动手丰衣足食，自己写js搞定。&lt;/p&gt;

&lt;p&gt;　　首先看一下源码，在assets\app.js文件中的Toc中看可以看到：&lt;/p&gt;

&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node.children.each(function(){  
    cache += '&amp;lt;li class=&quot;sub&quot;&amp;gt;&amp;lt;a href=&quot;#'+ this.id + '&quot;&amp;gt;'+ $(this).text() + '&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;';  
})  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　显然他在这为链接设置了href，但是调用了h2对象（也就是侧边栏目录的二级菜单）的id属性，而用Firebug查看最终解析成的html文件，发现&amp;lt;h2&gt;的id是不存在的，于是自然想到这在之前先为h2设置唯一的id属性。这个用jQuery很容易就能实现：&lt;/p&gt;

&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&quot;h2&quot;).each(function(){$(this).attr(&quot;id&quot;,&quot;_&quot;+$(this).text());});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;类似于could't parse YAML at line 6 column 6 (Psych::SyntaxError)的问题&lt;br/&gt;
YAM了貌似对空格比较敏感，需要一个空格的时候就不要敲多个空格，同时注意你的Tab缩进，_config.yml中的属性都是key: value形式的，别忘了：后边有个空格。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　另外post文件头中的属性配置也要注意：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---  
layout: post  
title : post_title  
categories : category_name  
description: |  
    This is a decription.  
---  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　description第二行开头我敲了一个Tab（四个字符宽度）就出错了，一些细节，注意一下就好了。&lt;/p&gt;

&lt;h3&gt;域名绑定&lt;/h3&gt;

&lt;p&gt;　　Github会为你分配一个类似于USERNAME.github.com的二级域名，如果你自己有一个顶级域名，你可以将它与Github提供的一个共有IP(204.232.175.78)绑定，这个在Github Pages上有详细介绍，在你的网站根目录下增加一个CNAME文件，里边写你自己的域名，再给你的域名增加一条A记录，稍等片刻之后就可以用你的域名访问了。&lt;/p&gt;

&lt;p&gt;　　当然域名是需要花钱的，如果你舍不得花银子，免费的午餐还是会有的，你可以免费申请一个（当然也可以是多个）.tk的域名。DotTK提供yourname.tk的免费顶级域名。.tk是南太平洋岛国托克劳的国家域名，免费注册一个帐户可以任意申请.tk域名，支持域名转发（可隐藏原URL）、电邮转发、A记录解析、CNAME别名记录、MX邮件记录、设置DNS服务器等服务。当然免费的总是会有一些限制条件喽。&lt;/p&gt;

&lt;p&gt;　　如果你注册的域名在90天内访问量少于25个，你的域名将被删除！
　　如果你开通的电邮转发在90天内收到的邮件少于10封，你的电邮转发服务将被停止！
　　另外很多看起来不错的域名不是免费的，要交费才能注册使用！比如说cn.tk。&lt;/p&gt;

&lt;p&gt;　　注册流程很简单，有中文版的，几十秒钟你的免费顶级域名就到手了，是不是很happy！&lt;/p&gt;

&lt;h3&gt;其他&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;html代码转markdown &lt;a href=&quot;http://johnmacfarlane.net/pandoc/installing.html&quot;&gt;pandoc&lt;/a&gt;:&lt;br/&gt;
pandoc -f html -t markdown hello.html -o 2012-08-06-hello.md&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/rollenholt/articles/2389459.html&quot;&gt;github中的登录认证&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>互联网协议入门（二）</title>
   <link href="http://beango.github.com/archives/2012/07/15/internet-protocol-suite-part-ii.html"/>
   <updated>2012-07-15T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/07/15/internet-protocol-suite-part-ii</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;/archives/internet-protocol-suite-part-i/&quot;&gt;上一篇&lt;/a&gt;文章分析了互联网的总体构思，从下至上，每一层协议的设计思想。
这是从设计者的角度看问题，今天我想切换到用户的角度，看看用户是如何从上至下，与这些协议互动的。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;七、一个小结&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012052913.png&quot; alt=&quot;&quot; class=&quot;Pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发送这个包，需要知道两个地址：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;* 对方的MAC地址&lt;/p&gt;

&lt;p&gt;* 对方的IP地址&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012061101.jpg&quot; alt=&quot;&quot; class=&quot;Pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。&lt;/p&gt;

&lt;p&gt;1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：&lt;/p&gt;

&lt;table width=&quot;500px&quot; border=&quot;1&quot; style=&quot;border-collapse:collapse;border-spacing:0;&quot;&gt;
&lt;tr&gt;&lt;td&gt;场景&lt;/td&gt;&lt;td&gt;数据包地址&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;同一个子网络&lt;/td&gt;&lt;td&gt;对方的MAC地址，对方的IP地址&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;非同一个子网络&lt;/td&gt;&lt;td&gt;网关的MAC地址，对方的IP地址&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;八、用户的上网设置&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;8.1 静态IP地址&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012061110.jpg&quot; alt=&quot;&quot; class=&quot;Pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt; * 本机的IP地址&lt;br&gt;
 * 子网掩码&lt;br&gt;
 * 网关的IP地址&lt;br&gt;
 * DNS的IP地址&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;下图是Windows系统的设置窗口。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012061111.png&quot; alt=&quot;&quot; class=&quot;Pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作&quot;静态IP地址上网&quot;。&lt;/p&gt;

&lt;p&gt;但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用&quot;动态IP地址上网&quot;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8.2 动态IP地址&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所谓&quot;动态IP地址&quot;，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做&lt;a href=&quot;http://zh.wikipedia.org/zh/DHCP&quot;&gt;DHCP协议&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做&quot;DHCP服务器&quot;。新的计算机加入网络，必须向&quot;DHCP服务器&quot;发送一个&quot;DHCP请求&quot;数据包，申请IP地址和相关的网络参数。&lt;/p&gt;

&lt;p&gt;前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？&lt;/p&gt;

&lt;p&gt;DHCP协议做了一些巧妙的规定。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8.3 DHCP协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012061102.png&quot; alt=&quot;&quot; class=&quot;Pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（1）最前面的&quot;以太网标头&quot;，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。&lt;/p&gt;

&lt;p&gt;（2）后面的&quot;IP标头&quot;，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。&lt;/p&gt;

&lt;p&gt;（3）最后的&quot;UDP标头&quot;，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。&lt;/p&gt;

&lt;p&gt;这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道&quot;这个包是发给我的&quot;，而其他计算机就可以丢弃这个包。&lt;/p&gt;

&lt;p&gt;接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个&quot;DHCP响应&quot;数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。&lt;/p&gt;

&lt;p&gt;新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8.4 上网设置：小结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个部分，需要记住的就是一点：不管是&quot;静态IP地址&quot;还是&quot;动态IP地址&quot;，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt; * 本机的IP地址&lt;br&gt;
 * 子网掩码&lt;br&gt;
 * 网关的IP地址&lt;br&gt;
 * DNS的IP地址&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;有了这几个数值，电脑就可以上网&quot;冲浪&quot;了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;九、一个实例：访问网页&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;9.1 本机参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们假定，经过上一节的步骤，用户设置好了自己的网络参数：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt; * 本机的IP地址：192.168.1.100&lt;br&gt;
 * 子网掩码：255.255.255.0&lt;br&gt;
 * 网关的IP地址：192.168.1.1&lt;br&gt;
 * DNS的IP地址：8.8.8.8&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;然后他打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012061103.png&quot; alt=&quot;&quot; class=&quot;Pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;这意味着，浏览器要向Google发送一个网页请求的数据包。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9.2 DNS协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Domain_Name_System&quot;&gt;DNS协议&lt;/a&gt; 可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012061105.png&quot; alt=&quot;&quot; class=&quot;Pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9.3 子网掩码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。&lt;/p&gt;

&lt;p&gt;已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。&lt;/p&gt;

&lt;p&gt;因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9.4 应用层协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;浏览网页用的是HTTP协议，它的整个数据包构造是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012061106.png&quot; alt=&quot;&quot; class=&quot;Pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;HTTP部分的内容，类似于下面这样：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt; GET / HTTP/1.1&lt;br&gt;
 Host: www.google.com&lt;br&gt;
 Connection: keep-alive&lt;br&gt;
 User-Agent: Mozilla/5.0 (Windows NT 6.1) ……&lt;br&gt;
 Accept:&lt;br&gt;
 text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&lt;br&gt;
 Accept-Encoding: gzip,deflate,sdch&lt;br&gt;
 Accept-Language: zh-CN,zh;q=0.8&lt;br&gt;
 Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3&lt;br&gt;
 Cookie: … …&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9.5 TCP协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。&lt;/p&gt;

&lt;p&gt;TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9.6 IP协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。&lt;/p&gt;

&lt;p&gt;IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9.7 以太网协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。&lt;/p&gt;

&lt;p&gt;以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012061107.png&quot; alt=&quot;&quot; class=&quot;Pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9.8 服务器端响应&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。&lt;/p&gt;

&lt;p&gt;根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的&quot;HTTP请求&quot;，接着做出&quot;HTTP响应&quot;，再用TCP协议发回来。&lt;/p&gt;

&lt;p&gt;本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012061104.jpg&quot; alt=&quot;&quot; class=&quot;Pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个例子就到此为止，虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。&lt;/p&gt;

&lt;p&gt;（完）&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>互联网协议入门（一）</title>
   <link href="http://beango.github.com/archives/2012/07/12/internet-protocol-suite-part-i.html"/>
   <updated>2012-07-12T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/07/12/internet-protocol-suite-part-i</id>
   <content type="html">&lt;h3&gt;&lt;strong&gt;一、概述&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1.1 五层模型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。&lt;/p&gt;

&lt;p&gt;用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。&lt;/p&gt;

&lt;p&gt;如何分层有不同的模型，有的模型分七层，有的分四层。我觉得，把互联网分成五层，比较容易解释。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012052902.png&quot; alt=&quot;互联网层&quot; class=&quot;Pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，最底下的一层叫做&quot;实体层&quot;（Physical
Layer），最上面的一层叫做&quot;应用层&quot;（Application
Layer），中间的三层（自下而上）分别是&quot;链接层&quot;（Link Layer）、&quot;网络层&quot;（Network
Layer）和&quot;传输层&quot;（Transport
Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。&lt;/p&gt;

&lt;p&gt;它们叫什么名字，其实并不重要。只需要知道，互联网分成若干层就可以了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2 层与协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。&lt;/p&gt;

&lt;p&gt;大家都遵守的规则，就叫做&quot;协议&quot;（protocol）。&lt;/p&gt;

&lt;p&gt;互联网的每一层，都定义了很多协议。这些协议的总称，就叫做&quot;互联网协议&quot;（Internet
Protocol
Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;二、实体层&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;我们从最底下的一层开始。&lt;/p&gt;

&lt;p&gt;电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012052903.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这就叫做&quot;实体层&quot;，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;三、链接层&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;3.1 定义&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这就是&quot;链接层&quot;的功能，它在&quot;实体层&quot;的上方，确定了0和1的分组方式。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2 以太网协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91&quot;&gt;&quot;以太网&quot;&lt;/a&gt;（Ethernet）的协议，占据了主导地位。&lt;/p&gt;

&lt;p&gt;以太网规定，一组电信号构成一个数据包，叫做&quot;帧&quot;（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012052904.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&quot;标头&quot;包含数据包的一些说明项，比如发送者、接受者、数据类型等等；&quot;数据&quot;则是数据包的具体内容。&lt;/p&gt;

&lt;p&gt;&quot;标头&quot;的长度，固定为18字节。&quot;数据&quot;的长度，最短为46字节，最长为1500字节。因此，整个&quot;帧&quot;最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3 MAC地址&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面提到，以太网数据包的&quot;标头&quot;，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？&lt;/p&gt;

&lt;p&gt;以太网规定，连入网络的所有设备，都必须具有&quot;网卡&quot;接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012052905.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012052906.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.4 广播&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;定义地址只是第一步，后面还有更多的步骤。&lt;/p&gt;

&lt;p&gt;首先，一块网卡怎么会知道另一块网卡的MAC地址？&lt;/p&gt;

&lt;p&gt;回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。&lt;/p&gt;

&lt;p&gt;其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？&lt;/p&gt;

&lt;p&gt;回答是以太网采用了一种很&quot;原始&quot;的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012052907.png&quot; alt=&quot;&quot; class=&quot;Pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的&quot;标头&quot;，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做&quot;广播&quot;（broadcasting）。&lt;/p&gt;

&lt;p&gt;有了数据包的定义、网卡的MAC地址、广播的发送方式，&quot;链接层&quot;就可以在多台计算机之间传送数据了。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;四、网络层&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;4.1 网络层的由来&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。&lt;/p&gt;

&lt;p&gt;但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一&quot;包&quot;，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。&lt;/p&gt;

&lt;p&gt;互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012052914.png&quot; alt=&quot;&quot; class=&quot;Pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用&quot;路由&quot;方式发送。（&quot;路由&quot;的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这就导致了&quot;网络层&quot;的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做&quot;网络地址&quot;，简称&quot;网址&quot;。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;于是，&quot;网络层&quot;出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。&lt;/p&gt;

&lt;p&gt;网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.2 IP协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。&lt;/p&gt;

&lt;p&gt;目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012052908.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。&lt;/p&gt;

&lt;p&gt;互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。&lt;/p&gt;

&lt;p&gt;但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。&lt;/p&gt;

&lt;p&gt;那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数&quot;子网掩码&quot;（subnet
mask）。&lt;/p&gt;

&lt;p&gt;所谓&quot;子网掩码&quot;，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。&lt;/p&gt;

&lt;p&gt;知道&quot;子网掩码&quot;，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。&lt;/p&gt;

&lt;p&gt;比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。&lt;/p&gt;

&lt;p&gt;总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.3 IP数据包&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。&lt;/p&gt;

&lt;p&gt;但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？&lt;/p&gt;

&lt;p&gt;回答是不需要，我们可以把IP数据包直接放进以太网数据包的&quot;数据&quot;部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。&lt;/p&gt;

&lt;p&gt;具体来说，IP数据包也分为&quot;标头&quot;和&quot;数据&quot;两个部分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012052909.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&quot;标头&quot;部分主要包括版本、长度、IP地址等信息，&quot;数据&quot;部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012052910.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;IP数据包的&quot;标头&quot;部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的&quot;数据&quot;部分，最长为65,515字节。前面说过，以太网数据包的&quot;数据&quot;部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.4 ARP协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;关于&quot;网络层&quot;，还有最后一点需要说明。&lt;/p&gt;

&lt;p&gt;因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。&lt;/p&gt;

&lt;p&gt;所以，我们需要一种机制，能够从IP地址得到MAC地址。&lt;/p&gt;

&lt;p&gt;这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的&quot;网关&quot;（gateway），让网关去处理。&lt;/p&gt;

&lt;p&gt;第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个&quot;广播&quot;地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。&lt;/p&gt;

&lt;p&gt;总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;五、传输层&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;5.1 传输层的由来&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。&lt;/p&gt;

&lt;p&gt;接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？&lt;/p&gt;

&lt;p&gt;也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做&quot;端口&quot;（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。&lt;/p&gt;

&lt;p&gt;&quot;端口&quot;是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&quot;传输层&quot;的功能，就是建立&quot;端口到端口&quot;的通信。相比之下，&quot;网络层&quot;的功能是建立&quot;主机到主机&quot;的通信。只要确定主机和端口，我们就能实现程序之间的交流。&lt;/strong&gt;因此，Unix系统就把主机+端口，叫做&quot;套接字&quot;（socket）。有了它，就可以进行网络应用程序开发了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.2 UDP协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。&lt;/p&gt;

&lt;p&gt;UDP数据包，也是由&quot;标头&quot;和&quot;数据&quot;两部分组成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012052911.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&quot;标头&quot;部分主要定义了发出端口和接收端口，&quot;数据&quot;部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的&quot;数据&quot;部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012052912.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;UDP数据包非常简单，&quot;标头&quot;部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.3 TCP协议&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。&lt;/p&gt;

&lt;p&gt;因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。&lt;/p&gt;

&lt;p&gt;TCP数据包和UDP数据包一样，都是内嵌在IP数据包的&quot;数据&quot;部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;六、应用层&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;应用程序收到&quot;传输层&quot;的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&quot;应用层&quot;的作用，就是规定应用程序的数据格式。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了&quot;应用层&quot;。&lt;/p&gt;

&lt;p&gt;这是最高的一层，直接面对用户。它的数据就放在TCP数据包的&quot;数据&quot;部分。因此，现在的以太网的数据包就变成下面这样。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/bg2012052913.png&quot; alt=&quot;&quot; class=&quot;Pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。下一篇，我反过来，从用户的角度，自上而下看看这个结构是如何发挥作用，完成一次网络数据交换的。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Windows下nginx的启动，重启，关闭</title>
   <link href="http://beango.github.com/archives/2012/06/29/windows-nginx-start-restart-shutdown.html"/>
   <updated>2012-06-29T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/06/29/windows-nginx-start-restart-shutdown</id>
   <content type="html">

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;   
&lt;span class=&quot;nv&quot;&gt;@ECHO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OFF&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NGINX_PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E:&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NGINX_DIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nginx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.8.40&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;\&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;TITLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Nginx&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;管理程序&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Power&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;By&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ants&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http:&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leleroyn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnblogs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;GOTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MENU&lt;/span&gt;   
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MENU&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;CLS&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Nginx&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;管理程序&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Power&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;By&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ants&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http:&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leleroyn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnblogs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;    
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;启动&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Nginx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;关闭&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Nginx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;重启&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Nginx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;退&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;出&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;请输入选择项目的序号：&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;%id%&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;1&amp;quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GOTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd1&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;%id%&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;2&amp;quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GOTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd2&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;%id%&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;3&amp;quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GOTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd3&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;%id%&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;4&amp;quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EXIT&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;PAUSE&lt;/span&gt;   
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd1&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;启动&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Nginx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;......&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EXIST&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%NGINX_DIR%nginx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exe&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%NGINX_DIR%nginx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exe&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;不存在&lt;/span&gt;   
&lt;span class=&quot;nv&quot;&gt;%NGINX_PATH%&lt;/span&gt;   
&lt;span class=&quot;nv&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%NGINX_DIR%&lt;/span&gt;   
&lt;span class=&quot;nv&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EXIST&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%NGINX_DIR%nginx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exe&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%NGINX_DIR%nginx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exe&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OK&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;PAUSE&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;GOTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MENU&lt;/span&gt;   
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd2&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;关闭&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Nginx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;......&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;taskkill&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/F /&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nginx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nul&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OK&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;PAUSE&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;GOTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MENU&lt;/span&gt;   
&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd3&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;关闭&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Nginx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;......&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;taskkill&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/F /&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nginx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nul&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;ECHO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OK&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;GOTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd1&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;GOTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MENU&lt;/span&gt;   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/nginx.bat&quot;&gt;猛击这里下载&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>如何绘制业务流程图(二)</title>
   <link href="http://beango.github.com/archives/2012/06/26/how-to-draw-business-process-diagrams-2.html"/>
   <updated>2012-06-26T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/06/26/how-to-draw-business-process-diagrams-2</id>
   <content type="html">&lt;p&gt;来源：&lt;a href=&quot;http://heidixie.blog.sohu.com/222277336.html&quot;&gt;heidixie的博客&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;接上篇&lt;a href=&quot;/archives/2012/06/03/how-to-draw-business-process-diagrams-1.html&quot;&gt;《业务流程图绘制流程分享(一)》&lt;/a&gt;，本篇将对上篇中间的第四部分——如何绘制业务流程图展开更多讨论。&lt;/p&gt;

&lt;p&gt;本来写完上篇，我发现没有太多必要单纯讨论这一部分内容，因为对于很多人来讲，缺的不是具体的做法，而是做这件事情的意义以及目标性的明确。一旦对这件事情的意义和目标有深刻认同，那自然会产生较大的动力去研究How这个层次的所需方法和技能。时间管理也如此，很多时间管理技巧牛逼的人未必能够把时间管理做到位，因为内心克服不了强大的拖延症，而克服拖延很多时候是一个心理问题而不是技巧问题……咳咳，这不是在说我自己吗？&lt;/p&gt;

&lt;p&gt;话又扯远了，扯扯扯回来啊。那么为何还专门狗尾续貂（恩，原文也不见得是貂，成语有限，暂时凑合吧），又来这么一篇How的枯燥乏味的文章呢？因为在上篇文章后，Heidi确实在邮件里收到一些邮件，询问业务流程图的具体操作指南——这东西很好，这东西很有用，但是似乎上篇都是讲的“真实的道理”，但是具体怎么做呢？我应该注意什么呢？……&lt;/p&gt;

&lt;p&gt;所以，干脆也分享一下吧。但在书写过程中，我发现一个大难题在于收集整理出更生动易懂又典型的案例。不能使用工作中的实际案例，但是短时间又难以找到合适的。所以本人对这部分不太满意。也希望各位读到本文的人，能够提供更多案例分享。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/u82672385_138dff826a1g214_blog1.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/u82672385_138dff826a1g214_blog1.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot; alt=&quot;如何绘制业务流程图(二)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 业务流程图的“烹饪三部曲”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在绘制业务流程图前，思考如何精美，如何交互，使用什么工具，都不应该是重点。&lt;/p&gt;

&lt;p&gt;真正重点的是将业务流程图的关键要素给搜集一番。请试图回答清楚以下几个问题，否则不要开始绘制流程图：&lt;/p&gt;

&lt;p&gt;● 整个流程的起始点是什么？整个流程的终结点是什么？&lt;/p&gt;

&lt;p&gt;● 在整个流程中，涉及到的角色都是谁？&lt;/p&gt;

&lt;p&gt;● 在整个流程中，都需要做什么事情？（可是是一个会议，可以是一个任务）&lt;/p&gt;

&lt;p&gt;● 这些会议和任务是可选还是必选的？&lt;/p&gt;

&lt;p&gt;● 分别产出什么文档？&lt;/p&gt;

&lt;p&gt;这有点像一个头脑风暴，能够帮助你将所需用到的原材料获取到，有了这些“米”和“水”，那就不愁去如何烹饪了。&lt;/p&gt;

&lt;p&gt;在项目管理中，上个月，我们也试图给去规范化一个数据产品的设计开发流程。&lt;/p&gt;

&lt;p&gt;这是一个数据产品的项目，而我们都不是对此很有经验的人。所以我们召集到所有相关的角色，组织了一次头脑风暴及卡片分类法的混合式应用。&lt;/p&gt;

&lt;p&gt;1.让大家头脑风暴出自己认为在项目里必须的节点，如“需求调研”，“需求分析”，“kick off会议”，“PRD撰写及确认”，“数据评估”，“技术架构”，“DEMO绘制”，“指标算法定义”，等等。&lt;/p&gt;

&lt;p&gt;2.在头脑风暴过程中，主持人将这些节点都写到白板上，等没有新的节点诞生后，大家一起对节点进行合并归类。之后呢？&lt;/p&gt;

&lt;p&gt;3.将这些剩余下来的真正有价值的节点，撰写到即时贴上，开始进行排序。在排序过程中，可以由一个人先主导，他会按照自己的理解，将各个节点放到按角色排布的泳道中，并设计好先后的顺序。在他进行的过程中，其他人不断进行提问：“这项任务开始前，需要什么样的条件？”“这个任务是必须的吗？”然后一起调整先后顺序。直到最终没有人有任何重大的异议。&lt;/p&gt;

&lt;p&gt;4.之后拍照留念。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/u82672385_138c71f8885g214_blog2.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/u82672385_138c71f8885g214_blog2.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot; alt=&quot;如何绘制业务流程图(二)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后可整理成电子文档，如project或者excel版本（&lt;a href=&quot;http://heidixie.i.sohu.com/blog/view/164631214.htm&quot;&gt;使用excel做项目管理&lt;/a&gt;？）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/u82672385_138c726651eg214_blog3.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/u82672385_138c726651eg214_blog3.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot; alt=&quot;如何绘制业务流程图(二)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;但是，业务流程图和上述项目中的流程不太相同的是：&lt;/p&gt;

&lt;p&gt;项目中的各种活动节点有更宽泛的可配置性，任务A和任务B是否并行，还是串行，如果项目组成员达成共识，是可以调整，并且多做尝试的。所以可以用集思广益的做法去头脑风暴出一个暂定比较合理的流程。而业务流程图的梳理，有两种:&lt;/p&gt;

&lt;p&gt;●
一种是基于现实发生的业务流程如实反映。这显然不是你一个团队能够YY的结果。更需要走到现实环境中，去调研，去梳理，去确认。&lt;/p&gt;

&lt;p&gt;●
另一种是基于流程优化的方案，当你已经掌握了目前的流程现实如何运作时，基于分析，讨论，能够判断出流程中不合理的地方，给出一个更完善或者有更效率、成本更低的新的流程出来——或许你要求增加一个部门，或者你需要删减一个环节，或者中间的若干步使用新开发的系统去取代。&lt;/p&gt;

&lt;p&gt;总之，大多数时候，你要想做第二种流程图，必然要先将第一种给梳理出来。所以，第一种如实反映的流程图是躲不过的。既然如此，基于YY或者头脑风暴是不现实的。我们需要走到前线去，掌握现实中业务是如何运作的。而且很多时候，越细节越好。&lt;/p&gt;

&lt;p&gt;那怎么做呢？&lt;strong&gt;基于有限的知识与经验&lt;/strong&gt;，我可以给如下建议：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 调研——2.梳理呈现——3.评审确认三部曲，如图所示：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/u82672385_138c72113c8g213_blog4.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/u82672385_138c72113c8g213_blog4.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot; alt=&quot;如何绘制业务流程图(二)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 调研——问正确的问题，多问问题，多问几个人&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;除了在本部分开始的那几个问题要顾及到，其实调研过程解决的仍然是&lt;strong&gt;who，what，why，how，以及wher&lt;/strong&gt;e的问题：谁，在什么情况下，做了什么事情，这个事情需要什么前置条件，又输出了什么，这个事情在哪里完成的？搞明白这几个问题，我们的调研就可以圆满完成了。&lt;/p&gt;

&lt;p&gt;流程图的表现，要回答这几个问题：&lt;/p&gt;

&lt;p&gt;1.Who——谁？部门，角色，岗位&lt;/p&gt;

&lt;p&gt;2.What——什么事情？&lt;/p&gt;

&lt;p&gt;3.Where——在哪里做的？在我梳理的业务流程图上，where更多表示是文档还是各种系统，用来表示信息化的程度。比如当我们梳理中发现，有一项登记，是用excel而不是业务系统来进行的，那么在这里的where就可以表示为：excel文档。&lt;/p&gt;

&lt;p&gt;4.Document——那产生的这份文档叫什么名字？也写出来，代表有文件的传递，而以后要进行信息化的话，此份人肉文档也是需要被消除而被系统取代的。（相反，如果这项工作是在某个系统里操作的，where就可以写成“人事系统”，文档可以继续存在，即该系统中的表单名称：“员工登记表单”）&lt;/p&gt;

&lt;p&gt;5.Condition——条件。在这种条件下，下一个活动还能够继续，即用逻辑链接线的方式来表示一项活动的输入和输出，指向某个活动的箭头就表示此活动的前置输入条件。&lt;/p&gt;

&lt;p&gt;6.Dicision——决策。有些活动会产生一个条件判断，根据不同的判断结果从而走不同的分支流程。比如输入员工信息的时候，可以根据员工之前是否就职过，选择不同的流程，对于已经就职过的，选用之前的工号而不用生成新的工号。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/u82672385_138dffbf479g215_blog5.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/u82672385_138dffbf479g215_blog5.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot; alt=&quot;如何绘制业务流程图(二)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;举个案例（如果不太恰当，请意会）。假设你受命要调研两家餐饮店的业务流程，目的是给他们提供性价比最高的点餐系统。&lt;/p&gt;

&lt;p&gt;在调研中：&lt;/p&gt;

&lt;p&gt;​1. 你首先可以要求精通业务流程的人给你系统讲解一遍。&lt;/p&gt;

&lt;p&gt;​2. 调研具体操作的人，来验证他给你讲解的是否全面和偏差。&lt;/p&gt;

&lt;p&gt;​3. 实地观察和记录（花点时间走遍业务流程）&lt;/p&gt;

&lt;p&gt;三种方式相互结合使用。第一种方法可以让你首先建立一个系统观，了解大体枝干，但是很难切入到可能会出现问题的细节。第二种方法太依赖于问题的质量以及问问题的场景。有很多结论的不正确其实是因为问错了人或者问问题的方法不对。那么就需要借助第三种，在观察中再进行验证。&lt;/p&gt;

&lt;p&gt;比如，你现在找到了一个厨师：&lt;/p&gt;

&lt;p&gt;你主要负责做什么菜系？&lt;/p&gt;

&lt;p&gt;热菜。&lt;/p&gt;

&lt;p&gt;那菜单都是谁给你的？&lt;/p&gt;

&lt;p&gt;我们的服务员。&lt;/p&gt;

&lt;p&gt;她都怎么提供给你？&lt;/p&gt;

&lt;p&gt;她负责客人点菜后，然后手写一个单子，给我放到窗口上。&lt;/p&gt;

&lt;p&gt;单子上都会写什么？&lt;/p&gt;

&lt;p&gt;桌号，菜名等&lt;/p&gt;

&lt;p&gt;那如何客人点的是冷菜呢？&lt;/p&gt;

&lt;p&gt;恩，有复印本，直接拿一份给冷菜间。&lt;/p&gt;

&lt;p&gt;那你怎么开始工作呢？从洗菜到切菜，一直烹饪都是一个人吗？&lt;/p&gt;

&lt;p&gt;哦，不，我只负责烹饪。当接到菜单后，首先我的助理会进行择菜，刀工进行切菜，这样如果有几个菜就完全可以并行。&lt;/p&gt;

&lt;p&gt;当你们做好后呢？&lt;/p&gt;

&lt;p&gt;放到窗口，按铃，喊桌号和菜名，传菜员就会传菜。&lt;/p&gt;

&lt;p&gt;……&lt;/p&gt;

&lt;p&gt;在这些问题中，就涉及到了“分单”，“切菜”，“择菜”，”烹饪”，“传菜”，“上菜”几个活动，也涉及到了“服务员”，“厨师”，“助理”，“刀工”，“传菜员”几个角色。几个活动的次序也比较清楚了。&lt;/p&gt;

&lt;p&gt;而另一家餐饮店的业务流程却是不一样的，你同样抓住一个厨师进行询问：&lt;/p&gt;

&lt;p&gt;要做什么菜，菜单是哪里来的？&lt;/p&gt;

&lt;p&gt;打印出来的。&lt;/p&gt;

&lt;p&gt;所有菜都会在这里打印吗？&lt;/p&gt;

&lt;p&gt;哦，只有热菜在这里打印出来，冷菜、酒水就会在冷菜间和酒水间打印出来。&lt;/p&gt;

&lt;p&gt;打印机是谁在操作的？&lt;/p&gt;

&lt;p&gt;没人操作，它会自动打印不同的单子给我们。&lt;/p&gt;

&lt;p&gt;……下面的问题，可能厨师就不了解了，要问点菜员了。&lt;/p&gt;

&lt;p&gt;请问你是怎么点菜的？&lt;/p&gt;

&lt;p&gt;拿设备啊，客人点菜就按几下，确认就好了。&lt;/p&gt;

&lt;p&gt;之后呢？&lt;/p&gt;

&lt;p&gt;之后就可以将菜单打印出来。&lt;/p&gt;

&lt;p&gt;不同的菜系会在不同的烹饪间打印吗？&lt;/p&gt;

&lt;p&gt;是的，我们可以分单打印。是在这中心打印机里完成分单。&lt;/p&gt;

&lt;p&gt;然后，你可以继续调研烹饪后的传菜和上菜流程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 梳理并呈现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你的调研和观察使你拥有了“烹饪”所需的原材料。&lt;/p&gt;

&lt;p&gt;● 角色：部门、岗位或人&lt;/p&gt;

&lt;p&gt;● 活动：做了什么事情&lt;/p&gt;

&lt;p&gt;● 次序：做这些事情的次序如何&lt;/p&gt;

&lt;p&gt;● 规则：什么情况下到什么事情&lt;/p&gt;

&lt;p&gt;还记得我们之前提过的流程图要素吗？回顾下：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/u82672385_138c72ee0fbg213_blog6.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/u82672385_138c72ee0fbg213_blog6.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot; alt=&quot;如何绘制业务流程图(二)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;接下来的任务是不是很简单，&lt;strong&gt;对，就像填空题一样简单&lt;/strong&gt;。将活动/事件按照一定的规则填到由部门和时间两条维度决定的框框里。&lt;/p&gt;

&lt;p&gt;这个阶段是paper
work，你需要将调研阶段收集到的原材料用更直观明了的方式呈现出来。从而能够更好进行评审和确认。也为以后的流程评审和优化做准备。&lt;/p&gt;

&lt;p&gt;在刚开始，笔和纸的原始搭配仍然是最好的起步工具。你可以暂时忽略掉美观或者可复用的因素。但是当你对要呈现的流程已经有足够的信心时，就可以借助软件工具了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1 复杂流程的分解&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不可能将所有的活动都放到一张图里呈现。&lt;/p&gt;

&lt;p&gt;“业务流程是有层次性的，这种层次体现在由上至下、由整体到部分、由宏观到微观、由抽象到具体的逻辑关系。这样一个层次关系符合人们的思维习惯，有利于企业业务模型的建立
 企业部门之间的层次关系表。一般来说，我们可以先建立主要业务流程的总体运行过程（其中包括了整个企业的大的战略），然后对其中的每项活动进行细化，落实到各个部门的业务过程，建立相对独立的子业务流程以及为其服务的辅助业务流程。”&lt;/p&gt;

&lt;p&gt;——&lt;a href=&quot;http://baike.baidu.com/view/1368133.htm&quot;&gt;引自《百度百科》
业务流程词条&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于很多新人来讲，业务最难的在于划分业务流程图的层次上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首先，明确你要梳理的业务流程的范围&lt;/strong&gt;——用大的粗略的关键节点，讲清楚这个业务流程范围中的故事，就是顶层业务流程图。你的顶层业务流程图是业务全局故事的简单表达，但是请注意这里的业务全局不见得是公司整体的业务全局，而是你界定好的业务范围。比如，下图是餐厅的日常运作流程图，若你界定的业务范围是面向顾客的点餐和结帐流程，那么这就是顶层业务流程图。但是若你界定的是整个餐厅的运作业务流程，那这显然还是一个子集——并没有包含餐厅的采购、供应商管理、一级库存管理等工作。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/u82672385_138dfdb7b14g215_blog7.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/u82672385_138dfdb7b14g215_blog7.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot; alt=&quot;如何绘制业务流程图(二)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其次，先从顶层的业务流程分解开始，由粗至细。顶层业务流程图的梳理原则：&lt;/p&gt;

&lt;p&gt;1.界定范围内的业务全局故事。&lt;/p&gt;

&lt;p&gt;2.包含该范围内的关键节点。并且，当被质疑说某某环节怎么不存在时，自己要清楚它在下一层分解中应该被包含在那个关键节点中。比如，赠送10周年优惠券，应该会在结帐节点分解中出现。而打印分单，会在点菜节点中分解。而准备儿童座椅应该是接待入座环节。&lt;/p&gt;

&lt;p&gt;​3.
顶层流程图分解出来的关键节点未必都会细化分解下去，生成二级以及三级的流程图。这要看该节点涉及到的“活动”以及“角色”是否复杂。&lt;/p&gt;

&lt;p&gt;再看一个案例，对传统生产型企业的进销存主业务流程进行分解。橙色的代表被分解点，已经可以分解为四层。当我们分解到第四层，发现再往下去涉及到的活动和角色都已经很少时，就不必再分解了，而是可以将第四层的关键节点直接作为第三层业务流程的“活动”，而不是子流程图。&lt;/p&gt;

&lt;p&gt;当然，这是依赖于你梳理业务流程的目标。如果你偏偏是要对“打样”环节进行剖析优化，则还可以继续分解下去。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/u82672385_138dfdb4c0eg215_blog8.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/u82672385_138dfdb4c0eg215_blog8.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot; alt=&quot;如何绘制业务流程图(二)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这一步的工作会帮你建立出清晰的流程目录结构，如下图所示是摘选于刚完成的一个流程梳理的项目中的目录结构部分。可以看到全图即是顶层关键节点，作为老大，可能只要看这一层就够了。下面则会对顶层做更多细化拆解。&lt;/p&gt;

&lt;p&gt;“H3.样品认证”在顶层业务流程图中，仅仅是一个“活动”，而在自己细化的这一个层次中，则会包含详细的子活动一级参与者。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/u82672385_138dfe8f9dfg215_blog9.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/u82672385_138dfe8f9dfg215_blog9.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot; alt=&quot;如何绘制业务流程图(二)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2 流程图的常用图示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;\
&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/u82672385_138c721a473g215_blog0.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/u82672385_138c721a473g215_blog0.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot; alt=&quot;如何绘制业务流程图(二)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我常用的就是前两行的“活动”，“判断”，“逻辑关系线”，“起始与终止”，以及第二行的“子流程”，和“文件/表单”。如果你不是符号控，我建议这几个就足够了。&lt;/p&gt;

&lt;p&gt;其中，“子流程”此图示就是可以帮助你将流程分解得到的子流程能够串联起来，比如，当在”A流程”中涉及到进一步需要分解的”A1.1流程”时，就可以在”A流程”中用子流程符号代表“A1.1”。然后你的读者就会明白要想进一步了解”A1.1″应该参考另外一个流程图。&lt;/p&gt;

&lt;p&gt;流程图的常用结构：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/u82672385_138c721d7f5g215_blog11.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/u82672385_138c721d7f5g215_blog11.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot; alt=&quot;如何绘制业务流程图(二)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;给大家看一些案例：&lt;/p&gt;

&lt;p&gt;基本上包含大多数图示的流程图：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/u82672385_138c722702fg214_blog12.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/u82672385_138c722702fg214_blog12.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot; alt=&quot;如何绘制业务流程图(二)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文档地址：http://www.ais.npic.edu.tw/ais/971%20materials/DfdSfPm_20080724.pdf&lt;/p&gt;

&lt;p&gt;只用到少数几个图示画的简单流程图（台湾人的文档中称为程序图——不过这里的程序不是指计算机程序，而是process，仅仅是体现任务之间的处理流程，所以使用极简单的符号也不为怪了）：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/u82672385_138c722fa0bg214_blog13.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/u82672385_138c722fa0bg214_blog13.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot; alt=&quot;如何绘制业务流程图(二)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以上两个流程图案例，从符号的复杂程度上来讲，一个是完整流程图，一个是基本流程图，但是从表现形式来讲，都属于“泳道图”——Swimlane。这也是我们最常用的一种表现形式了。泳道图能够很好体现部门或者角色在流程中的职责以及上下游的协作关系。且流程图本身的标准容易掌握，达成共识也就更加容易。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3 泳道图精要&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/u82672385_138c7233cdcg215_blog14.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/u82672385_138c7233cdcg215_blog14.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot; alt=&quot;如何绘制业务流程图(二)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2大维度：一般泳道图的横向会作为部门或岗位维，当然也有例外，如上述案例中就是横的泳道。而纵向则做为阶段维——时间是从上到下发展的。如果复杂的泳道图，在任务分解上可以在阶段维里做一些划分，比如“采购”，“生产”，“销售”，”配送”等。&lt;/li&gt;
&lt;li&gt;活动流转：活动就像一个游泳员一样，游到不同的泳道中去执行任务。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在上文中的软件推荐部分，我推荐过smartdraw工具，此工具还附带了泳道图的模板，大家比较更快能够上手：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/u82672385_138c723f489g213_blog15.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/u82672385_138c723f489g213_blog15.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot; alt=&quot;如何绘制业务流程图(二)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/u82672385_138c7243215g214_blog16.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/u82672385_138c7243215g214_blog16.jpg&quot; title=&quot;如何绘制业务流程图(二)&quot; alt=&quot;如何绘制业务流程图(二)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.4 Do vs Donnot 业务流程图的注意事项！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DO&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 让涉众参与，不要闭门造车&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;业务流程图包含了你图上的各个参与角色代表，与他们适时确认事情的原本流程，禁止自己YY。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2. 恰当的层次分解，不要将所有都铺到一张图上&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;如上所示。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;3. 逐渐深入，先抓枝干&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;切忌胡子眉毛一把抓。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;4. 流程一定有开始和结束&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;切忌交付出来的流程图，让读者还来问你：流程的开始点是什么？用清晰的代表开始和结束的符号来完成第一步和最后一步。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 编号，编号，编号&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是让沟通效率更高的优化措施。当你有了编号系统，相当于对你的流程图都赋予了唯一识别身份证号。这比中文名称更有效。比如当我们完成了业务流程图后，负责业务流程规则审核和优化的部门能够清楚在邮件里传达：H5.1流程优化，大家就更明确指的是什么。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;DONNOT&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;​1. 自己YY应用的环节而不是现实中的环节&lt;/p&gt;

&lt;p&gt;​2. 所有的环节都试图放到一张图上&lt;/p&gt;

&lt;p&gt;​3. 一开始就陷入细节，胡子眉毛一起抓&lt;/p&gt;

&lt;p&gt;​4. 流程很难让人分清楚从哪里开始，到哪里结束&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;4. 评审及后续行动&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;验证你是否做到了以上的DO，以及规避了Donnot的做法是什么？&lt;/p&gt;

&lt;p&gt;很好办，及时与各位进行评审。将各个涉众都叫到一起，给他们看你梳理出来的成果。&lt;/p&gt;

&lt;p&gt;这会发现一些有意思的事情，除了评审你的流程图是否符合现实外，也会评审目前的业务流程是否符合理想。不同的部门和岗位的代表会在这个评审中，确认当前，也会相互提出意见，甚至吵起来，这不失于做流程优化的一个很好的契机。暂且不表了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>坐得越久 死得越快 还是站着编程吧</title>
   <link href="http://beango.github.com/archives/2012/06/25/confirmed-he-who-sits-the-most-dies-the-soonest.html"/>
   <updated>2012-06-25T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/06/25/confirmed-he-who-sits-the-most-dies-the-soonest</id>
   <content type="html">&lt;p&gt;又一项研究显示，久坐对你的健康是真的、真的、真的非常有害。请买一个可站着工作的桌子吧！&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-05/sitecode.jpg&quot;&gt;&lt;img src=&quot;/assets/files/2012-05/sitecode.jpg&quot; title=&quot;可站着编程的电脑桌&quot; alt=&quot;可站着编程的电脑桌&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;可站着编程的电脑桌一项对超过20万个澳大利亚人的研究结果给这样一个事实又增加了一份活体证明：坐得越久的人死得越快。研究同时还发现，锻炼不能改变这种趋势——尽管它能有效降低这种风险。&lt;/p&gt;

&lt;p&gt;研究结果清晰的告诉我们这样一个简单的信息：多站立、少坐着，这样能延长你的寿命。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;尽管那些每周锻炼超过5个小时的人的死亡风险会大大降低，但当他们坐的过久时，这种风险仍然会升高。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;目前，“久坐对身体有害”已经被广泛的认可。最近几年的研究表明，在电脑屏幕前、电视前做得太久，或仅是闲坐太久，都会增加你死亡的风险。&lt;/p&gt;

&lt;p&gt;这次的调查采取了一种更直接的方式，观察人们每日坐着的时间总和和他们在之后三年内死亡率之间的关系，希望能给久坐的危害程度标个数字。&lt;/p&gt;

&lt;p&gt;结果让人震惊，每天坐着超过11小时的人在未来三年的死亡风险要比每天坐着少于4小时的人的死亡风险高出40%。这是经过了对年龄、体重、物理锻炼、健康水平等所有会影响到死亡风险的因素进行校正后得到的结果。同时得到的一个正比数据是：坐得越久，死亡风险越高。&lt;/p&gt;

&lt;p&gt;这个研究是萨克斯研究所（Sax Institute）的45 and Up研究项目的组成部分。45 and Up Study是南半球目前最大的真正进行的关于健康衰老研究项目。研究数据来自222497个超过45岁的澳大利亚人每天自主报告的总计坐的时间。研究者拿
这些数据跟他们在之后三年的死亡率进行了对比。&lt;/p&gt;

&lt;p&gt;不管他们健康还是有病，喜欢运动还是不爱运动，他们坐得越久，在未来三年里的死亡风险就会越高。&lt;a href=&quot;http://www.aqee.net/he-who-sits-the-most-dies-the-soonest/www.thedoctorwillseeyounow.com/content/aging/art2066.html&quot;&gt;锻炼可以大量的降低这种风险&lt;/a&gt;：坐的最久的人比坐的很少的人的死亡风险只高出40%，但拿坐的最久且锻炼最少的人和坐的很少但锻炼最多的对比，这个数字会变成100%。尽管每周锻炼超过5小时的人的风险会低很多，但当他们做的太久时，风险度仍是往上走的。&lt;/p&gt;

&lt;p&gt;换句话说就是，你需要去锻炼，但同等重要的事是，尽量少坐。&lt;/p&gt;

&lt;p&gt;有一篇社论曾建议说，证据已经如此丰富，我们的大夫完全应该在给病人的处方中建议他们减少坐着的时间。但我们自己为什么不能主动行动，给自己开出这样的药方呢。&lt;/p&gt;

&lt;p&gt;据粗略统计，人们在休闲时90%以上的时间是坐着的。所以，我们还有很大改善的空间。&lt;/p&gt;

&lt;p&gt;[本文英文原文链接：&lt;a href=&quot;http://www.theatlantic.com/health/archive/2012/04/confirmed-he-who-sits-the-most-dies-the-soonest/256101/&quot;&gt;He Who Sits the Most Dies the Soonest&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;本文转载自: 外刊IT评论 &lt;a href=&quot;http://www.aqee.net/&quot;&gt;http://www.aqee.net/&lt;/a&gt;
(本站只作转载,不代表本站同意文中观点或证实文中信息)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>解密Redis持久化</title>
   <link href="http://beango.github.com/archives/2012/06/17/redis-persistence-demystified.html"/>
   <updated>2012-06-17T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/06/17/redis-persistence-demystified</id>
   <content type="html">&lt;p&gt;本文内容来源于&lt;a href=&quot;http://blog.nosqlfan.com/tags/redis&quot; title=&quot;查看 Redis 的全部文章&quot;&gt;Redis&lt;/a&gt;作者博文，Redis作者说，他看到的所有针对Redis的讨论中，对Redis&lt;a href=&quot;http://blog.nosqlfan.com/tags/%e6%8c%81%e4%b9%85%e5%8c%96&quot; title=&quot;查看 持久化 的全部文章&quot;&gt;持久化&lt;/a&gt;的误解是最大的，于是他写了&lt;a href=&quot;http://antirez.com/post/redis-persistence-demystified.html&quot;&gt;一篇长文&lt;/a&gt;来对Redis的持久化进行了系统性的论述。文章非常长，也很值得一看，NoSQLFan将主要内容简述成本文。&lt;/p&gt;

&lt;p&gt;什么是持久化，简单来讲就是将数据放到断电后数据不会丢失的设备中。也就是我们通常理解的硬盘上。&lt;/p&gt;

&lt;h2&gt;写操作的流程&lt;/h2&gt;

&lt;p&gt;首先我们来看一下数据库在进行写操作时到底做了哪些事，主要有下面五个过程。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;客户端向服务端发送写操作（数据在客户端的内存中）&lt;/li&gt;
&lt;li&gt;数据库服务端接收到写请求的数据（数据在服务端的内存中）&lt;/li&gt;
&lt;li&gt;服务端调用write(2)这个系统调用，将数据往磁盘上写（数据在系统内存的缓冲区中）&lt;/li&gt;
&lt;li&gt;操作系统将缓冲区中的数据转移到磁盘控制器上（数据在磁盘缓存中）&lt;/li&gt;
&lt;li&gt;磁盘控制器将数据写到磁盘的物理介质中（数据真正落到磁盘上）&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;故障分析&lt;/h2&gt;

&lt;p&gt;写操作大致有上面5个流程，下面我们结合上面的5个流程看一下各种级别的故障。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当数据库系统故障时，这时候系统内核还是OK的，那么此时只要我们执行完了第3步，那么数据就是安全的，因为后续操作系统会来完成后面几步，保证数据最终会落到磁盘上。&lt;/li&gt;
&lt;li&gt;当系统断电，这时候上面5项中提到的所有缓存都会失效，并且数据库和操作系统都会停止工作。所以只有当数据在完成第5步后，机器断电才能保证数据不丢失，在上述四步中的数据都会丢失。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;通过上面5步的了解，可能我们会希望搞清下面一些问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据库多长时间调用一次write(2)，将数据写到内核缓冲区&lt;/li&gt;
&lt;li&gt;内核多长时间会将系统缓冲区中的数据写到磁盘控制器&lt;/li&gt;
&lt;li&gt;磁盘控制器又在什么时候把缓存中的数据写到物理介质上&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;对于第一个问题，通常数据库层面会进行全面控制。而对第二个问题，操作系统有其默认的策略，但是我们也可以通过POSIX
API提供的fsync系列命令强制操作系统将数据从内核区写到磁盘控制器上。对于第三个问题，好像数据库已经无法触及，但实际上，大多数情况下磁盘缓存是被设置关闭的。或者是只开启为读缓存，也就是写操作不会进行缓存，直接写到磁盘。建议的做法是仅仅当你的磁盘设备有备用电池时才开启写缓存。&lt;/p&gt;

&lt;h2&gt;数据损坏&lt;/h2&gt;

&lt;p&gt;所谓数据损坏，就是数据无法恢复，上面我们讲的都是如何保证数据是确实写到磁盘上去，但是写到磁盘上可能并不意味着数据不会损坏。比如我们可能一次写请求会进行两次不同的写操作，当意外发生时，可能会导致一次写操作安全完成，但是另一次还没有进行。如果数据库的数据文件结构组织不合理，可能就会导致数据完全不能恢复的状况出现。&lt;/p&gt;

&lt;p&gt;这里通常也有三种策略来组织数据，以防止数据文件损坏到无法恢复的情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一种是最粗糙的处理，就是不通过数据的组织形式保证数据的可恢复性。而是通过配置数据同步备份的方式，在数据文件损坏后通过数据备份来进行恢复。实际上MongoDB在不开启journaling日志，通过配置Replica
Sets时就是这种情况。&lt;/li&gt;
&lt;li&gt;另一种是在上面基础上添加一个操作日志，每次操作时记一下操作的行为，这样我们可以通过操作日志来进行数据恢复。因为操作日志是顺序追加的方式写的，所以不会出现操作日志也无法恢复的情况。这也类似于MongoDB开启了journaling日志的情况。&lt;/li&gt;
&lt;li&gt;更保险的做法是数据库不进行老数据的修改，只是以追加方式去完成写操作，这样数据本身就是一份日志，这样就永远不会出现数据无法恢复的情况了。实际上CouchDB就是此做法的优秀范例。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;RDB快照&lt;/h2&gt;

&lt;p&gt;下面我们说一下Redis的第一个持久化策略，RDB快照。Redis支持将当前数据的快照存成一个数据文件的持久化机制。而一个持续写入的数据库如何生成快照呢。Redis借助了fork命令的copy
on
write机制。在生成快照时，将当前进程fork出一个子进程，然后在子进程中循环所有的数据，将数据写成为RDB文件。&lt;/p&gt;

&lt;p&gt;我们可以通过Redis的save指令来配置RDB快照生成的时机，比如你可以配置当10分钟以内有100次写入就生成快照，也可以配置当1小时内有1000次写入就生成快照，也可以多个规则一起实施。这些规则的定义就在Redis的配置文件中，你也可以通过Redis的CONFIG
SET命令在Redis运行时设置规则，不需要重启Redis。&lt;/p&gt;

&lt;p&gt;Redis的RDB文件不会坏掉，因为其写操作是在一个新进程中进行的，当生成一个新的RDB文件时，Redis生成的子进程会先将数据写到一个临时文件中，然后通过原子性rename系统调用将临时文件重命名为RDB文件，这样在任何时候出现故障，Redis的RDB文件都总是可用的。&lt;/p&gt;

&lt;p&gt;同时，Redis的RDB文件也是Redis主从同步内部实现中的一环。&lt;/p&gt;

&lt;p&gt;但是，我们可以很明显的看到，RDB有他的不足，就是一旦数据库出现问题，那么我们的RDB文件中保存的数据并不是全新的，从上次RDB文件生成到Redis停机这段时间的数据全部丢掉了。在某些业务下，这是可以忍受的，我们也推荐这些业务使用RDB的方式进行持久化，因为开启RDB的代价并不高。但是对于另外一些对数据安全性要求极高的应用，无法容忍数据丢失的应用，RDB就无能为力了，所以Redis引入了另一个重要的持久化机制：&lt;a href=&quot;http://blog.nosqlfan.com/tags/aof&quot; title=&quot;查看 AOF 的全部文章&quot;&gt;AOF&lt;/a&gt;日志。&lt;/p&gt;

&lt;h2&gt;AOF日志&lt;/h2&gt;

&lt;p&gt;aof日志的全称是append only
file，从名字上我们就能看出来，它是一个追加写入的日志文件。与一般数据库的binlog不同的是，AOF文件是可识别的纯文本，它的内容就是一个个的Redis标准命令。比如我们进行如下实验，使用Redis2.6版本，在启动命令参数中设置开启aof功能：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./redis-server --appendonly yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们执行如下的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; set key1 Hello
OK
redis 127.0.0.1:6379&amp;gt; append key1 &quot; World!&quot;
(integer) 12
redis 127.0.0.1:6379&amp;gt; del key1
(integer) 1
redis 127.0.0.1:6379&amp;gt; del non_existing_key
(integer) 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时我们查看AOF日志文件，就会得到如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat appendonly.aof
*2
$6
SELECT
$1
0
*3
$3
set
$4
key1
$5
Hello
*3
$6
append
$4
key1
$7
 World!
*2
$3
del
$4
key1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，写操作都生成了一条相应的命令作为日志。其中值得注意的是最后一个del命令，它并没有被记录在AOF日志中，这是因为Redis判断出这个命令不会对当前数据集做出修改。所以不需要记录这个无用的写命令。另外AOF日志也不是完全按客户端的请求来生成日志的，比如命令INCRBYFLOAT在记AOF日志时就被记成一条SET记录，因为浮点数操作可能在不同的系统上会不同，所以为了避免同一份日志在不同的系统上生成不同的数据集，所以这里只将操作后的结果通过SET来记录。&lt;/p&gt;

&lt;h2&gt;AOF重写&lt;/h2&gt;

&lt;p&gt;你可以会想，每一条写命令都生成一条日志，那么AOF文件是不是会很大？答案是肯定的，AOF文件会越来越大，所以Redis又提供了一个功能，叫做AOF
rewrite。其功能就是重新生成一份AOF文件，新的AOF文件中一条记录的操作只会有一次，而不像一份老文件那样，可能记录了对同一个值的多次操作。其生成过程和RDB类似，也是fork一个进程，直接遍历数据，写入新的AOF临时文件。在写入新文件的过程中，所有的写操作日志还是会写到原来老的AOF文件中，同时还会记录在内存缓冲区中。当重完操作完成后，会将所有缓冲区中的日志一次性写入到临时文件中。然后调用原子性的rename命令用新的AOF文件取代老的AOF文件。&lt;/p&gt;

&lt;p&gt;从上面的流程我们能够看到，RDB和AOF操作都是顺序IO操作，性能都很高。而同时在通过RDB文件或者AOF日志进行数据库恢复的时候，也是顺序的读取数据加载到内存中。所以也不会造成磁盘的随机读。&lt;/p&gt;

&lt;h2&gt;AOF可靠性设置&lt;/h2&gt;

&lt;p&gt;AOF是一个写文件操作，其目的是将操作日志写到磁盘上，所以它也同样会遇到我们上面说的写操作的5个流程。那么写AOF的操作安全性又有多高呢。实际上这是可以设置的，在Redis中对AOF调用write(2)写入后，何时再调用fsync将其写到磁盘上，通过&lt;a href=&quot;http://blog.nosqlfan.com/tags/appendfsync&quot; title=&quot;查看 appendfsync 的全部文章&quot;&gt;appendfsync&lt;/a&gt;选项来控制，下面appendfsync的三个设置项，安全强度逐渐变强。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;appendfsync no&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当设置appendfsync为no的时候，Redis不会主动调用fsync去将AOF日志内容同步到磁盘，所以这一切就完全依赖于操作系统的调试了。对大多数Linux操作系统，是每30秒进行一次fsync，将缓冲区中的数据写到磁盘上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;appendfsync everysec&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当设置appendfsync为everysec的时候，Redis会默认每隔一秒进行一次fsync调用，将缓冲区中的数据写到磁盘。但是当这一次的fsync调用时长超过1秒时。Redis会采取延迟fsync的策略，再等一秒钟。也就是在两秒后再进行fsync，这一次的fsync就不管会执行多长时间都会进行。这时候由于在fsync时文件描述符会被阻塞，所以当前的写操作就会阻塞。&lt;/p&gt;

&lt;p&gt;所以，结论就是，在绝大多数情况下，Redis会每隔一秒进行一次fsync。在最坏的情况下，两秒钟会进行一次fsync操作。&lt;/p&gt;

&lt;p&gt;这一操作在大多数数据库系统中被称为group
commit，就是组合多次写操作的数据，一次性将日志写到磁盘。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;appednfsync always&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当设置appendfsync为always时，每一次写操作都会调用一次fsync，这时数据是最安全的，当然，由于每次都会执行fsync，所以其性能也会受到影响。&lt;/p&gt;

&lt;h2&gt;对于pipelining有什么不同&lt;/h2&gt;

&lt;p&gt;对于pipelining的操作，其具体过程是客户端一次性发送N个命令，然后等待这N个命令的返回结果被一起返回。通过采用pipilining就意味着放弃了对每一个命令的返回值确认。由于在这种情况下，N个命令是在同一个执行过程中执行的。所以当设置appendfsync为everysec时，可能会有一些偏差，因为这N个命令可能执行时间超过1秒甚至2秒。但是可以保证的是，最长时间不会超过这N个命令的执行时间和。&lt;/p&gt;

&lt;h2&gt;与postgreSQL和MySQL的比较&lt;/h2&gt;

&lt;p&gt;这一块就不多说了，由于上面操作系统层面的数据安全已经讲了很多，所以其实不同的数据库在实现上都大同小异。总之最后的结论就是，在Redis开启AOF的情况下，其单机数据安全性并不比这些成熟的SQL数据库弱。&lt;/p&gt;

&lt;h2&gt;数据导入&lt;/h2&gt;

&lt;p&gt;这些持久化的数据有什么用，当然是用于重启后的数据恢复。Redis是一个内存数据库，无论是RDB还是AOF，都只是其保证数据恢复的措施。所以Redis在利用RDB和AOF进行恢复的时候，都会读取RDB或AOF文件，重新加载到内存中。相对于MySQL等数据库的启动时间来说，会长很多，因为MySQL本来是不需要将数据加载到内存中的。&lt;/p&gt;

&lt;p&gt;但是相对来说，MySQL启动后提供服务时，其被访问的热数据也会慢慢加载到内存中，通常我们称之为预热，而在预热完成前，其性能都不会太高。而Redis的好处是一次性将数据加载到内存中，一次性预热。这样只要Redis启动完成，那么其提供服务的速度都是非常快的。&lt;/p&gt;

&lt;p&gt;而在利用RDB和利用AOF启动上，其启动时间有一些差别。RDB的启动时间会更短，原因有两个，一是RDB文件中每一条数据只有一条记录，不会像AOF日志那样可能有一条数据的多次操作记录。所以每条数据只需要写一次就行了。另一个原因是RDB文件的存储格式和Redis数据在内存中的编码格式是一致的，不需要再进行数据编码工作。在CPU消耗上要远小于AOF日志的加载。&lt;/p&gt;

&lt;p&gt;好了，大概内容就说到这里。更详细完整的版本请看Redis作者的博文：&lt;a href=&quot;http://antirez.com/post/redis-persistence-demystified.html&quot;&gt;Redis persistence demystified&lt;/a&gt;。本文如有描述不周之处，就大家指正。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>深刻理解Python中的元类(metaclass)</title>
   <link href="http://beango.github.com/archives/2012/06/11/what-is-a-metaclass-in-python.html"/>
   <updated>2012-06-11T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/06/11/what-is-a-metaclass-in-python</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;译注：&lt;/strong&gt;这是一篇在&lt;a href=&quot;http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python&quot;&gt;Stack overflow&lt;/a&gt;上很热的帖子。提问者自称已经掌握了有关Python OOP编程中的各种概念，但始终觉得元类(metaclass)难以理解。他知道这肯定和自省有关，但仍然觉得不太明白，希望大家可以给出一些实际的例子和代码片段以帮助理解，以及在什么情况下需要进行元编程。于是e-satis同学给出了神一般的回复，该回复获得了985点的赞同点数，更有人评论说这段回复应该加入到Python的官方文档中去。而e-satis同学本人在Stack Overflow中的声望积分也高达64271分。以下就是这篇精彩的回复（提示：非常长）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/python-icon.jpg&quot; title=&quot;python-icon&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/python-icon.jpg&quot; title=&quot;python-icon&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类也是对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在理解元类之前，你需要先掌握Python中的类。Python中类的概念借鉴于Smalltalk，这显得有些奇特。在大多数&lt;a href=&quot;http://blog.jobbole.com/tag/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/&quot; title=&quot;如何选择语言和编程语言排名相关文章&quot;&gt;编程语言&lt;/a&gt;中，类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class ObjectCreator(object):
…       pass
…
&amp;gt;&amp;gt;&amp;gt; my_object = ObjectCreator()
&amp;gt;&amp;gt;&amp;gt; print my_object
&amp;lt;__main__.ObjectCreator object at 0x8974f2c&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，Python中的类还远不止如此。类同样也是一种对象。是的，没错，就是对象。只要你使用关键字class，Python解释器在执行的时候就会创建一个对象。下面的代码段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class ObjectCreator(object):
…       pass
…
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将在内存中创建一个对象，名字就是ObjectCreator。&lt;strong&gt;这个对象（类）自身拥有创建对象（类实例）的能力，而这就是为什么它是一个类的原因。&lt;/strong&gt;但是，它的本质仍然是一个对象，于是乎你可以对它做如下的操作：&lt;/p&gt;

&lt;p&gt;​1)   你可以将它赋值给一个变量&lt;/p&gt;

&lt;p&gt;​2)   你可以拷贝它&lt;/p&gt;

&lt;p&gt;​3)   你可以为它增加属性&lt;/p&gt;

&lt;p&gt;​4)   你可以将它作为函数参数进行传递&lt;/p&gt;

&lt;p&gt;下面是示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print ObjectCreator     # 你可以打印一个类，因为它其实也是一个对象
&amp;lt;class '__main__.ObjectCreator'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; def echo(o):
…       print o
…
&amp;gt;&amp;gt;&amp;gt; echo(ObjectCreator)                 # 你可以将类做为参数传给函数
&amp;lt;class '__main__.ObjectCreator'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print hasattr(ObjectCreator, 'new_attribute')
Fasle
&amp;gt;&amp;gt;&amp;gt; ObjectCreator.new_attribute = 'foo' #  你可以为类增加属性
&amp;gt;&amp;gt;&amp;gt; print hasattr(ObjectCreator, 'new_attribute')
True
&amp;gt;&amp;gt;&amp;gt; print ObjectCreator.new_attribute
foo
&amp;gt;&amp;gt;&amp;gt; ObjectCreatorMirror = ObjectCreator # 你可以将类赋值给一个变量
&amp;gt;&amp;gt;&amp;gt; print ObjectCreatorMirror()
&amp;lt;__main__.ObjectCreator object at 0x8997b4c&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;动态地创建类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。首先，你可以在函数中创建类，使用class关键字即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def choose_class(name):
…       if name == 'foo':
…           class Foo(object):
…               pass
…           return Foo     # 返回的是类，不是类的实例
…       else:
…           class Bar(object):
…               pass
…           return Bar
…
&amp;gt;&amp;gt;&amp;gt; MyClass = choose_class('foo')
&amp;gt;&amp;gt;&amp;gt; print MyClass              # 函数返回的是类，不是类的实例
&amp;lt;class '__main__'.Foo&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print MyClass()            # 你可以通过这个类创建类实例，也就是对象
&amp;lt;__main__.Foo object at 0x89c6d4c&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是通过什么东西来生成的才对。当你使用class关键字时，Python解释器自动创建这个对象。但就和Python中的大多数事情一样，Python仍然提供给你手动处理的方法。还记得内建函数type吗？这个古老但强大的函数能够让你知道一个对象的类型是什么，就像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print type(1)
&amp;lt;type 'int'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print type(&quot;1&quot;)
&amp;lt;type 'str'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print type(ObjectCreator)
&amp;lt;type 'type'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print type(ObjectCreator())
&amp;lt;class '__main__.ObjectCreator'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，type有一种完全不同的能力，它也能动态的创建类。type可以接受一个类的描述作为参数，然后返回一个类。（我知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性）&lt;/p&gt;

&lt;p&gt;type可以像这样工作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class MyShinyClass(object):
…       pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以手动像这样创建：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; MyShinyClass = type('MyShinyClass', (), {})  # 返回一个类对象
&amp;gt;&amp;gt;&amp;gt; print MyShinyClass
&amp;lt;class '__main__.MyShinyClass'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print MyShinyClass()  #  创建一个该类的实例
&amp;lt;__main__.MyShinyClass object at 0x8997cec&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你会发现我们使用“MyShinyClass”作为类名，并且也可以把它当做一个变量来作为类的引用。类和变量是不同的，这里没有任何理由把事情弄的复杂。&lt;/p&gt;

&lt;p&gt;type 接受一个字典来为类定义属性，因此&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Foo(object):
…       bar = True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以翻译为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Foo = type('Foo', (), {'bar':True})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并且可以将Foo当成一个普通的类一样使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print Foo
&amp;lt;class '__main__.Foo'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print Foo.bar
True
&amp;gt;&amp;gt;&amp;gt; f = Foo()
&amp;gt;&amp;gt;&amp;gt; print f
&amp;lt;__main__.Foo object at 0x8a9b84c&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print f.bar
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，你可以向这个类继承，所以，如下的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class FooChild(Foo):
…       pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以写成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; FooChild = type('FooChild', (Foo,),{})
&amp;gt;&amp;gt;&amp;gt; print FooChild
&amp;lt;class '__main__.FooChild'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print FooChild.bar   # bar属性是由Foo继承而来
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终你会希望为你的类增加方法。只需要定义一个有着恰当签名的函数并将其作为属性赋值就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def echo_bar(self):
…       print self.bar
…
&amp;gt;&amp;gt;&amp;gt; FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})
&amp;gt;&amp;gt;&amp;gt; hasattr(Foo, 'echo_bar')
False
&amp;gt;&amp;gt;&amp;gt; hasattr(FooChild, 'echo_bar')
True
&amp;gt;&amp;gt;&amp;gt; my_foo = FooChild()
&amp;gt;&amp;gt;&amp;gt; my_foo.echo_bar()
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以看到，在Python中，类也是对象，你可以动态的创建类。这就是当你使用关键字class时Python在幕后做的事情，而这就是通过元类来实现的。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;到底什么是元类（终于到主题了）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;元类就是用来创建类的“东西”。你创建类就是为了创建类的实例对象，不是吗？但是我们已经学习到了Python中的类也是对象。好吧，元类就是用来创建这些类（对象）的，元类就是类的类，你可以这样理解为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyClass = MetaClass()
MyObject = MyClass()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你已经看到了type可以让你像这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyClass = type('MyClass', (), {})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类。现在你想知道那为什么type会全部采用小写形式而不是Type呢？好吧，我猜这是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。你可以通过检查__class__属性来看到这一点。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; age = 35
&amp;gt;&amp;gt;&amp;gt; age.__class__
&amp;lt;type 'int'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; name = 'bob'
&amp;gt;&amp;gt;&amp;gt; name.__class__
&amp;lt;type 'str'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; def foo(): pass
&amp;gt;&amp;gt;&amp;gt;foo.__class__
&amp;lt;type 'function'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; class Bar(object): pass
&amp;gt;&amp;gt;&amp;gt; b = Bar()
&amp;gt;&amp;gt;&amp;gt; b.__class__
&amp;lt;class '__main__.Bar'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，对于任何一个__class__的__class__属性又是什么呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a.__class__.__class__
&amp;lt;type 'type'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; age.__class__.__class__
&amp;lt;type 'type'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; foo.__class__.__class__
&amp;lt;type 'type'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; b.__class__.__class__
&amp;lt;type 'type'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此，元类就是创建类这种对象的东西。如果你喜欢的话，可以把元类称为“类工厂”（不要和工厂类搞混了:D）
type就是Python的内建元类，当然了，你也可以创建自己的元类。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;__metaclass__&lt;/strong&gt;&lt;strong&gt;属性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你可以在写一个类的时候为其添加__metaclass__属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Foo(object):
    __metaclass__ = something…
[…]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你这么做了，Python就会用元类来创建类Foo。小心点，这里面有些技巧。你首先写下class Foo(object)，但是类对象Foo还没有在内存中创建。Python会在类的定义中寻找__metaclass__属性，如果找到了，Python就会用它来创建类Foo，如果没有找到，就会用内建的type来创建这个类。把下面这段话反复读几次。当你写如下代码时:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Foo(Bar):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python做了如下的操作：&lt;/p&gt;

&lt;p&gt;Foo中有__metaclass__这个属性吗？如果是，Python会在内存中通过__metaclass__创建一个名字为Foo的类对象（我说的是类对象，请紧跟我的思路）。如果Python没有找到__metaclass__，它会继续在Bar（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作。如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象。&lt;/p&gt;

&lt;p&gt;现在的问题就是，你可以在__metaclass__中放置些什么代码呢？答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东东都可以。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;自定义元类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;元类的主要目的就是为了当创建类时能够自动地改变类。通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类。假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。有好几种方法可以办到，但其中一种就是通过在模块级别设定__metaclass__。采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。&lt;/p&gt;

&lt;p&gt;幸运的是，__metaclass__实际上可以被任意调用，它并不需要是一个正式的类（我知道，某些名字里带有‘class’的东西并不需要是一个class，画画图理解下，这很有帮助）。所以，我们这里就先以一个简单的函数作为例子开始。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 元类会自动将你通常传给‘type’的参数作为自己的参数传入
def upper_attr(future_class_name, future_class_parents, future_class_attr):
    '''返回一个类对象，将属性都转为大写形式'''
    #  选择所有不以'__'开头的属性
    attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))

    # 将它们转为大写形式
    uppercase_attr = dict((name.upper(), value) for name, value in attrs)

    # 通过'type'来做类对象的创建
    return type(future_class_name, future_class_parents, uppercase_attr)

__metaclass__ = upper_attr  #  这会作用到这个模块中的所有类

class Foo(object):
    # 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中
    bar = 'bip'

print hasattr(Foo, 'bar')
# 输出: False
print hasattr(Foo, 'BAR')
# 输出:True

f = Foo()
print f.BAR
# 输出:'bip'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在让我们再做一次，这一次用一个真正的class来当做元类。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 请记住，'type'实际上是一个类，就像'str'和'int'一样
# 所以，你可以从type继承
class UpperAttrMetaClass(type):
    # __new__ 是在__init__之前被调用的特殊方法
    # __new__是用来创建对象并返回之的方法
    # 而__init__只是用来将传入的参数初始化给对象
    # 你很少用到__new__，除非你希望能够控制对象的创建
    # 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__
    # 如果你希望的话，你也可以在__init__中做些事情
    # 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用
    def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr):
        attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))
        uppercase_attr = dict((name.upper(), value) for name, value in attrs)
        return type(future_class_name, future_class_parents, uppercase_attr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，这种方式其实不是OOP。我们直接调用了type，而且我们没有改写父类的__new__方法。现在让我们这样去处理:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class UpperAttrMetaclass(type):
    def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr):
        attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))
        uppercase_attr = dict((name.upper(), value) for name, value in attrs)

        # 复用type.__new__方法
        # 这就是基本的OOP编程，没什么魔法
        return type.__new__(upperattr_metaclass, future_class_name, future_class_parents, uppercase_attr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能已经注意到了有个额外的参数upperattr_metaclass，这并没有什么特别的。类方法的第一个参数总是表示当前的实例，就像在普通的类方法中的self参数一样。当然了，为了清晰起见，这里的名字我起的比较长。但是就像self一样，所有的参数都有它们的传统名称。因此，在真实的产品代码中一个元类应该是像这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class UpperAttrMetaclass(type):
    def __new__(cls, name, bases, dct):
        attrs = ((name, value) for name, value in dct.items() if not name.startswith('__')
        uppercase_attr  = dict((name.upper(), value) for name, value in attrs)
        return type.__new__(cls, name, bases, uppercase_attr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用super方法的话，我们还可以使它变得更清晰一些，这会缓解继承（是的，你可以拥有元类，从元类继承，从type继承）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class UpperAttrMetaclass(type):
    def __new__(cls, name, bases, dct):
        attrs = ((name, value) for name, value in dct.items() if not name.startswith('__'))
        uppercase_attr = dict((name.upper(), value) for name, value in attrs)
        return super(UpperAttrMetaclass, cls).__new__(cls, name, bases, uppercase_attr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是这样，除此之外，关于元类真的没有别的可说的了。使用到元类的代码比较复杂，这背后的原因倒并不是因为元类本身，而是因为你通常会使用元类去做一些晦涩的事情，依赖于自省，控制继承等等。确实，用元类来搞些“黑暗魔法”是特别有用的，因而会搞出些复杂的东西来。但就元类本身而言，它们其实是很简单的：&lt;/p&gt;

&lt;p&gt;​1)   拦截类的创建&lt;/p&gt;

&lt;p&gt;​2)   修改类&lt;/p&gt;

&lt;p&gt;​3)   返回修改之后的类&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么要用metaclass类而不是函数?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于__metaclass__可以接受任何可调用的对象，那为何还要使用类呢，因为很显然使用类会更加复杂啊？这里有好几个原因：&lt;/p&gt;

&lt;p&gt;1） 意图会更加清晰。当你读到UpperAttrMetaclass(type)时，你知道接下来要发生什么。&lt;/p&gt;

&lt;p&gt;2） 你可以使用OOP编程。元类可以从元类中继承而来，改写父类的方法。元类甚至还可以使用元类。&lt;/p&gt;

&lt;p&gt;3） 你可以把代码组织的更好。当你使用元类的时候肯定不会是像我上面举的这种简单场景，通常都是针对比较复杂的问题。将多个方法归总到一个类中会很有帮助，也会使得代码更容易阅读。&lt;/p&gt;

&lt;p&gt;4） 你可以使用__new__,__init__以及__call__这样的特殊方法。它们能帮你处理不同的任务。就算通常你可以把所有的东西都在__new__里处理掉，有些人还是觉得用__init__更舒服些。&lt;/p&gt;

&lt;p&gt;5） 哇哦，这东西的名字是metaclass，肯定非善类，我要小心！&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;究竟为什么要使用元类？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，你根本就用不上它：&lt;/p&gt;

&lt;p&gt;“元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。” —— Python界的领袖 Tim Peters&lt;/p&gt;

&lt;p&gt;元类的主要用途是创建API。一个典型的例子是&lt;a href=&quot;http://blog.jobbole.com/15555/&quot; title=&quot;10个实用的Django建议&quot;&gt;Django&lt;/a&gt;ORM。它允许你像这样定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Person(models.Model):
    name = models.CharField(max_length=30)
    age = models.IntegerField()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果你像这样做的话：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;guy  = Person(name='bob', age='35')
print guy.age
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这并不会返回一个IntegerField对象，而是会返回一个int，甚至可以直接从数据库中取出数据。这是有可能的，因为models.Model定义了__metaclass__，并且使用了一些魔法能够将你刚刚定义的简单的Person类转变成对数据库的一个复杂hook。Django框架将这些看起来很复杂的东西通过暴露出一个简单的使用元类的API将其化简，通过这个API重新创建代码，在背后完成真正的工作。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，你知道了类其实是能够创建出类实例的对象。好吧，事实上，类本身也是实例，当然，它们是元类的实例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;class Foo(object): pass
&amp;gt;&amp;gt;&amp;gt; id(Foo)
142630324
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类，在纯Python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。其次，元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类：&lt;/p&gt;

&lt;p&gt;1） &lt;a href=&quot;http://en.wikipedia.org/wiki/Monkey_patch&quot;&gt;Monkey patching&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;​2） class decorators&lt;/p&gt;

&lt;p&gt;当你需要动态修改类时，99%的时间里你最好使用上面这两种技术。当然了，其实在99%的时间里你根本就不需要动态修改类&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;英文原文：&lt;a href=&quot;http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python&quot;&gt;Stack Overflow&lt;/a&gt;   编译：&lt;a href=&quot;http://www.jobbole.com/&quot;&gt;伯乐&lt;/a&gt;在线— &lt;a href=&quot;http://blog.jobbole.com/21351/&quot;&gt;陈舸&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>jQuery选择器大全</title>
   <link href="http://beango.github.com/archives/2012/06/07/jquery-selector.html"/>
   <updated>2012-06-07T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/06/07/jquery-selector</id>
   <content type="html">&lt;p&gt;选择器是jQuery最基础的东西，本文中列举的选择器基本上囊括了所有的jQuery选择器，也许各位通过这篇文章能够加深对jQuery选择器的理解，它们本身用法就非常简单，我更希望的是它能够提升个人编写jQuery代码的效率。本文配合截图、代码和简单的概括对所有jQuery选择器进行了介绍，也列举出了一些需要注意和区分的地方。&lt;/p&gt;

&lt;h3&gt;一、基本选择器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;id选择器（指定id元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;将id=&quot;one&quot;的元素背景色设置为黑色。（id选择器返单个元素）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {  
    $('#one').css('background', '#000');  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;class选择器（遍历css类元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;将class=&quot;cube&quot;的元素背景色设为黑色&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {  
    $('.cube').css('background', '#000');  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;element选择器（遍历html元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;将p元素的文字大小设置为12px&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {  
    $('p').css('font-size', '12px');  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;* 选择器（遍历所有元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;遍历form下的所有元素，将字体颜色设置为红色&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {  
    $('form *').css('color', '#FF0000');  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;并列选择器&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;将p元素和div元素的margin设为0&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {  
    $('p, div').css('margin', '0');  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;二、 层次选择器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;parent &gt; child（直系子元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;选取div下的第一代span元素，将字体颜色设为红色&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {  
    $('div &amp;gt; span').css('color', '#FF0000');  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的代码，只有第一个span会变色，第二个span不属于div的一代子元素，颜色保持不变。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;  
    &amp;lt;span&amp;gt;123&amp;lt;/span&amp;gt;  
    &amp;lt;p&amp;gt;  
        &amp;lt;span&amp;gt;456&amp;lt;/span&amp;gt;  
    &amp;lt;/p&amp;gt;  
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;prev + next（下一个兄弟元素，等同于next()方法）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;选取class为item的下一个div兄弟元素，两种写法都可以&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {  
    $('.item + div').css('color', '#FF0000');  
    $('.item').next('div').css('color', '#FF0000');  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的代码，只有123和789会变色&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p class=&quot;item&quot;&amp;gt;&amp;lt;/p&amp;gt;  
&amp;lt;div&amp;gt;123&amp;lt;/div&amp;gt;  
&amp;lt;div&amp;gt;456&amp;lt;/div&amp;gt;  
&amp;lt;span class=&quot;item&quot;&amp;gt;&amp;lt;/span&amp;gt;  
&amp;lt;div&amp;gt;789&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;prev ~ siblings（prev元素的所有兄弟元素，等同于nextAll()方法）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;选取class为inside之后的所有div兄弟元素，两种写法都可以&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {  
    $('.inside ~ div').css('color', '#FF0000');  
    $('.inside').nextAll('div').css('color', '#FF0000');  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的代码，G2和G4会变色&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;inside&quot;&amp;gt;G1&amp;lt;/div&amp;gt;  
&amp;lt;div&amp;gt;G2&amp;lt;/div&amp;gt;  
&amp;lt;span&amp;gt;G3&amp;lt;/span&amp;gt;  
&amp;lt;div&amp;gt;G4&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;三、 过滤选择器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;:first和:last（取第一个元素或最后一个元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {  
    $('span:first').css('color', '#FF0000');  
    $('span:last').css('color', '#FF0000');  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的代码，G1（first元素）和G3（last元素）会变色&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span&amp;gt;G1&amp;lt;/span&amp;gt;  
&amp;lt;span&amp;gt;G2&amp;lt;/span&amp;gt;  
&amp;lt;span&amp;gt;G3&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;:not（取非元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {  
    $('div:not(.wrap)').css('color', '#FF0000');  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的代码，G1会变色&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;G1&amp;lt;/div&amp;gt;  
&amp;lt;div class=&quot;wrap&quot;&amp;gt;G2&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，请注意下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;  
    G1  
    &amp;lt;div class=&quot;wrap&quot;&amp;gt;G2&amp;lt;/div&amp;gt;  
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当G1所在div和G2所在div是父子关系时，G1和G2都会变色。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:even和:odd（取偶数索引或奇数索引元素，索引从0开始，even表示偶数，odd表示奇数）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {  
    $('tr:even').css('background', '#EEE'); // 偶数行颜色  
    $('tr:odd').css('background', '#DADADA'); // 奇数行颜色  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A、C行颜色#EEE（第一行的索引为0），B、D行颜色#DADADA&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/201206022030141021.png&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/201206022030155067.png&quot; title=&quot;image&quot; alt=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;table width=&quot;200&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&amp;gt;  
    &amp;lt;tbody&amp;gt;  
        &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;A&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;  
        &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;B&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;  
        &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;C&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;  
        &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;D&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;  
    &amp;lt;/tbody&amp;gt;  
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;:eq(x) （取指定索引的元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/201206022030158348.png&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/201206022030166854.png&quot; title=&quot;image&quot; alt=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {  
    $('tr:eq(2)').css('background', '#FF0000');  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更改第三行的背景色，在上面的代码中C的背景会变色。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:gt(x)和:lt(x)（取大于x索引或小于x索引的元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {  
    $('ul li:gt(2)').css('color', '#FF0000');  
    $('ul li:lt(2)').css('color', '#0000FF');  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L4和L5会是红色，L1和L2会是蓝色，L3是默认颜色&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/201206022030173723.png&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/201206022030182228.png&quot; title=&quot;image&quot; alt=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;  
    &amp;lt;li&amp;gt;L1&amp;lt;/li&amp;gt;  
    &amp;lt;li&amp;gt;L2&amp;lt;/li&amp;gt;  
    &amp;lt;li&amp;gt;L3&amp;lt;/li&amp;gt;  
    &amp;lt;li&amp;gt;L4&amp;lt;/li&amp;gt;  
    &amp;lt;li&amp;gt;L5&amp;lt;/li&amp;gt;  
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;:header（取H1~H6标题元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {  
    $(':header').css('background', '#EFEFEF');  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的代码，H1~H6的背景色都会变&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/201206022030191573.png&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/20120602203020917.png&quot; title=&quot;image&quot; alt=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;H1&amp;lt;/h1&amp;gt;  
&amp;lt;h2&amp;gt;H2&amp;lt;/h2&amp;gt;  
&amp;lt;h3&amp;gt;H3&amp;lt;/h3&amp;gt;  
&amp;lt;h4&amp;gt;H4&amp;lt;/h4&amp;gt;  
&amp;lt;h5&amp;gt;H5&amp;lt;/h5&amp;gt;  
&amp;lt;h6&amp;gt;H6&amp;lt;/h6&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;:contains(text)（取包含text文本的元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {  
    //dd元素中包含&quot;jQuery&quot;文本的会变色  
    $('dd:contains(&quot;jQuery&quot;)').css('color', '#FF0000');  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的代码，第二个dd会变色&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dl&amp;gt;  
    &amp;lt;dt&amp;gt;技术&amp;lt;/dt&amp;gt;  
    &amp;lt;dd&amp;gt;jQuery, .NET, CLR&amp;lt;/dd&amp;gt;  
    &amp;lt;dt&amp;gt;SEO&amp;lt;/dt&amp;gt;  
    &amp;lt;dd&amp;gt;关键字排名&amp;lt;/dd&amp;gt;  
    &amp;lt;dt&amp;gt;其他&amp;lt;/dt&amp;gt;  
    &amp;lt;dd&amp;gt;&amp;lt;/dd&amp;gt;  
&amp;lt;/dl&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;:empty（取不包含子元素或文本为空的元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {  
    $('dd:empty').html('没有内容');  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;:has(selector)（取选择器匹配的元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {  
    //为包含span元素的div添加边框  
    $('div:has(span)').css('border', '1px solid #000');  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即使span不是div的直系子元素，也会生效&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/20120602203024488.png&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/201206022030258994.png&quot; title=&quot;image&quot; alt=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;  
    &amp;lt;h2&amp;gt;  
        A  
        &amp;lt;span&amp;gt;B&amp;lt;/span&amp;gt;  
    &amp;lt;/h2&amp;gt;  
&amp;lt;/div&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;:parent（取包含子元素或文本的元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function () {  
    $('ol li:parent').css('border', '1px solid #000');  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的代码，A和D所在的li会有边框&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/201206022030269451.png&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/201206022030266320.png&quot; title=&quot;image&quot; alt=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ol&amp;gt;  
    &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;  
    &amp;lt;li&amp;gt;A&amp;lt;/li&amp;gt;  
    &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;  
    &amp;lt;li&amp;gt;D&amp;lt;/li&amp;gt;  
&amp;lt;/ol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;:hidden（取不可见的元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;jQuery至1.3.2之后的:hidden选择器仅匹配display:none或&amp;lt;input type=&quot;hidden&quot; /&gt;的元素，而不匹配visibility:hidden或opacity:0的元素。这也意味着hidden只匹配那些“隐藏的”并且不占空间的元素，像visibility:hidden或opactity:0的元素占据了空间，会被排除在外。&lt;/p&gt;

&lt;p&gt;参照：&lt;a href=&quot;http://www.jquerysdk.com/api/hidden-selector&quot;&gt;http://www.jquerysdk.com/api/hidden-selector&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面的代码，先弹出&quot;hello&quot;对话框，然后hid-1会显示，hid-2仍然是不可见的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/2012060220302892.png&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/201206022030299088.png&quot; title=&quot;image&quot; alt=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;  
&amp;lt;head runat=&quot;server&quot;&amp;gt;  
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;  
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;  
        div{  
            margin: 10px;  
            width: 200px;  
            height: 40px;  
            border: 1px solid #FF0000;  
            display:block;  
        }  
        .hid-1{  
            display: none;  
        }  
        .hid-2{  
            visibility: hidden;  
        }  
    &amp;lt;/style&amp;gt;  
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;  
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
        $(document).ready(function() {  
            $('div:hidden').show(500);  
            alert($('input:hidden').val());  
        });  
    &amp;lt;/script&amp;gt;  
&amp;lt;/head&amp;gt;  
&amp;lt;body&amp;gt;  
    &amp;lt;div class=&quot;hid-1&quot;&amp;gt;display: none&amp;lt;/div&amp;gt;  
    &amp;lt;div class=&quot;hid-2&quot;&amp;gt;visibility: hidden&amp;lt;/div&amp;gt;  
    &amp;lt;input type=&quot;hidden&quot; value=&quot;hello&quot;/&amp;gt;  
&amp;lt;/body&amp;gt;  
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;:visible（取可见的元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;下面的代码，最后一个div会有背景色&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-06/201206022030314463.png&quot; title=&quot;image&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
    $(document).ready(function() {  
        $('div:visible').css('background', '#EEADBB');  
    });  
&amp;lt;/script&amp;gt;  
&amp;lt;div class=&quot;hid-1&quot;&amp;gt;display: none&amp;lt;/div&amp;gt;  
&amp;lt;div class=&quot;hid-2&quot;&amp;gt;visibility: hidden&amp;lt;/div&amp;gt;  
&amp;lt;input type=&quot;hidden&quot; value=&quot;hello&quot;/&amp;gt;  
&amp;lt;div&amp;gt;  
    jQuery选择器大全  
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4. 属性过滤选择器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;[attribute]（取拥有attribute属性的元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;下面的代码，最后一个a标签没有title属性，所以它仍然会带下划线&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/201206022030329347.png&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/20120602203033643.png&quot; title=&quot;image&quot; alt=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(document).ready(function() {
        $('a[title]').css('text-decoration', 'none');
    });
&amp;lt;/script&amp;gt;       
&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; title=&quot;DOM对象和jQuery对象&quot; class=&quot;item&quot;&amp;gt;DOM对象和jQuery对象&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; title=&quot;jQuery选择器大全&quot; class=&quot;item-selected&quot;&amp;gt;jQuery选择器大全&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; title=&quot;jQuery事件大全&quot; class=&quot;item&quot;&amp;gt;jQuery事件大全&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; title=&quot;基于jQuery的插件开发&quot; class=&quot;item&quot;&amp;gt;基于jQuery的插件开发&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; title=&quot;Wordpress &amp;amp; jQuery&quot; class=&quot;item&quot;&amp;gt;Wordpress &amp;amp; jQuery&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; class=&quot;item&quot;&amp;gt;其他&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;[attribute = value]和[attribute != value]（取attribute属性值等于value或不等于value的元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;分别为class=&quot;item&quot;和class!=item的a标签指定文字颜色&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/201206022030343576.png&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/201206022030352921.png&quot; title=&quot;image&quot; alt=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(document).ready(function() {
        $('a[class=item]').css('color', '#FF99CC');
        $('a[class!=item]').css('color', '#FF6600');
    });
&amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;[attribute ^= value], [attribute $= value]和[attribute *= value]（attribute属性值以value开始，以value结束，或包含value值）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在属性选择器中，&lt;sup&gt;$符号和正则表达式的开始结束符号表示的含义是一致的，*模糊匹配，类似于sql中的like'%str%'。&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/201206022030364217.png&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/201206022030377150.png&quot; title=&quot;image&quot; alt=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    // 识别大小写，输入字符串时可以输入引号，[title^=jQuery]和[title^=&quot;jQuery&quot;]是一样的
    $('a[title^=jQuery]').css('font-weight', 'bold');
    $('a[title$=jQuery]').css('font-size', '24px');
    $('a[title*=jQuery]').css('text-decoration', 'line-through');
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;[selector1][selector2]（复合型属性过滤器，同时满足多个条件）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;将title以&quot;jQuery&quot;开始，并且class=&quot;item&quot;的a标签隐藏，那么&amp;lt;a href=&quot;#&quot; title=&quot;jQuery事件大全&quot; class=&quot;item&quot;&gt;jQuery事件大全&amp;lt;/a&gt;会被隐藏&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(document).ready(function() {
        $('a[title^=jQuery][class=item]').hide();
    });
&amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;5. 子元素过滤选择器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;:first-child和:last-child&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;:first-child表示第一个子元素，:last-child表示最后一个子元素。&lt;/p&gt;

&lt;p&gt;需要大家注意的是，:fisrst和:last返回的都是单个元素，而:first-child和:last-child返回的都是集合元素。举个例子：div:first返回的是整个DOM文档中第一个div元素，而div:first-child是返回所有div元素下的第一个元素合并后的集合。&lt;/p&gt;

&lt;p&gt;这里有个问题：如果一个元素没有子元素，:first-child和:last-child会返回null吗？请看下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;  
&amp;lt;head runat=&quot;server&quot;&amp;gt;  
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;  
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;  
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
    $(document).ready(function() {  
        var len1 = $('div:first-child').length;  
        var len2 = $('div:last-child').length;  
     });  
    &amp;lt;/script&amp;gt;  
&amp;lt;/head&amp;gt;  
&amp;lt;body&amp;gt;  
&amp;lt;div&amp;gt;  
    &amp;lt;div&amp;gt;  
        &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;  
    &amp;lt;/div&amp;gt;  
&amp;lt;/div&amp;gt;  
&amp;lt;/body&amp;gt;  
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也许你觉得这个答案，是不是太简单了？len1 = 2, len2 =2。但实际确并不是，它们俩都等于3。
把上面的代码稍微修改一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;  
&amp;lt;head runat=&quot;server&quot;&amp;gt;  
&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;  
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;  
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
$(document).ready(function() {  
    var len1 = $('div:first-child').length;  
    var len2 = $('div:last-child').length;  
    $('div:first-child').each(function() {  
        alert($(this).html());  
    });  
});  
&amp;lt;/script&amp;gt;  
&amp;lt;/head&amp;gt;  
&amp;lt;body&amp;gt;  
&amp;lt;div&amp;gt;123  
&amp;lt;div&amp;gt;456  
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;  
&amp;lt;/div&amp;gt;  
&amp;lt;/div&amp;gt;  
&amp;lt;/body&amp;gt;  
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果却是弹出三个alert，只不过最后一个alert里面是空白的。&lt;br/&gt;
&lt;a href=&quot;/assets/files/2012-06/201206022030416753.png&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/201206022030416753.png&quot; title=&quot;image&quot; alt=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:only-child&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;当某个元素有且仅有一个子元素时，:only-child才会生效。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;  
&amp;lt;head runat=&quot;server&quot;&amp;gt;  
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;  
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;  
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
        $(document).ready(function() {  
            $('div:only-child').css('border', '1px solid #FF0000').css('width','200px');  
        });  
    &amp;lt;/script&amp;gt;  
&amp;lt;/head&amp;gt;  
&amp;lt;body&amp;gt;  
&amp;lt;div&amp;gt;123  
    &amp;lt;div&amp;gt;456  
        &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;  
    &amp;lt;/div&amp;gt;  
&amp;lt;/div&amp;gt;  
&amp;lt;/body&amp;gt;  
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里:only-child也是三个元素，从最后一个很粗的红色边框（实际是两个元素的边框重叠了）也可以看出来。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/201206022030431539.png&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/201206022030443325.png&quot; title=&quot;image&quot; alt=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:nth-child&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;看到这个就想起英文单词里的，fourth, fifth,sixth……，nth表示第n个，:nth-child就表示第n个child元素。要注意的是，这儿的n不像eq(x)、gt(x)或lt(x)是从0开始的，它是从1开始的，英文里好像也没有zeroth这样的序号词吧。&lt;br/&gt;
:nth-child有三种用法：
1) :nth-child(x)，获取第x个子元素&lt;br/&gt;
2) :nth-child(even)和:nth-child(odd)，从1开始，获取第偶数个元素或第奇数个元素&lt;br/&gt;
​3) :nth-child(xn+y)，x&gt;=0，y&gt;=0。例如x = 3, y = 0时就是3n，表示取第3n个元素（n&gt;=0）。实际上xn+y是上面两种的通项式。（当x=0,y&gt;=0时，等同于:hth-child(x)；当x=2,y=0时，等同于nth-child(even)；当x=2,y=1时，等同于:nth-child(odd)）&lt;/p&gt;

&lt;p&gt;下面的两个例子是针对2)和3)的，1)的例子我就不列举了。&lt;/p&gt;

&lt;p&gt;例2：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/201206022030467894.png&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/201206022030482123.png&quot; title=&quot;image&quot; alt=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; &gt;
&lt;head runat=&quot;server&quot;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;style type=&quot;text/css&quot;&amp;gt;
    td {
        width: 200px;
        height: 32px;
        line-height: 32px;
    }
&amp;lt;/style&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(document).ready(function() {
        //偶数行背景红色
        $('tr:nth-child(even)').css('background', '#FF0000');
        //奇数行背景蓝色
        $('tr:nth-child(odd)').css('background', '#0000FF');
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/head&gt;
&lt;body&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1. NBA 2012季后赛&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;2. NBA 2011季后赛&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;3. NBA 2010季后赛&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;4. NBA 2009季后赛&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;5. NBA 2008季后赛&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;6. NBA 2007季后赛&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;

&lt;p&gt;例3（html代码和例2是一样的）：&lt;br/&gt;
&lt;a href=&quot;/assets/files/2012-06/201206022030495056.png&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/20120602203050812.png&quot; title=&quot;SNAGHTMLd6d414&quot; alt=&quot;SNAGHTMLd6d414&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(document).ready(function() {
        $('tr:nth-child(3n)').css('background', '#0000FF');
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;6. 表单对象属性过滤选择器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;:enabled和:disabled（取可用或不可用元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;:enabled和:diabled的匹配范围包括input, select, textarea。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/201206022030515697.png&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/20120602203052265.png&quot; title=&quot;image&quot; alt=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(document).ready(function() {
        $(':enabled').css('border', '1px solid #FF0000');
        $(':disabled').css('border', '1px solid #0000FF');
    });
&amp;lt;/script&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;input type=&quot;text&quot; value=&quot;可用的文本框&quot; /&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;input type=&quot;text&quot; disabled=&quot;disabled&quot; value=&quot;不可用的文本框&quot; /&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;textarea disabled=&quot;disabled&quot;&amp;gt;不可用的文本域&amp;lt;/textarea&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;select disabled=&quot;disabled&quot;&amp;gt;
        &amp;lt;option&amp;gt;English&amp;lt;/option&amp;gt;
        &amp;lt;option&amp;gt;简体中文&amp;lt;/option&amp;gt;
    &amp;lt;/select&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;:checked（取选中的单选框或复选框元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;下面的代码，更改边框或背景色仅在IE下有效果，chrome和firefox不会改变，但是alert都会弹出来。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/201206022030537974.png&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/20120602203054906.png&quot; title=&quot;image&quot; alt=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(document).ready(function() {
        $(':checked').css('background', '#FF0000').each(function() {
            alert($(this).val());
        });
    });
&amp;lt;/script&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; value=&quot;must&quot;/&amp;gt;必须勾选
&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;
你现在工作的企业属于：
    &amp;lt;input type=&quot;radio&quot; name=&quot;radio&quot; checked=&quot;checked&quot; value=&quot;外企&quot;/&amp;gt;外企
    &amp;lt;input type=&quot;radio&quot; name=&quot;radio&quot; value=&quot;国企&quot;/&amp;gt;国企
    &amp;lt;input type=&quot;radio&quot; name=&quot;radio&quot; value=&quot;民企&quot;/&amp;gt;民企
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;:selected（取下拉列表被选中的元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/201206022030566281.png&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/2012060220305753.png&quot; title=&quot;SNAGHTML14414ae&quot; alt=&quot;SNAGHTML14414ae&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    $(document).ready(function() {
        alert($(':selected').val());
    });
&amp;lt;/script&amp;gt;
&amp;lt;select&amp;gt;
    &amp;lt;option value=&quot;外企&quot;&amp;gt;外企&amp;lt;/option&amp;gt;
    &amp;lt;option value=&quot;国企&quot;&amp;gt;国企&amp;lt;/option&amp;gt;
    &amp;lt;option value=&quot;私企&quot;&amp;gt;私企&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;四、表单选择器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;:input（取input,textarea,select,button元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;:input元素这里就不再多说了，前面的一些例子中也已经囊括了。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:text（取单行文本框元素）和:password（取密码框元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这两个选择器分别和属性选择器$('input[type=text]')、$('input[type=password]')等同。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/201206022030582985.png&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/201206022030599506.png&quot; title=&quot;image&quot; alt=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
   $(document).ready(function() {
        $(':text').css('border', '1px solid #FF0000');
        $(':password').css('border', '1px solid #0000FF');

        // 等效代码
        //$('input[type=text]').css('border', '1px solid #FF0000');
        //$('input[type=password]').css('border', '1px solid #0000FF');
   });
&amp;lt;/script&amp;gt;
&amp;lt;fieldset style=&quot;width: 300px;&quot;&amp;gt;
    &amp;lt;legend&amp;gt;账户登录&amp;lt;/legend&amp;gt;
     &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;用户名：&amp;lt;/label&amp;gt;&amp;lt;input type=&quot;text&quot;/&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;密&amp;amp;nbsp;&amp;amp;nbsp;码：&amp;lt;/label&amp;gt;&amp;lt;input type=&quot;password&quot;/&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/fieldset&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;:radio（取单选框元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;:radio选择器和属性选择器$('input[type=radio]')等同&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
$(document).ready(function() {
    $(':radio').each(function() {
        alert($(this).val());
    });
    // 等效代码
    $('input[type=radio]').each(function() {
        alert($(this).val());
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你现在工作的企业属于：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&quot;radio&quot; name=&quot;radio&quot; checked=&quot;checked&quot; value=&quot;外企&quot;/&amp;gt;外企
&amp;lt;input type=&quot;radio&quot; name=&quot;radio&quot; value=&quot;国企&quot;/&amp;gt;国企
&amp;lt;input type=&quot;radio&quot; name=&quot;radio&quot; value=&quot;民企&quot;/&amp;gt;民企
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;:checkbox（取复选框元素）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;:checkbox选择器和属性选择器$('input[type=checkbox]')等同&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
$(document).ready(function() {
    $(':checkbox').each(function() {
        alert($(this).val());
    });
    // 等效代码
    $('input[type=checkbox]').each(function() {
        alert($(this).val());
    });
});
&amp;lt;/script&amp;gt;
您的兴趣爱好：
&amp;lt;input type=&quot;checkbox&quot; /&amp;gt;游泳
&amp;lt;input type=&quot;checkbox&quot; /&amp;gt;看书
&amp;lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; value=&quot;打篮球&quot;/&amp;gt;打篮球
&amp;lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; value=&quot;电脑游戏&quot;/&amp;gt;电脑游戏
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码，会将所有额checkbox的value输出出来。若你想选择选中项，有三种写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(':checkbox:checked').each(function() {
    alert($(this).val());
});

$('input[type=checkbox][checked]').each(function() {
    alert($(this).val());
});

$(':checked').each(function() {
    alert($(this).val());
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;:submit（取提交按钮元素）&lt;br/&gt;
:submit选择器和属性选择器$('input[type=submit]')等同&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;:reset（取重置按钮元素）&lt;br/&gt;
:reset选择器和属性选择器$('input[type=reset]')等同&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;:button（取按钮元素）&lt;br/&gt;
:button选择器和属性选择器$('input[type=button]')等同&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;:file（取上传域元素）&lt;br/&gt;
:file选择器和属性选择器$('input[type=file]')等同&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;:hidden（取不可见元素）&lt;br/&gt;
:hidden选择器和属性选择器$('input[type=hidden]')等同&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>如何绘制业务流程图(一)</title>
   <link href="http://beango.github.com/archives/2012/06/03/how-to-draw-business-process-diagrams-1.html"/>
   <updated>2012-06-03T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/06/03/how-to-draw-business-process-diagrams-1</id>
   <content type="html">&lt;p&gt;来源：&lt;a href=&quot;http://heidixie.blog.sohu.com/219290540.html&quot;&gt;heidixie 的博客&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;前言：近来一段时间，忙于整理业务流程图，期间，关于流程图的绘制方法和工具也与内部团队和外部做了心得交流，恰好，个人生活也牵涉在买房，婚礼，户口迁移等流程中。不知不觉，伴随着实践与反思，个人所得的系统知识趋于完整，今儿天气极好，坐在飘窗一隅，听着间或几声鸟鸣歌唱，偶尔瞥一眼窗外的遍地绿荫，真真觉得是个写点什么的日子。所以就整理成文，如果恰好对你有所帮助，那是真真好的。&lt;/p&gt;

&lt;p&gt;真实整理的流程牵涉到公司未公布的计划，不好公开，所以在本文中会借助一个简单的案例替代（这个案例呢，也就是计划写本文前30分分钟才想到的，如有考虑不周，请各位见谅），但是仅传达概念和方法，倒也足够了。恩，甄環体告一段落，咱们开始吧。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams1.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams1.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图1：用即时贴与白板做的简单流程图&lt;/p&gt;

&lt;p&gt;本文会包含几块内容：&lt;/p&gt;

&lt;p&gt;​1.什么是流程图？流程图和其他图表（如线框图，概念图，架构图，用例图）有什么不同？&lt;/p&gt;

&lt;p&gt;​2. 为什么需要流程图？&lt;/p&gt;

&lt;p&gt;​3. 流程图的分类？&lt;/p&gt;

&lt;p&gt;​4. 如何绘制流程图？&lt;/p&gt;

&lt;p&gt;​5. 流程图绘制工具&lt;/p&gt;

&lt;p&gt;视篇幅情况，会在行文时略加划分为系列，敬请关注并多多交流。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一部分：什么是流程图？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 定义&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;了解一个事情，我习惯从它的定义开始。至于为什么，可以参见我之前的博客文章：http://heidixie.blog.sohu.com/161709085.html&lt;/p&gt;

&lt;p&gt;我们因为厌恶十年教育，厌恶背各种定理和定义，所以我发现生活中和工作中很多人都很讨厌给一个事情下定义以及去参考定义。所以你会发现很多人在一起争吵得不可开交，仔细去听，原来是鸡同鸭讲，根本不在一个频道上。对于一个事情的描述，没有一个共同的语言，没有所谓的术语。有定义很好办，你们共同引用一个定义，发现定义有问题，OK，去补充这个定义，并扩展到更多的人群。&lt;strong&gt;当然，任何事情&lt;a href=&quot;http://www.amazon.cn/gp/product/B004JMZNYS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=B004JMZNYS&amp;amp;linkCode=as2&amp;amp;tag=vastwork-23&quot; title=&quot;过犹不及:如何建立你的心理界线&quot;&gt;过犹不及&lt;/a&gt;，我们相互提醒吧。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;那什么是流程图呢？说文解字是一种了解定义的好方法。流程图=流程+图，如下图：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams2.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams2.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图2：流程图的定义&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;流程&lt;/strong&gt;：Flow,是指特定主体为了满足特定需求而进行的有特定逻辑关系的一系列操作过程，流程是自然而然就存在的。但是它可以不规范，可以不固定，可以充满问题。所以就会造成看似没有流程。前不久，团队每个人对接一个业务团队去调研流程，反馈给我的流程有一些缺失。询问时，负责人反馈给我的答复是：这一块业务他们没有流程。其实严格意义上讲，业务已经开展，不可能没有流程，只是说没有固定的流程或者你调研的对象也讲不清楚。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图&lt;/strong&gt;：Chart 或者 Diagram,
是将基本固化有一定规律的流程进行显性化和书面化，从而有利于传播与沉淀、流程重组参考。&lt;/p&gt;

&lt;p&gt;从定义可以看出，只要有事情和任务，流程就会有，但是并不是所有的流程都适合用流程图的方式去表现，适合用流程图去表现的流程是一定程度固定的有规律可循的，流程中的关键环节不会朝令夕改的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 流程图与其他图表的对比&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;工作中我们还用到或听到很多其他类型的图表，比如交互设计师们经常说的线框图(Wireframes)，信息架构图或站点地图(Site
Map)，，开发工程师们经常说的用例图(Use
Case)或E-R图。这些不同的图表要表达的内容有何种差异呢？简单做个对比，如图：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams3.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams3.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图3：流程图VS其他常用图表&lt;/p&gt;

&lt;p&gt;如果要串到某一个项目来说，可以理解成：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用例图（Use Case）：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;表现了一个角色在系统里要完成的活动是什么，比如用户这个角色与ATM取款机的交互过程中，用户需要完成的活动有存钱，取钱，查询等。而存钱这个活动再可以进一步细分为插卡，输入密码，输入金额，ATM吐钞，用户收款，退卡等活动。用例图可以不考虑用户动作的前后次序，而仅仅提取一些关键的动宾短语，映射出系统应该满足的功能点。常用用例图的人是产品经理和开发工程师。&lt;/p&gt;

&lt;p&gt;流程图则表示用户每一个活动的前后次序，比如用户必须要先插入银行卡，才能够输入密码，且流程图必须直接表现出各种异常判断，比如当密码错误时，出现什么提示，密码输入错误超过多少次时，出现什么提示和动作。常用流程图的人是产品经理，设计师，或者任何需要讲述业务如何运作的人。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;信息架构图,站点地图(Site Map)：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;表现为了做一个这样的系统，功能与内容的展现层次是什么，比如用户一进去后，欢迎页面的导航如何设计，是否直接出现取款，存款，查询，或者还有别的导航？常用信息架构图的是设计师。但是常用组织架构图的是HR。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;线框图（Wireframe）：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将具体每个界面的内容布局和权重表达出来，且标注出一些交互细节的设计，比如当密码错误后，如何提示下一步动作。常用线框图的人是设计师。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实体关系图(E-R图):&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;则是数据库架构的工作，表示一个业务系统或场景中的实体时间的关系，比如储户与银行卡的关系是归属1对多，通过开卡事件产生关联。一般来讲，用矩形来表示实体，椭圆标识这个实体的属性，比如储户这个实体的属性有：姓，名，手机号码，住址等。而银行卡的属性有：开户行，开户名称，银行卡号等。&lt;/p&gt;

&lt;p&gt;以上的这些图表各自都有领域的专家，我这里就不班门弄斧了。&lt;/p&gt;

&lt;p&gt;那么流程图要体现出他的差异定义，要素是什么？总结出了流程图的6大要素，希望大家能够记住，这6个要素可以在以后的文章里不断回顾，你也可以拿来判断你所看到的流程图是否专业。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams4.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams4.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图4：流程图6大要素&lt;/p&gt;

&lt;p&gt;●参与者：谁在这个流程中？可以是系统，可以是个打印机，更多的指什么角色——一般是有某种工种的人。比如客服同时有小A和小B两人，但是若他们的工作性质完全一样，那么在流程图里只需要写一个客服角色就可以了。&lt;/p&gt;

&lt;p&gt;●活动：做了什么事，比如点餐，结帐等活动。&lt;/p&gt;

&lt;p&gt;●次序：这些事情发生的前后顺序如何，哪个任务是其他任务的前置条件？比如客人不结帐，就不会产生送他优惠卡的活动。&lt;/p&gt;

&lt;p&gt;●输入：每项活动开始取决于什么样的输入物或数据，比如做饭的师傅开始做菜时，需要拿到具体的点菜单。&lt;/p&gt;

&lt;p&gt;●输出：每项活动结束后，会输入什么样的文档或数据传递给下一方，比如师傅做好菜后，如何让负责传菜的人知道菜已经做好？&lt;/p&gt;

&lt;p&gt;●标准化：采用一套标准化的符号用以传递你的流程图，从而使受众更快明白。&lt;/p&gt;

&lt;p&gt;关于流程图的标准化，并不是强制的，事实上，我们见过很多种类的流程图，只要能够传递明白任务和次序其实已经归类于流程图了。如下面的图：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams5.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams5.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams6.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams6.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;但是若在一个公司的环境下，你的流程图的受众又非常多的话，采取标准化的符号会带来很多交流上的好处，总之你懂的。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二部分：流程图的分类？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;常见的流程图有业务流程图（Transaction Flow）, 页面流程图（Page Flow）。&lt;/p&gt;

&lt;p&gt;在工作中，作为UED，你可能会发现PD经常谈的是业务流程，而作为交互设计师，我们更多产出的是页面流程图。页面流程图和业务流程图到底有什么关系呢？
先有谁，其次再有谁呢？&lt;/p&gt;

&lt;p&gt;先讲个故事：假设你的梦想是开个中高档的全国连锁餐馆，那么首先你想到的应该不是如何去选址，而是将为何要开连锁餐馆这件事情，以及你的定位，核心竞争力想清楚。是快餐，还是点餐，是连锁还是加盟？定位于社区还是繁华商圈？是川菜还是江浙海鲜？是面向中老年还是年轻人？是家庭主题还是动漫主题？竞争对手是谁？需要什么样的投资？可能的风险是什么？这些都想清楚了，问题都有答案了，所谓战略层要清晰了吧。然后假设你现在分析来分析去，与主要投资方决定了一个方向：面向年轻人的时尚动漫茶餐厅，连锁，但是先在杭州开始第一家，选址定位于年轻人约会，扫街的地域，比如风景区，著名商圈，电影院旁…………等等等等，那么接下来呢？&lt;/p&gt;

&lt;p&gt;接下来就是想办法让这些实现吧？那么需要做什么事情呢？选址？拉投资？搞装修？选餐饮菜单？雇佣员工？每一步怎么去做，时间点是什么？等等的任务拆解以及计划，就需要到战术层了。&lt;/p&gt;

&lt;p&gt;这些事情的执行，总是需要请人的吧？先是核心团队分工去部署各项建设任务，当餐厅开设起来后，就需要组织稳定的运营团队，如服务、卫生、厨房、采购、人事等等，厨房里面还得分工，白案，热菜，冷菜等等吧？每个部门需要设置管理层以及汇报关系吧？所以你的组织结构就诞生了。&lt;/p&gt;

&lt;p&gt;那具体每种角色是如何顺畅合作完成日常稳定的以及突发的各项任务呢？比如，当顾客上门时，谁去引导客人入座，谁去点菜，怎么将点菜的讯息迅速传递到厨房，并分发到酒水间、冷菜间、热菜间？并保证客人尽快能够吃到所点的菜？你必须要考虑各种人员的协作流程，优化效率，所以业务流程就出现了。&lt;/p&gt;

&lt;p&gt;人肉运营了一段时间，没有借助任何点餐系统，你发现也还可以。客人点菜时，服务员手抄写下客人的要求，因为有复印纸，所以服务员能够将副本送入厨房，同时写下餐桌号码。厨房规模较小，负责分配任务的员工看下菜单，分别往冷菜处的黑板上写下需要他们处理的，以及跑到热菜区的黑板上写下待处理的菜品，以及去酒水间报下品名即可。可是随着经营的扩大，以上的人肉方式出现了很多问题，首先，手抄效率太低，顾客频繁换菜，响应来不及，手抄出错，导致经常报错菜。厨房很混乱，不得不多招了几个人专门跑堂。而一旦顾客要加菜，撤菜就更麻烦了，需要找出他们当时点的菜，再进行人工的批注和修改，同时要修改厨房后端的各个黑板……&lt;/p&gt;

&lt;p&gt;所以你们想要开发一套智能系统，取代很多人肉工作，你们请了系统开发团队，他们经过评估，判断从点菜开始，一直到传菜都可以用系统解决。手持终端，能够快速传递顾客点菜需求到打印机，打印系统能够根据顾客点菜的类型进行自动的分单打印，所以热菜间看到自己的热菜菜单，冷菜间看到自己的冷菜菜单，而酒水间看到酒店菜单。当他们准备完毕后，送出，传菜员可以根据菜名与打印出来的单据进行传菜并根据顾客的点菜小票进行核对。这套系统同时必须配备结算系统，将最终确认掉的菜单及消费价格传递到结算前台，收银员能够快速进行操作。&lt;/p&gt;

&lt;p&gt;这套系统最终是需要展现出来的，那么手持终端的界面如何设计？服务员能够用更少的点击完成一个菜的点餐吗？结算中心的界面如何设计？&lt;/p&gt;

&lt;p&gt;通过以上的故事，是不是更明白从战略、战术、业务流程图到页面流程图的关系了？总结下：&lt;/p&gt;

&lt;p&gt;●先是有一个业务需求和业务目标，也即我们的愿景是什么？（战略）&lt;/p&gt;

&lt;p&gt;●然后就诞生了我们需要分解出什么样的任务，如何执行战术？（战术）&lt;/p&gt;

&lt;p&gt;●然后就诞生了需要架构什么部门，岗位去分工协作？（组织架构）&lt;/p&gt;

&lt;p&gt;●然后就诞生了不同的部门在协作完成某件任务时的业务流程？（业务流程）&lt;/p&gt;

&lt;p&gt;●业务流程基本稳定后，往往会考虑优化效率，所以会诞生出系统来支持流程，减少人肉环节，促进数据采集（系统愿景）&lt;/p&gt;

&lt;p&gt;●为了设计这个系统，PD需要思考什么功能能够取代某个环节的人肉工作（功能需求，系统流程）&lt;/p&gt;

&lt;p&gt;●不管是怎么样的功能最终都会以界面的方式呈现，设计师们会关注用户在系统里的任务流，行为路径，让用户完成任务更加高效愉悦。（页面流程）&lt;/p&gt;

&lt;p&gt;当然，除了业务流程，系统流程，页面流程，还有数据流程被人关注。&lt;/p&gt;

&lt;p&gt;我们平时工作中，还会经常听人谈到泳道图啊，任务流程图啊等等概念，究竟是神马关系呢？&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams7.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams7.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图5：流程图的分类&lt;/p&gt;

&lt;p&gt;本文着重于上述流程中的“业务流程图”——并会分享如何绘制泳道图——也即是PD们最多使用，技术们最多参考，UED们最多看到的流程图。&lt;/p&gt;

&lt;p&gt;本来在第四部分会对泳道图的图示以及绘制方法、原则做更详细的说明，但是看目前的篇幅情况，预计会放到下篇，所以先在这里简单说明下吧。&lt;/p&gt;

&lt;p&gt;在工作中，我们经常能够看到两种业务流程图，从表现形式来看，一种很好区分，俗称为“泳道图”的它，在样子上也确实像个泳道，可以有横向的泳道，也会有纵向的泳道。泳道图在某些文档里会被称为“以活动为单位的流程图”，浮在泳道中的都是一个个活动。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams8.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams8.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;另外一种类型是以部门和岗位为单位的流程图，下图中的圆形就代表一个个部门或岗位。矩形代表活动。这种流程图关注事情如何完成的逻辑，但是在体现各个部门的责任上比较弱。如果是某个岗位的人来看，很难像泳道图那样一眼就能看到自己部门的职责和任务。所以现在用得比较少。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams10.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams10.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;再回过头来说泳道图，泳道图有几个关键点：两大维度，活动流转，流程要素。我们会在以后详解。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams11.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams11.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三部分：为什么需要业务流程图？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;流程图可以提供一种简单扼要的“缩略俯瞰图”，帮助观众快速了解业务如何运转。它包含了几个关键词：谁，什么时候，在什么条件下，做了什么事情，输入什么，输出什么，输出给谁……&lt;/p&gt;

&lt;p&gt;与系统流程不同，业务流程更关注于业务本身如何运作，讲的是业务故事，包含的是业务规则。而系统流程则是满足业务流程，实现部分流程或全部流程的信息化和系统化。&lt;/p&gt;

&lt;p&gt;所以业务流程是所有环节的前置条件——软件需求分析，信息系统建设也会先进行业务流程的梳理。&lt;/p&gt;

&lt;p&gt;下面表现了业务流程图是如何在三个主要场景中发挥作用的：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 员工培训&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams12.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams12.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图6：流程图的应用场景之一：培训&lt;/p&gt;

&lt;p&gt;在此场景中：流程图能够提供一种快速了解业务如何运作的视图，通过业务流程图，新员工能够快速明白业务的最终目标是什么，中有哪些角色在参与以及他们的职责，以及彼此之间的联接。&lt;/p&gt;

&lt;p&gt;除了培训新员工，在员工轮岗、调职场景中，员工也需要业务流程图参考，明白新的工作内容如何开展，以及自己所处的位置，自己的上游是谁，下游是谁，自己需要交付的工作内容是什么。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2：流程优化与重组&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams13.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams13.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图7：流程图的应用场景之二：流程优化&lt;/p&gt;

&lt;p&gt;业务流程重组（Business Process
Reengineering）的存在可以明确反驳：存在即合理。事实上，存在的业务流程并未是合理的，有可能是参与的多个角色习惯了某种做法，有可能是变革尚未影响到末端的操作，也有可能缺乏对于运行中的业务流程问题的洞察以及强有力的变革推动——因为要推动业务流程变革，不是某个部门的事情，而是需要流程中各个部门的通力配合。&lt;/p&gt;

&lt;p&gt;更多时候，业务流程优化是自上而下的，但是老板们未必对实际运作的业务流程那么心知肚明，业务流程图能够很好去表现这个“运作模型”。通过看业务流程图，找关键节点的人访问，能够直接切入：为什么要这么做，为什么不这么做？从而探索出更深层次的问题，而不是问：你们现在怎么做？&lt;/p&gt;

&lt;p&gt;通过调研，分析业务流程图，引入更多角色，能够分析出目前业务流程的问题：缺失，重复，风险，效率等等。从而制定相应的优化方案。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3：信息化的基础&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams14.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams14.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图8：流程图的应用场景之三：信息化基础&lt;/p&gt;

&lt;p&gt;正如上文所述的餐馆梦想的案例，信息系统的一项任务就是解放员工的手脚，取代一些重复的人力劳动工作。系统上了之后，不是说业务流程不需要而是经过了一些调整，其中某个参与者变成了系统，或手持设备，或打印机而已。&lt;/p&gt;

&lt;p&gt;那么在做系统的功能设计和系统流程设计时，是不是必须先要了解目前业务是如何运作的呢？从而更好分析分析，更好说明系统在什么环节取代了什么类型的人肉工作？&lt;/p&gt;

&lt;p&gt;所以我们看到的PRD往往也会先以业务流程图开始说明，而叙述一个系统建设的好处时，也可以用以前的业务流程与系统上了之后的业务流程进行对比。根据分析，将愿景中的新的业务流程图背后需要系统的功能点撰写清楚。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第四部分：如何绘制业务流程图？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先绘制业务流程图本身有没有流程？一定是有的。在软件工程学里听说一句话叫：万物皆对象。那么在流程学里，万事皆流程。吃饭难道没流程吗？就吃饭的动作而言，就有流程：拿筷子——夹菜——入口——咀嚼——吞咽。&lt;/p&gt;

&lt;p&gt;有不少同学在这一部份很快想会问一个问题：Heidi，请介绍画流程图的工具吧？&lt;/p&gt;

&lt;p&gt;我个人是工具派，从不否认人工欲善其事，必先利其器的道理。好的工具本身就是一名好的老师，除了技能，也能够教会我们一些理论与理念，这些理念也是“器”中很重要的一部分。其次才是具体的工具应用技能。所以我并不建议直接跳转到工具应用。对于初学者而言，笔与纸永远是最好的入门工具，因为你无需和任何一个陌生的软件较劲。&lt;/p&gt;

&lt;p&gt;那么，绘制业务流程图有没有可遵循的流程呢？我建议可以从下面4步着手。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 调研&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如何快速了解业务运作真相？有没有调研的技巧放送？&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;2. 梳理与呈现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;能否快速将调研得到的文字和问题，快速转化为业务流程图？&lt;/p&gt;

&lt;p&gt;业务流程图的标准图示是什么？&lt;/p&gt;

&lt;p&gt;怎么评价一个业务流程图的好与坏？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 评审与确认&lt;/strong&gt;——能否真正让业务流程图反映现实中的业务？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 归档维护&lt;/strong&gt;——流程不断变更，业务流程图如何快速响应？&lt;/p&gt;

&lt;p&gt;这些将会在下篇《业务流程图的绘制流程分享(二)》详解。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第五部分：绘制工具？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果不搞工具研讨会的话，这部分比较简单.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Windows:&lt;/strong&gt; 线下工具大家常用的就是下面三个：&lt;/p&gt;

&lt;p&gt;小的流程图用用PPT就够了，完了就导出图片或截图。交互设计师们因为常用axure绘制线框图，所以也不必为了流程图去学习新的工具，完全可以用axure的flow控件完成简单的业务流程图的制作。而PD们则常用微软的visio。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams15.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams15.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;此外，特别推荐一个软件：&lt;a href=&quot;http://www.smartdraw.com/&quot;&gt;SmartDraw&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我最近的流程图都是用SmartDraw绘制的，你可以下载一个免费版本体验下。这个工具不仅仅是为了流程图而设计的，几乎上包罗万象：线框图，流程图，E-R图，UML
,韦恩图，甚至甘特图，脑图……没有像很多人推荐就是因为他太庞大了，尤其是里面的模版。大家体验下：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams16.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams16.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Mac电脑:&lt;/p&gt;

&lt;p&gt;自然要推荐&lt;a href=&quot;http://www.omnigroup.com/products/omnigraffle/features/&quot;&gt;omniGraffle&lt;/a&gt;.
绘制出来的任何图表不知为何总会觉得很美……&lt;/p&gt;

&lt;p&gt;当然，这个软件是可以去www.macx.cn下载免费版的……&lt;/p&gt;

&lt;p&gt;但是不管windows还是mac，除了线下的工具，还有更多线上的选择：&lt;/p&gt;

&lt;p&gt;不过貌似我们对线上工具普遍来说都不太放心，是对服务器，网速，还有对GFW不放心吧。&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&quot;https://cacoo.com/&quot;&gt;https://cacoo.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams17.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams17.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个是界面做得最好看的一个工具。我用它来绘制过概念图（Concept
map）。如下图即是用以上的工具画的。&lt;/p&gt;

&lt;p&gt; &lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams18.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams18.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;​2. http://creately.com/&lt;/p&gt;

&lt;p&gt; &lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams19.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams19.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;​3. www.lucidchart.com&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams20.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot;&gt;&lt;img src=&quot;/assets/files/2012-06/Drawing-process-to-share-business-process-diagrams20.jpg&quot; title=&quot;业务流程图的绘制流程分享&quot; alt=&quot;业务流程图的绘制流程分享&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;转载请注明来处，关注我请点击：&lt;a href=&quot;http://weibo.com/heidixie&quot;&gt;http://weibo.com/heidixie&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>使用缓存的9大误区（下）</title>
   <link href="http://beango.github.com/archives/2012/05/31/misunderstanding-using-cache-2.html"/>
   <updated>2012-05-31T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/05/31/misunderstanding-using-cache-2</id>
   <content type="html">&lt;p&gt;　　&lt;strong&gt;相关文章：&lt;a href=&quot;/archives/2012/04/15/misunderstanding-using-cache.html&quot;&gt;使用缓存的9大误区（上）&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　本篇文章在上篇的基础上继续讨论了使用缓存的几个误区，包括：缓存大量的数据集合，而读取其中一部分；缓存大量具有图结构的对象导致内存浪费；缓存应用程序的配置信息；使用很多不同的键指向相同的缓存项；没有及时的更新或者删除再缓存中已经过期或者失效的数据。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;缓存大量的数据集合，而读取其中一部分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在很多时候，我们往往会缓存一个对象的集合，但是，我们在读取的时候，只是每次读取其中一部分。
我们举个例子来说明这个问题（例子可能不是很恰当，但是足以说明问题）。&lt;/p&gt;

&lt;p&gt;　　在购物站点中，常见的操作就是查询一些产品的信息，这个时候，如果用户输入了“25寸电视机”，然后查找相关的产品。这个时候，在后台，我们可以查询数据库，找到几百条这样的数据，然后，我们将这几百条数据作为一个缓存项缓存起来，代码的代码如下：&lt;img src=&quot;/assets/files/2013-02/2012053015182139.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　同时，我们对找出的产品进行分页的显示，每次展示10条。其实在每次分页的时候，我们都是根据缓存的键去获取数据，然后选择下一个10条数据，然后显示。&lt;/p&gt;

&lt;p&gt;　　如果是使用本地内存缓存，那么这可能不是什么问题，如果是采用分布式缓存，问题就来了。下图可以清楚的说明这个过程，如图所示：&lt;img src=&quot;/assets/files/2013-02/2012053015184551.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　相信大家看完这个图，然后结合之前的讲述应该很清楚了问题所在了：每次都按照缓存键获取全部数据，然后在应用服务器那里反序列化全部数据，但是只是取其中10条。&lt;/p&gt;

&lt;p&gt;　　这里可以将数据集合再次拆分，分为例如25-0-10-products，25-11-20-products等的缓存项，如下图所示：&lt;/p&gt;

&lt;p&gt;　　当然，查询和缓存的方式有很多，拆分的方式也有很多，这里这是给出一些常见的问题！&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;缓存大量具有图结构的对象导致内存浪费&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　为了更好的说明这个问题，我们首先看到下面的一个类结构图，如图：&lt;img src=&quot;/assets/files/2013-02/2012053015190285.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　如果我们要把一些Customer数据缓存起来，这里就可以可能出现两个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;由于使用.NET的默认序列化机制，或者没有适当的加入相应Attribute（属性），使得缓存了一些原本不需要缓存的数据。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将Customer缓存的时候，同时，为了更快的获取Customer的Order信息，将Order信息缓存在了另外一个缓存项中，导致同一份数据被缓存两次。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;　　下面，我们就分别来看看这两个问题。&lt;/p&gt;

&lt;p&gt;　　首先看到第一个。如果我们使用分布式缓存来缓存一些Customer的信息的时候，如果我们没有自己重新Customer的序列化机制，而是采用的默认的，那么序列化机制在序列化Customer的时候，会将Customer所引用的对象也序列化，然后在序列化被序列化对象中的其他引用对象，最后的结果就是：Customer被序列化，Customer的Order信息被序列化，Order引用的OrderItem被序列化，最后OrderItem引用的Product也会序列化。&lt;/p&gt;

&lt;p&gt;　　整个对象图全部被序列化了，如果这种情况是我们想要的，那么没有问题；如果不是的，那么，我们就浪费了很多的资源了，解决的方法有两个：第一，自己实现序列化，自己完全控制哪些对象需要序列化，我们前面已经讲过了；第二，如果使用默认的序列化机制，那么在不要需要序列化的对象上面加上[NonSerialized]标记。&lt;/p&gt;

&lt;p&gt;　　下面，我们看到第二个问题。这个问题主要是由于第一个问题引起的：原本在缓存Customer的时候，已经将Customer的其他信息，例如Order，Product已经缓存了。但是很多的技术人员不清楚这一点，然后又把Customer的Order信息去缓存在其他的缓存项，使用的使用就根据Customer的标识，例如ID去缓存中获取Order信息，如下代码所示：&lt;img src=&quot;/assets/files/2013-02/2012053015191817.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　解决这个问题的方法也比较明显，参看第一个问题的解决方案就可以了！&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;缓存应用程序的配置信息&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　因为缓存是有一套数据失效检测周期的（之前说过，要么是固定时间失效，要么是相对时间失效），所以，很多的技术人员喜欢把一些动态变化的信息保存在缓存中，以充分利用缓存机制的这种特性，其中，缓存程序的配置信息就是其中一个例子。&lt;/p&gt;

&lt;p&gt;　　因为在应用的中的一些配置，可能会发生变化，最简单的就是数据库连接字符串了，如下代码：&lt;img src=&quot;/assets/files/2013-02/2012053015193222.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　当这样设置之后，每隔一段时间缓存失效之后，就去重新读取配置文件，这时候，可能此时的配置就和之前不一样了，并且其他的地方都可以读取缓存从而进行更新，特别是在多台服务器上面部署同一个站点的时候，有时候，我们没有及时的去修改每个服务器上面的站点的配置文件里面的信息，这个时候如何使用分布式缓存缓存配置信息，只要更新一个站点的配置文件，其他站点就全部修改了，技术人员皆大欢喜。OK，这确实看起来是个不错的方法（在必要的时候可以采用一下），但是，不是所有的配置信息都要保持一样的，而且还要考虑怎样一个情况：如果缓存服务器出了问题，宕机了，那么我们所有使用这个配置信息的站点可能都会出问题。&lt;/p&gt;

&lt;p&gt;　　建议对于这些配置文件的信息，采用监控的机制，例如文件监控，每次文件发生变化，就重新加载配置信息。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;使用很多不同的键指向相同的缓存项&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　我们有时候会遇到这样的一个情况：我们把一个对象缓存起来，用一个键作为缓存键来获取这个数据，之后，我们又通过一个索引作为缓存键来获取这个数据，如下代码所示：&lt;img src=&quot;/assets/files/2013-02/2012053015195341.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　我们之所以这样写，主要因为我们会以多种方式来从缓存中读取数据，例如在进行循环遍历的时候，需要通过索引来获取数据，例如index++等，而有些情况，我们可能需要通过其他的方式，例如，产品名来获取产品的信息。&lt;/p&gt;

&lt;p&gt;　　如果遇到这样的情况，那么就建议将这些多个键组合起来，形成如下的形式：&lt;img src=&quot;/assets/files/2013-02/2012053015200756.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　另外一个常见的问题就是：相同的数据被缓存在不同的缓存项中，例如，如果用户查询尺寸为36寸的彩电，那么可能有可能一个编号为100的电视产品就在结果中，此时，我们将结果缓存。另外，用户在查找一个生产厂家为TCL的电视，如果编号为100的电视产品又出现在结果中，我们把结果又缓存在另外一个缓存项中。这个时候，很显然，出现了内存的浪费。&lt;/p&gt;

&lt;p&gt;　　对于这样的情况，之前笔者采用的方法就是，在缓存中创建了一个索引列表，如图所示：&lt;img src=&quot;/assets/files/2013-02/2012053015202258.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　当然，这其中有很多的细节和问题需要解决，这里就不一一述说，要看各自的应用和情况而定！
也非常欢迎大家提供更好的方法。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;没有及时的更新或者删除再缓存中已经过期或者失效的数据&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　这种情况应该是使用缓存最常见的问题，例如，如果我们现在获取了一个Customer的所有没有处理的订单的信息，然后缓存起来，类似的代码如下：&lt;img src=&quot;/assets/files/2013-02/2012053015203643.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　之后，用户的一个订单被处理了，但是缓存还没有更新，那么这个时候，缓存中的数据就已经有问题！当然，我这里只是列举的最简单的场景，大家可以联想自己应用中的其他产品，很有可能会出现缓存中的数据和实际数据库中的不一样。&lt;/p&gt;

&lt;p&gt;　　现在很多的时候，我们已经容忍了这种短时间的不一致的情况。其实对于这种情况，没有非常完美的解决方案，如果要做，倒是可以实现，例如每次修改或者删除一个数据，就去遍历缓存中的所有数据，然后进行操作，但是这样往往得不偿失。另外一个折中的方法就是，判断数据的变化周期，然后尽可能的将缓存的时间变短一点。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;关于作者&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　汪洋，现任惠普架构师、信息分析师《NET应用架构设计：模式、原则与实践》作者。上海益思研发管理咨询有限公司首席软件架构专家，软件咨询组副组长。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MongoDB索引实战技巧</title>
   <link href="http://beango.github.com/archives/2012/05/19/mongodb-indexing-in-practice.html"/>
   <updated>2012-05-19T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/05/19/mongodb-indexing-in-practice</id>
   <content type="html">&lt;p&gt;本文内容源自&lt;a href=&quot;http://www.manning.com/banker/&quot;&gt;Kyle Banker&lt;/a&gt; 的&lt;a href=&quot;http://blog.nosqlfan.com/tags/mongodb&quot; title=&quot;查看 MongoDB 的全部文章&quot;&gt;MongoDB&lt;/a&gt;
In Action一书。主要描述了MongoDB&lt;a href=&quot;http://blog.nosqlfan.com/tags/%e7%b4%a2%e5%bc%95&quot; title=&quot;查看 索引 的全部文章&quot;&gt;索引&lt;/a&gt;相关的一些基础知识和使用技巧。&lt;/p&gt;

&lt;h2&gt;索引类型&lt;/h2&gt;

&lt;p&gt;虽然MongoDB的索引在存储结构上都是一样的，但是根据不同的应用层需求，还是分成了唯一索引（unique）、稀疏索引（sparse）、多值索引（multikey）等几种类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;唯一索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;唯一索引在创建时加上unique:true 的选项即可，创建命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.users.ensureIndex({username: 1}, {unique: true})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的唯一索引创建后，如果insert一条username已经存在的数据，则会报如下的错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;E11000 duplicate key error index: gardening.users.$username_1 dup key: { : &quot;kbanker&quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你在一个已有数据的collection上创建唯一索引，若唯一索引对应的字段原来就有重复的数据项，那么创建会失败，我们需要加上一个dropDups的选项来强制将重复的项删除掉，命令如下例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.users.ensureIndex({username: 1}, {unique: true, dropDups: true})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;松散索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果你的数据中一些行中没有某个字段或字段值为null，那么如果在这个字段上建立普通索引，那么无此字段或值null的行也会参与到索引结构中，占用相应的空间。如果我们不希望这些值为空的行参与到我们的索引中，这时候可以采用松散索引，松散索引只会让指定字段不为空的行参与到索引创建中来。创建一个松散索引可以用下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.reviews.ensureIndex({user_id: 1}, {sparse: true})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;多值索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MongoDB可以对一个array类型创建索引，比如像下面的结构，MongoDB可以在tags字段上创建索引：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ name: &quot;Wheelbarrow&quot;,
tags: [&quot;tools&quot;, &quot;gardening&quot;, &quot;soil&quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在生成索引时，会为tags中的三个值分别生成三个索引元素，索引中tools，gardening，soil三个值都会指向这同一行数据。相当于分裂成了三个独立的索引项。&lt;/p&gt;

&lt;h2&gt;索引管理&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;索引的创建和删除&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;创建和删除索引的方法有很多种，下面两个是比较原始的方法，通过对system.indexes这个collection进行相应的写操作来完成索引的创建：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;spec = {ns: &quot;green.users&quot;, key: {‘addresses.zip’: 1}, name: ‘zip’}
db.system.indexes.insert(spec, true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面命令往system.indexes中写入一条记录来创建索引，这条记录包含了要在上面创建索引的collection的名字空间，索引的信息，以及索引的名称。&lt;/p&gt;

&lt;p&gt;创建完成后，我们可以通过下面命令找到我们创建的索引：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.system.indexes.find()
{ &quot;_id&quot; : ObjectId(&quot;4d2205c4051f853d46447e95&quot;), &quot;ns&quot; : &quot;green.users&quot;,
&quot;key&quot; : { &quot;addresses.zip&quot; : 1 }, &quot;name&quot; : &quot;zip&quot;, &quot;v&quot; : 0 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要删除一个已创建的索引，我们可以使用下面的命令来实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use green
db.runCommand({deleteIndexes: &quot;users&quot;, index: &quot;zip&quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;创建索引命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;实际上创建索引还有更方便的命令，那就是ensure&lt;a href=&quot;http://blog.nosqlfan.com/tags/index&quot; title=&quot;查看 Index 的全部文章&quot;&gt;Index&lt;/a&gt;，比如我们创建一个open和close两个字段的联合索引，就可以用下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.values.ensureIndex({open: 1, close: 1})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令会触发索引创建的两个过程，一个是将相应的字段排序，因为索引是按B+树来组织的，要构建树，将数据进行排序后能够提高插入B+树的效率（第二个过程的效率），在日志中，你能看到和下面类似的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Tue Jan 4 09:58:17 [conn1] building new index on { open: 1.0, close: 1.0 } for stocks.values
1000000/4308303 23%
2000000/4308303 46%
3000000/4308303 69%
4000000/4308303 92%
Tue Jan 4 09:59:13 [conn1] external sort used : 5 files in 55 secs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二个过程是将排序好的数据插入到索引结构中，构成可用的索引：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1200300/4308303 27%
2227900/4308303 51%
2837100/4308303 65%
3278100/4308303 76%
3783300/4308303 87%
4075500/4308303 94%
Tue Jan 4 10:00:16 [conn1] done building bottom layer, going to commit
Tue Jan 4 10:00:16 [conn1] done for 4308303 records 118.942secs
Tue Jan 4 10:00:16 [conn1] insert stocks.system.indexes 118942ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了日志中的输出外，你还可以通过在终端执行currentOp命令来获取当前操作线程的相关信息，如下例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; db.currentOp()
{
    &quot;inprog&quot; : [
        {
            &quot;opid&quot; : 58,
            &quot;active&quot; : true,
            &quot;lockType&quot; : &quot;write&quot;,
            &quot;waitingForLock&quot; : false,
            &quot;secs_running&quot; : 55,
            &quot;op&quot; : &quot;insert&quot;,
            &quot;ns&quot; : &quot;stocks.system.indexes&quot;,
            &quot;query&quot; : {
            },
            &quot;client&quot; : &quot;127.0.0.1:53421&quot;,
            &quot;desc&quot; : &quot;conn&quot;,
            &quot;msg&quot; : &quot;index: (1/3) external sort 3999999/4308303 92%&quot;
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后一部分就是一个索引构建过程，目前正在执行排序过程，执行到92%。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在后台创建索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;创建索引会对数据库添加写锁，如果数据集比如大，会将线上读写数据库的操作挂起，以等待索引创建结束。这影响了数据库的正常服务，我们可以通过在创建索引时加background:true
的选项，让创建工作在后台执行，这时候创建索引还是需要加写锁，但是这个写锁不会直接独占到索引创建完成，而是会暂停为其它读写操作让路，不至于造成严重的性能影响。具体方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.values.ensureIndex({open: 1, close: 1}, {background: true})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;离线创建索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;无论如何，索引的创建都会给数据库造成一定的压力，从而影响线上服务。如果希望创建索引的过程完全不影响线上服务，我们可以通过将replica
sets中的节点先从集群中剥离，在这个节点上添加相应的索引，等索引添加完毕后再将其添加到replica
sets中。这只需要保证一个条件，就是创建索引的时间不能长于oplog能够保存日志的时间，否则创建完后节点再上线发现再也无法追上primary了，这时会进行resync操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;索引备份&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们知道，无论是使用mongodump还是mongoexport命令，都只是对数据进行备份，无法备份索引。我们在恢复的时候，还是需要等待漫长的索引创建过程。所以，如果你希望备份的时候带上索引，那么最好采用备份数据文件的方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;索引压缩&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;索引在使用一段时间后，经历增删改等操作，会变得比较松散，从而战用不必要的空间，我们可以通过reindex命令，重新组织索引，让索引的空间占用变得更小。&lt;/p&gt;

&lt;p&gt;来源：&lt;a href=&quot;http://www.cloudcomputingdevelopment.net/mongodb-indexing-in-practice/&quot;&gt;www.cloudcomputingdevelopment.net&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Javascript内存泄露</title>
   <link href="http://beango.github.com/archives/2012/05/06/javascript-memory-leaks.html"/>
   <updated>2012-05-06T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/05/06/javascript-memory-leaks</id>
   <content type="html">&lt;p&gt;　　英文原文：&lt;a href=&quot;http://nesj.net/blog/2012/04/javascript-memory-leaks/&quot;&gt;JavaScript Memory
Leaks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;1. 什么是内存泄露？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　内存泄露是指分配给应用的内存不能被重新分配，即使在内存已经不被使用的时候。正常情况下，垃圾回收器在
DOM 元素和 event 处理器不被引用或访问的时候回收它们。但是，IE
的早些版本（IE7和之前）中内存泄露是很容易出现的，因为内存管理器不能正确理解
Javascript 生命周期而且在周期被打破(可以通过赋值为 null
实现)前不会回收内存。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;2. 为什么你需要注意它？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在大型 Web
应用程序中内存泄露是一种常见的无意的编程错误。内存泄露会降低 Web
应用程序的性能，直到浪费的内存超过了系统所能分配的，应用程序将不能使用。作为一位
Web 开发者，开发一个满足功能要求的应用程序只是第一步，性能要求和 Web
应用程序的成功是同样重要的，更何况它可能会导致应用程序错误或浏览器崩溃。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;3. Javascript 中出现内存泄露的主要原因是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　1) 循环引用&lt;/p&gt;

&lt;p&gt;　　一个很简单的例子：一个 DOM 对象被一个 Javascript
对象引用，与此同时又引用同一个或其它的 Javascript 对象，这个 DOM
对象可能会引发内存泄露。这个 DOM
对象的引用将不会在脚本停止的时候被垃圾回收器回收。要想破坏循环引用，引用
DOM 元素的对象或 DOM 对象的引用需要被赋值为 null。&lt;/p&gt;

&lt;p&gt;　　2) Javascript 闭包&lt;/p&gt;

&lt;p&gt;　　因为 Javascript 范围的限制，许多实现依赖 Javascript
闭包。如果你想了解更多闭包方面的问题，请查看我的前面的文章 &lt;a href=&quot;http://nesj.net/blog/2012/03/javascript-scope-and-closure/&quot;&gt;JavaScript
Scope and
Closure&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;　　闭包可以导致内存泄露是因为内部方法保持一个对外部方法变量的引用，所以尽管方法返回了，内部方法还可以继续访问在外部方法中定义的私有变量。对
Javascript 程序员来说最好的做法是在页面重载前断开所有的事件处理器。&lt;/p&gt;

&lt;p&gt;　　3) DOM 插入顺序&lt;/p&gt;

&lt;p&gt;　　当 2 个不同范围的
DOM 对象附加到一起的时候，一个临时的对象会被创建。这个 DOM 对象改变范围到
document 时，那个临时对象就没用了。也就是说，
DOM 对象应该按照从当前页面存在的最上面的 DOM 元素开始往下直到剩下的
DOM 元素的顺序添加，这样它们就总是有同样的范围，不会产生临时对象。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;4) 如何检测？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　内存泄露对开发者来说一般很难检测，因为它们是由大量代码中的一些意外的错误引起的，但它在系统内存不足前并不影响程序的功能。这就是为什么会有人在很长时间的测试期中收集应用程序性能指标来测试性能。&lt;/p&gt;

&lt;p&gt;　　最简单的检测内存泄露的方式是用任务管理器检查内存使用情况。在 Chrome
浏览器的新选项卡中打开应用并查看内存使用量是不是越来越多。还有其他的调试工具提供内存监视器，比如
Chrome
开发者工具。这是谷歌开者这网站中的&lt;a href=&quot;https://developers.google.com/chrome-developer-tools/docs/heap-profiling&quot;&gt;堆分析&lt;/a&gt;的特性的教程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-05/20120504_161658_1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　1.
&lt;a href=&quot;http://javascript.crockford.com/memory/leak.html&quot;&gt;http://javascript.crockford.com/memory/leak.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　2.
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/Bb250448&quot;&gt;http://msdn.microsoft.com/en-us/library/Bb250448&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　3.
&lt;a href=&quot;http://www.ibm.com/developerworks/web/library/wa-memleak/&quot;&gt;http://www.ibm.com/developerworks/web/library/wa-memleak/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　（OsChina.NET 编译）&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>IIS是如何处理ASP.NET请求的</title>
   <link href="http://beango.github.com/archives/2012/04/20/how-iis-process-asp-net-request.html"/>
   <updated>2012-04-20T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/04/20/how-iis-process-asp-net-request</id>
   <content type="html">&lt;p&gt;　　英文原文：&lt;a href=&quot;http://abhijitjana.net/2010/03/14/beginner%E2%80%99s-guide-how-iis-process-asp-net-request/&quot;&gt;Beginner’s Guide: How IIS Process ASP.NET
Request&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　每次服务器接受到请求，都要先经IIS处理。这不是一篇描述ASP.NE生命周期的文章，仅仅是关于IIS操作的。在我们开始之前，先了解这些会有助于对全文的理解，同时欢迎反馈和建议。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;什么是Web Server?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　每当我们通过VS运行ASP.NET网站时，VS集成的ASP.NET引擎会响应各种请求，这个引擎的名字叫“WebDev.WebServer.exe”。&lt;/p&gt;

&lt;p&gt;　　当我们配置一个Web程序时，总会涉及到一个词“Web
Server”，它的功能便是会响应所有请求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-04/20120420_135408_1.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;什么是IIS？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　IIS（&lt;em&gt;Internet Information Server&lt;/em&gt;）是微软Web
Server的一种，用来配置ASP.NET站点。IIS拥有自己的ASP.NET处理引擎来处理请求，因此，当一个请求到达时，IIS接收并处理请求，然后返回内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-04/20120420_135410_2.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;请求处理过程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　现在，你应能搞清楚Web
Server和IIS的区别。现在我们来看一下核心部分。在继续之前，你需要搞清两个概念：&lt;/p&gt;

&lt;p&gt;　　1、工作进程（Worker Process）&lt;/p&gt;

&lt;p&gt;　　2、应用程序池（Application Pool）&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;工作进程&lt;/strong&gt;：在IIS中，工作进程（w3wp.exe）运行着ASP.NET应用程序，管理并响应所有的请求，ASP.NET所有的功能都运行在工作进程下，当请求到来时，工作进程会生成Request和Response相关的信息。简而言之，工作进程就是ASP.NET程序的心脏。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;应用程序池&lt;/strong&gt;：应用程序池是工作进程的容器，通常用来隔开不同配置的工作进程。当一个程序出错或进程资源回收时，其他池中的程序不会受到影响。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-04/20120420_135411_3.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;注&lt;/strong&gt;：当一个应用程序池包含多个工作进程时，被叫做“Web Garden”。&lt;/p&gt;

&lt;p&gt;　　如果我们看一下IIS 6.0的结构，就会发现，可以把它分成两部分：&lt;/p&gt;

&lt;p&gt;　　1、内核模块（Kernel Mode）&lt;/p&gt;

&lt;p&gt;　　2、用户模块（User Mode）&lt;/p&gt;

&lt;p&gt;　　内核模式是从IIS
6.0被引入的，它包含了一个叫HTTP.SYS的文件，每当请求进来时，会首先触发该文件的响应。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-04/20120420_135411_4.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　HTTP.SYS文件负责把请求传入相应的应用程序池中。但HTTP.SYS如何知道应传给哪个应用程序池呢？当然不是随机抽取，每当创建一个应用程序池，该池的ID就会生成并在HTTP.SYS文件中注册，因此该文件才能确定将请求往哪传。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-04/20120420_135412_5.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　以上便是IIS处理请求的第一步。接着，我们来看一下请求如何从HTTP.SYS传入应用程序池。&lt;/p&gt;

&lt;p&gt;　　在IIS的用户模块中，通过&lt;em&gt;Web Admin Services
(WAS)&lt;/em&gt;从HTTP.SYS接收请求，并传入相应的应用程序池中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-04/20120420_135414_6.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　当应用程序池接收到请求，会接着传给工作进程（w3wp.exe），该进程检查来请求的URL后缀以确定加载哪个ISAPI扩展。ASP.NET加载时会附带自己的ISAPI扩展（aspnet_isapi.dll），以便在IIS中映射。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;注意&lt;/strong&gt;：如果先安装了asp.net，然后再安装IIS，就需要通过aspnet_regiis命令来注册ASP.NET中的ISAPI扩展。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-04/20120420_135415_7.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　一旦工作进程加载了aspnet_isapi.dll,
就会构造一个HttpRuntime类，该类是应用程序的入口，通过ProcessRequest方法处理请求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-04/20120420_135417_8.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　一旦这个方法被调用，一个HttpContext的实例就产生了。可通过HTTPContent.Current获取到这个实例，且该实例会在整个生命周期中存活，我们通过它可以获取到一些常用对象，如Request，Response，Session
等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-04/20120420_135418_9.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　之后HttpRuntime会通过HttpApplicationFactory类加载一个HttpApplication对象。每一次请求都要穿过一堆HttpModule到达HttpHandler，以便被响应。而这些HttpModule就被配置在HttpApplication中。&lt;/p&gt;

&lt;p&gt;　　有一个概念叫“Http管道”，被叫做管道是因为它包含了一系列的HttpModule，这些HttpModule拦截请求并将其导向相应的HttpHandler。我们也可自定义HttpModule，以便在请求响应之间做点特别的处理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-04/20120420_135419_10.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　HttpHandler是“Http管道”的终点。所有请求穿过HttpModule需抵达相应的HttpHandler，然后HttpHandler根据请求资源，产生并输出内容。也正因此，我们请求任何aspx页面才会得到响应的Html内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-04/20120420_135422_11.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;结语&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　每当请求Web服务器上的某些信息时，该请求首先会到达Http.SYS,
然后Http.SYS将其发送到相应的应用程序池，应用程序池传给工作进程并加载ISAPI扩展，然后HttpRuntime对象会被创建，并通过HttpModule和HttpHandler处理请求。&lt;/p&gt;

&lt;p&gt;　　最后，ASP.NET页面生命周期就开始了。&lt;/p&gt;

&lt;p&gt;　　这只是大致描述IIS处理过程的文章，如果你想进一步了解相应细节，请点击下面链接来进一步学习。&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;http://www.west-wind.com/presentations/howaspnetworks/howaspnetworks.asp&quot;&gt;A low-level Look at the ASP.NET
Architecture&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;http://learn.iis.net/page.aspx/101/introduction-to-iis-7-architecture/&quot;&gt;IIS
Architecture&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　本文翻译自：&lt;a href=&quot;http://abhijitjana.net/2010/03/14/beginner%E2%80%99s-guide-how-iis-process-asp-net-request/&quot;&gt;Beginner’s Guide: How IIS Process ASP.NET
Request&lt;/a&gt;&lt;a href=&quot;http://abhijitjana.net/2010/03/14/beginner%E2%80%99s-guide-how-iis-process-asp-net-request/&quot;&gt;\
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;译后小注：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　1、如果在IIS配置完站点却看不到“w3wp.exe”进程，只要用浏览器打开该站其中一个页面，“w3wp.exe”进程就会出现了。&lt;/p&gt;

&lt;p&gt;　　2、为节省时间，直接引用了原图，英文差的，小查一下字典应该没啥问题。&lt;/p&gt;

&lt;p&gt;　　相关博文：　　&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;http://www.cnblogs.com/JimmyZhang/archive/2007/09/04/880967.html&quot;&gt;Asp.Net构架(Http请求处理流程) &lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>说说JSON和JSONP</title>
   <link href="http://beango.github.com/archives/2012/04/19/json-jsonp-jquery.html"/>
   <updated>2012-04-19T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/04/19/json-jsonp-jquery</id>
   <content type="html">&lt;p&gt;来源：&lt;a href=&quot;http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html&quot;&gt;随它去吧&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于Sencha Touch 2这种开发模式的特性，基本决定了它原生的数据交互行为几乎只能通过AJAX来实现。&lt;/p&gt;

&lt;p&gt;当然了，通过调用强大的PhoneGap插件然后打包，你可以实现100%的Socket通讯和本地数据库功能，又或者通过HTML5的WebSocket也可以实现与服务器的通讯和服务端推功能，但这两种方式都有其局限性，前者需要PhoneGap支持，后者要求用户设备必须支持WebSocket，因此都不能算是ST2的原生解决方案，原生的只有AJAX。&lt;/p&gt;

&lt;p&gt;说到AJAX就会不可避免的面临两个问题，第一个是AJAX以何种格式来交换数据？第二个是跨域的需求如何解决？这两个问题目前都有不同的解决方案，比如数据可以用自定义字符串或者用XML来描述，跨域可以通过服务器端代理来解决。&lt;/p&gt;

&lt;p&gt;但到目前为止最被推崇或者说首选的方案还是用JSON来传数据，靠JSONP来跨域。而这就是本文将要讲述的内容。&lt;/p&gt;

&lt;p&gt;JSON和JSONP虽然只有一个字母的差别，但其实他们根本不是一回事儿：JSON是一种数据交换格式，而JSONP是一种依靠开发人员的聪明才智创造出的一种非官方跨域数据交互协议。我们拿最近比较火的谍战片来打个比方，JSON是地下党们用来书写和交换情报的“暗号”，而JSONP则是把用暗号书写的情报传递给自己同志时使用的接头方式。看到没？一个是描述信息的格式，一个是信息传递双方约定的方法。&lt;/p&gt;

&lt;p&gt;既然随便聊聊，那我们就不再采用教条的方式来讲述，而是把关注重心放在帮助开发人员理解是否应当选择使用以及如何使用上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;什么是JSON&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面简单说了一下，JSON是一种基于文本的数据交换方式，或者叫做数据描述格式，你是否该选用他首先肯定要关注它所拥有的优点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JSON的优点：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、基于纯文本，跨平台传递极其简单；&lt;/p&gt;

&lt;p&gt;2、Javascript原生支持，后台语言几乎全部支持；&lt;/p&gt;

&lt;p&gt;3、轻量级数据格式，占用字符数量极少，特别适合互联网传递；&lt;/p&gt;

&lt;p&gt;4、可读性较强，虽然比不上XML那么一目了然，但在合理的依次缩进之后还是很容易识别的；&lt;/p&gt;

&lt;p&gt;5、容易编写和解析，当然前提是你要知道数据结构；&lt;/p&gt;

&lt;p&gt;JSON的缺点当然也有，但在作者看来实在是无关紧要的东西，所以不再单独说明。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JSON的格式或者叫规则：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JSON能够以非常简单的方式来描述数据结构，XML能做的它都能做，因此在跨平台方面两者完全不分伯仲。&lt;/p&gt;

&lt;p&gt;1、JSON只有两种数据类型描述符，大括号{}和方括号[]，其余英文冒号:是映射符，英文逗号,是分隔符，英文双引号”&quot;是定义符。&lt;/p&gt;

&lt;p&gt;2、大括号{}用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述），方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组）。&lt;/p&gt;

&lt;p&gt;3、上述两种集合中若有多个子项，则通过英文逗号,进行分隔。&lt;/p&gt;

&lt;p&gt;4、键值对以英文冒号:进行分隔，并且建议键名都加上英文双引号”&quot;，以便于不同语言的解析。&lt;/p&gt;

&lt;p&gt;5、JSON内部常用数据类型无非就是字符串、数字、布尔、日期、null
这么几个，字符串必须用双引号引起来，其余的都不用，日期类型比较特殊，这里就不展开讲述了，只是建议如果客户端没有按日期排序功能需求的话，那么把日期时间直接作为字符串传递就好，可以省去很多麻烦。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JSON实例：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 描述一个人
var person = {
    &quot;Name&quot;: &quot;Bob&quot;,
    &quot;Age&quot;: 32,
    &quot;Company&quot;: &quot;IBM&quot;,
    &quot;Engineer&quot;: true
}

// 获取这个人的信息
var personAge = person.Age;

// 描述几个人
var members = [
    {
        &quot;Name&quot;: &quot;Bob&quot;,
        &quot;Age&quot;: 32,
        &quot;Company&quot;: &quot;IBM&quot;,
        &quot;Engineer&quot;: true
    },
    {
        &quot;Name&quot;: &quot;John&quot;,
        &quot;Age&quot;: 20,
        &quot;Company&quot;: &quot;Oracle&quot;,
        &quot;Engineer&quot;: false
    },
    {
        &quot;Name&quot;: &quot;Henry&quot;,
        &quot;Age&quot;: 45,
        &quot;Company&quot;: &quot;Microsoft&quot;,
        &quot;Engineer&quot;: false
    }
]

// 读取其中John的公司名称
var johnsCompany = members[1].Company;

// 描述一次会议
var conference = {
    &quot;Conference&quot;: &quot;Future Marketing&quot;,
    &quot;Date&quot;: &quot;2012-6-1&quot;,
    &quot;Address&quot;: &quot;Beijing&quot;,
    &quot;Members&quot;:
    [
        {
            &quot;Name&quot;: &quot;Bob&quot;,
            &quot;Age&quot;: 32,
            &quot;Company&quot;: &quot;IBM&quot;,
            &quot;Engineer&quot;: true
        },
        {
            &quot;Name&quot;: &quot;John&quot;,
            &quot;Age&quot;: 20,
            &quot;Company&quot;: &quot;Oracle&quot;,
            &quot;Engineer&quot;: false
        },
        {
            &quot;Name&quot;: &quot;Henry&quot;,
            &quot;Age&quot;: 45,
            &quot;Company&quot;: &quot;Microsoft&quot;,
            &quot;Engineer&quot;: false
        }
    ]
}

// 读取参会者Henry是否工程师
var henryIsAnEngineer = conference.Members[2].Engineer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于JSON，就说这么多，更多细节请在开发过程中查阅资料深入学习。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;什么是JSONP&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;先说说JSONP是怎么产生的：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其实网上关于JSONP的讲解有很多，但却千篇一律，而且云里雾里，对于很多刚接触的人来讲理解起来有些困难，小可不才，试着用自己的方式来阐释一下这个问题，看看是否有帮助。&lt;/p&gt;

&lt;p&gt;1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准；&lt;/p&gt;

&lt;p&gt;2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如&amp;lt;script&gt;、&amp;lt;img&gt;、&amp;lt;iframe&gt;）；&lt;/p&gt;

&lt;p&gt;3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；&lt;/p&gt;

&lt;p&gt;4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；&lt;/p&gt;

&lt;p&gt;5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。&lt;/p&gt;

&lt;p&gt;6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。&lt;/p&gt;

&lt;p&gt;7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。&lt;/p&gt;

&lt;p&gt;如果对于callback参数如何使用还有些模糊的话，我们后面会有具体的实例来讲解。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JSONP的客户端具体实现：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不管jQuery也好，extjs也罢，又或者是其他支持jsonp的框架，他们幕后所做的工作都是一样的，下面我来循序渐进的说明一下jsonp在客户端的实现：&lt;/p&gt;

&lt;p&gt;1、我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。&lt;/p&gt;

&lt;p&gt;远程服务器remoteserver.com根目录下有个remote.js文件代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alert('我是远程文件');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本地服务器localserver.com下有个jsonp.html页面代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://remoteserver.com/remote.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。&lt;/p&gt;

&lt;p&gt;2、现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。&lt;/p&gt;

&lt;p&gt;jsonp.html页面代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var localHandler = function(data){
        alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result);
    };
    &amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://remoteserver.com/remote.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;remote.js文件代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;localHandler({&quot;result&quot;:&quot;我是远程js带来的数据&quot;});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。&lt;/p&gt;

&lt;p&gt;3、聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。&lt;/p&gt;

&lt;p&gt;看jsonp.html页面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    // 得到航班信息查询结果后的回调函数
    var flightHandler = function(data){
        alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');
    };
    // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）
    var url = &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;amp;callback=flightHandler&quot;;
    // 创建script标签，设置其属性
    var script = document.createElement('script');
    script.setAttribute('src', url);
    // 把script标签加入head，此时调用开始
    document.getElementsByTagName('head')[0].appendChild(script);
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。&lt;/p&gt;

&lt;p&gt;我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。&lt;/p&gt;

&lt;p&gt;OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flightHandler({
    &quot;code&quot;: &quot;CA1998&quot;,
    &quot;price&quot;: 1780,
    &quot;tickets&quot;: 5
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！&lt;/p&gt;

&lt;p&gt;4、到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。&lt;/p&gt;

&lt;p&gt;什么？你用的是jQuery，想知道jQuery如何实现jsonp调用？好吧，那我就好人做到底，再给你一段jQuery使用jsonp的代码（我们依然沿用上面那个航班信息查询的例子，假定返回jsonp结果不变）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
 &amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; &amp;gt;
 &amp;lt;head&amp;gt;
     &amp;lt;title&amp;gt;Untitled Page&amp;lt;/title&amp;gt;
      &amp;lt;script type=&quot;text/javascript&quot; src=jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
      &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
     jQuery(document).ready(function(){
        $.ajax({
             type: &quot;get&quot;,
             async: false,
             url: &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&quot;,
             dataType: &quot;jsonp&quot;,
             jsonp: &quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)
             jsonpCallback:&quot;flightHandler&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据
             success: function(json){
                 alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。');
             },
             error: function(){
                 alert('fail');
             }
         });
     });
     &amp;lt;/script&amp;gt;
     &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
  &amp;lt;/body&amp;gt;
 &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是有点奇怪？为什么我这次没有写flightHandler这个函数呢？而且竟然也运行成功了！哈哈，这就是jQuery的功劳了，jquery在处理jsonp类型的ajax时（还是忍不住吐槽，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用，是不是很爽呀？&lt;/p&gt;

&lt;p&gt;好啦，写到这里，我已经无力再写下去，又困又累，得赶紧睡觉。朋友们要是看这不错，觉得有启发，给点个“推荐”呗！由于实在比较简单，所以就不再提供demo源码下载了。&lt;/p&gt;

&lt;p&gt;没想到上了博客园的头条推荐。看到大家对这篇文章的认可和评论，还是很开心的，这里针对ajax与jsonp的异同再做一些补充说明：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4月20日下午补充&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；&lt;/p&gt;

&lt;p&gt;2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&amp;lt;script&gt;标签来调用服务器提供的js脚本。&lt;/p&gt;

&lt;p&gt;3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。&lt;/p&gt;

&lt;p&gt;4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。&lt;/p&gt;

&lt;p&gt;总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变着一点！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>使用缓存的9大误区（上）</title>
   <link href="http://beango.github.com/archives/2012/04/15/misunderstanding-using-cache.html"/>
   <updated>2012-04-15T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/04/15/misunderstanding-using-cache</id>
   <content type="html">&lt;p&gt;　　如果说要对一个站点或者应用程序经常优化，可以说缓存的使用是最快也是效果最明显的方式。一般而言，我们会把一些常用的，或者需要花费大量的资源或时间而产生的数据缓存起来，使得后续的使用更加快速。&lt;/p&gt;

&lt;p&gt;　　如果真要细说缓存的好处，还真是不少，但是在实际的应用中，很多时候使用缓存的时候，总是那么的不尽人意。换句话说，假设本来采用缓存，可以使得性能提升为100（这里的数字只是一个计量符号而已，只是为了给大家一个“量”的体会），但是很多时候，提升的效果只有80,70，或者更少，甚至还会导致性能严重的下降，这个现象在使用分布式缓存的时候尤为突出。&lt;/p&gt;

&lt;p&gt;　　在本篇文章中，我们将为大家讲述导致以上问题的9大症结，并且给出相对应的解决方案。文章以.NET为例子进行代码的演示，对于来及其他技术平台的朋友也是有参考价值的，只要替换相对应的代码就行了！&lt;/p&gt;

&lt;p&gt;　　为了使得后文的阐述更加的方便，也使得文章更为的完整，我们首先来看看缓存的两种形式：本地内存缓存，分布式缓存。&lt;/p&gt;

&lt;p&gt;　　首先对于本地内存缓存，就是把数据缓存在本机的内存中，如下图1所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/2012041314085328.png&quot; alt=&quot;缓存&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　从上图中可以很清楚的看出：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;应用程序把数据缓存在本机的内存，需要的时候直接去本机内存进行获取。&lt;/li&gt;
&lt;li&gt;对于.NET的应用而言，在获取缓存中的数据的时候，是通过对象的引用去内存中查找数据对象的，也就说，如果我们通过引用获取了数据对象之后，我们直接修改这个对象，其实我们真正的是在修改处于内存中的那个缓存对象。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　对于分布式的缓存，此时因为缓存的数据是放在缓存服务器中的，或者说，此时应用程序需要跨进程的去访问分布式缓存服务器，如图2：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/2012041314090310.png&quot; alt=&quot;缓存&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　不管缓存服务器在哪里，因为涉及到了跨进程，甚至是跨域访问缓存数据，那么缓存数据在发送到缓存服务器之前就要先被序列化，当要用缓存数据的时候，应用程序服务器接收到了序列化的数据之后，会将之反序列化。序列化与反序列化的过程是非常消耗CPU的操作，很多问题就出现在这上面。&lt;/p&gt;

&lt;p&gt;　　另外，如果我们把获取到的数据，在应用程序中进行了修改，此时缓存服务器中的原先的数据是没有修改的，除非我们再次将数据保存到缓存服务器。请注意：这一点和之前的本地内存缓存是不一样的。&lt;/p&gt;

&lt;p&gt;　　对于缓存中的每一份数据，为了后文的讲述方面，我们称之为“缓存项“。&lt;/p&gt;

&lt;p&gt;　　普及完了这两个概念之后，我们就进入今天的主题：使用缓存常见的9大误区：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;太过于依赖.NET&lt;/strong&gt;&lt;strong&gt;默认的序列化机制&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存大对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用缓存机制在线程间进行数据的共享&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;认为调用缓存API&lt;/strong&gt;&lt;strong&gt;之后，数据会被立刻缓存起来&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存大量的数据集合，而读取其中一部分&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存大量具有图结构的对象导致内存浪费&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存应用程序的配置信息&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用很多不同的键指向相同的缓存项&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;没有及时的更新或者删除再缓存中已经过期或者失效的数据&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;　　下面，我们就每一点来具体的看看！&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;太过于依赖.NET默认的序列化机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　当我们在应用中使用跨进程的缓存机制，例如分布式缓存memcached或者微软的AppFabric，此时数据被缓存在应用程序之外的进程中。每次，当我们要把一些数据缓存起来的时候，缓存的API就会把数据首先序列化为字节的形式，然后把这些字节发送给缓存服务器去保存。同理，当我们在应用中要再次使用缓存的数据的时候，缓存服务器就会将缓存的字节发送给应用程序，而缓存的客户端类库接受到这些字节之后就要进行反序列化的操作了，将之转换为我们需要的数据对象。&lt;/p&gt;

&lt;p&gt;　　另外还有三点需要注意的就是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这个序列化与反序列化的机制都是发生在应用程序服务器上的，而缓存服务器只是负责保存而已。&lt;/li&gt;
&lt;li&gt;.NET中的默认使用的序列化机制不是最优的，因为它要使用反射机制，而反射机制是是非常耗CPU的，特别是当我们缓存了比较复杂的数据对象的时候。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　基于这个问题，我们要自己选择一个比较好的序列化方法来尽可能的减少对CPU的使用。常用的方法就是让对象自己来实现ISerializable接口。&lt;/p&gt;

&lt;p&gt;　　首先我们来看看默认的序列化机制是怎么样的。如图3：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/2012041314091150.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　然后，我们自己来实现ISerializable接口，如下图4所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/2012041314092260.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　我们自己实现的方式与.NET默认的序列化机制的最大区别在于：没有使用反射。自己实现的这种方式速度可以是默认机制的上百倍。&lt;/p&gt;

&lt;p&gt;　　可能有人认为没有什么，不就是一个小小的序列化而已，有必要小题大做么？&lt;/p&gt;

&lt;p&gt;　　在开发一个高性能应用（例如网站）而言，从架构，到代码的编写，以及后面的部署，每一个地方都需要优化。一个小问题，例如这个序列化的问题，初看起来不是问题，如果我们站点应用的访问量是百万，千万，甚至更高级别的，而这些访问需要去获取一些公共的缓存的数据，这个之前所谓的小问题就不小了！&lt;/p&gt;

&lt;p&gt;　　下面，我们来看第二个误区。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;缓存大对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　有时候，我们想要把一些大对象缓存起来，因为产生一次大对象的代价很大，我们需要产生一次，尽可能的多次使用，从而提升响应。&lt;/p&gt;

&lt;p&gt;　　提到大对象，这里就很有必要对其进行一个比较深入的介绍了。在.NET中，所谓的大对象，就是指的其占用的内存大于了85K的对象，下面通过一个比较将问题说清楚。&lt;/p&gt;

&lt;p&gt;　　如果现在有一个Person类的集合，定义为List&amp;lt;Person&gt;，每个Person对象占用1K的内存，如果这个Person集合中包含了100个Person对象实例，那么这个集合是否是大对象呢？&lt;/p&gt;

&lt;p&gt;　　回答是：不是！&lt;/p&gt;

&lt;p&gt;　　因为集合中只是包含的Person对象实例的引用而言，即，在.NET的托管堆上面，这个Person集合分配的内存大小也就是100个引用的大小而言。&lt;/p&gt;

&lt;p&gt;　　然后，对于下面的这个对象，就是大对象了: byte[] data = new byte[87040]（85 * 1024 = 87040）。&lt;/p&gt;

&lt;p&gt;　　说到了这里，那就就谈谈，为什么说：产生一次大对象的代价很大。&lt;/p&gt;

&lt;p&gt;　　因为在.NET中，大对象是分配在大对象托管堆上面的（我们简称为“大堆”，当然，还有一个对应的小堆），而这个大堆上面的对象的分配机制和小堆不一样：大堆在分配的时候，总是去需找合适的内存空间，结果就是导致出现内存碎片，导致内存不足！我们用一个图来描述一下，如图5所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/2012041314093247.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　上图非常明了，在图5中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;垃圾回收机制不会在回收对象之后压缩大堆（小堆是压缩的）。&lt;/li&gt;
&lt;li&gt;分配对象的时候，需要去遍历大堆，去需找合适的空间，遍历是要花成本的。&lt;/li&gt;
&lt;li&gt;如果某些空间小于85K，那么就不能分配了，只能白白浪费，也导致内存碎片。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　讲完了这些之后，我们言归正传，来看看大对象的缓存。&lt;/p&gt;

&lt;p&gt;　　正如之前讲过，将对象缓存和读取的时候是要进行序列化与反序列化的，缓存的对象越大（例如，有1M等），整个过程中就消耗更多的CPU。&lt;/p&gt;

&lt;p&gt;　　对于这样的大对象，要看它使用的是否很频繁，是否是公用的数据对象，还是每个用户都要产生的。因为我们一旦缓存了（特别在分布式缓存中），就需要同时消耗缓存服务器的内存与应用程序服务器的CPU。如果使用的不频繁，建议每次生成！如果是公用的数据，那么建议多多的测试：将生产大对象的成本与缓存它的时候消耗的内存和CPU的成本进行比较，选择成本小的！如果是每个用户都要产生的，看看是否可以分解，如果实在不能分解，那么缓存，但是及时的释放！&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;使用缓存机制在线程间进行数据的共享&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　当数据放在缓存中的时候，我们程序的多个线程都可以访问这个公共的区域。多个线程在访问缓存数据的时候，会产生一些竞争，这也是多线程中常常发生的问题。&lt;/p&gt;

&lt;p&gt;　　下面我们分别从本地内存缓存与分布式缓存两个方面介绍竞争的带来的问题。&lt;/p&gt;

&lt;p&gt;　　看下面的一段代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/2012041314094321.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　对于本地内存缓存，对于上面的代码，当这个三个线程运行起来之后，在线程1中，item的值很多时候可能为1，线程2可能是2，线程3可能是3。当然，这不一定！只是大多数情况下的可能值！&lt;/p&gt;

&lt;p&gt;　　如果是对于分布式缓存，就不好说了！因为数据的修改不是立刻发生在本机的内存中的，而是经过了一个跨进程的过程。&lt;/p&gt;

&lt;p&gt;　　有一些缓存模块已经实现了加锁的方式来解决这个问题，例如AppFabric。大家在修改缓存数据的时候要特别注意这一点。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;认为调用缓存API之后，数据会被立刻缓存起来&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　有时候，当我们调用了缓存的API之后，我们就会认为：数据已经被换成了，之后就可以直接读取缓存中的数据。尽管情况很多时候如此，但是不是绝对的！很多的问题就是这样产生的！&lt;/p&gt;

&lt;p&gt;　　我们通过一个例子来讲解。&lt;/p&gt;

&lt;p&gt;　　例如，对于一个ASP.NET应用而言，如果我们在一个按钮的Click事件中调用了缓存API，然后在页面呈现的时候，就去读取缓存，代码如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/2012041314095217.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　上面的代码照道理来说是对的，但是会发生问题。按钮点击之后回传页面，然后呈现页面的时候显示数据，流程没有问题。但是没有考虑到这样一个问题：如果服务器的内存紧张，而导致进行服务器内存的回收，那么很有可能缓存的数据就没有了！&lt;/p&gt;

&lt;p&gt;　　这里有朋友就要说了：内存回收这么快？&lt;/p&gt;

&lt;p&gt;　　这主要看我们的一些设置和处理。&lt;/p&gt;

&lt;p&gt;　　一般而言，缓存机制都是会设置绝对过期时间与相对过期时间，二者的区别，大家应很清楚，我这里不多说。对于上面的代码而言，如果我们设置的是绝对过期时间，假设1分钟，如果页面处理的非常慢，时间超过了1分钟，那么等到呈现的时候，可能缓存中的数据已经没有了！&lt;/p&gt;

&lt;p&gt;　　有时候，即使我们在第一行代码中缓存了数据，那么也许在第三行代码中，我们去缓存读取数据的时候，就已经没有了。这或许是因为在服务器内存压力很大的，缓存机制将最少访问的数据直接清掉。或者服务器CPU很忙，网络也不好，导致数据没有被即使的序列化保存到缓存服务器中。&lt;/p&gt;

&lt;p&gt;　　另外，对于ASP.NET而言，如果使用了本地内存缓存，那么，还涉及到IIS的配置问题（对缓存内存的限制），我们有机会专门为大家分享这方面的知识。&lt;/p&gt;

&lt;p&gt;　　所以，每次在使用缓存数据的时候，要判断是否存在，不然，会有很多的“找不到对象”的错误，产生一些我们认为的“奇怪而又合理的现象”。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;关于作者&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　汪洋，现任惠普架构师、信息分析师《NET应用架构设计：模式、原则与实践》作者。上海益思研发管理咨询有限公司首席软件架构专家，软件咨询组副组长。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MongoDB最佳实践</title>
   <link href="http://beango.github.com/archives/2012/03/29/mongodb-best-practices.html"/>
   <updated>2012-03-29T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/03/29/mongodb-best-practices</id>
   <content type="html">&lt;p&gt;英文原文：&lt;a href=&quot;http://www.engineyard.com/blog/2011/mongodb-best-practices/&quot;&gt;mongodb-best-practices&lt;/a&gt;，翻译：&lt;a href=&quot;http://blog.nosqlfan.com/html/3661.html&quot;&gt;NoSQL
Fan&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;将MongoDB加入到我们的服务支持列表中，是整个团队年初工作计划中的首要任务。但我们感觉如果先添加一项对&lt;a href=&quot;http://blog.jobbole.com/1344/&quot; title=&quot;8种Nosql数据库系统对比&quot;&gt;NoSQL&lt;/a&gt;存储的支持，而不是先升级已支持的关系型数据库，可能对用户不太好，毕竟目前的用户都使用关系型数据库。&lt;/p&gt;

&lt;p&gt;所以我们决定将引入MongoDB这项工作放到升级MySQL和PostgreSQL之后来做。到目前为止，MySQL
5.5的Beta版已在进行中，而PostgreSQL的9.1
Beta版也将进入流程，因此我们打算在2012年第一季度中应用这两个版本。&lt;/p&gt;

&lt;p&gt;由于我们对MongoDB的关注，我们选择性地为几名使用MongoDB的用户提供了技术支持。在这个过程中，我们了解到了很多可能出现问题的地方。所以想借此文与大家分享Engine
Yard眼中的MongoDB最佳实践。&lt;/p&gt;

&lt;p&gt;如果你的MongoDB是定制化安装的，我们强烈建议你将自己的设置与本文讲到的内容进行对比，并进行必要的设置修改。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通常意义上的NoSQL最佳实践&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;已有很多文章对NoSQL选型方面进行过讨论。在选择一个数据库产品时，通常可能需要考虑以下因素：读写吞吐量、持久化、一致性以及延迟等。在Nathan
Hurst的文章《Visual Guide to NoSQL
Systems》中对这些方面都做了详尽的介绍。&lt;/p&gt;

&lt;p&gt;数据库的选择是个大问题，本文不打算就这方面深入介绍，但希望读者能够自己去了解这方面的知识。一旦开发者了解得足够多，最后的结论永远都只有一个：没有任何一个数据库能够满足所有的应用场景。本文内容是基于选择MongoDB作为数据库存储上来说的。Engine
Yard在这方面提出了如下四点建议。&lt;/p&gt;

&lt;p&gt;全面测试。测试一定要使用切合实际场景的数据，并且需要尽量模拟业务场景的数据操作情况。否则，开发者会发现在上线后的实际场景下，可能导致一些性能瓶颈甚至发现整体架构上的设计缺陷。因此，尽可能使用实际场景的操作使用来进行测试，然后收集足够的测试数据。&lt;/p&gt;

&lt;p&gt;千万别以为在关系型数据库上的使用方法可以被直接移植。MongoDB并不支持一些关系型数据库的功能，所以开发者最好先搞清楚MongoDB支持哪些功能。为了获得更好的性能，开发者最好多看10gen官方建议的文档设计和操作方法。另外，在使用MongoDB前，建议开发者做好对整个架构进行&lt;a href=&quot;http://www.amazon.cn/gp/product/B003BY6PLK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;tag=vastwork-23&amp;amp;linkCode=as2&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=B003BY6PLK&quot; title=&quot;重构:改善既有代码的设计&quot;&gt;重构&lt;/a&gt;以适用新的存储模型的准备。为了更好地理解数据迁移的代价，建议阅读《The
cost of Migration》一文。&lt;/p&gt;

&lt;p&gt;明确数据需要的一致性和可靠性。对MongoDB来说，可靠性不再过度地依赖将数据写入到磁盘的操作，更多的是通过将数据同步到其他节点的方式解决可靠性问题。绝不建议开发者在真实环境中使用没有备份的节点单独工作。这一点很重要，所以建议开发者了解其中的原因。&lt;/p&gt;

&lt;p&gt;明确你对EBS的期望。如果你是Engine Yard云平台的用户（AWS
EC2），那么应该知道，EBS的性能不太稳定。所以在测试时，你最好收集足够多的EBS设备吞吐数据以做考量。Engine
Yard本身并没有对用户在EBS性能上做限制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MongoDB最佳实践&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以下是我们将MongoDB引入到服务支持列表过程中所遵循的原则。&lt;/p&gt;

&lt;p&gt;总是使用Replica Sets。Replica
Sets通过自动failover机制提供MongoDB的高可用性。在应用中，如primary机器出现故障，那么某一台secondary机器就会通过选举成为新的primary，整个集群仍然能够提供正常服务。我们的服务不会支持无同步机制的MongoDB布置方案。如果在开发者自己的环境中同步机制的代价过高，我们建议其使用一些云存储服务。Engine
Yard目前已经与MongoHQ和MongoLab都建立了合作关系。开发者可以在合作者页面找到更多这方面的信息。&lt;/p&gt;

&lt;p&gt;保持版本更新。保持版本更新很重要，10gen在每个版本中都会修复一些问题，使MongoDB的运行更出色。比如在2.0.x版本中，MongoDB的存储性能和并发性能就有极大提高，同时还包括索引优化、Bug修复以及compaction命令等一系列改进，以便开发者更方便地扩展其集群。如果你还在使用1.6.3版本，那就快升级吧。&lt;/p&gt;

&lt;p&gt;不要在32位系统上使用MongoDB。在32位机器上，MongoDB只能存储约2.5GB的数据。因为MongoDB在内部实现上是通过内存映射的方式来提高性能的，所以在32位机器上其内存地址本身就限制了数据容量。在Engine
Yard云服务中使用MongoDB，请使用Large
instance来部署MongoDB。在实际产品中，我们也只支持64位的MongoDB。&lt;/p&gt;

&lt;p&gt;默认开启journaling日志。MongoDB支持在写操作前记录journaling日志来提高节点的可用性。强烈建议在部署时开启journaling日志。注意数据文件的存放位置。在使用时，请确认你的数据文件处于一个持久化存储中（比如/data/mongodb目录）。也可以使用非持久化的设备进行数据文件存储，不过你最好小心再小心，因为这可能会对你的集群架构造成影响。推荐使用EBS进行MongoDB的数据文件存储。热数据最好能放在内存中。能够保持热数据（以及索引数据）一直放在内存中，这一点非常重要，它将对整个集群的性能造成影响。如果通过监控发现page
fault的数量增加，那么很可能就是热数据量超出了可用内存大小。当热数据量超出了可用内存量时，通常有两种解决方法：增加内存和数据分片。建议先增加内存，再考虑通过数据分片的方式解决。&lt;/p&gt;

&lt;p&gt;压力过大升级配置。如果机器负载达到65%，那么应该考虑升级机器配置。在日常使用中，最好保持负载低于65%。同时这也对数据恢复和纵向扩展有影响。当需要升级配置时，AWS建议按下面的顺序来做：Large、Extra
Large、High Memory 4XL。而在更高配置的机器上，网络延迟也会更小。&lt;/p&gt;

&lt;p&gt;分片需谨慎。分片策略会受数据访问特点的影响，所以在进行数据分片前，最好先理清楚数据的访问特点，并想明白是否确实需要分片。分片字段对性能的影响非常大，所以选择一个好的分片字段是非常重要的。Config节点对整个集群的健康运行是至关重要的，所以一旦你选择使用分片机制，就一定要保证有3个Config节点。永远不要删除Config节点的数据，要确保频繁地对这些数据进行日常备份。如果可能，通过域名来指定节点的地址，比如在/etc/hosts文件中指定相应的本地域名，这能让你在集群配置上更灵活。Config节点的压力很小，但还需运行在64位机器上。千万不要把3个Config节点都放在同一台机器上！&lt;/p&gt;

&lt;p&gt;另外，如果你要部署一个分片集群，那么可以向Engine
Yard专家服务预约咨询服务。&lt;/p&gt;

&lt;p&gt;使用Mongo MMS图形化监控服务。如果你还没有完善的MongoDB监控，可以尝试Mongo
MMS。Mongo
MMS是10gen官方发布的一个监控服务，可以将集群的各项健康指标以图形化的方式汇总展示。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>一张破图胜过长篇大论（译文：关于Windows 8的新编程体系）</title>
   <link href="http://beango.github.com/archives/2012/03/23/a-bad-picture-is-worth-a-thousand-long-discussions.html"/>
   <updated>2012-03-23T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/03/23/a-bad-picture-is-worth-a-thousand-long-discussions</id>
   <content type="html">&lt;p&gt;　　译者：linger(sysu大三 )&lt;/p&gt;

&lt;p&gt;　　注：本文是DOUG SEVEN写的关于Windows 8新的编程体系的一篇文章《&lt;a href=&quot;http://dougseven.com/2011/09/15/a-bad-picture-is-worth-a-thousand-long-discussions/&quot;&gt;A bad
picture is worth a thousand
long discussions&lt;/a&gt;》的译文。&lt;/p&gt;

&lt;p&gt;　　在Build会议中，我跟顾客，还有其他的参与者，Microsoft的mvp，Microsoft的地方主管，Microsoft的工程团队成员谈了很多。其中谈的最多的是，Windows
8的平台和工具的技术盒子图。如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-03/2012032322562391.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　现在我告诉你，我曾画过很多这种软件架构图，当然并不是很容易画出来的。这种图从技术的角度来说永不可能是精确的。显然没有一种简单的方式对这种复杂的系统来画一张技术上精确无误的框架图。结果是，你的框架图是会漏掉很多盒子的（漏掉很多在整个体系中实际存在的技术）。不幸的是，那正是这里所发生的事（Windows
8的技术盒子漏掉了一些实际存在的技术）。&lt;/p&gt;

&lt;p&gt;　　谈话中其中之一的话题是围绕着技术盒子中绿色部分（即是Metro风格的应用程序）为何没有出现.NET和CLR。是不是在Metro风格的应用程序中，VB，C#在编译和运行过程都不兼容WinRT？这意味着.NET框架的终结么？&lt;/p&gt;

&lt;p&gt;　　还有一些研究过二进制码的质疑是否有两个CLR。Windows 8究竟在搞什么呢？&lt;/p&gt;

&lt;p&gt;　　昨晚我跟.NET
CLR的团队的成员们交流过（这里不说出他们的名，不过请相信我，他们肯定明确知道这个体系是如何运行的），下面是一些内部消息。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;基本事实：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　只有一个CLR。每个应用程序或者应用程序池围绕着一个进程旋转，而CLR就是在该进程内部工作的。这意味着，同时运行的一个Metro风格的应用程序和一个桌面模式的应用程序用的是相同的CLR二进制码，只不过是CLR的两个不同的实例。&lt;/p&gt;

&lt;p&gt;　　.NET4.5在桌面模式的应用程序和Metro风格的应用程序都可以用到。不过有点不同。Metro风格的应用程序使用的是最适合称之为另一个.NET的Profile
（比如说桌面模式的应用程序使用的是.NET Client的Profile
，而Metro风格的应用程序使用的是.NET
Metro的Profile）。事实上并不是不相同，但在Metro风格的应用程序中.NET的实现像是另一个Profile一样。&lt;/p&gt;

&lt;p&gt;　　不管一个桌面模式的应用程序或者Metro风格的应用程序是不是.NET的app,
但都是编译成相同的MSIL（微软中间语言代码）。并不存在一个特殊的Windows
8的Metro的中间语言代码（就像CLR那样，只有一个MSIL）。&lt;/p&gt;

&lt;p&gt;　　下面是一张更准确的图（当然还是技术上不是精确的框架图）&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;/assets/files/2012-03/2012032323015116.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　在这张图中，你可以看到CLR和.NET4.5都用到了用C#和VB写的桌面模式的app(蓝色部分)和Metro风格的app（绿色部分）。Silverlight仍然只能在桌面模式作为IE的插件运用到（当然，离开浏览器，它在桌面模式下还是支持的）。这幅图中另一个新添加的是DirectX，原来第一张图是完全没有存在的。DirectX在高级app中是一种很重要的技术，比如游戏。DirectX使得C++可以访问控制GPU。&lt;/p&gt;

&lt;p&gt;　　最大的疑惑，正如我所提到的，是跨越了了蓝色部分和绿色部分的.NET的使用。为什么会存在.NET
Metro
Profile（我起的名）呢？因为Metro风格的app运行在一个特殊app的容器中，该容器限制了应用程序的访问权限，从而保护了终端用户，防止受到恶意程序的攻击。就本身而论，Metro
Profile其实是.NET Client
Profile的一个子集，只不过是去掉了一些app容器中对于Metro风格程序不允许的权限。开发者如果习惯了.NET的话，会发现很容易使用WinRT，就像是这样子的，有一些引用的集合，然后去使用那些集合中的成员。&lt;/p&gt;

&lt;p&gt;　　Additionally, some of the changes in the Metro Profile are to ensure
Metro style apps are constructed in the preferred way for touch-first
design and portable form factors.
（该句不知该怎么翻译）比如File.Create()。以前如果你使用.NET来创建一个新文件的话，你会使用File.Create(string
fileLocation) 在磁盘上创建一个新文件，然后使用一个stream
reader来创建以字符串形式存在的文本的内容。这是一个同步操作（你调用了该函数，进程就阻塞在那里，直到函数返回）。而如今的Metro风格的app的理念是，应该利用异步的编程来减少比如IO延迟之类的东西，比如上面提到的文件系统的操作。这意味着，.NET
Metro
Profile提供给你的不是同步操作FileCreate()。不过，你仍然可以调用File.Create()（或者是File.CreateNew()我也想不起来函数名），不过是异步操作。一旦回调函数被使用，你仍然可以打开一个stream
reader然后对文件的内容视作一个字符串来处理，就像你所做的那样。&lt;/p&gt;

&lt;p&gt;　　最后，所有这些意味着，你会有一些选择，但你不会因此牺牲多少。你仍然可以建立.NET和Silverlight的app，正如你所习惯的那样，当然他们还可以在Windows上跑很多年。如果你想建立一个Metro风格的app，你有四种选择：&lt;/p&gt;

&lt;p&gt;1.Xaml和.NET(C#或者VB)。你不会放弃很多.NET的东西（记住，你只是抛弃那些在app容器中所禁止的那些），你还可以使用WinRT来访问传感输入和其他的系统资源。&lt;/p&gt;

&lt;p&gt;2.Xaml和C++。你可以使用你在Xaml和C++的技能来使用WinRT。当然你就感觉不到了.NET的好处，不过，有些人喜欢管理自己程序的垃圾回收。&lt;/p&gt;

&lt;p&gt;3.Html和Javascript。你可以利用你在UI方面的能力，在Javascript中调用WinRT来访问系统资源和传感输入。&lt;/p&gt;

&lt;p&gt;4.DirectX和C++。如果你在开发一个刺激好玩的游戏，你可以利用DirectX和通过C++跟WinRT来访问设备传感器和系统资源。&lt;/p&gt;

&lt;p&gt;以上是译文，若那些译的不好，敬请指正。下面在提供一些关于Windows 8的编程链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blogs.microsoft.co.il/blogs/sasha/archive/2011/09/15/winrt-and-%20%20net-in-windows-8.aspx&quot;&gt;WinRT and .NET in Windows 8&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://ardalis.com/Analyzing-Windows-8-and-WinRT&quot;&gt;Analyzing Windows 8 and WinRT&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://dougseven.com/2011/09/15/a-bad-picture-is-worth-a-thousand-long-discussions/&quot;&gt;A bad picture is worth a thousand long discussions&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/7457371/why-is-winrt-unmanaged&quot;&gt;Why is WinRT unmanaged?&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>TokyoTyrant的管理工具tcrmgr使用</title>
   <link href="http://beango.github.com/archives/2012/03/12/tokyotyrant-tools-tcrmgr-usage.html"/>
   <updated>2012-03-12T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/03/12/tokyotyrant-tools-tcrmgr-usage</id>
   <content type="html">&lt;p&gt;&lt;li&gt;查看服务器统计信息&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tcrmgr inform -port 20000 -st 192.168.0.100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;写入数据&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tcrmgr put -port 20000 192.168.0.100 key1 value1  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;读取数据&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tcrmgr get -port 20000 192.168.0.100 key1  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;删除数据&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tcrmgr out -port 20000 192.168.0.100 key1  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;查看所有的key&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tcrmgr list -port 20000 192.168.0.100  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;清空所有数据&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tcrmgr vanish -port 20000  192.168.0.100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;备份数据&lt;/li&gt;
注意：路径是服务器上的绝对路径，否则显示“./tcrmgr: error: 9999:miscellaneous error”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tcrmgr copy -port 20000 192.168.0.100 /temp/test2.tch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;优化数据库文件&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tcrmgr optimize -port 20000 192.168.0.100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;同步内存数据到磁盘（没搞懂有什么特别之处，可能是当ttserver使用-uas参数异步写入日志的时候起作用）&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tcrmgr sync -port 20000 192.168.0.100 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;数据导入&lt;/li&gt;
注意：tsv格式的文件以TAB分隔，如：test2\tvalue2\n&lt;br/&gt;
注意：路径是本地路径，所以不必是绝对路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tcrmgr importtsv -port 20000 192.168.0.100 /data/ttserver/db.tsv 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;通过ulog日志恢复数据&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;注意：路径是服务器上的绝对路径  
tcrmgr restore -port 20000 192.168.0.100 /data/ttserver/ulog/00000010.ulog 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;打印更新日志（挂起，一直显示日志）&lt;/li&gt;
可能是用于实时查看ttserver有哪些操作，相当于tail -f&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tcrmgr repl -port 20000 -ph 192.168.0.100 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;下一个实验：启动一个带复制功能的ttserver，以前面启动的ttserver为master&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ttserver -host 192.168.0.100 -port 20001 -mhost 192.168.0.100 -mport 20000 -rcc -rts /data/ttserver/temp_1/test_1.rts -thnum 4 -dmn -ulim 1024m  -ulog /data/ttserver/temp_1/ -log /data/ttserver/temp_1/test_1.log -pid /data/ttserver/temp_1/test_1.pid -sid 10 /data/ttserver/temp_1/test_1.tch#bnum=1000#rcnum=0#xmsiz=0m 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;再启动一个普通的ttserver，不与其他服务器相关&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ttserver -host 192.168.0.100 -port 20002 -thnum 4 -dmn -ulim 1024m -ulog /data/ttserver/ulog_2/ -log /data/ttserver/temp_2/test_2.log -pid /data/ttserver/temp_2/test_2.pid -sid 11 /data/ttserver/temp_2/test_data_2.tch#bnum=1000#rcnum=0#xmsiz=0m 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;修改某个ttserver的master&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tcrmgr setmst -port 20001 -mport 20002 192.168.0.100 192.168.0.100  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：只有以复制方式启动的ttserver，修改master后才能从新的数据库复制数据&lt;br/&gt;
注意：每个ttserver只能有一个master，修改后，不能再从以前的master复制数据&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Memcached真的过时了吗？</title>
   <link href="http://beango.github.com/archives/2012/03/12/is-memcached-a-dinosaur-in-comparison-to-redis.html"/>
   <updated>2012-03-12T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/03/12/is-memcached-a-dinosaur-in-comparison-to-redis</id>
   <content type="html">&lt;p&gt;这两年&lt;a href=&quot;http://blog.nosqlfan.com/tags/redis&quot; title=&quot;查看 Redis 的全部文章&quot;&gt;Redis&lt;/a&gt;火得可以，Redis也常常被当作&lt;a href=&quot;http://blog.nosqlfan.com/tags/memcached&quot; title=&quot;查看 Memcached 的全部文章&quot;&gt;Memcached&lt;/a&gt;的挑战者被提到桌面上来。关于Redis与Memcached的比较更是比比皆是。然而，Redis真的在功能、性能以及内存使用效率上都超越了Memcached吗？&lt;/p&gt;

&lt;p&gt;下面内容来自Redis作者在stackoverflow上的一个回答，对应的问题是《&lt;a href=&quot;http://stackoverflow.com/questions/2873249/is-memcached-a-dinosaur-in-comparison-to-redis&quot;&gt;Is
memcached a dinosaur in comparison to
Redis?&lt;/a&gt;》（相比Redis，Memcached真的过时了吗？）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You should not care too much about performances. Redis is faster per
core with small values, but memcached is able to use multiple cores
with a single executable and TCP port without help from the client.
Also memcached is faster with big values in the order of 100k. Redis
recently improved a lot about big values (unstable branch) but still
memcached is faster in this use case. The point here is: nor one or
the other will likely going to be your bottleneck for the
query-per-second they can deliver.&lt;/li&gt;
&lt;li&gt;没有必要过多的关心性能，因为二者的性能都已经足够高了。由于Redis只使用单核，而Memcached可以使用多核，所以在比较上，平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。说了这么多，结论是，无论你使用哪一个，每秒处理请求的次数都不会成为瓶颈。（比如瓶颈可能会在网卡）&lt;/li&gt;
&lt;li&gt;You should care about memory usage. For simple key-value pairs
memcached is more memory efficient. If you use Redis hashes, Redis
is more memory efficient. Depends on the use case.&lt;/li&gt;
&lt;li&gt;如果要说内存使用效率，使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。当然，这和你的应用场景和数据特性有关。&lt;/li&gt;
&lt;li&gt;You should care about persistence and replication, two features only
available in Redis. Even if your goal is to build a cache it helps
that after an upgrade or a reboot your data are still there.&lt;/li&gt;
&lt;li&gt;如果你对数据持久化和数据同步有所要求，那么推荐你选择Redis，因为这两个特性Memcached都不具备。即使你只是希望在升级或者重启系统后缓存数据不会丢失，选择Redis也是明智的。&lt;/li&gt;
&lt;li&gt;You should care about the kind of operations you need. In Redis
there are a lot of complex operations, even just considering the
caching use case, you often can do a lot more in a single operation,
without requiring data to be processed client side (a lot of I/O is
sometimes needed). This operations are often as fast as plain GET
and SET. So if you don’t need just GEt/SET but more complex things
Redis can help a lot (think at timeline caching).&lt;/li&gt;
&lt;li&gt;当然，最后还得说到你的具体应用需求。Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果你需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;来源：&lt;a href=&quot;http://stackoverflow.com/questions/2873249/is-memcached-a-dinosaur-in-comparison-to-redis&quot;&gt;Is memcached a dinosaur in comparison to
Redis?&lt;/a&gt;（其他人的回答同样值得一看）&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java堆内存的10个要点</title>
   <link href="http://beango.github.com/archives/2012/02/20/java-heap-space-memory-size-jvm.html"/>
   <updated>2012-02-20T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/02/20/java-heap-space-memory-size-jvm</id>
   <content type="html">&lt;p&gt;当我开始学习Java编程时，我不知道什么是堆内存或堆空间，我甚至不知道当对象创建时，它们被放在了哪里。当我开始正式写一些程序后，我会经常遇到java.lang.outOfMemoryError的报错，之后我才开始关注什么是堆内存或者说堆空间(heap space)。对大多数程序员都经历过这样的过程，因为学习一种语言是非常容易来的，但是学习基础是非常难的，因为没有什么特定的流程让你学习编程的每个基础，使你发觉编程的秘诀。对于程序员来说，知道堆空间，设置堆空间，处理堆空间的outOfMemoryError错误，分析heap dump是非常重要的。这个关于Java堆的教程是给我刚开始学编程的兄弟看的。如果你知道这个基础知识或者知道底层发生了什么，当然可能帮助不是那么大。除非你知道了对象被创建在堆中，否则你不会意识到OutOfMemoryError是发生在堆空间中的。我尽可能的将我所知道的所有关于堆的知识都写下来了，也希望你们能够尽可能多的贡献和分享你的知识，以便可以让其他人也受益。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java中的堆空间是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当Java程序开始运行时，JVM会从操作系统获取一些内存。JVM使用这些内存，这些内存的一部分就是堆内存。堆内存通常在存储地址的底层，向上排列。当一个对象通过new关键字或通过其他方式创建后，对象从堆中获得内存。当对象不再使用了，被当做垃圾回收掉后，这些内存又重新回到堆内存中。要学习垃圾回收，请阅读”Java中垃圾回收的工作原理”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何增加Java堆空间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在大多数32位机、Sun的JVM上，Java的堆空间默认的大小为128MB，但也有例外，例如在32未Solaris操作系统(SPARC平台版本)上，默认的最大堆空间和起始堆空间大小为 -Xms=3670K 和 -Xmx=64M。对于64位操作系统，一般堆空间大小增加约30%。但你使用Java 1.5的throughput垃圾回收器，默认最大的堆大小为物理内存的四分之一，而起始堆大小为物理内存的十六分之一。要想知道默认的堆大小的方法，可以用默认的设置参数打开一个程序，使用JConsole(JDK 1.5之后都支持)来查看，在VM Summary页面可以看到最大的堆大小。&lt;/p&gt;

&lt;p&gt;用这种方法你可以根据你的程序的需要来改变堆内存大小，我强烈建议采用这种方法而不是默认值。如果你的程序很大，有很多对象需要被创建的话，你可以用-Xms and -Xmx这两个参数来改变堆内存的大小。Xms表示起始的堆内存大小，Xmx表示最大的堆内存的大小。另外有一个参数 -Xmn，它表示new generation（后面会提到）的大小。有一件事你需要注意，你不能任意改变堆内存的大小，你只能在启动JVM时设定它。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;堆和垃圾回收&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们知道对象创建在堆内存中，垃圾回收这样一个进程，它将已死对象清除出堆空间，并将这些内存再还给堆。为了给垃圾回收器使用，堆主要分成三个区域，分别叫作New Generation，Old Generation或叫Tenured Generation，以及Perm space。New Generation是用来存放新建的对象的空间，在对象新建的时候被使用。如果长时间还使用的话，它们会被垃圾回收器移动到Old Generation(或叫Tenured Generation)。Perm space是JVM存放Meta数据的地方，例如类，方法，字符串池和类级别的详细信息。你可以查看“Java中垃圾回收的工作原理”来获得更多关于堆和垃圾回收的信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java堆中的OutOfMemoryError错误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当JVM启动时，使用了-Xms参数设置的对内存。当程序继续进行，创建更多对象，JVM开始扩大堆内存以容纳更多对象。JVM也会使用垃圾回收器来回收内存。当快达到-Xmx设置的最大堆内存时，如果没有更多的内存可被分配给新对象的话，JVM就会抛出java.lang.outofmemoryerror，你的程序就会当掉。在抛出OutOfMemoryError之前，JVM会尝试着用垃圾回收器来释放足够的空间，但是发现仍旧没有足够的空间时，就会抛出这个错误。为了解决这个问题，你需要清楚你的程序对象的信息，例如，你创建了哪些对象，哪些对象占用了多少空间等等。你可以使用profiler或者堆分析器来处理OutOfMemoryError错误。”java.lang.OutOfMemoryError: Java heap space”表示堆没有足够的空间了，不能继续扩大了。”java.lang.OutOfMemoryError: PermGen space”表示permanent generation已经装满了，你的程序不能再装在类或者再分配一个字符串了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java Heap dump&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Heap dump是在某一时间对Java堆内存的快照。它对于分析堆内存或处理内存泄露和Java.lang.outofmemoryerror错误是非常有用的。在JDK中有一些工具可以帮你获取heap dump，也有一些堆分析工具来帮你分析heap dump。你可以用“jmap”来获取heap dump，它帮你创建heap dump文件，然后，你可以用“jhat”（堆分析工具）来分析这些heap dump。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java堆内存(heap memory)的十个要点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​1. Java堆内存是操作系统分配给JVM的内存的一部分。&lt;/p&gt;

&lt;p&gt;​2. 当我们创建对象时，它们存储在Java堆内存中。&lt;/p&gt;

&lt;p&gt;​3. 为了便于垃圾回收，Java堆空间分成三个区域，分别叫作New Generation, Old Generation或叫作Tenured Generation，还有Perm Space。&lt;/p&gt;

&lt;p&gt;​4. 你可以通过用JVM的命令行选项 -Xms, -Xmx, -Xmn来调整Java堆空间的大小。不要忘了在大小后面加上”M”或者”G”来表示单位。举个例子，你可以用-Xmx256m来设置堆内存最大的大小为256MB。&lt;/p&gt;

&lt;p&gt;​5. 你可以用JConsole或者 Runtime.maxMemory(), Runtime.totalMemory(), Runtime.freeMemory()来查看Java中堆内存的大小。&lt;/p&gt;

&lt;p&gt;​6. 你可以使用命令“jmap”来获得heap dump，用“jhat”来分析heap dump。&lt;/p&gt;

&lt;p&gt;​7. Java堆空间不同于栈空间，栈空间是用来储存调用栈和局部变量的。&lt;/p&gt;

&lt;p&gt;​8.Java垃圾回收器是用来将死掉的对象(不再使用的对象)所占用的内存回收回来，再释放到Java堆空间中。&lt;/p&gt;

&lt;p&gt;​9.当你遇到java.lang.outOfMemoryError时，不要紧张，有时候仅仅增加堆空间就可以了，但如果经常出现的话，就要看看Java程序中是不是存在内存泄露了。&lt;/p&gt;

&lt;p&gt;​10. 请使用Profiler和Heap dump分析工具来查看Java堆空间，可以查看给每个对象分配了多少内存。&lt;/p&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;http://javarevisited.blogspot.com/2011/05/java-heap-space-memory-size-jvm.html&quot;&gt;java revisited&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>理解Java对象序列化</title>
   <link href="http://beango.github.com/archives/2012/02/13/java-serializable.html"/>
   <updated>2012-02-13T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/02/13/java-serializable</id>
   <content type="html">&lt;p&gt;**
关于Java序列化的文章早已是汗牛充栋了，本文是对我个人过往学习，理解及应用Java序列化的一个总结。此文内容涉及Java序列化的基本原理，以及多种方法对序列化形式进行定制。在撰写本文时，既参考了Thinking in Java, Effective Java，JavaWorld，developerWorks中的相关文章和其它网络资料，也加入了自己的实践经验与理解，文、码并茂，希望对大家有所帮助。(2012.02.14最后更新)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 什么是Java对象序列化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能。&lt;/p&gt;

&lt;p&gt;使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的&quot;状态&quot;，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量。&lt;/p&gt;

&lt;p&gt;除了在持久化对象时会用到对象序列化之外，当使用RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用，在本文的后续章节中将会陆续讲到。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 简单示例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化。此处将创建一个可序列化的类Person，本文中的所有示例将围绕着该类或其修改版。
Gender类，是一个枚举类型，表示性别&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public enum Gender {
    MALE, FEMALE
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果熟悉Java枚举类型的话，应该知道每个枚举类型都会默认继承类java.lang.Enum，而该类实现了Serializable接口，所以枚举类型对象都是默认可以被序列化的。&lt;/p&gt;

&lt;p&gt;Person类，实现了Serializable接口，它包含三个字段：name，String类型；age，Integer类型；gender，Gender类型。另外，还重写该类的toString()方法，以方便打印Person实例中的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Person implements Serializable {
    private String name = null;
    private Integer age = null;
    private Gender gender = null;
    public Person() {
        System.out.println(&quot;none-arg constructor&quot;);
    }

    public Person(String name, Integer age, Gender gender) {
        System.out.println(&quot;arg constructor&quot;);
        this.name = name;
        this.age = age;
        this.gender = gender;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Gender getGender() {
        return gender;
    }

    public void setGender(Gender gender) {
        this.gender = gender;
    }

    @Override
    public String toString() {
        return &quot;[&quot; + name + &quot;, &quot; + age + &quot;, &quot; + gender + &quot;]&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SimpleSerial，是一个简单的序列化程序，它先将一个Person对象保存到文件person.out中，然后再从该文件中读出被存储的Person对象，并打印该对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SimpleSerial {

    public static void main(String[] args) throws Exception {
        File file = new File(&quot;person.out&quot;);

        ObjectOutputStream oout = new ObjectOutputStream(new FileOutputStream(file));
        Person person = new Person(&quot;John&quot;, 101, Gender.MALE);
        oout.writeObject(person);
        oout.close();

        ObjectInputStream oin = new ObjectInputStream(new FileInputStream(file));
        Object newPerson = oin.readObject(); // 没有强制转换到Person类型
        oin.close();
        System.out.println(newPerson);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述程序的输出的结果为：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  arg constructor&lt;br/&gt;
  [John, 31, MALE]&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;此时必须注意的是，当重新读取被保存的Person对象时，并没有调用Person的任何构造器，看起来就像是直接使用字节将Person对象还原出来的。
当Person对象被保存到person.out文件中之后，我们可以在其它地方去读取该文件以还原对象，但必须确保该读取程序的CLASSPATH中包含有Person.class(哪怕在读取Person对象时并没有显示地使用Person类，如上例所示)，否则会抛出ClassNotFoundException。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. Serializable的作用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为什么一个类实现了Serializable接口，它就可以被序列化呢？在上节的示例中，使用ObjectOutputStream来持久化对象，在该类中有如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void writeObject0(Object obj, boolean unshared) throws IOException {
    ...
    if (obj instanceof String) {
        writeString((String) obj, unshared);
    } else if (cl.isArray()) {
        writeArray(obj, desc, unshared);
    } else if (obj instanceof Enum) {
        writeEnum((Enum) obj, desc, unshared);
    } else if (obj instanceof Serializable) {
        writeOrdinaryObject(obj, desc, unshared);
    } else {
        if (extendedDebugInfo) {
            throw new NotSerializableException(cl.getName() + &quot;\n&quot;
                    + debugInfoStack.toString());
        } else {
            throw new NotSerializableException(cl.getName());
        }
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上述代码可知，如果被写对象的类型是String，或数组，或Enum，或Serializable，那么就可以对该对象进行序列化，否则将抛出NotSerializableException。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 默认序列化机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果仅仅只是让某个类实现Serializable接口，而没有其它任何处理的话，则就是使用默认序列化机制。使用默认机制，在序列化对象时，不仅会序列化当前对象本身，还会对该对象引用的其它对象也进行序列化，同样地，这些其它对象引用的另外对象也将被序列化，以此类推。所以，如果一个对象包含的成员变量是容器类对象，而这些容器所含有的元素也是容器类对象，那么这个序列化的过程就会较复杂，开销也较大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 影响序列化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在现实应用中，有些时候不能使用默认序列化机制。比如，希望在序列化过程中忽略掉敏感数据，或者简化序列化过程。下面将介绍若干影响序列化的方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.1 transient关键字&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当某个字段被声明为transient后，默认序列化机制就会忽略该字段。此处将Person类中的age字段声明为transient，如下所示，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Person implements Serializable {
    ...
    transient private Integer age = null;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再执行SimpleSerial应用程序，会有如下输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;   arg constructor  
&amp;gt;   [John, null, MALE]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，age字段未被序列化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.2 writeObject()方法与readObject()方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于上述已被声明为transitive的字段age，除了将transitive关键字去掉之外，是否还有其它方法能使它再次可被序列化？方法之一就是在Person类中添加两个方法：writeObject()与readObject()，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Person implements Serializable {
    ...
    transient private Integer age = null;
    ...

    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
        out.writeInt(age);
    }

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        age = in.readInt();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在writeObject()方法中会先调用ObjectOutputStream中的defaultWriteObject()方法，该方法会执行默认的序列化机制，如5.1节所述，此时会忽略掉age字段。然后再调用writeInt()方法显示地将age字段写入到ObjectOutputStream中。readObject()的作用则是针对对象的读取，其原理与writeObject()方法相同。
    再次执行SimpleSerial应用程序，则又会有如下输出：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  arg constructor&lt;br/&gt;
  [John, 31, MALE]&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;必须注意地是，writeObject()与readObject()都是private方法，那么它们是如何被调用的呢？毫无疑问，是使用反射。详情可见ObjectOutputStream中的writeSerialData方法，以及ObjectInputStream中的readSerialData方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.3 Externalizable接口&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;无论是使用transient关键字，还是使用writeObject()和readObject()方法，其实都是基于Serializable接口的序列化。JDK中提供了另一个序列化接口--Externalizable，使用该接口之后，之前基于Serializable接口的序列化机制就将失效。此时将Person类修改成如下，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Person implements Externalizable {

    private String name = null;
    transient private Integer age = null;
    private Gender gender = null;

    public Person() {
        System.out.println(&quot;none-arg constructor&quot;);
    }

    public Person(String name, Integer age, Gender gender) {
        System.out.println(&quot;arg constructor&quot;);
        this.name = name;
        this.age = age;
        this.gender = gender;
    }

    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
        out.writeInt(age);
    }

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        age = in.readInt();
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {

    }

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {

    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时再执行SimpleSerial程序之后会得到如下结果：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  arg constructor&lt;br/&gt;
  none-arg constructor&lt;br/&gt;
  [null, null, null]&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;从该结果，一方面可以看出Person对象中任何一个字段都没有被序列化。另一方面，如果细心的话，还可以发现这此次序列化过程调用了Person类的无参构造器。&lt;/p&gt;

&lt;p&gt;Externalizable继承于Serializable，当使用该接口时，序列化的细节需要由程序员去完成。如上所示的代码，由于writeExternal()与readExternal()方法未作任何处理，那么该序列化行为将不会保存/读取任何一个字段。这也就是为什么输出结果中所有字段的值均为空。&lt;/p&gt;

&lt;p&gt;另外，若使用Externalizable进行序列化，当读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。这就是为什么在此次序列化过程中Person类的无参构造器会被调用。由于这个原因，实现Externalizable接口的类必须要提供一个无参的构造器，且它的访问权限为public。&lt;/p&gt;

&lt;p&gt;对上述Person类作进一步的修改，使其能够对name与age字段进行序列化，但要忽略掉gender字段，如下代码所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Person implements Externalizable {

    private String name = null;
    transient private Integer age = null;
    private Gender gender = null;

    public Person() {
        System.out.println(&quot;none-arg constructor&quot;);
    }

    public Person(String name, Integer age, Gender gender) {
        System.out.println(&quot;arg constructor&quot;);
        this.name = name;
        this.age = age;
        this.gender = gender;
    }

    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
        out.writeInt(age);
    }

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        age = in.readInt();
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject(name);
        out.writeInt(age);
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        name = (String) in.readObject();
        age = in.readInt();
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行SimpleSerial之后会有如下结果：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  arg constructor&lt;br/&gt;
  none-arg constructor&lt;br/&gt;
  [John, 31, null]&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;5.4 readResolve()方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当我们使用Singleton模式时，应该是期望某个类的实例应该是唯一的，但如果该类是可序列化的，那么情况可能会略有不同。此时对第2节使用的Person类进行修改，使其实现Singleton模式，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Person implements Serializable {

    private static class InstanceHolder {
        private static final Person instatnce = new Person(&quot;John&quot;, 31, Gender.MALE);
    }

    public static Person getInstance() {
        return InstanceHolder.instatnce;
    }

    private String name = null;

    private Integer age = null;

    private Gender gender = null;

    private Person() {
        System.out.println(&quot;none-arg constructor&quot;);
    }

    private Person(String name, Integer age, Gender gender) {
        System.out.println(&quot;arg constructor&quot;);
        this.name = name;
        this.age = age;
        this.gender = gender;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时要修改SimpleSerial应用，使得能够保存/获取上述单例对象，并进行对象相等性比较，如下代码所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SimpleSerial {

    public static void main(String[] args) throws Exception {
        File file = new File(&quot;person.out&quot;);
        ObjectOutputStream oout = new ObjectOutputStream(new FileOutputStream(file));
        oout.writeObject(Person.getInstance()); // 保存单例对象
        oout.close();

        ObjectInputStream oin = new ObjectInputStream(new FileInputStream(file));
        Object newPerson = oin.readObject();
        oin.close();
        System.out.println(newPerson);

        System.out.println(Person.getInstance() == newPerson); // 将获取的对象与Person类中的单例对象进行相等性比较
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行上述应用程序后会得到如下结果：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  arg constructor&lt;br/&gt;
  [John, 31, MALE]&lt;br/&gt;
  false&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;值得注意的是，从文件person.out中获取的Person对象与Person类中的单例对象并不相等。为了能在序列化过程仍能保持单例的特性，可以在Person类中添加一个readResolve()方法，在该方法中直接返回Person的单例对象，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Person implements Serializable {

    private static class InstanceHolder {
        private static final Person instatnce = new Person(&quot;John&quot;, 31, Gender.MALE);
    }

    public static Person getInstance() {
        return InstanceHolder.instatnce;
    }

    private String name = null;

    private Integer age = null;

    private Gender gender = null;

    private Person() {
        System.out.println(&quot;none-arg constructor&quot;);
    }

    private Person(String name, Integer age, Gender gender) {
        System.out.println(&quot;arg constructor&quot;);
        this.name = name;
        this.age = age;
        this.gender = gender;
    }

    private Object readResolve() throws ObjectStreamException {
        return InstanceHolder.instatnce;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次执行本节的SimpleSerial应用后将有如下输出：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  arg constructor&lt;br/&gt;
  [John, 31, MALE]&lt;br/&gt;
  true&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;无论是实现Serializable接口，或是Externalizable接口，当从I/O流中读取对象时，readResolve()方法都会被调用到。实际上就是用readResolve()中返回的对象直接替换在反序列化过程中创建的对象，而被创建的对象则会被垃圾回收掉。
(持续更新中...)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>前端必读：浏览器内部工作原理</title>
   <link href="http://beango.github.com/archives/2012/02/09/How-browsers-work--Behind-the-scenes-of-modern-web-browsers.html"/>
   <updated>2012-02-09T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/02/09/How-browsers-work--Behind-the-scenes-of-modern-web-browsers</id>
   <content type="html">&lt;p&gt;　　目录&lt;/p&gt;

&lt;p&gt;　　一、&lt;a href=&quot;#chapter1&quot;&gt;介绍&lt;/a&gt;&lt;br/&gt;
　　二、&lt;a href=&quot;#chapter2&quot;&gt;渲染引擎&lt;/a&gt;&lt;br/&gt;
　　三、&lt;a href=&quot;#chapter3&quot;&gt;解析与DOM树构建&lt;/a&gt;&lt;br/&gt;
　　四、&lt;a href=&quot;#chapter4&quot;&gt;渲染树构建&lt;/a&gt;&lt;br/&gt;
　　五、&lt;a href=&quot;#chapter5&quot;&gt;布局&lt;/a&gt;&lt;br/&gt;
　　六、&lt;a href=&quot;#chapter6&quot;&gt;绘制&lt;/a&gt;&lt;br/&gt;
　　七、&lt;a href=&quot;#chapter7&quot;&gt;动态变化&lt;/a&gt;&lt;br/&gt;
　　八、&lt;a href=&quot;#chapter8&quot;&gt;渲染引擎的线程&lt;/a&gt;&lt;br/&gt;
　　九、&lt;a href=&quot;#chapter9&quot;&gt;CSS2可视模型&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　英文原文：&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/&quot;&gt;How Browsers Work: Behind the Scenes of Modern Web
Browsers&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;&lt;label id=&quot;chapter1&quot; /&gt;一、介绍&lt;/h2&gt;

&lt;p&gt;　　浏览器可以被认为是使用最广泛的软件，本文将介绍浏览器的工作原理，我们将看到，从你在地址栏输入google.com到你看到google主页过程中都发生了什么。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;将讨论的浏览器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　今天，有五种主流浏览器——IE、Firefox、Safari、Chrome及Opera。&lt;/p&gt;

&lt;p&gt;　　本文将基于一些开源浏览器的例子——Firefox、Chrome及Safari，Safari是部分开源的。&lt;/p&gt;

&lt;p&gt;　　根据W3C（World Wide Web
Consortium万维网联盟）的浏览器统计数据，当前（2011年5月），Firefox、Safari及Chrome的市场占有率综合已接近60％。（原文为2009年10月，数据没有太大变化）因此，可以说开源浏览器已经占据了浏览器市场的半壁江山。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;浏览器的主要功能&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　浏览器的主要功能是将用户选择的web资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF、image及其他格式。用户用URI（Uniform
Resource
Identifier统一资源标识符）来指定所请求资源的位置，在网络一章有更多讨论。&lt;/p&gt;

&lt;p&gt;　　HTML和CSS规范中规定了浏览器解释html文档的方式，由W3C组织对这些规范进行维护，W3C是负责制定web标准的组织。&lt;/p&gt;

&lt;p&gt;　　HTML规范的最新版本是HTML4(http://www.w3.org/TR/html401/)，HTML5还在制定中（译注：两年前），最新的CSS规范版本是2（http://www.w3.org/TR/CSS2），CSS3也还正在制定中（译注：同样两年前）。&lt;/p&gt;

&lt;p&gt;　　这些年来，浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为web开发者带来了严重的兼容性问题。&lt;/p&gt;

&lt;p&gt;　　但是，浏览器的用户界面则差不多，常见的用户界面元素包括：&lt;/p&gt;

&lt;p&gt;　　1. 用来输入URI的地址栏&lt;/p&gt;

&lt;p&gt;　　2. 前进、后退按钮&lt;/p&gt;

&lt;p&gt;　　3. 书签选项&lt;/p&gt;

&lt;p&gt;　　4. 用于刷新及暂停当前加载文档的刷新、暂停按钮&lt;/p&gt;

&lt;p&gt;　　5. 用于到达主页的主页按钮&lt;/p&gt;

&lt;p&gt;　　奇怪的是，并没有哪个正式公布的规范对用户界面做出规定，这些是多年来各浏览器厂商之间相互模仿和不断改进的结果。&lt;/p&gt;

&lt;p&gt;　　HTML5并没有规定浏览器必须具有的UI元素，但列出了一些常用元素，包括地址栏、状态栏及工具栏。还有一些浏览器有自己专有的功能，比如Firefox的下载管理。更多相关内容将在后面讨论用户界面时介绍。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;浏览器的主要构成（High Level Structure）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　浏览器的主要组件包括：&lt;/p&gt;

&lt;p&gt;　　1. 用户界面 －
包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分。&lt;/p&gt;

&lt;p&gt;　　2. 浏览器引擎 － 用来查询及操作渲染引擎的接口。&lt;/p&gt;

&lt;p&gt;　　3. 渲染引擎 －
用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来。&lt;/p&gt;

&lt;p&gt;　　4. 网络 －
用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作。&lt;/p&gt;

&lt;p&gt;　　5. UI后端 －
用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。&lt;/p&gt;

&lt;p&gt;　　6. JS解释器 － 用来解释执行JS代码。&lt;/p&gt;

&lt;p&gt;　　7. 数据存储 －
属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web
database技术，这是一种轻量级完整的客户端存储技术&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316262567.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;图1：浏览器主要组件&lt;/center&gt;


&lt;p&gt;　　需要注意的是，不同于大部分浏览器，Chrome为每个Tab分配了各自的渲染引擎实例，每个Tab就是一个独立的进程。&lt;/p&gt;

&lt;p&gt;　　对于构成浏览器的这些组件，后面会逐一详细讨论。&lt;/p&gt;

&lt;h2&gt;&lt;label id=&quot;chapter2&quot; /&gt;二、渲染引擎（The rendering engine）&lt;/h2&gt;

&lt;p&gt;　　渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。&lt;/p&gt;

&lt;p&gt;　　默认情况下，渲染引擎可以显示html、xml文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用PDF阅读器插件，可以显示PDF格式，将由专门一章讲解插件及扩展，这里只讨论渲染引擎最主要的用途——显示应用了CSS之后的html及图片。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;渲染引擎简介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　本文所讨论的浏览器——Firefox、Chrome和Safari是基于两种渲染引擎构建的，Firefox使用Geoko——Mozilla自主研发的渲染引擎，Safari和Chrome都使用webkit。&lt;/p&gt;

&lt;p&gt;　　Webkit是一款开源渲染引擎，它本来是为Linux平台研发的，后来由Apple移植到Mac及Windows上，相关内容请参考&lt;a href=&quot;http://webkit.org/&quot;&gt;http://webkit.org&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;渲染主流程（The main flow）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　渲染引擎首先通过网络获得所请求文档的内容，通常以8K分块的方式完成。&lt;/p&gt;

&lt;p&gt;　　下面是渲染引擎在取得内容之后的基本流程：&lt;/p&gt;

&lt;p&gt;　　解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt;
绘制render树&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316263715.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;图2：渲染引擎基本流程&lt;/center&gt;


&lt;p&gt;　　渲染引擎开始解析html，并将标签转化为内容树中的dom节点。接着，它解析外部CSS文件及style标签中的样式信息。这些样式信息以及html中的可见性指令将被用来构建另一棵树——render树。&lt;/p&gt;

&lt;p&gt;　　Render树由一些包含有颜色和大小等属性的矩形组成，它们将被按照正确的顺序显示到屏幕上。&lt;/p&gt;

&lt;p&gt;　　Render树构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标。再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。&lt;/p&gt;

&lt;p&gt;　　值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316264892.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;图3：webkit主流程&lt;/center&gt;


&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316270146.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;图4：Mozilla的Geoko渲染引擎主流程&lt;/center&gt;


&lt;p&gt;　　从图3和4中可以看出，尽管webkit和Gecko使用的术语稍有不同，他们的主要流程基本相同。Gecko称可见的格式化元素组成的树为frame树，每个元素都是一个frame，webkit则使用render树这个名词来命名由渲染对象组成的树。Webkit中元素的定位称为布局，而Gecko中称为回流。Webkit称利用dom节点及样式信息去构建render树的过程为attachment，Gecko在html和dom树之间附加了一层，这层称为内容接收器，相当制造dom元素的工厂。下面将讨论流程中的各个阶段。&lt;/p&gt;

&lt;h2&gt;&lt;label id=&quot;chapter3&quot; /&gt;三、解析与DOM树构建（Parsing and DOM tree construction）&lt;/h2&gt;

&lt;p&gt;　　&lt;strong&gt;解析（Parsing－general）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　既然解析是渲染引擎中一个非常重要的过程，我们将稍微深入的研究它。首先简要介绍一下解析。&lt;/p&gt;

&lt;p&gt;　　解析一个文档即将其转换为具有一定意义的结构——编码可以理解和使用的东西。解析的结果通常是表达文档结构的节点树，称为解析树或语法树。&lt;/p&gt;

&lt;p&gt;　　例如，解析&quot;2＋3－1&quot;这个表达式，可能返回这样一棵树。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316271310.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;图5：数学表达式树节点&lt;/center&gt;


&lt;p&gt;　　&lt;strong&gt;文法（Grammars）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　解析基于文档依据的语法规则——文档的语言或格式。每种可被解析的格式必须具有由词汇及语法规则组成的特定的文法，称为上下文无关文法。人类语言不具有这一特性，因此不能被一般的解析技术所解析。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;解析器－词法分析器（Parser－Lexer combination）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　解析可以分为两个子过程——语法分析及词法分析&lt;/p&gt;

&lt;p&gt;　　词法分析就是将输入分解为符号，符号是语言的词汇表——基本有效单元的集合。对于人类语言来说，它相当于我们字典中出现的所有单词。&lt;/p&gt;

&lt;p&gt;　　语法分析指对语言应用语法规则。&lt;/p&gt;

&lt;p&gt;　　解析器一般将工作分配给两个组件——词法分析器（有时也叫分词器）负责将输入分解为合法的符号，解析器则根据语言的语法规则分析文档结构，从而构建解析树，词法分析器知道怎么跳过空白和换行之类的无关字符。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316272491.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;图6：从源文档到解析树&lt;/center&gt;


&lt;p&gt;　　解析过程是迭代的，解析器从词法分析器处取到一个新的符号，并试着用这个符号匹配一条语法规则，如果匹配了一条规则，这个符号对应的节点将被添加到解析树上，然后解析器请求另一个符号。如果没有匹配到规则，解析器将在内部保存该符号，并从词法分析器取下一个符号，直到所有内部保存的符号能够匹配一项语法规则。如果最终没有找到匹配的规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;转换（Translation）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　很多时候，解析树并不是最终结果。解析一般在转换中使用——将输入文档转换为另一种格式。编译就是个例子，编译器在将一段源码编译为机器码的时候，先将源码解析为解析树，然后将该树转换为一个机器码文档。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316274796.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;图7：编译流程&lt;/center&gt;


&lt;p&gt;　　&lt;strong&gt;解析实例Parsing example&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　图5中，我们从一个数学表达式构建了一个解析树，这里定义一个简单的数学语言来看下解析过程。&lt;/p&gt;

&lt;p&gt;　　词汇表：我们的语言包括整数、加号及减号。&lt;/p&gt;

&lt;p&gt;　　语法：&lt;/p&gt;

&lt;p&gt;　　1. 该语言的语法基本单元包括表达式、term及操作符&lt;/p&gt;

&lt;p&gt;　　2. 该语言可以包括多个表达式&lt;/p&gt;

&lt;p&gt;　　3. 一个表达式定义为两个term通过一个操作符连接&lt;/p&gt;

&lt;p&gt;　　4. 操作符可以是加号或减号&lt;/p&gt;

&lt;p&gt;　　5. term可以是一个整数或一个表达式&lt;/p&gt;

&lt;p&gt;　　现在来分析一下&quot;2＋3－1&quot;这个输入&lt;/p&gt;

&lt;p&gt;　　第一个匹配规则的子字符串是&quot;2&quot;，根据规则5，它是一个term，第二个匹配的是&quot;2+3&quot;，它符合第2条规则——一个操作符连接两个term，下一次匹配发生在输入的结束处。&quot;2+3-1&quot;是一个表达式，因为我们已经知道&quot;2+3&quot;是一个term，所以我们有了一个term紧跟着一个操作符及另一个term。&quot;2++&quot;将不会匹配任何规则，因此是一个无效输入。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;词汇表及语法的定义&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　词汇表通常利用正则表达式来定义。&lt;/p&gt;

&lt;p&gt;　　例如上面的语言可以定义为：&lt;/p&gt;

&lt;p&gt;　　INTEGER：0｜［1－9］［0－9］＊&lt;/p&gt;

&lt;p&gt;　　PLUS：+&lt;/p&gt;

&lt;p&gt;　　MINUS：－&lt;/p&gt;

&lt;p&gt;　　正如看到的，这里用正则表达式定义整数。&lt;/p&gt;

&lt;p&gt;　　语法通常用BNF格式定义，我们的语言可以定义为：&lt;/p&gt;

&lt;p&gt;　　expression :＝ term operation term&lt;/p&gt;

&lt;p&gt;　　operation := PLUS | MINUS&lt;/p&gt;

&lt;p&gt;　　term := INTEGER | expression&lt;/p&gt;

&lt;p&gt;　　如果一个语言的文法是上下文无关的，则它可以用正则解析器来解析。对上下文无关文法的一个直观的定义是，该文法可以用BNF来完整的表达。可查看&lt;a href=&quot;http://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;http://en.wikipedia.org/wiki/Context-free_grammar&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;解析器类型（Types of parsers）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　有两种基本的解析器——自顶向下解析及自底向上解析。比较直观的解释是，自顶向下解析，查看语法的最高层结构并试着匹配其中一个；自底向上解析则从输入开始，逐步将其转换为语法规则，从底层规则开始直到匹配高层规则。&lt;/p&gt;

&lt;p&gt;　　来看一下这两种解析器如何解析上面的例子：&lt;/p&gt;

&lt;p&gt;　　自顶向下解析器从最高层规则开始——它先识别出&quot;2+3&quot;，将其视为一个表达式，然后识别出&quot;2+3-1&quot;为一个表达式（识别表达式的过程中匹配了其他规则，但出发点是最高层规则）。&lt;/p&gt;

&lt;p&gt;　　自底向上解析会扫描输入直到匹配了一条规则，然后用该规则取代匹配的输入，直到解析完所有输入。部分匹配的表达式被放置在解析堆栈中。&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; align=&quot;center&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p style=&quot;text-align: center;&quot; align=&quot;center&quot;&gt;&lt;strong&gt;Stack&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;Input&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;2 + 3 – 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p&gt;term&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;+ 3 - 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p&gt;term operation&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;3 – 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p&gt;expression&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;- 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p&gt;expression operation&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p&gt;expression&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;　　自底向上解析器称为shift
reduce解析器，因为输入向右移动（想象一个指针首先指向输入开始处，并向右移动），并逐渐简化为语法规则。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;自动化解析（Generating parsers automatically）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　解析器生成器这个工具可以自动生成解析器，只需要指定语言的文法——词汇表及语法规则，它就可以生成一个解析器。创建一个解析器需要对解析有深入的理解，而且手动的创建一个由较好性能的解析器并不容易，所以解析生成器很有用。Webkit使用两个知名的解析生成器——用于创建语法分析器的Flex及创建解析器的Bison（你可能接触过Lex和Yacc）。Flex的输入是一个包含了符号定义的正则表达式，Bison的输入是用BNF格式表示的语法规则。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;HTML解析器（HTML Parser）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　HTML解析器的工作是将html标识解析为解析树。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;HTML文法定义（The HTML grammar definition）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　W3C组织制定规范定义了HTML的词汇表和语法。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;非上下文无关文法（Not a context free grammar）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　正如在解析简介中提到的，上下文无关文法的语法可以用类似BNF的格式来定义。&lt;/p&gt;

&lt;p&gt;　　不幸的是，所有的传统解析方式都不适用于html（当然我提出它们并不只是因为好玩，它们将用来解析css和js），html不能简单的用解析所需的上下文无关文法来定义。&lt;/p&gt;

&lt;p&gt;　　Html有一个正式的格式定义——DTD（Document Type
Definition文档类型定义）——但它并不是上下文无关文法，html更接近于xml，现在有很多可用的xml解析器，html有个xml的变体——xhtml，它们间的不同在于，html更宽容，它允许忽略一些特定标签，有时可以省略开始或结束标签。总的来说，它是一种soft语法，不像xml呆板、固执。&lt;/p&gt;

&lt;p&gt;　　显然，这个看起来很小的差异却带来了很大的不同。一方面，这是html流行的原因——它的宽容使web开发人员的工作更加轻松，但另一方面，这也使很难去写一个格式化的文法。所以，html的解析并不简单，它既不能用传统的解析器解析，也不能用xml解析器解析。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;HTML DTD&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　Html适用DTD格式进行定义，这一格式是用于定义SGML家族的语言，包括了对所有允许元素及它们的属性和层次关系的定义。正如前面提到的，html
DTD并没有生成一种上下文无关文法。&lt;/p&gt;

&lt;p&gt;　　DTD有一些变种，标准模式只遵守规范，而其他模式则包含了对浏览器过去所使用标签的支持，这么做是为了兼容以前内容。最新的标准DTD在&lt;a href=&quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;http://www.w3.org/TR/html4/strict.dtd&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;DOM&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　输出的树，也就是解析树，是由DOM元素及属性节点组成的。DOM是文档对象模型的缩写，它是html文档的对象表示，作为html元素的外部接口供js等调用。&lt;/p&gt;

&lt;p&gt;　　树的根是&quot;document&quot;对象。&lt;/p&gt;

&lt;p&gt;　　DOM和标签基本是一一对应的关系，例如，如下的标签：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;Hello DOM&amp;lt;/p&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;img src=&quot;example.png&quot; /&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　将会被转换为下面的DOM树：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316280265.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;图8：示例标签对应的DOM树&lt;/center&gt;


&lt;p&gt;　　和html一样，DOM的规范也是由W3C组织制定的。访问&lt;a href=&quot;http://www.w3.org/DOM/DOMTR&quot;&gt;http://www.w3.org/DOM/DOMTR&lt;/a&gt;，这是使用文档的一般规范。一个模型描述一种特定的html元素，可以在&lt;a href=&quot;http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.htm&quot;&gt;http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.htm&lt;/a&gt;查看html定义。&lt;/p&gt;

&lt;p&gt;　　这里所谓的树包含了DOM节点是说树是由实现了DOM接口的元素构建而成的，浏览器使用已被浏览器内部使用的其他属性的具体实现。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;解析算法（The parsing algorithm）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　正如前面章节中讨论的，hmtl不能被一般的自顶向下或自底向上的解析器所解析。&lt;/p&gt;

&lt;p&gt;　　原因是：&lt;/p&gt;

&lt;p&gt;　　1. 这门语言本身的宽容特性&lt;/p&gt;

&lt;p&gt;　　2. 浏览器对一些常见的非法html有容错机制&lt;/p&gt;

&lt;p&gt;　　3.
解析过程是往复的，通常源码不会在解析过程中发生改变，但在html中，脚本标签包含的&quot;document.write&quot;可能添加标签，这说明在解析过程中实际上修改了输入。&lt;/p&gt;

&lt;p&gt;　　不能使用正则解析技术，浏览器为html定制了专属的解析器。&lt;/p&gt;

&lt;p&gt;　　Html5规范中描述了这个解析算法，算法包括两个阶段——符号化及构建树。&lt;/p&gt;

&lt;p&gt;　　符号化是词法分析的过程，将输入解析为符号，html的符号包括开始标签、结束标签、属性名及属性值。&lt;/p&gt;

&lt;p&gt;　　符号识别器识别出符号后，将其传递给树构建器，并读取下一个字符，以识别下一个符号，这样直到处理完所有输入。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316282058.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;图9：HTML解析流程&lt;/center&gt;


&lt;p&gt;　　&lt;strong&gt;符号识别算法（The tokenization algorithm）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　算法输出html符号，该算法用状态机表示。每次读取输入流中的一个或多个字符，并根据这些字符转移到下一个状态，当前的符号状态及构建树状态共同影响结果，这意味着，读取同样的字符，可能因为当前状态的不同，得到不同的结果以进入下一个正确的状态。&lt;/p&gt;

&lt;p&gt;　　这个算法很复杂，这里用一个简单的例子来解释这个原理。&lt;/p&gt;

&lt;p&gt;　　基本示例——符号化下面的html：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;Hello world&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　初始状态为&quot;Data State&quot;，当遇到&quot;&amp;lt;&quot;字符，状态变为&quot;Tag open
state&quot;，读取一个a－z的字符将产生一个开始标签符号，状态相应变为&quot;Tag name
state&quot;，一直保持这个状态直到读取到&quot;&gt;&quot;，每个字符都附加到这个符号名上，例子中创建的是一个html符号。&lt;/p&gt;

&lt;p&gt;　　当读取到&quot;&gt;&quot;，当前的符号就完成了，此时，状态回到&quot;Data
state&quot;，&quot;&amp;lt;body&gt;&quot;重复这一处理过程。到这里，html和body标签都识别出来了。现在，回到&quot;Data
state&quot;，读取&quot;Hello
world&quot;中的字符&quot;H&quot;将创建并识别出一个字符符号，这里会为&quot;Hello
world&quot;中的每个字符生成一个字符符号。&lt;/p&gt;

&lt;p&gt;　　这样直到遇到&quot;&amp;lt;/body&gt;&quot;中的&quot;&amp;lt;&quot;。现在，又回到了&quot;Tag open
state&quot;，读取下一个字符&quot;/&quot;将创建一个闭合标签符号，并且状态转移到&quot;Tag name
state&quot;，还是保持这一状态，直到遇到&quot;&gt;&quot;。然后，产生一个新的标签符号并回到&quot;Data
state&quot;。后面的&quot;&amp;lt;/html&gt;&quot;将和&quot;&amp;lt;/body&gt;&quot;一样处理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316283115.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;图10：符号化示例输入&lt;/center&gt;


&lt;p&gt;　　&lt;strong&gt;树的构建算法（Tree construction algorithm）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在树的构建阶段，将修改以Document为根的DOM树，将元素附加到树上。每个由符号识别器识别生成的节点将会被树构造器进行处理，规范中定义了每个符号相对应的Dom元素，对应的Dom元素将会被创建。这些元素除了会被添加到Dom树上，还将被添加到开放元素堆栈中。这个堆栈用来纠正嵌套的未匹配和未闭合标签，这个算法也是用状态机来描述，所有的状态采用插入模式。&lt;/p&gt;

&lt;p&gt;　　来看一下示例中树的创建过程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;Hello world&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　构建树这一阶段的输入是符号识别阶段生成的符号序列。&lt;/p&gt;

&lt;p&gt;　　首先是&quot;initial mode&quot;，接收到html符号后将转换为&quot;before
html&quot;模式，在这个模式中对这个符号进行再处理。此时，创建了一个HTMLHtmlElement元素，并将其附加到根Document对象上。&lt;/p&gt;

&lt;p&gt;　　状态此时变为&quot;before
head&quot;，接收到body符号时，即使这里没有head符号，也将自动创建一个HTMLHeadElement元素并附加到树上。&lt;/p&gt;

&lt;p&gt;　　现在，转到&quot;in head&quot;模式，然后是&quot;after
head&quot;。到这里，body符号会被再次处理，将创建一个HTMLBodyElement并插入到树中，同时，转移到&quot;in
body&quot;模式。&lt;/p&gt;

&lt;p&gt;　　然后，接收到字符串&quot;Hello
world&quot;的字符符号，第一个字符将导致创建并插入一个text节点，其他字符将附加到该节点。&lt;/p&gt;

&lt;p&gt;　　接收到body结束符号时，转移到&quot;after
body&quot;模式，接着接收到html结束符号，这个符号意味着转移到了&quot;after after
body&quot;模式，当接收到文件结束符时，整个解析过程结束。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316284511.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;图11：示例html树的构建过程&lt;/center&gt;


&lt;p&gt;　　&lt;strong&gt;解析结束时的处理（Action when the parsing is finished）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在这个阶段，浏览器将文档标记为可交互的，并开始解析处于延时模式中的脚本——这些脚本在文档解析后执行。&lt;/p&gt;

&lt;p&gt;　　文档状态将被设置为完成，同时触发一个load事件。&lt;/p&gt;

&lt;p&gt;　　Html5规范中有符号化及构建树的完整算法(http://www.w3.org/TR/html5/syntax.html#html-parser)。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;浏览器容错（Browsers error tolerance）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　你从来不会在一个html页面上看到&quot;无效语法&quot;这样的错误，浏览器修复了无效内容并继续工作。&lt;/p&gt;

&lt;p&gt;　　以下面这段html为例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;mytag&amp;gt;&amp;lt;/mytag&amp;gt;
  &amp;lt;div&amp;gt;&amp;lt;p&amp;gt;&amp;lt;/div&amp;gt;Really lousy HTML&amp;lt;/p&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　这段html违反了很多规则（mytag不是合法的标签，p及div错误的嵌套等等），但是浏览器仍然可以没有任何怨言的继续显示，它在解析的过程中修复了html作者的错误。&lt;/p&gt;

&lt;p&gt;　　浏览器都具有错误处理的能力，但是，另人惊讶的是，这并不是html最新规范的内容，就像书签及前进后退按钮一样，它只是浏览器长期发展的结果。一些比较知名的非法html结构，在许多站点中出现过，浏览器都试着以一种和其他浏览器一致的方式去修复。&lt;/p&gt;

&lt;p&gt;　　Html5规范定义了这方面的需求，webkit在html解析类开始部分的注释中做了很好的总结。&lt;/p&gt;

&lt;p&gt;　　解析器将符号化的输入解析为文档并创建文档，但不幸的是，我们必须处理很多没有很好格式化的html文档，至少要小心下面几种错误情况。&lt;/p&gt;

&lt;p&gt;　　1.在未闭合的标签中添加明确禁止的元素。这种情况下，应该先将前一标签闭合&lt;/p&gt;

&lt;p&gt;　　2.不能直接添加元素。有些人在写文档的时候会忘了中间一些标签（或者中间标签是可选的），比如HTML
HEAD BODY TR TD LI等&lt;/p&gt;

&lt;p&gt;　　3.想在一个行内元素中添加块状元素。关闭所有的行内元素，直到下一个更高的块状元素&lt;/p&gt;

&lt;p&gt;　　4. 如果这些都不行，就闭合当前标签直到可以添加该元素。&lt;/p&gt;

&lt;p&gt;　　下面来看一些webkit容错的例子：&lt;/p&gt;

&lt;p&gt;　　&amp;lt;/br&gt;替代&amp;lt;br&gt;&lt;/p&gt;

&lt;p&gt;　　一些网站使用&amp;lt;/br&gt;替代&amp;lt;br&gt;，为了兼容IE和Firefox，webkit将其看作&amp;lt;br&gt;。&lt;/p&gt;

&lt;p&gt;　　代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (t-&amp;gt;isCloseTag(brTag) &amp;amp;&amp;amp; m_document-&amp;gt;inCompatMode()) {
  reportError(MalformedBRError);
  t-&amp;gt;beginTag = true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　Note －这里的错误处理在内部进行，用户看不到。&lt;/p&gt;

&lt;p&gt;　　迷路的表格&lt;/p&gt;

&lt;p&gt;　　这指一个表格嵌套在另一个表格中，但不在它的某个单元格内。&lt;/p&gt;

&lt;p&gt;　　比如下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;table&amp;gt;
  &amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;inner table&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
  &amp;lt;/table&amp;gt;
  &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;outer table&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　webkit将会将嵌套的表格变为两个兄弟表格：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;table&amp;gt;
  &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;outer table&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;table&amp;gt;
  &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;inner table&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (m_inStrayTableContent &amp;amp;&amp;amp; localName == tableTag)
  popBlock(tableTag);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　webkit使用堆栈存放当前的元素内容，它将从外部表格的堆栈中弹出内部的表格，则它们变为了兄弟表格。&lt;/p&gt;

&lt;p&gt;　　嵌套的表单元素&lt;/p&gt;

&lt;p&gt;　　用户将一个表单嵌套到另一个表单中，则第二个表单将被忽略。&lt;/p&gt;

&lt;p&gt;　　代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!m_currentFormElement) {
  m_currentFormElement = new HTMLFormElement(formTag,m_document);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　太深的标签继承&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;http://www.liceo.edu.mx/&quot;&gt;www.liceo.edu.mx&lt;/a&gt;是一个由嵌套层次的站点的例子，最多只允许20个相同类型的标签嵌套，多出来的将被忽略。&lt;/p&gt;

&lt;p&gt;　　代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool HTMLParser::allowNestedRedundantTag(const AtomicString&amp;amp; tagName)
{
  unsigned i = 0;
  for (HTMLStackElem* curr = m_blockStack;
  i &amp;lt; cMaxRedundantTagDepth &amp;amp;&amp;amp; curr &amp;amp;&amp;amp; curr-&amp;gt;tagName == tagName;
  curr = curr-&amp;gt;next, i++) { }
  return i != cMaxRedundantTagDepth;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　放错了地方的html、body闭合标签&lt;/p&gt;

&lt;p&gt;　　又一次不言自明。&lt;/p&gt;

&lt;p&gt;　　支持不完整的html。我们从来不闭合body，因为一些愚蠢的网页总是在还未真正结束时就闭合它。我们依赖调用end方法去执行关闭的处理。&lt;/p&gt;

&lt;p&gt;　　代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (t-&amp;gt;tagName == htmlTag || t-&amp;gt;tagName == bodyTag )
  return;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　所以，web开发者要小心了，除非你想成为webkit容错代码的范例，否则还是写格式良好的html吧。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;CSS解析（CSS parsing）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　还记得简介中提到的解析的概念吗，不同于html，css属于上下文无关文法，可以用前面所描述的解析器来解析。Css规范定义了css的词法及语法文法。&lt;/p&gt;

&lt;p&gt;　　看一些例子：&lt;/p&gt;

&lt;p&gt;　　每个符号都由正则表达式定义了词法文法（词汇表）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;comment///*[^*]*/*+([^/*][^*]*/*+)*//
num[0-9]+|[0-9]*&quot;.&quot;[0-9]+
nonascii[/200-/377]
nmstart[_a-z]|{nonascii}|{escape}
nmchar[_a-z0-9-]|{nonascii}|{escape}
name{nmchar}+
ident{nmstart}{nmchar}*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　&quot;ident&quot;是识别器的缩写，相当于一个class名，&quot;name&quot;是一个元素id（用&quot;＃&quot;引用）。&lt;/p&gt;

&lt;p&gt;　　语法用BNF进行描述：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ruleset
: selector [ ',' S* selector ]*
'{' S* declaration [ ';' S* declaration ]* '}' S*
;
selector
: simple_selector [ combinator selector | S+ [ combinator selector ] ]
;
simple_selector
: element_name [ HASH | class | attrib | pseudo ]*
| [ HASH | class | attrib | pseudo ]+
;
class
: '.' IDENT
;
element_name
: IDENT | '*'
;
attrib
: '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S*
[ IDENT | STRING ] S* ] ']'
;
pseudo
: ':' [ IDENT | FUNCTION S* [IDENT S*] ')' ]
;
说明：一个规则集合有这样的结构
div.error , a.error {
color:red;
font-weight:bold;
}
div.error和a.error时选择器，大括号中的内容包含了这条规则集合中的规则，这个结构在下面的定义中正式的定义了：
ruleset
: selector [ ',' S* selector ]*
'{' S* declaration [ ';' S* declaration ]* '}' S*
;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　这说明，一个规则集合具有一个或是可选个数的多个选择器，这些选择器以逗号和空格（S表示空格）进行分隔。每个规则集合包含大括号及大括号中的一条或多条以分号隔开的声明。声明和选择器在后面进行定义。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;Webkit CSS解析器（Webkit CSS parser）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　Webkit使用Flex和Bison解析生成器从CSS语法文件中自动生成解析器。回忆一下解析器的介绍，Bison创建一个自底向上的解析器，Firefox使用自顶向下解析器。它们都是将每个css文件解析为样式表对象，每个对象包含css规则，css规则对象包含选择器和声明对象，以及其他一些符合css语法的对象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316290151.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;图12：解析css&lt;/center&gt;


&lt;p&gt;　　&lt;strong&gt;处理脚本及样式表的顺序（The order of processing scripts and style sheets）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;脚本&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　web的模式是同步的，开发者希望解析到一个script标签时立即解析执行脚本，并阻塞文档的解析直到脚本执行完。如果脚本是外引的，则网络必须先请求到这个资源——这个过程也是同步的，会阻塞文档的解析直到资源被请求到。这个模式保持了很多年，并且在html4及html5中都特别指定了。开发者可以将脚本标识为defer，以使其不阻塞文档解析，并在文档解析结束后执行。Html5增加了标记脚本为异步的选项，以使脚本的解析执行使用另一个线程。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;预解析（Speculative parsing）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　Webkit和Firefox都做了这个优化，当执行脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变Dom树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;样式表（Style sheets）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　样式表采用另一种不同的模式。理论上，既然样式表不改变Dom树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，脚本可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题，这看起来是个边缘情况，但确实很常见。Firefox在存在样式表还在加载和解析时阻塞所有的脚本，而Chrome只在当脚本试图访问某些可能被未加载的样式表所影响的特定的样式属性时才阻塞这些脚本。&lt;/p&gt;

&lt;h2&gt;&lt;label id=&quot;chapter4&quot; /&gt;四、渲染树构建（Render tree construction）&lt;/h2&gt;

&lt;p&gt;　　当Dom树构建完成时，浏览器开始构建另一棵树——渲染树。渲染树由元素显示序列中的可见元素组成，它是文档的可视化表示，构建这棵树是为了以正确的顺序绘制文档内容。&lt;/p&gt;

&lt;p&gt;　　Firefox将渲染树中的元素称为frames，WebKit则用renderer或渲染对象来描述这些元素。&lt;/p&gt;

&lt;p&gt;　　一个渲染对象知道怎么布局及绘制自己及它的children。&lt;/p&gt;

&lt;p&gt;　　RenderObject是Webkit的渲染对象基类，它的定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class RenderObject{
  virtual void layout();
  virtual void paint(PaintInfo);
  virtual void rect repaintRect();
  Node* node;//the DOM node
  RenderStyle* style;// the computed style
  RenderLayer* containgLayer; //the containing z-index layer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　每个渲染对象用一个和该节点的css盒模型相对应的矩形区域来表示，正如css2所描述的那样，它包含诸如宽、高和位置之类的几何信息。盒模型的类型受该节点相关的display样式属性的影响（参考样式计算章节）。下面的webkit代码说明了如何根据display属性决定某个节点创建何种类型的渲染对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)
{
    Document* doc = node-&amp;gt;document();
    RenderArena* arena = doc-&amp;gt;renderArena();
    ...
    RenderObject* o = 0;
    switch (style-&amp;gt;display()) {
        case NONE:
            break;
        case INLINE:
            o = new (arena) RenderInline(node);
            break;
        case BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case INLINE_BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case LIST_ITEM:
            o = new (arena) RenderListItem(node);
            break;
        ...
    }
    return o;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　元素的类型也需要考虑，例如，表单控件和表格带有特殊的框架。&lt;/p&gt;

&lt;p&gt;　　在Webkit中，如果一个元素想创建一个特殊的渲染对象，它需要重写&quot;createRenderer&quot;方法，使渲染对象指向不包含几何信息的样式对象。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;渲染树和Dom树的关系（The render tree relation to the DOM tree）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　渲染对象和Dom元素相对应，但这种对应关系不是一对一的，不可见的Dom元素不会被插入渲染树，例如head元素。另外，display属性为none的元素也不会在渲染树中出现（visibility属性为hidden的元素将出现在渲染树中）。&lt;/p&gt;

&lt;p&gt;　　还有一些Dom元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。例如，select元素有三个渲染对象——一个显示区域、一个下拉列表及一个按钮。同样，当文本因为宽度不够而折行时，新行将作为额外的渲染元素被添加。另一个多个渲染对象的例子是不规范的html，根据css规范，一个行内元素只能仅包含行内元素或仅包含块状元素，在存在混合内容时，将会创建匿名的块状渲染对象包裹住行内元素。&lt;/p&gt;

&lt;p&gt;　　一些渲染对象和所对应的Dom节点不在树上相同的位置，例如，浮动和绝对定位的元素在文本流之外，在两棵树上的位置不同，渲染树上标识出真实的结构，并用一个占位结构标识出它们原来的位置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316305784.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;图13：渲染树及对应的Dom树&lt;/center&gt;


&lt;p&gt;　　&lt;strong&gt;创建树的流程（The flow of constructing the tree）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　Firefox中，表述为一个监听Dom更新的监听器，将frame的创建委派给Frame
Constructor，这个构建器计算样式（参看样式计算）并创建一个frame。&lt;/p&gt;

&lt;p&gt;　　Webkit中，计算样式并生成渲染对象的过程称为attachment，每个Dom节点有一个attach方法，attachment的过程是同步的，调用新节点的attach方法将节点插入到Dom树中。&lt;/p&gt;

&lt;p&gt;　　处理html和body标签将构建渲染树的根，这个根渲染对象对应被css规范称为containing
block的元素——包含了其他所有块元素的顶级块元素。它的大小就是viewport——浏览器窗口的显示区域，Firefox称它为viewPortFrame，webkit称为RenderView，这个就是文档所指向的渲染对象，树中其他的部分都将作为一个插入的Dom节点被创建。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;样式计算（Style Computation）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　创建渲染树需要计算出每个渲染对象的可视属性，这可以通过计算每个元素的样式属性得到。&lt;/p&gt;

&lt;p&gt;　　样式包括各种来源的样式表，行内样式元素及html中的可视化属性（例如bgcolor），可视化属性转化为css样式属性。&lt;/p&gt;

&lt;p&gt;　　样式表来源于浏览器默认样式表，及页面作者和用户提供的样式表——有些样式是浏览器用户提供的（浏览器允许用户定义喜欢的样式，例如，在Firefox中，可以通过在Firefox
Profile目录下放置样式表实现）。&lt;/p&gt;

&lt;p&gt;　　计算样式的一些困难：&lt;/p&gt;

&lt;p&gt;　　1. 样式数据是非常大的结构，保存大量的样式属性会带来内存问题。&lt;/p&gt;

&lt;p&gt;　　2.如果不进行优化，找到每个元素匹配的规则会导致性能问题，为每个元素查找匹配的规则都需要遍历整个规则表，这个过程有很大的工作量。选择符可能有复杂的结构，匹配过程如果沿着一条开始看似正确，后来却被证明是无用的路径，则必须去尝试另一条路径。&lt;/p&gt;

&lt;p&gt;　　例如，下面这个复杂选择符&lt;/p&gt;

&lt;p&gt;　　div div div div｛…｝&lt;/p&gt;

&lt;p&gt;　　这意味着规则应用到三个div的后代div元素，选择树上一条特定的路径去检查，这可能需要遍历节点树，最后却发现它只是两个div的后代，并不使用该规则，然后则需要沿着另一条路径去尝试&lt;/p&gt;

&lt;p&gt;　　3. 应用规则涉及非常复杂的级联，它们定义了规则的层次&lt;/p&gt;

&lt;p&gt;　　我们来看一下浏览器如何处理这些问题：&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;共享样式数据（Sharing style data）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　WebkKit节点引用样式对象（渲染样式），某些情况下，这些对象可以被节点间共享，这些节点需要是兄弟或是表兄弟节点，并且：&lt;/p&gt;

&lt;p&gt;　　1.这些元素必须处于相同的鼠标状态（比如不能一个处于hover，而另一个不是）&lt;/p&gt;

&lt;p&gt;　　2. 不能有元素具有id&lt;/p&gt;

&lt;p&gt;　　3. 标签名必须匹配&lt;/p&gt;

&lt;p&gt;　　4. class属性必须匹配&lt;/p&gt;

&lt;p&gt;　　5. 对应的属性必须相同&lt;/p&gt;

&lt;p&gt;　　6. 链接状态必须匹配&lt;/p&gt;

&lt;p&gt;　　7. 焦点状态必须匹配&lt;/p&gt;

&lt;p&gt;　　8. 不能有元素被属性选择器影响&lt;/p&gt;

&lt;p&gt;　　9. 元素不能有行内样式属性&lt;/p&gt;

&lt;p&gt;　　10.不能有生效的兄弟选择器，webcore在任何兄弟选择器相遇时只是简单的抛出一个全局转换，并且在它们显示时使整个文档的样式共享失效，这些包括＋选择器和类似:first-child和:last-child这样的选择器。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;Firefox规则树（Firefox rule tree）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　Firefox用两个树用来简化样式计算－规则树和样式上下文树，WebKit也有样式对象，但它们并没有存储在类似样式上下文树这样的树中，只是由Dom节点指向其相关的样式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316563380.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;图14：Firefox样式上下文树&lt;/center&gt;


&lt;p&gt;　　样式上下文包含最终值，这些值是通过以正确顺序应用所有匹配的规则，并将它们由逻辑值转换为具体的值，例如，如果逻辑值为屏幕的百分比，则通过计算将其转化为绝对单位。样式树的使用确实很巧妙，它使得在节点中共享的这些值不需要被多次计算，同时也节省了存储空间。&lt;/p&gt;

&lt;p&gt;　　所有匹配的规则都存储在规则树中，一条路径中的底层节点拥有最高的优先级，这棵树包含了所找到的所有规则匹配的路径（译注：可以取巧理解为每条路径对应一个节点，路径上包含了该节点所匹配的所有规则）。规则树并不是一开始就为所有节点进行计算，而是在某个节点需要计算样式时，才进行相应的计算并将计算后的路径添加到树中。&lt;/p&gt;

&lt;p&gt;　　我们将树上的路径看成辞典中的单词，假如已经计算出了如下的规则树：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316565168.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　假如需要为内容树中的另一个节点匹配规则，现在知道匹配的规则（以正确的顺序）为B-E-I，因为我们已经计算出了路径A-B-E-I-L，所以树上已经存在了这条路径，剩下的工作就很少了。&lt;/p&gt;

&lt;p&gt;　　现在来看一下树如何保存。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;结构化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　样式上下文按结构划分，这些结构包括类似border或color这样的特定分类的样式信息。一个结构中的所有特性不是继承的就是非继承的，对继承的特性，除非元素自身有定义，否则就从它的parent继承。非继承的特性（称为reset特性）如果没有定义，则使用默认的值。&lt;/p&gt;

&lt;p&gt;　　样式上下文树缓存完整的结构（包括计算后的值），这样，如果底层节点没有为一个结构提供定义，则使用上层节点缓存的结构。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;使用规则树计算样式上下文&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　当为一个特定的元素计算样式时，首先计算出规则树中的一条路径，或是使用已经存在的一条，然后使用路径中的规则去填充新的样式上下文，从样式的底层节点开始，它具有最高优先级（通常是最特定的选择器），遍历规则树，直到填满结构。如果在那个规则节点没有定义所需的结构规则，则沿着路径向上，直到找到该结构规则。&lt;/p&gt;

&lt;p&gt;　　如果最终没有找到该结构的任何规则定义，那么如果这个结构是继承型的，则找到其在内容树中的parent的结构，这种情况下，我们也成功的共享了结构；如果这个结构是reset型的，则使用默认的值。&lt;/p&gt;

&lt;p&gt;　　如果特定的节点添加了值，那么需要做一些额外的计算以将其转换为实际值，然后在树上的节点缓存该值，使它的children可以使用。&lt;/p&gt;

&lt;p&gt;　　当一个元素和它的一个兄弟元素指向同一个树节点时，完整的样式上下文可以被它们共享。&lt;/p&gt;

&lt;p&gt;　　来看一个例子：假设有下面这段html&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div class=&quot;err&quot; id=&quot;div1&quot;&amp;gt;
            &amp;lt;p&amp;gt;this is a
            &amp;lt;span class=&quot;big&quot;&amp;gt; big error &amp;lt;/span&amp;gt;
            this is also a
            &amp;lt;span class=&quot;big&quot;&amp;gt; verybigerror&amp;lt;/span&amp;gt;
            error
            &amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;err&quot; id=&quot;div2&quot;&amp;gt;another error&amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　以及下面这些规则&lt;/p&gt;

&lt;p&gt;　　1.div {margin:5px;color:black}&lt;br/&gt;
　　2..err {color:red}&lt;br/&gt;
　　3..big {margin-top:3px}&lt;br/&gt;
　　4.div span {margin-bottom:4px}&lt;br/&gt;
　　5.#div1 {color:blue}&lt;br/&gt;
　　6.#div2 {color:green}&lt;/p&gt;

&lt;p&gt;　　简化下问题，我们只填充两个结构——color和margin，color结构只包含一个成员－颜色，margin结构包含四边。&lt;/p&gt;

&lt;p&gt;　　生成的规则树如下（节点名：指向的规则）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316570450.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　上下文树如下（节点名：指向的规则节点）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316572022.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　假设我们解析html，遇到第二个div标签，我们需要为这个节点创建样式上下文，并填充它的样式结构。&lt;/p&gt;

&lt;p&gt;　　我们进行规则匹配，找到这个div匹配的规则为1、2、6，我们发现规则树上已经存在了一条我们可以使用的路径1、2，我们只需为规则6新增一个节点添加到下面（就是规则树中的F）。&lt;/p&gt;

&lt;p&gt;　　然后创建一个样式上下文并将其放到上下文树中，新的样式上下文将指向规则树中的节点F。&lt;/p&gt;

&lt;p&gt;　　现在我们需要填充这个样式上下文，先从填充margin结构开始，既然最后一个规则节点没有添加margin结构，沿着路径向上，直到找到缓存的前面插入节点计算出的结构，我们发现B是最近的指定margin值的节点。因为已经有了color结构的定义，所以不能使用缓存的结构，既然color只有一个属性，也就不需要沿着路径向上填充其他属性。计算出最终值（将字符串转换为RGB等），并缓存计算后的结构。&lt;/p&gt;

&lt;p&gt;　　第二个span元素更简单，进行规则匹配后发现它指向规则G，和前一个span一样，既然有兄弟节点指向同一个节点，就可以共享完整的样式上下文，只需指向前一个span的上下文。&lt;/p&gt;

&lt;p&gt;　　因为结构中包含继承自parent的规则，上下文树做了缓存（color特性是继承来的，但Firefox将其视为reset并在规则树中缓存）。&lt;/p&gt;

&lt;p&gt;　　例如，如果我们为一个paragraph的文字添加规则：&lt;/p&gt;

&lt;p&gt;　　p {font-family:Verdana;font size:10px;font-weight:bold}&lt;/p&gt;

&lt;p&gt;　　那么这个p在内容树中的子节点div，会共享和它parent一样的font结构，这种情况发生在没有为这个div指定font规则时。&lt;/p&gt;

&lt;p&gt;　　Webkit中，并没有规则树，匹配的声明会被遍历四次，先是应用非important的高优先级属性（之所以先应用这些属性，是因为其他的依赖于它们－比如display），其次是高优先级important的，接着是一般优先级非important的，最后是一般优先级important的规则。这样，出现多次的属性将被按照正确的级联顺序进行处理，最后一个生效。&lt;/p&gt;

&lt;p&gt;　　总结一下，共享样式对象（结构中完整或部分内容）解决了问题1和3，Firefox的规则树帮助以正确的顺序应用规则。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;对规则进行处理以简化匹配过程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　样式规则有几个来源：&lt;/p&gt;

&lt;p&gt;　　-   外部样式表或style标签内的css规则&lt;br/&gt;
　　-   行内样式属性&lt;br/&gt;
　　-   html可视化属性（映射为相应的样式规则）&lt;/p&gt;

&lt;p&gt;　　后面两个很容易匹配到元素，因为它们所拥有的样式属性和html属性可以将元素作为key进行映射。&lt;/p&gt;

&lt;p&gt;　　就像前面问题2所提到的，css的规则匹配可能很狡猾，为了解决这个问题，可以先对规则进行处理，以使其更容易被访问。&lt;/p&gt;

&lt;p&gt;　　解析完样式表之后，规则会根据选择符添加一些hash映射，映射可以是根据id、class、标签名或是任何不属于这些分类的综合映射。如果选择符为id，规则将被添加到id映射，如果是class，则被添加到class映射，等等。&lt;/p&gt;

&lt;p&gt;　　这个处理是匹配规则更容易，不需要查看每个声明，我们能从映射中找到一个元素的相关规则，这个优化使在进行规则匹配时减少了95+%的工作量。&lt;/p&gt;

&lt;p&gt;　　来看下面的样式规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p.error {color:red}
#messageDiv {height:50px}
div {margin:5px}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　第一条规则将被插入class映射，第二条插入id映射，第三条是标签映射。&lt;/p&gt;

&lt;p&gt;　　下面这个html片段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p class=&quot;error&quot;&amp;gt;an error occurred &amp;lt;/p&amp;gt;
&amp;lt;div id=&quot; messageDiv&quot;&amp;gt;this is a message&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我们首先找到p元素对应的规则，class映射将包含一个&quot;error&quot;的key，找到p.error的规则，div在id映射和标签映射中都有相关的规则，剩下的工作就是找出这些由key对应的规则中哪些确实是正确匹配的。&lt;/p&gt;

&lt;p&gt;　　例如，如果div的规则是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;table div {margin:5px}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　这也是标签映射产生的，因为key是最右边的选择符，但它并不匹配这里的div元素，因为这里的div没有table祖先。&lt;/p&gt;

&lt;p&gt;　　Webkit和Firefox都会做这个处理。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;以正确的级联顺序应用规则&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　样式对象拥有对应所有可见属性的属性，如果特性没有被任何匹配的规则所定义，那么一些特性可以从parent的样式对象中继承，另外一些使用默认值。&lt;/p&gt;

&lt;p&gt;　　这个问题的产生是因为存在不止一处的定义，这里用级联顺序解决这个问题。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;样式表的级联顺序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　一个样式属性的声明可能在几个样式表中出现，或是在一个样式表中出现多次，因此，应用规则的顺序至关重要，这个顺序就是级联顺序。根据css2的规范，级联顺序为（从低到高）：&lt;/p&gt;

&lt;p&gt;　　1. 浏览器声明&lt;/p&gt;

&lt;p&gt;　　2. 用户声明&lt;/p&gt;

&lt;p&gt;　　3. 作者的一般声明&lt;/p&gt;

&lt;p&gt;　　4. 作者的important声明&lt;/p&gt;

&lt;p&gt;　　5. 用户important声明&lt;/p&gt;

&lt;p&gt;　　浏览器声明是最不重要的，用户只有在声明被标记为important时才会覆盖作者的声明。具有同等级别的声明将根据specifity以及它们被定义时的顺序进行排序。Html可视化属性将被转换为匹配的css声明，它们被视为最低优先级的作者规则。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;Specifity&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　Css2规范中定义的选择符specifity如下：&lt;/p&gt;

&lt;p&gt;　　-   如果声明来自style属性，而不是一个选择器的规则，则计1，否则计0（＝a）&lt;br/&gt;
　　-   计算选择器中id属性的数量（＝b）&lt;br/&gt;
　　-   计算选择器中class及伪类的数量（＝c）&lt;br/&gt;
　　-   计算选择器中元素名及伪元素的数量（＝d）&lt;/p&gt;

&lt;p&gt;　　连接a－b－c－d四个数量（用一个大基数的计算系统）将得到specifity。这里使用的基数由分类中最高的基数定义。例如，如果a为14，可以使用16进制。不同情况下，a为17时，则需要使用阿拉伯数字17作为基数，这种情况可能在这个选择符时发生html
body div div …（选择符中有17个标签，一般不太可能）。&lt;/p&gt;

&lt;p&gt;　　一些例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*{}/* a=0 b=0 c=0 d=0 -&amp;gt; specificity = 0,0,0,0 */

li{}/* a=0 b=0 c=0 d=1 -&amp;gt; specificity = 0,0,0,1 */

li:first-line {}/* a=0 b=0 c=0 d=2 -&amp;gt; specificity = 0,0,0,2 */

ul li{}/* a=0 b=0 c=0 d=2 -&amp;gt; specificity = 0,0,0,2 */

ul ol+li{}/* a=0 b=0 c=0 d=3 -&amp;gt; specificity = 0,0,0,3 */

h1 + *[rel=up]{}/* a=0 b=0 c=1 d=1 -&amp;gt; specificity = 0,0,1,1 */

ul ol li.red{}/* a=0 b=0 c=1 d=3 -&amp;gt; specificity = 0,0,1,3 */

li.red.level{}/* a=0 b=0 c=2 d=1 -&amp;gt; specificity = 0,0,2,1 */

#x34y{}/* a=0 b=1 c=0 d=0 -&amp;gt; specificity = 0,1,0,0 */

/* a=1 b=0 c=0 d=0 -&amp;gt; specificity = 1,0,0,0 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　&lt;strong&gt;规则排序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　规则匹配后，需要根据级联顺序对规则进行排序，WebKit先将小列表用冒泡排序，再将它们合并为一个大列表，WebKit通过为规则复写&quot;&gt;&quot;操作来执行排序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static bool operator &amp;gt;(CSSRuleData&amp;amp; r1, CSSRuleData&amp;amp; r2)
{
    int spec1 = r1.selector()-&amp;gt;specificity();
    int spec2 = r2.selector()-&amp;gt;specificity();
    return (spec1 == spec2) : r1.position() &amp;gt; r2.position() : spec1 &amp;gt; spec2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　&lt;strong&gt;逐步处理Gradual process&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　webkit使用一个标志位标识所有顶层样式表都已加载，如果在attch时样式没有完全加载，则放置占位符，并在文档中标记，一旦样式表完成加载就重新进行计算。&lt;/p&gt;

&lt;h2&gt;&lt;label id=&quot;chapter5&quot; /&gt;五、布局（Layout）&lt;/h2&gt;

&lt;p&gt;　　当渲染对象被创建并添加到树中，它们并没有位置和大小，计算这些值的过程称为layout或reflow。&lt;/p&gt;

&lt;p&gt;　　Html使用基于流的布局模型，意味着大部分时间，可以以单一的途径进行几何计算。流中靠后的元素并不会影响前面元素的几何特性，所以布局可以在文档中从右向左、自上而下的进行。也存在一些例外，比如html
tables。&lt;/p&gt;

&lt;p&gt;　　坐标系统相对于根frame，使用top和left坐标。&lt;/p&gt;

&lt;p&gt;　　布局是一个递归的过程，由根渲染对象开始，它对应html文档元素，布局继续递归的通过一些或所有的frame层级，为每个需要几何信息的渲染对象进行计算。&lt;/p&gt;

&lt;p&gt;　　根渲染对象的位置是0,0，它的大小是viewport－浏览器窗口的可见部分。&lt;/p&gt;

&lt;p&gt;　　所有的渲染对象都有一个layout或reflow方法，每个渲染对象调用需要布局的children的layout方法。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;Dirty bit系统&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　为了不因为每个小变化都全部重新布局，浏览器使用一个dirty
bit系统，一个渲染对象发生了变化或是被添加了，就标记它及它的children为dirty——需要layout。存在两个标识——dirty及children
are dirty，children are
dirty说明即使这个渲染对象可能没问题，但它至少有一个child需要layout。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;全局和增量layout&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　当layout在整棵渲染树触发时，称为全局layout，这可能在下面这些情况下发生：&lt;/p&gt;

&lt;p&gt;　　1. 一个全局的样式改变影响所有的渲染对象，比如字号的改变。&lt;/p&gt;

&lt;p&gt;　　2. 窗口resize。&lt;/p&gt;

&lt;p&gt;　　layout也可以是增量的，这样只有标志为dirty的渲染对象会重新布局（也将导致一些额外的布局）。增量layout会在渲染对象dirty时异步触发，例如，当网络接收到新的内容并添加到Dom树后，新的渲染对象会添加到渲染树中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316575534.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;图20：增量layout&lt;/center&gt;


&lt;p&gt;　　&lt;strong&gt;异步和同步layout&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　增量layout的过程是异步的，Firefox为增量layout生成了reflow队列，以及一个调度执行这些批处理命令。WebKit也有一个计时器用来执行增量layout－遍历树，为dirty状态的渲染对象重新布局。&lt;/p&gt;

&lt;p&gt;　　另外，当脚本请求样式信息时，例如&quot;offsetHeight&quot;，会同步的触发增量布局。&lt;/p&gt;

&lt;p&gt;　　全局的layout一般都是同步触发。&lt;/p&gt;

&lt;p&gt;　　有些时候，layout会被作为一个初始layout之后的回调，比如滑动条的滑动。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;优化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　当一个layout因为resize或是渲染位置改变（并不是大小改变）而触发时，渲染对象的大小将会从缓存中读取，而不会重新计算。&lt;/p&gt;

&lt;p&gt;　　一般情况下，如果只有子树发生改变，则layout并不从根开始。这种情况发生在，变化发生在元素自身并且不影响它周围元素，例如，将文本插入文本域（否则，每次击键都将触发从根开始的重排）。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;layout过程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　layout一般有下面这几个部分：&lt;/p&gt;

&lt;p&gt;　　1. parent渲染对象决定它的宽度&lt;/p&gt;

&lt;p&gt;　　2. parent渲染对象读取chilidren，并：&lt;/p&gt;

&lt;p&gt;　　　　a. 放置child渲染对象（设置它的x和y）&lt;/p&gt;

&lt;p&gt;　　　　b. 在需要时（它们当前为dirty或是处于全局layout或者其他原因）调用child渲染对象的layout，这将计算child的高度&lt;/p&gt;

&lt;p&gt;　　　　c. parent渲染对象使用child渲染对象的累积高度，以及margin和padding的高度来设置自己的高度－这将被parent渲染对象的parent使用&lt;/p&gt;

&lt;p&gt;　　　　d. 将dirty标识设置为false&lt;/p&gt;

&lt;p&gt;　　Firefox使用一个&quot;state&quot;对象（nsHTMLReflowState）做为参数去布局（firefox称为reflow），state包含parent的宽度及其他内容。&lt;/p&gt;

&lt;p&gt;　　Firefox布局的输出是一个&quot;metrics&quot;对象（nsHTMLReflowMetrics）。它包括渲染对象计算出的高度。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;宽度计算&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　渲染对象的宽度使用容器的宽度、渲染对象样式中的宽度及margin、border进行计算。例如，下面这个div的宽度：&lt;/p&gt;

&lt;p&gt;　　&amp;lt;div /&gt;&lt;/p&gt;

&lt;p&gt;　　webkit中宽度的计算过程是（RenderBox类的calcWidth方法）：&lt;/p&gt;

&lt;p&gt;　　-   容器的宽度是容器的可用宽度和0中的最大值，这里的可用宽度为：contentWidth=clientWidth()-paddingLeft()-paddingRight()，clientWidth和clientHeight代表一个对象内部的不包括border和滑动条的大小
　　-   元素的宽度指样式属性width的值，它可以通过计算容器的百分比得到一个绝对值
　　-   加上水平方向上的border和padding&lt;/p&gt;

&lt;p&gt;　　到这里是最佳宽度的计算过程，现在计算宽度的最大值和最小值，如果最佳宽度大于最大宽度则使用最大宽度，如果小于最小宽度则使用最小宽度。最后缓存这个值，当需要layout但宽度未改变时使用。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;Line breaking&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　当一个渲染对象在布局过程中需要折行时，则暂停并告诉它的parent它需要折行，parent将创建额外的渲染对象并调用它们的layout。&lt;/p&gt;

&lt;h2&gt;&lt;label id=&quot;chapter6&quot; /&gt;六、绘制（Painting）&lt;/h2&gt;

&lt;p&gt;　　绘制阶段，遍历渲染树并调用渲染对象的paint方法将它们的内容显示在屏幕上，绘制使用UI基础组件，这在UI的章节有更多的介绍。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;全局和增量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　和布局一样，绘制也可以是全局的——绘制完整的树——或增量的。在增量的绘制过程中，一些渲染对象以不影响整棵树的方式改变，改变的渲染对象使其在屏幕上的矩形区域失效，这将导致操作系统将其看作dirty区域，并产生一个paint事件，操作系统很巧妙的处理这个过程，并将多个区域合并为一个。Chrome中，这个过程更复杂些，因为渲染对象在不同的进程中，而不是在主进程中。Chrome在一定程度上模拟操作系统的行为，表现为监听事件并派发消息给渲染根，在树中查找到相关的渲染对象，重绘这个对象（往往还包括它的children）。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;绘制顺序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　css2定义了绘制过程的顺序——&lt;a href=&quot;http://www.w3.org/TR/CSS21/zindex.html&quot;&gt;http://www.w3.org/TR/CSS21/zindex.html&lt;/a&gt;。这个就是元素压入堆栈的顺序，这个顺序影响着绘制，堆栈从后向前进行绘制。&lt;/p&gt;

&lt;p&gt;　　一个块渲染对象的堆栈顺序是：&lt;/p&gt;

&lt;p&gt;　　1. 背景色&lt;/p&gt;

&lt;p&gt;　　2. 背景图&lt;/p&gt;

&lt;p&gt;　　3. border&lt;/p&gt;

&lt;p&gt;　　4. children&lt;/p&gt;

&lt;p&gt;　　5. outline&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;Firefox显示列表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　Firefox读取渲染树并为绘制的矩形创建一个显示列表，该列表以正确的绘制顺序包含这个矩形相关的渲染对象。&lt;/p&gt;

&lt;p&gt;　　用这样的方法，可以使重绘时只需查找一次树，而不需要多次查找——绘制所有的背景、所有的图片、所有的border等等。&lt;/p&gt;

&lt;p&gt;　　Firefox优化了这个过程，它不添加会被隐藏的元素，比如元素完全在其他不透明元素下面。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;WebKit矩形存储&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　重绘前，WebKit将旧的矩形保存为位图，然后只绘制新旧矩形的差集。&lt;/p&gt;

&lt;h2&gt;&lt;label id=&quot;chapter7&quot; /&gt;七、动态变化&lt;/h2&gt;

&lt;p&gt;　　浏览器总是试着以最小的动作响应一个变化，所以一个元素颜色的变化将只导致该元素的重绘，元素位置的变化将大致元素的布局和重绘，添加一个Dom节点，也会大致这个元素的布局和重绘。一些主要的变化，比如增加html元素的字号，将会导致缓存失效，从而引起整数的布局和重绘。&lt;/p&gt;

&lt;h2&gt;&lt;label id=&quot;chapter8&quot; /&gt;八、渲染引擎的线程&lt;/h2&gt;

&lt;p&gt;　　渲染引擎是单线程的，除了网络操作以外，几乎所有的事情都在单一的线程中处理，在Firefox和Safari中，这是浏览器的主线程，Chrome中这是tab的主线程。&lt;/p&gt;

&lt;p&gt;　　网络操作由几个并行线程执行，并行连接的个数是受限的（通常是2－6个）。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;事件循环&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　浏览器主线程是一个事件循环，它被设计为无限循环以保持执行过程的可用，等待事件（例如layout和paint事件）并执行它们。下面是Firefox的主要事件循环代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (!mExiting)
  NS_ProcessNextEvent(thread);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;&lt;label id=&quot;chapter9&quot; /&gt;九、CSS2可视模型（CSS2 visual module）&lt;/h2&gt;

&lt;p&gt;　　&lt;strong&gt;画布The Canvas&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　根据CSS2规范，术语canvas用来描述格式化的结构所渲染的空间——浏览器绘制内容的地方。画布对每个维度空间都是无限大的，但浏览器基于viewport的大小选择了一个初始宽度。&lt;/p&gt;

&lt;p&gt;　　根据&lt;a href=&quot;http://www.w3.org/TR/CSS2/zindex.html&quot;&gt;http://www.w3.org/TR/CSS2/zindex.html&lt;/a&gt;的定义，画布如果是包含在其他画布内则是透明的，否则浏览器会指定一个颜色。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;CSS盒模型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　CSS盒模型描述了矩形盒，这些矩形盒是为文档树中的元素生成的，并根据可视的格式化模型进行布局。每个box包括内容区域（如图片、文本等）及可选的四周padding、border和margin区域。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316582721.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　每个节点生成0－n个这样的box。&lt;/p&gt;

&lt;p&gt;　　所有的元素都有一个display属性，用来决定它们生成box的类型，例如：&lt;/p&gt;

&lt;p&gt;　　block －生成块状box&lt;/p&gt;

&lt;p&gt;　　inline －生成一个或多个行内box&lt;/p&gt;

&lt;p&gt;　　none －不生成box&lt;/p&gt;

&lt;p&gt;　　默认的是inline，但浏览器样式表设置了其他默认值，例如，div元素默认为block。可以访问&lt;a href=&quot;http://www.w3.org/TR/CSS2/sample.html&quot;&gt;http://www.w3.org/TR/CSS2/sample.html&lt;/a&gt;查看更多的默认样式表示例。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;定位策略Position scheme&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　这里有三种策略：&lt;/p&gt;

&lt;p&gt;　　1. normal
－对象根据它在文档的中位置定位，这意味着它在渲染树和在Dom树中位置一致，并根据它的盒模型和大小进行布局。&lt;/p&gt;

&lt;p&gt;　　2. float －对象先像普通流一样布局，然后尽可能的向左或是向右移动。&lt;/p&gt;

&lt;p&gt;　　3. absolute －对象在渲染树中的位置和Dom树中位置无关。&lt;/p&gt;

&lt;p&gt;　　static和relative是normal，absolute和fixed属于absolute。&lt;/p&gt;

&lt;p&gt;　　在static定位中，不定义位置而使用默认的位置。其他策略中，作者指定位置——top、bottom、left、right。&lt;/p&gt;

&lt;p&gt;　　Box布局的方式由这几项决定：box的类型、box的大小、定位策略及扩展信息（比如图片大小和屏幕尺寸）。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;Box类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　Block box：构成一个块，即在浏览器窗口上有自己的矩形&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316585169.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　Inline box：并没有自己的块状区域，但包含在一个块状区域内&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316590681.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　block一个挨着一个垂直格式化，inline则在水平方向上格式化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316591786.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　Inline盒模型放置在行内或是line
box中，每行至少和最高的box一样高，当box以baseline对齐时——即一个元素的底部和另一个box上除底部以外的某点对齐，行高可以比最高的box高。当容器宽度不够时，行内元素将被放到多行中，这在一个p元素中经常发生。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316593174.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;定位Position&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;strong&gt;Relative&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　相对定位——先按照一般的定位，然后按所要求的差值移动。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316594780.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;strong&gt;Floats&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　一个浮动的box移动到一行的最左边或是最右边，其余的box围绕在它周围。下面这段html：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
  &amp;lt;img src=&quot;images/image.gif&quot; width=&quot;100&quot; height=&quot;100&quot;&amp;gt;Lorem ipsum dolor sit amet, consectetuer...
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　将显示为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110316595942.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;strong&gt;Absolute和Fixed&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　这种情况下的布局完全不顾普通的文档流，元素不属于文档流的一部分，大小取决于容器。Fixed时，容器为viewport（可视区域）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110317001254.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;center&gt;图17：fixed&lt;/center&gt;


&lt;p&gt;　　注意－fixed即使在文档流滚动时也不会移动。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;strong&gt;Layered representation&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　这个由CSS属性中的z-index指定，表示盒模型的第三个大小，即在z轴上的位置。Box分发到堆栈中（称为堆栈上下文），每个堆栈中靠后的元素将被较早绘制，栈顶靠前的元素离用户最近，当发生交叠时，将隐藏靠后的元素。堆栈根据z-index属性排序，拥有z-index属性的box形成了一个局部堆栈，viewport有外部堆栈，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;STYLE type=&quot;text/css&quot;&amp;gt;
    div {
        position: absolute;
        left: 2in;
        top: 2in;
    }
&amp;lt;/STYLE&amp;gt;
&amp;lt;P&amp;gt;
&amp;lt;DIV&amp;gt;
&amp;lt;/DIV&amp;gt;
&amp;lt;DIV&amp;gt;
&amp;lt;/DIV&amp;gt;
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　结果是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-02/2011110317002510.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　虽然绿色div排在红色div后面，可能在正常流中也已经被绘制在后面，但z-index有更高优先级，所以在根box的堆栈中更靠前。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>完全理解关键字this</title>
   <link href="http://beango.github.com/archives/2012/02/01/fully-understanding-the-this-keyword.html"/>
   <updated>2012-02-01T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2012/02/01/fully-understanding-the-this-keyword</id>
   <content type="html">&lt;p&gt;今天的教程来自天才的&lt;a href=&quot;http://codylindley.com/&quot;&gt;Cody Lindley&lt;/a&gt;的新书：《JavaScript启蒙教程&lt;a href=&quot;http://javascriptenlightenment.com/&quot;&gt;JavaScript Enlightenment&lt;/a&gt;》。他讨论了令人迷惑的关键字this，以及确定和设置this的值的方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;概念性的概述this&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当一个函数创建后，一个关键字this就随之(在后台)创建，它链接到一个对象，而函数正是在这个对象中进行操作。换句话说，关键字this可在函数中使用，是对一个对象的引用，而函数正是该对象的属性或方法。&lt;/p&gt;

&lt;p&gt;让我们来看这个对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;body&amp;gt;&amp;lt;script&amp;gt;
var cody = {
  living:true,
  age:23,
  gender:'male',
  getGender:function(){return cody.gender;}
};

console.log(cody.getGender()); // logs 'male'

&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意在函数getGender里，由于在cody对象内部，我们可以通过.来获取gender属性(也就是cody.gender)。也可以用this来获取cody对象，因为this正是指向cody对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;body&amp;gt;&amp;lt;script&amp;gt;
var cody = {
  living:true,
  age:23,
  gender:'male',
  getGender:function(){return this.gender;}
};

console.log(cody.getGender()); // logs 'male'

&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;this.gender中this指向cody对象，而getGender函数可以操作cody对象。&lt;/p&gt;

&lt;p&gt;关于this的主题可能有点让人感到困惑，其实不必如此。仅记住，通常，this指向的对象正是包含函数的对象，而不是函数本身（当然也有例外，例如采用关键字new或者call()和apply()）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要提示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;****- 关键字this就像其他的变量，唯一不同就是你不能更改它。&lt;/p&gt;

&lt;p&gt;-
不同于传给函数的其他参数和变量，在调用函数的对象中，this是一个关键字(而不是属性)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何确定this的值？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;this传递给所有的函数，它的值取决于函数运行时何时被调用。这里请注意，因为这是你需要记住的一个很特别的地方。&lt;/p&gt;

&lt;p&gt;下面的代码中myObject对象有个属性sayFoo，它指向函数sayFoo。当在全局域中调用sayFoo函数时，this指向window对象。当myObject调用函数时，this指向的是myObject。&lt;/p&gt;

&lt;p&gt;因为myObject有个叫foo的属性，在这里被使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;body&amp;gt;&amp;lt;script&amp;gt;

var foo = 'foo';
var myObject = {foo: 'I am myObject.foo'};

var sayFoo = function() {
  console.log(this['foo']);
};

￼￼// give myObject a sayFoo property and have it point to sayFoo function
myObject.sayFoo = sayFoo;
myObject.sayFoo(); // logs 'I am myObject.foo' 12

sayFoo(); // logs 'foo'

&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很清楚，this的值取决于函数什么时候被调用。myObject.sayFoo和sayFoo都指向同样的函数，但sayFoo()调用的上下文不同，this的值也就不同。下面是类似的代码，head对象(window)显式使用，希望对你有用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;body&amp;gt;&amp;lt;script&amp;gt;

window.foo = 'foo';
window.myObject = {foo: 'I am myObject.foo'};
window.sayFoo = function() { ! console.log(this.foo); };
window.myObject.sayFoo = window.sayFoo;
window.myObject.sayFoo();
window.sayFoo();

&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;确保当你有多个引用指向同一个函数的时候，你清楚的知道this的值是随调用函数的上下文的不同而改变。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要提示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;****- 除了this以外的所有变量和参数都属于静态变量范围(&lt;a href=&quot;http://en.wikipedia.org/wiki/Lexical_scope#Lexical_scoping&quot;&gt;lexical
scope&lt;/a&gt;)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在嵌入函数内this指向head对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你可能想知道在嵌入在另外一个函数的函数中使用this会发生什么事。不幸的是在ECMA 3中，this不遵循规律，它不指向函数属于的对象，而是指向head对象(&lt;a href=&quot;http://blog.jobbole.com/12749/&quot; title=&quot;浏览器&quot;&gt;浏览器&lt;/a&gt;的window对象)。&lt;/p&gt;

&lt;p&gt;在下面的代码，func2和func3中的this不再指向myObject，而是head对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;body&amp;gt;&amp;lt;script&amp;gt;

var myObject = {
  func1:function() {
     console.log(this); //logs myObject
     varfunc2=function() {
        console.log(this); //logs window, and will do so from this point on
        varfunc3=function() {
           console.log(this); //logs window, as it’s the head object
        }();
     }();
  }
};

myObject.func1();

&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而在ECMAScript 5中，这个问题将会得到修正。现在，你应该意识到这个问题，尤其是当你将一个函数的值传递到另一个函数时。&lt;/p&gt;

&lt;p&gt;看看下面的代码，将一个匿名函数传给foo.func1，当在foo.func1中调用匿名函数(函数嵌套在另一个函数中)，匿名函数中this将会指向是head对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;body&amp;gt;&amp;lt;script&amp;gt;
var foo = {
  func1:function(bar){
    bar(); //logs window, not foo
    console.log(this);//the this keyword here will be a reference to foo object
  }
};

foo.func1(function(){console.log(this)});
&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你不会忘了，如果包含this的函数在另一个函数中，或者被另一个函数调用，this的值将会指向的是head对象(再说一次，这将在ECMAScript 5中被修正。)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决嵌套函数的问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了使this的值不丢失，你可以在父函数中使用一个作用域链(scope chain)来保存对this进行引用。下面的代码中，使用一个叫that的变量，利用它的作用域，我们可以更好的保存函数上下文。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;body&amp;gt;&amp;lt;script&amp;gt;

var myObject = {
  myProperty:'Icanseethelight',
    myMethod:function() {
   var that=this; //store a reference to this (i.e.myObject) in myMethod scope varhelperFunctionfunction(){//childfunction
   var helperFunction function() { //childfunction
      //logs 'I can see the light' via scope chain because that=this
           console.log(that.myProperty); //logs 'I can see the light'
           console.log(this); // logs window object, if we don't use &quot;that&quot;
        }();
    }
}

myObject.myMethod(); // invoke myMethod

&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;控制this的值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;this的值通常取决于调用函数的上下文(除非使用关键字new，稍后会为你介绍)，但是你可以用apply()或call()指定触发一个函数时this指向的对象，以改变/控制this的值。用这两种方法就好像再说：“嘿，调用X函数，但让Z对象来作this的值。”这样做，JavaScript默认的this的值将被更改。&lt;/p&gt;

&lt;p&gt;下面，我们创建了一个对象和一个函数，然后我们通过call()来触发函数，所以函数中的this指向的是myOjbect。在myFunction函数中的this会操作myObject而不是head对象，这样我们就改变了在myFunction中this指向的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;body&amp;gt;&amp;lt;script&amp;gt;

var myObject = {};

var myFunction = function(param1, param2) {
  //setviacall()'this'points to my Object when function is invoked
  this.foo = param1;
  this.bar = param2;
  console.log(this); //logs Object{foo = 'foo', bar = 'bar'}
};

myFunction.call(myObject, 'foo', 'bar'); // invoke function, set this value to myObject

console.log(myObject) // logs Object {foo = 'foo', bar = 'bar'}

&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子，我们用了call()，apply()也可适用于同样用法，二者的不同之处在于参数如何传给函数。用call()，参数用逗号分开，而用apply()，参数放在一个数组中传递。下面是同样的代码，但是用apply()。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;body&amp;gt;&amp;lt;script&amp;gt;

var myObject = {};

var myFunction = function(param1, param2) {
  //set via apply(), this points to my Object when function is invoked
  this.foo=param1;
  this.bar=param2;
  console.log(this); // logs Object{foo='foo', bar='bar'}
};

myFunction.apply(myObject, ['foo', 'bar']); // invoke function, set this value
console.log(myObject); // logs Object {foo = 'foo', bar = 'bar'}

&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;在自定义构造函数中用this&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当函数用关键字new来触发，this的值–由于在构造函数中声明–指向实例本身。换种说法：在构造函数中，我们可以在对象真正创建之前，就用this来指定对象。这样看来，this值的更改和call()或apply()相似。&lt;/p&gt;

&lt;p&gt;下面，我们构造了一个构造函数Person，this指向创建的对象。当Person的对象创建后，this指向这个对象，并将属性name放在对象内，值为传给这个构造函数的参数值(name)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;body&amp;gt;&amp;lt;script&amp;gt;

var Person = function(name) {
  this.name = name || 'johndoe'; // this will refer to the instanc ecreated
}

var cody = new Person('Cody Lindley'); // create an instance, based on Person constructor

console.log(cody.name); // logs 'Cody Lindley'

&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，当用关键字new触发构造函数时，this指向“要创建的对象”。那么如果我们没有用关键字new，this的值将会指向触发Person的上下文——这时是head对象。让我们来看看下面的代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;body&amp;gt;&amp;lt;script&amp;gt;

var Person = function(name) {
  this.name=name||'johndoe';
}

var cody = Person('Cody Lindley'); // notice we did not use 'new'
console.log(cody.name); // undefined, the value is actually set at window.name
console.log(window.name); // logs 'Cody Lindley'

&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;在prototype方法内的this指向构造实例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当一个方法作为一个构造函数的prototype属性时，这个方法中的this指向触发方法的实例。这里，我们有一个Person()的构造函数，它需要person的全名(full name)，为了获得全名(full name)，我们在Person.prototype中加入了一个whatIsMyFullName方法，所有的Person实例都继承该方法。这个方法中的this指向触发这个方法的实例(以及它的属性)。&lt;/p&gt;

&lt;p&gt;下面我创建了两个Person对象(cody和lisa)，继承的whatIsMyFullName方法包含的this就指向这个实例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;body&amp;gt;&amp;lt;script&amp;gt;

var Person = function(x){
    if(x){this.fullName = x};
};

Person.prototype.whatIsMyFullName = function() {
    return this.fullName; // 'this' refers to the instance created from Person()
}

var cody = new Person('cody lindley');
var lisa = new Person('lisa lindley');

// call the inherited whatIsMyFullName method, which uses this to refer to the instance
console.log(cody.whatIsMyFullName(), lisa.whatIsMyFullName());

/* The prototype chain is still in effect, so if the instance does not have a
fullName property, it will look for it in the prototype chain.
Below, we add a fullName property to both the Person prototype and the Object
prototype. See notes. */

Object.prototype.fullName = 'John Doe';
var john = new Person(); // no argument is passed so fullName is not added to instance
console.log(john.whatIsMyFullName()); // logs 'John Doe'

&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在prototype对象内的方法里使用this，this就指向实例。如果实例不包含属性的话，prototype查找便开始了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;-如果this指向的对象不包含想要查找的属性，那么这时对于任何属性都适用的法则在这里也适用，也就是，属性会沿着prototype链(prototype chain)上“寻找”。所以在我们的例子中，如果实例中不包含fullName属性，那么fullName就会查找Person.prototype.fullName，然后是Object.prototype.fullName。&lt;/p&gt;

&lt;p&gt;英文原文：&lt;a href=&quot;http://net.tutsplus.com/tutorials/javascript-ajax/fully-understanding-the-this-keyword/?ref=vastwork&quot;&gt;Fully Understanding the this Keyword&lt;/a&gt; 
编译：&lt;a href=&quot;http://www.jobbole.com&quot;&gt;伯乐在线&lt;/a&gt; - &lt;a href=&quot;http://blog.jobbole.com/12203/&quot;&gt;唐小娟&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>CentOS6.3下Redis安装</title>
   <link href="http://beango.github.com/archives/2011/12/19/redis-install.html"/>
   <updated>2011-12-19T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2011/12/19/redis-install</id>
   <content type="html">&lt;ul&gt;
&lt;li&gt;下载最新的稳定版redis&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://redis.googlecode.com/files/redis-2.6.7.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar xzf  redis-2.6.7.tar.gz
cd redis-2.6.7
make PREFIX=/usr/local install
cp src/redis-server /usr/bin/ 
cp src/redis-cli /usr/bin/
cp src/redis-check-aof /usr/bin/
cp src/redis-check-dump /usr/bin/
cp src/redis-benchmark /usr/bin/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;make命令执行完成后，会在src目录下生成5个可执行文件，分别是redis-server、redis-cli、redis-benchmark、redis-check-aof、redis-check-dump，它们的作用如下：
redis-server：Redis服务器的daemon启动程序
redis-cli：Redis命令行操作工具。当然，你也可以用telnet根据其纯文本协议来操作
redis-benchmark：Redis性能测试工具，测试Redis在你的系统及你的配置下的读写性能
redis-check-aof：更新日志检查
redis-check-dump：用于本地数据库检查&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编写redis配置文件&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p /etc/redis/
cp redis.conf /etc/redis/redis.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;启动&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis-server /etc/redis/redis.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis-cli
redis 127.0.0.1:6379&amp;gt;set myKey  myValue
OK
redis 127.0.0.1:6379&amp;gt; get myKey
&quot;myValue&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;redis.conf 配置参数：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot; class=&quot;linkcodetoggle&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#是否作为守护进程运行
daemonize yes

#如以后台进程运行，则需指定一个pid，默认为/var/run/redis.pid
pidfile redis.pid

#绑定主机IP，默认值为127.0.0.1
#bind 127.0.0.1

#Redis默认监听端口
port 6379

#客户端闲置多少秒后，断开连接，默认为300（秒）
timeout 300

#日志记录等级，有4个可选值，debug，verbose（默认值），notice，warning
loglevel verbose

#指定日志输出的文件名，默认值为stdout，也可设为/dev/null屏蔽日志
logfile stdout

#可用数据库数，默认值为16，默认数据库为0
databases 16

#保存数据到disk的策略
#当有一条Keys数据被改变是，900秒刷新到disk一次
save 900 1

#当有10条Keys数据被改变时，300秒刷新到disk一次
save 300 10

#当有1w条keys数据被改变时，60秒刷新到disk一次
save 60 10000

#当dump .rdb数据库的时候是否压缩数据对象
rdbcompression yes

#本地数据库文件名，默认值为dump.rdb
dbfilename dump.rdb

#本地数据库存放路径，默认值为 ./
dir /var/lib/redis/

########### Replication #####################

#Redis的复制配置
# slaveof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt; 当本机为从服务时，设置主服务的IP及端口
# masterauth &amp;lt;master-password&amp;gt; 当本机为从服务时，设置主服务的连接密码

#连接密码
# requirepass foobared

#最大客户端连接数，默认不限制
# maxclients 128

#最大内存使用设置，达到最大内存设置后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理后，任到达最大内存设置，将无法再进行写入操作。
# maxmemory &amp;lt;bytes&amp;gt;

#是否在每次更新操作后进行日志记录，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认值为no
appendonly no

#更新日志文件名，默认值为appendonly.aof
#appendfilename

#更新日志条件，共有3个可选值。no表示等操作系统进行数据缓存同步到磁盘，always表示每次更新操作后手动调用fsync()将数据写到磁盘，everysec表示每秒同步一次（默认值）。
# appendfsync always

appendfsync everysec

# appendfsync no

################ VIRTUAL MEMORY ###########

#是否开启VM功能，默认值为no
vm-enabled no
# vm-enabled yes

#虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享
vm-swap-file /tmp/redis.swap

#将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的 (Redis的索引数据就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0。
vm-max-memory 0
vm-page-size 32
vm-pages 134217728
vm-max-threads 4

############# ADVANCED CONFIG ###############

glueoutputbuf yes
hash-max-zipmap-entries 64
hash-max-zipmap-value 512

#是否重置Hash表
activerehashing yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：Redis官方文档对VM的使用提出了一些建议:&lt;/p&gt;

&lt;p&gt;当你的key很小而value很大时,使用VM的效果会比较好.因为这样节约的内存比较大.
当你的key不小时,可以考虑使用一些非常方法将很大的key变成很大的value,比如你可以考虑将key,value组合成一个新的value.
最好使用linux ext3 等对稀疏文件支持比较好的文件系统保存你的swap文件.
vm-max-threads这个参数,可以设置访问swap文件的线程数,设置最好不要超过机器的核数.如果设置为0,那么所有对swap文件的操作都是串行的.可能会造成比较长时间的延迟,但是对数据完整性有很好的保证.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;常见错误-zmalloc.h:51:31: error: jemalloc/jemalloc.h: No such file or directory&lt;br/&gt;
检查是否安装gcc，如果已经安装，先执行make distclean再make&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;python操作redis&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;wget&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http:&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pypi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;python&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/packages/so&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;urce&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/r/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;redis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;redis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.7.2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gz&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#tar xvzf redis-py-2.7.2.tar.gz&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;python&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;#打开Python解释器：&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redis&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Redis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6379&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;bar&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;#或者写成 r[&amp;#39;foo&amp;#39;] = &amp;#39;bar&amp;#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   
&lt;span class=&quot;s&quot;&gt;&amp;#39;bar&amp;#39;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dbsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;#库里有多少key，多少条数据&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;OK!&amp;#39;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;#强行把数据库保存到硬盘。保存时阻塞&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;--------------------------------&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flushdb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;#删除当前数据库的所有数据&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;chang&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;# 因为是Noen对象，什么也不显示！&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;__class__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__delattr__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__doc__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__format__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__getattribute__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__hash__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__init__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__new__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__reduce__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__reduce_ex__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__repr__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__setattr__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__sizeof__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__str__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__subclasshook__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;chang&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;#看是否存在这个键值&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;False&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;# 列出所有键值。（这时候已经存了4个了）&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;aaa&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;bbb&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;key1&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>利用Tokyo Tyrant构建兼容Memcached协议、支持故障转移、高并发的分布式key-value持久存储系统</title>
   <link href="http://beango.github.com/archives/2011/12/03/tokyotyrant-memcached-keyvalue-system.html"/>
   <updated>2011-12-03T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2011/12/03/tokyotyrant-memcached-keyvalue-system</id>
   <content type="html">&lt;h3&gt;一、安装&lt;/h3&gt;

&lt;p&gt;&lt;li&gt;首先编译安装tokyocabinet数据库&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://www.1978th.net/tokyocabinet/tokyocabinet-1.4.45.tar.gz  
tar zxvf tokyocabinet-1.4.45.tar.gz  
cd tokyocabinet-1.4.45/  
./configure  
#注：在32位Linux操作系统上编译Tokyo cabinet，请使用./configure --enable-off64代替./configure，可以使数据库文件突破2GB的限制。   
#./configure --enable-off64  
make  
make install  
cd ../
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;然后编译安装tokyotyrant&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://www.1978th.net/tokyotyrant/tokyotyrant-1.1.40.tar.gz  
tar zxvf tokyotyrant-1.1.40.tar.gz  
cd tokyotyrant-1.1.40/  
./configure  
make  
make install  
cd ../
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;二、配置&lt;/h3&gt;

&lt;p&gt;1.创建tokyotyrant数据文件存放目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p /ttserver/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.启动tokyotyrant的主进程（ttserver）&lt;/p&gt;

&lt;p&gt;&lt;li&gt;单机模式&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ulimit -SHn 51200  
ttserver -host 127.0.0.1 -port 11211 -thnum 8 -dmn -pid /ttserver/ttserver.pid -log /ttserver/ttserver.log -le -ulog /ttserver/ -ulim 128m -sid 1 -rts /ttserver/ttserver.rts /ttserver/database.tcb\#lmemb=1024\#nmemb=2048\#bnum=10000000  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;双机互为主辅模式&lt;/li&gt;&lt;/p&gt;

&lt;p&gt;服务器192.168.1.91：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ulimit -SHn 51200  
ttserver -host 192.168.1.91 -port 11211 -thnum 8 -dmn -pid /ttserver/ttserver.pid -log /ttserver/ttserver.log -le -ulog /ttserver/ -ulim 128m -sid 91 -mhost 192.168.1.92 -mport 11211 -rts /ttserver/ttserver.rts /ttserver/database.tcb\#lmemb=1024\#nmemb=2048\#bnum=10000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务器192.168.1.92：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ulimit -SHn 51200  
ttserver -host 192.168.1.92 -port 11211 -thnum 8 -dmn -pid /ttserver/ttserver.pid -log /ttserver/ttserver.log -le -ulog /ttserver/ -ulim 128m -sid 92 -mhost 192.168.1.91 -mport 11211 -rts /ttserver/ttserver.rts /ttserver/database.tcb\#lmemb=1024\#nmemb=2048\#bnum=10000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.停止tokyotyrant（ttserver）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ps -ef | grep ttserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;找到ttserver的进程号并kill，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kill -TERM 2159
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.参数说明&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ttserver [-host name] [-port num] [-thnum num] [-tout num] [-dmn] [-pid path] [-log path] [-ld|-le] [-ulog path] [-ulim num] [-uas] [-sid num] [-mhost name] [-mport num] [-rts path] [dbname]  

-host name: 指定需要绑定的服务器域名或IP地址。默认绑定这台服务器上的所有IP地址。  
-port num: 指定需要绑定的端口号。默认端口号为1978  
-thnum num: 指定线程数。默认为8个线程。  
-tout num: 指定每个会话的超时时间（单位为秒）。默认永不超时。  
-dmn: 以守护进程方式运行。  
-pid path: 输出进程ID到指定文件（这里指定文件名）。  
-log path: 输出日志信息到指定文件（这里指定文件名）。  
-ld: 在日志文件中还记录DEBUG调试信息。  
-le: 在日志文件中仅记录错误信息。  
-ulog path: 指定同步日志文件存放路径（这里指定目录名）。  
-ulim num: 指定每个同步日志文件的大小（例如128m）。  
-uas: 使用异步IO记录更新日志（使用此项会减少磁盘IO消耗，但是数据会先放在内存中，不会立即写入磁盘，如果重启服务器或ttserver进程被kill掉，将导致部分数据丢失。一般情况下不建议使用）。  
-sid num: 指定服务器ID号（当使用主辅模式时，每台ttserver需要不同的ID号）   
-mhost name: 指定主辅同步模式下，主服务器的域名或IP地址。  
-mport num: 指定主辅同步模式下，主服务器的端口号。  
-rts path: 指定用来存放同步时间戳的文件名。  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用的是哈希数据库，可以指定参数“#bnum=xxx”来提高性能。它可以指定bucket存储桶的数量。例如指定“#bnum=1000000”，就可以将最新最热的100万条记录缓存在内存中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ttserver -host 127.0.0.1 -port 11211 -thnum 8 -dmn -pid /ttserver/ttserver.pid -log /ttserver/ttserver.log -le -ulog /ttserver/ -ulim 128m -sid 1 -rts /ttserver/ttserver.rts /ttserver/database.tch\#bnum=1000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果大量的客户端访问ttserver，请确保文件描述符够用。许多服务器的默认文件描述符为1024，可以在启动ttserver前使用ulimit命令提高这项值。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ulimit -SHn 51200
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;三、调用&lt;/h3&gt;

&lt;p&gt;1.任何Memcached客户端均可直接调用tokyotyrant。&lt;/p&gt;

&lt;p&gt;2.还可以通过HTTP方式调用，下面以Linux的curl命令为例，介绍如何操作tokyotyrant：&lt;/p&gt;

&lt;p&gt;&lt;li&gt;写数据，将数据“value”写入到“key”中：&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -X PUT http://127.0.0.1:11211/key -d &quot;value&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;读数据，读取“key”中数据：&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl http://127.0.0.1:11211/key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;li&gt;删数据，删除“key”：&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -X DELETE http://127.0.0.1:11211/key
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Redis系统性介绍</title>
   <link href="http://beango.github.com/archives/2011/11/20/exploring-redis.html"/>
   <updated>2011-11-20T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2011/11/20/exploring-redis</id>
   <content type="html">&lt;p&gt;虽然&lt;a href=&quot;http://blog.nosqlfan.com/tags/redis&quot; title=&quot;查看 Redis 的全部文章&quot;&gt;Redis&lt;/a&gt;已经很火了，相信还是有很多同学对Redis只是有所听闻或者了解并不全面，下面是一个比较系统的Redis介绍，对Redis的特性及各种数据类型及操作进行了介绍。是一个很不错的Redis入门教程。&lt;/p&gt;

&lt;h3&gt;1.介绍&lt;/h3&gt;

&lt;h4&gt;1.1 Redis是什么&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;RE&lt;/strong&gt;mote &lt;strong&gt;DI&lt;/strong&gt;ctionary &lt;strong&gt;S&lt;/strong&gt;erver(Redis) 是一个由Salvatore
Sanfilippo写的key-value存储系统。Redis提供了一些丰富的数据结构，包括 lists,
sets, ordered sets 以及 hashes
，当然还有和Memcached一样的 strings结构.Redis当然还包括了对这些数据结构的丰富操作。&lt;/p&gt;

&lt;h4&gt;1.2 Redis的优点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;性能极高 – Redis能支持超过 100K+ 每秒的读写频率。&lt;/li&gt;
&lt;li&gt;丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets
及 Ordered Sets 数据类型操作。&lt;/li&gt;
&lt;li&gt;原子 –
Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。&lt;/li&gt;
&lt;li&gt;丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;2.数据类型&lt;/h3&gt;

&lt;h4&gt;2.1 String类型&lt;/h4&gt;

&lt;p&gt;Redis能存储二进制安全的字符串，最大长度为1GB&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; SET name &quot;John Doe&quot;
OK
redis 127.0.0.1:6379&amp;gt; GET name
&quot;John Doe&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;String类型还支持批量的读写操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; MSET age 30 sex &quot;male&quot;
OK
redis 127.0.0.1:6379&amp;gt; MGET age sex
1) &quot;30&quot;
2) &quot;male&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;String类型其实也可以用来存储数字，并支持对数字的加减操作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; INCR age
(integer) 31
redis 127.0.0.1:6379&amp;gt; INCRBY age 4
(integer) 35
redis 127.0.0.1:6379&amp;gt; GET age
&quot;35&quot;
redis 127.0.0.1:6379&amp;gt; DECR age
(integer) 34
redis 127.0.0.1:6379&amp;gt; DECRBY age 4
(integer) 30
redis 127.0.0.1:6379&amp;gt; GET age
&quot;30&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;String类型还支持对其部分的修改和获取操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; APPEND name &quot; Mr.&quot;
(integer) 12
redis 127.0.0.1:6379&amp;gt; GET name
&quot;John Doe Mr.&quot;
redis 127.0.0.1:6379&amp;gt; STRLEN name
(integer) 12
redis 127.0.0.1:6379&amp;gt; SUBSTR name 0 3
&quot;John&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.2 List类型&lt;/h4&gt;

&lt;p&gt;Redis能够将数据存储成一个链表，并能对这个链表进行丰富的操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; LPUSH students &quot;John Doe&quot;
(integer) 1
redis 127.0.0.1:6379&amp;gt; LPUSH students &quot;Captain Kirk&quot;
(integer) 2
redis 127.0.0.1:6379&amp;gt; LPUSH students &quot;Sheldon Cooper&quot;
(integer) 3
redis 127.0.0.1:6379&amp;gt; LLEN students
(integer) 3
redis 127.0.0.1:6379&amp;gt; LRANGE students 0 2
1) &quot;Sheldon Cooper&quot;
2) &quot;Captain Kirk&quot;
3) &quot;John Doe&quot;
redis 127.0.0.1:6379&amp;gt; LPOP students
&quot;Sheldon Cooper&quot;
redis 127.0.0.1:6379&amp;gt; LLEN students
(integer) 2
redis 127.0.0.1:6379&amp;gt; LRANGE students 0 1
1) &quot;Captain Kirk&quot;
2) &quot;John Doe&quot;
redis 127.0.0.1:6379&amp;gt; LREM students 1 &quot;John Doe&quot;
(integer) 1
redis 127.0.0.1:6379&amp;gt; LLEN students
(integer) 1
redis 127.0.0.1:6379&amp;gt; LRANGE students 0 0
1) &quot;Captain Kirk&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Redis也支持很多修改操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; LINSERT students BEFORE &quot;Captain Kirk&quot; &quot;Dexter Morgan&quot;
(integer) 3
redis 127.0.0.1:6379&amp;gt; LRANGE students 0 2
1) &quot;Dexter Morgan&quot;
2) &quot;Captain Kirk&quot;
3) &quot;John Doe&quot;
redis 127.0.0.1:6379&amp;gt; LPUSH students &quot;Peter Parker&quot;
(integer) 4
redis 127.0.0.1:6379&amp;gt; LRANGE students 0 3
1) &quot;Peter Parker&quot;
2) &quot;Dexter Morgan&quot;
3) &quot;Captain Kirk&quot;
4) &quot;John Doe&quot;
redis 127.0.0.1:6379&amp;gt; LTRIM students 1 3
OK
redis 127.0.0.1:6379&amp;gt; LLEN students
(integer) 3
redis 127.0.0.1:6379&amp;gt; LRANGE students 0 2
1) &quot;Dexter Morgan&quot;
2) &quot;Captain Kirk&quot;
3) &quot;John Doe&quot;
redis 127.0.0.1:6379&amp;gt; LREM students 1 &quot;John Doe&quot;
(integer) 1
redis 127.0.0.1:6379&amp;gt; LLEN students
(integer) 1
redis 127.0.0.1:6379&amp;gt; LRANGE students 0 1
1) &quot;Captain Kirk&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.3 集合（Sets）类型&lt;/h4&gt;

&lt;p&gt;Redis能够将一系列不重复的值存储成一个集合&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; SADD birds crow
(integer) 1
redis 127.0.0.1:6379&amp;gt; SADD birds pigeon
(integer) 1
redis 127.0.0.1:6379&amp;gt; SADD birds bat
(integer) 1
redis 127.0.0.1:6379&amp;gt; SADD mammals dog
(integer) 1
redis 127.0.0.1:6379&amp;gt; SADD mammals cat
(integer) 1
redis 127.0.0.1:6379&amp;gt; SADD mammals bat
(integer) 1
redis 127.0.0.1:6379&amp;gt; SMEMBERS birds
1) &quot;bat&quot;
2) &quot;crow&quot;
3) &quot;pigeon&quot;
redis 127.0.0.1:6379&amp;gt; SMEMBERS mammals
1) &quot;bat&quot;
2) &quot;cat&quot;
3) &quot;dog&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sets结构也支持相应的修改操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; SREM mammals cat
(integer) 1
redis 127.0.0.1:6379&amp;gt; SMEMBERS mammals
1) &quot;bat&quot;
2) &quot;dog&quot;
redis 127.0.0.1:6379&amp;gt; SADD mammals human
(integer) 1
redis 127.0.0.1:6379&amp;gt; SMEMBERS mammals
1) &quot;bat&quot;
2) &quot;human&quot;
3) &quot;dog&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Redis还支持对集合的子交并补等操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; SINTER birds mammals
1) &quot;bat&quot;
redis 127.0.0.1:6379&amp;gt; SUNION birds mammals
1) &quot;crow&quot;
2) &quot;bat&quot;
3) &quot;human&quot;
4) &quot;pigeon&quot;
5) &quot;dog&quot;
redis 127.0.0.1:6379&amp;gt; SDIFF birds mammals
1) &quot;crow&quot;
2) &quot;pigeon&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.4 有序集合（Sorted Sets）类型&lt;/h4&gt;

&lt;p&gt;Sorted Sets和Sets结构相似，不同的是存在Sorted
Sets中的数据会有一个score属性，并会在写入时就按这个score排好序。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; ZADD days 0 mon
(integer) 1
redis 127.0.0.1:6379&amp;gt; ZADD days 1 tue
(integer) 1
redis 127.0.0.1:6379&amp;gt; ZADD days 2 wed
(integer) 1
redis 127.0.0.1:6379&amp;gt; ZADD days 3 thu
(integer) 1
redis 127.0.0.1:6379&amp;gt; ZADD days 4 fri
(integer) 1
redis 127.0.0.1:6379&amp;gt; ZADD days 5 sat
(integer) 1
redis 127.0.0.1:6379&amp;gt; ZADD days 6 sun
(integer) 1
redis 127.0.0.1:6379&amp;gt; ZCARD days
(integer) 7
redis 127.0.0.1:6379&amp;gt; ZRANGE days 0 6
1) &quot;mon&quot;
2) &quot;tue&quot;
3) &quot;wed&quot;
4) &quot;thu&quot;
5) &quot;fri&quot;
6) &quot;sat&quot;
7) &quot;sun&quot;
redis 127.0.0.1:6379&amp;gt; ZSCORE days sat
&quot;5&quot;
redis 127.0.0.1:6379&amp;gt; ZCOUNT days 3 6
(integer) 4
redis 127.0.0.1:6379&amp;gt; ZRANGEBYSCORE days 3 6
1) &quot;thu&quot;
2) &quot;fri&quot;
3) &quot;sat&quot;
4) &quot;sun&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.5 Hash类型&lt;/h4&gt;

&lt;p&gt;Redis能够存储key对多个属性的数据（比如user1.uname user1.passwd）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; HKEYS student
1) &quot;name&quot;
2) &quot;age&quot;
3) &quot;sex&quot;
redis 127.0.0.1:6379&amp;gt; HVALS student
1) &quot;Ganesh&quot;
2) &quot;30&quot;
3) &quot;Male&quot;
redis 127.0.0.1:6379&amp;gt; HGETALL student
1) &quot;name&quot;
2) &quot;Ganesh&quot;
3) &quot;age&quot;
4) &quot;30&quot;
5) &quot;sex&quot;
6) &quot;Male&quot;
redis 127.0.0.1:6379&amp;gt; HDEL student sex
(integer) 1
redis 127.0.0.1:6379&amp;gt; HGETALL student
1) &quot;name&quot;
2) &quot;Ganesh&quot;
3) &quot;age&quot;
4) &quot;30&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hash数据结构能够批量修改和获取&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; HMSET kid name Akshi age 2 sex Female
OK
redis 127.0.0.1:6379&amp;gt; HMGET kid name age sex
1) &quot;Akshi&quot;
2) &quot;2&quot;
3) &quot;Female&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3.Publish/Subscribe&lt;/h3&gt;

&lt;p&gt;Redis支持这样一种特性，你可以将数据推到某个信息管道中，然后其它人可以通过订阅这些管道来获取推送过来的信息。&lt;/p&gt;

&lt;h4&gt;3.1 订阅信息管道&lt;/h4&gt;

&lt;p&gt;用一个客户端订阅管道&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; SUBSCRIBE channelone
Reading messages... (press Ctrl-C to quit)
1) &quot;subscribe&quot;
2) &quot;channelone&quot;
3) (integer) 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个客户端往这个管道推送信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; PUBLISH channelone hello
(integer) 1
redis 127.0.0.1:6379&amp;gt; PUBLISH channelone world
(integer) 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后第一个客户端就能获取到推送的信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; SUBSCRIBE channelone
Reading messages... (press Ctrl-C to quit)
1) &quot;subscribe&quot;
2) &quot;channelone&quot;
3) (integer) 1
1) &quot;message&quot;
2) &quot;channelone&quot;
3) &quot;hello&quot;
1) &quot;message&quot;
2) &quot;channelone&quot;
3) &quot;world&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3.2 按一定模式批量订阅&lt;/h4&gt;

&lt;p&gt;用下面的命令订阅所有channel开头的信息通道&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; PSUBSCRIBE channel*
Reading messages... (press Ctrl-C to quit)
1) &quot;psubscribe&quot;
2) &quot;channel*&quot;
3) (integer) 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在另一个客户端对两个推送信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; PUBLISH channelone hello
(integer) 1
redis 127.0.0.1:6379&amp;gt; PUBLISH channeltwo world
(integer) 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在第一个客户端就能收到推送的信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; PSUBSCRIBE channel*
Reading messages... (press Ctrl-C to quit)
1) &quot;psubscribe&quot;
2) &quot;channel*&quot;
3) (integer) 1
1) &quot;pmessage&quot;
2) &quot;channel*&quot;
3) &quot;channelone&quot;
4) &quot;hello&quot;
1) &quot;pmessage&quot;
2) &quot;channel*&quot;
3) &quot;channeltwo&quot;
4) &quot;world&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4.数据过期设置&lt;/h3&gt;

&lt;p&gt;Redis支持按key设置过期时间，过期后值将被删除（在客户端看来是补删除了的）&lt;/p&gt;

&lt;p&gt;用TTL命令可以获取某个key值的过期时间（-1表示永不过期）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; SET name &quot;John Doe&quot;
OK
redis 127.0.0.1:6379&amp;gt; TTL name
(integer) -1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面命令先用EXISTS命令查看key值是否存在，然后设置了5秒的过期时间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; SET name &quot;John Doe&quot;
OK
redis 127.0.0.1:6379&amp;gt; EXISTS name
(integer) 1
redis 127.0.0.1:6379&amp;gt; EXPIRE name 5
(integer) 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5秒后再查看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; EXISTS name
(integer) 0
redis 127.0.0.1:6379&amp;gt; GET name
(nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个值已经没有了。&lt;/p&gt;

&lt;p&gt;上在是直接设置多少秒后过期，你也可以设置在某个时间点过期，下面例子是设置2011-09-24
00:40:00过期。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; SET name &quot;John Doe&quot;
OK
redis 127.0.0.1:6379&amp;gt; EXPIREAT name 1316805000
(integer) 1
redis 127.0.0.1:6379&amp;gt; EXISTS name
(integer) 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;5.事务性&lt;/h3&gt;

&lt;p&gt;Redis本身支持一些简单的组合型的命令，比如以NX结尾命令都是判断在这个值没有时才进行某个命令。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; SET name &quot;John Doe&quot;
OK
redis 127.0.0.1:6379&amp;gt; SETNX name &quot;Dexter Morgan&quot;
(integer) 0
redis 127.0.0.1:6379&amp;gt; GET name
&quot;John Doe&quot;

redis 127.0.0.1:6379&amp;gt; GETSET name &quot;Dexter Morgan&quot;
&quot;John Doe&quot;
redis 127.0.0.1:6379&amp;gt; GET name
&quot;Dexter Morgan&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，Redis还支持自定义的命令组合，通过MULTI和EXEC，将几个命令组合起来执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; SET counter 0
OK
redis 127.0.0.1:6379&amp;gt; MULTI
OK
redis 127.0.0.1:6379&amp;gt; INCR counter
QUEUED
redis 127.0.0.1:6379&amp;gt; INCR counter
QUEUED
redis 127.0.0.1:6379&amp;gt; INCR counter
QUEUED
redis 127.0.0.1:6379&amp;gt; EXEC
1) (integer) 1
2) (integer) 2
3) (integer) 3
redis 127.0.0.1:6379&amp;gt; GET counter
&quot;3&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你还可以用DICARD命令来中断执行中的命令序列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; SET newcounter 0
OK
redis 127.0.0.1:6379&amp;gt; MULTI
OK
redis 127.0.0.1:6379&amp;gt; INCR newcounter
QUEUED
redis 127.0.0.1:6379&amp;gt; INCR newcounter
QUEUED
redis 127.0.0.1:6379&amp;gt; INCR newcounter
QUEUED
redis 127.0.0.1:6379&amp;gt; DISCARD
OK
redis 127.0.0.1:6379&amp;gt; GET newcounter
&quot;0&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;6.持久化&lt;/h3&gt;

&lt;p&gt;Redis的所有数据都存储在内存中，但是他也提供对这些数据的持久化。&lt;/p&gt;

&lt;h4&gt;6.1 数据快照&lt;/h4&gt;

&lt;p&gt;数据快照的原理是将整个Redis中存的所有数据遍历一遍存到一个扩展名为rdb的数据文件中。通过SAVE命令可以调用这个过程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; SET name &quot;John Doe&quot;
OK
redis 127.0.0.1:6379&amp;gt; SAVE
OK
redis 127.0.0.1:6379&amp;gt; SET name &quot;Sheldon Cooper&quot;
OK
redis 127.0.0.1:6379&amp;gt; BGSAVE
Background saving started
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你是使用的brew在Mac OSX上安全的Redis，那么rdb文件会存在如下路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/var/db/redis/dump.rdb
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;6.2 Append-Only File（追加式的操作日志记录）&lt;/h4&gt;

&lt;p&gt;Redis还支持一种追加式的操作日志记录，叫append only
file，其日志文件以aof结局，我们一般各为aof文件。要开启aof日志的记录，你需要在配置文件中进行如下设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;appendonly yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时候你所有的操作都会记录在aof日志文件中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; GET name
(nil)
redis 127.0.0.1:6379&amp;gt; SET name &quot;Ganesh Gunasegaran&quot;
OK
redis 127.0.0.1:6379&amp;gt; EXIT

→ cat /usr/local/var/db/redis/appendonly.aof
*2
$6
SELECT
$1
0
*3
$3
SET
$4
name
$18
Ganesh Gunasegaran
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;7.管理命令&lt;/h3&gt;

&lt;p&gt;Redis支持多个DB，默认是16个，你可以设置将数据存在哪一个DB中，不同DB间的数据具有隔离性。也可以在多个DB间移动数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; SELECT 0
OK
redis 127.0.0.1:6379&amp;gt; SET name &quot;John Doe&quot;
OK
redis 127.0.0.1:6379&amp;gt; SELECT 1
OK
redis 127.0.0.1:6379[1]&amp;gt; GET name
(nil)
redis 127.0.0.1:6379[1]&amp;gt; SELECT 0
OK
redis 127.0.0.1:6379&amp;gt; MOVE name 1
(integer) 1
redis 127.0.0.1:6379&amp;gt; SELECT 1
OK
redis 127.0.0.1:6379[1]&amp;gt; GET name
&quot;John Doe&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Redis还能进行一些如下操作，获取一些运行信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379[1]&amp;gt; DBSIZE
(integer) 1
redis 127.0.0.1:6379[1]&amp;gt; INFO
redis_version:2.2.13
redis_git_sha1:00000000
redis_git_dirty:0
arch_bits:64
multiplexing_api:kqueue
......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Redis还支持对某个DB数据进行清除（当然清空所有数据的操作也是支持的）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6379&amp;gt; SET name &quot;John Doe&quot;
OK
redis 127.0.0.1:6379&amp;gt; DBSIZE
(integer) 1
redis 127.0.0.1:6379&amp;gt; SELECT 1
OK
redis 127.0.0.1:6379[1]&amp;gt; SET name &quot;Sheldon Cooper&quot;
OK
redis 127.0.0.1:6379[1]&amp;gt; DBSIZE
(integer) 1
redis 127.0.0.1:6379[1]&amp;gt; SELECT 0
OK
redis 127.0.0.1:6379&amp;gt; FLUSHDB
OK
redis 127.0.0.1:6379&amp;gt; DBSIZE
(integer) 0
redis 127.0.0.1:6379&amp;gt; SELECT 1
OK
redis 127.0.0.1:6379[1]&amp;gt; DBSIZE
(integer) 1
redis 127.0.0.1:6379[1]&amp;gt; FLUSHALL
OK
redis 127.0.0.1:6379[1]&amp;gt; DBSIZE
(integer) 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;8.客户端&lt;/h3&gt;

&lt;p&gt;Redis的客户端很丰富，几乎所有流行的语言都有其客户端，这里就不再赘述，有兴趣的同学可以上Redis的&lt;a href=&quot;http://redis.io/clients&quot;&gt;Clients页面&lt;/a&gt;去查找。&lt;/p&gt;

&lt;h3&gt;9.资料引用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://redis.io/documentation&quot;&gt;Redis documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://simonwillison.net/static/2010/redis-tutorial/&quot;&gt;Simon Willison – Redis
tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.mjrusso.com/2010/10/17/redis-from-the-ground-up.html&quot;&gt;Michael J. Russo – Redis from ground
up&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;10.总结&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2011-11/12pXcY.png&quot; title=&quot;Redis overview&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;来源：&lt;a href=&quot;http://itsgg.com/2011/09/24/exploring-redis/&quot;&gt;itsgg.com&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MongoDB运行状态、性能监控，分析</title>
   <link href="http://beango.github.com/archives/2011/10/26/mongodb-running-state-performance-monitoring-analysis.html"/>
   <updated>2011-10-26T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2011/10/26/mongodb-running-state-performance-monitoring-analysis</id>
   <content type="html">&lt;p&gt;这篇文章的目的是让你知道怎么了解你正在运行的Mongdb是否健康。&lt;/p&gt;

&lt;h2&gt;mongostat详解&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2011-10/mongod_stat-300x46.png&quot; title=&quot;mongod_stat&quot; alt=&quot;mongostat&quot; style=&quot;float:right;&quot;&gt;
mongostat是mongdb自带的状态检测工具，在命令行下使用。它会间隔固定时间获取mongodb的当前运行状态，并输出。如果你发现数据库突然变慢或者有其他问题的话，你第一手的操作就考虑采用mongostat来查看mongo的状态。&lt;/p&gt;

&lt;p&gt;它的输出有以下几列：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;inserts/s 每秒插入次数&lt;/li&gt;
&lt;li&gt;query/s 每秒查询次数&lt;/li&gt;
&lt;li&gt;update/s 每秒更新次数&lt;/li&gt;
&lt;li&gt;delete/s 每秒删除次数&lt;/li&gt;
&lt;li&gt;getmore/s 每秒执行getmore次数&lt;/li&gt;
&lt;li&gt;command/s 每秒的命令数，比以上插入、查找、更新、删除的综合还多，还统计了别的命令&lt;/li&gt;
&lt;li&gt;flushs/s 每秒执行fsync将数据写入硬盘的次数。&lt;/li&gt;
&lt;li&gt;mapped/s 所有的被mmap的数据量，单位是MB，&lt;/li&gt;
&lt;li&gt;vsize 虚拟内存使用量，单位MB&lt;/li&gt;
&lt;li&gt;res 物理内存使用量，单位MB&lt;/li&gt;
&lt;li&gt;faults/s 每秒访问失败数（只有Linux有），数据被交换出物理内存，放到swap。不要超过100，否则就是机器内存太小，造成频繁swap写入。此时要升级内存或者扩展&lt;/li&gt;
&lt;li&gt;locked % 被锁的时间百分比，尽量控制在50%以下吧&lt;/li&gt;
&lt;li&gt;idx miss % 索引不命中所占百分比。如果太高的话就要考虑索引是不是少了&lt;/li&gt;
&lt;li&gt;q t|r|w 当Mongodb接收到太多的命令而数据库被锁住无法执行完成，它会将命令加入队列。这一栏显示了总共、读、写3个队列的长度，都为0的话表示mongo毫无压力。高并发时，一般队列值会升高。&lt;/li&gt;
&lt;li&gt;conn 当前连接数&lt;/li&gt;
&lt;li&gt;time 时间戳&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;使用profiler&lt;/h2&gt;

&lt;p&gt;类似于MySQL的slow log, MongoDB可以监控所有慢的以及不慢的查询。&lt;/p&gt;

&lt;p&gt;Profiler默认是关闭的，你可以选择全部开启，或者有慢查询的时候开启。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; use test
switched to db test
&amp;gt; db.setProfilingLevel(2);
{&quot;was&quot; : 0 , &quot;slowms&quot; : 100, &quot;ok&quot; : 1} // &quot;was&quot; is the old setting
&amp;gt; db.getProfilingLevel()
2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看Profile日志&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; db.system.profile.find().sort({$natural:-1})
{&quot;ts&quot; : &quot;Thu Jan 29 2009 15:19:32 GMT-0500 (EST)&quot; , &quot;info&quot; :
&quot;query test.$cmd ntoreturn:1 reslen:66 nscanned:0 query: { profile: 2 } nreturned:1 bytes:50&quot; ,
&quot;millis&quot; : 0} ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3个字段的意义&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ts：时间戳&lt;/li&gt;
&lt;li&gt;info：具体的操作&lt;/li&gt;
&lt;li&gt;millis：操作所花时间，毫秒&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;不多说，此处有&lt;a href=&quot;http://www.mongodb.org/display/DOCS/Database+Profiler&quot;&gt;官方文档&lt;/a&gt;。注意，造成满查询可能是索引的问题，也可能是数据不在内存造成因此磁盘读入造成。&lt;/p&gt;

&lt;h2&gt;使用Web控制台&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2011-10/mongod-localhost.png&quot;&gt;&lt;img src=&quot;/assets/files/2011-10/mongod-localhost.png&quot; title=&quot;mongodb web monitor&quot; alt=&quot;mongodb web
monitor&quot; /&gt;&lt;/a&gt;Mongodb自带了Web控制台，默认和数据服务一同开启。他的端口在Mongodb数据库服务器端口的基础上加1000，如果是默认的Mongodb数据服务端口(Which is 27017)，则相应的Web端口为28017这个页面可以看到&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当前Mongodb的所有连接&lt;/li&gt;
&lt;li&gt;各个数据库和Collection的访问统计，包括：Reads, Writes, Queries, GetMores ,Inserts, Updates, Removes&lt;/li&gt;
&lt;li&gt;写锁的状态&lt;/li&gt;
&lt;li&gt;以及日志文件的最后几百行（CentOS+10gen yum安装的mongodb默认的日志文件位于/var/log/mongo/mongod.log)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;可以参考右边的截图&lt;/p&gt;

&lt;h2&gt;db.stat()&lt;/h2&gt;

&lt;p&gt;获取当前数据库的信息，比如Obj总数、数据库总大小、平均Obj大小等&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; use test
switched to db test
&amp;gt; db.stats()
{
    &quot;collections&quot; : 9,
    &quot;objects&quot; : 4278845,
    &quot;avgObjSize&quot; : 224.56603031892953,
    &quot;dataSize&quot; : 960883236,
    &quot;storageSize&quot; : 1195438080,
    &quot;numExtents&quot; : 59,
    &quot;indexes&quot; : 13,
    &quot;indexSize&quot; : 801931264,
    &quot;fileSize&quot; : 6373244928,
    &quot;ok&quot; : 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;db.serverStatus()&lt;/h2&gt;

&lt;p&gt;获取服务器的状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &quot;version&quot; : &quot;1.6.5&quot;,
    &quot;uptime&quot; : 7208469,
    &quot;uptimeEstimate&quot; : 7138829,
    &quot;localTime&quot; : &quot;Wed Oct 26 2011 22:23:07 GMT+0800 (CST)&quot;,
    &quot;globalLock&quot; : {
        &quot;totalTime&quot; : 7208469556704,
        &quot;lockTime&quot; : 4959693717,
        &quot;ratio&quot; : 0.000688036992871448,
        &quot;currentQueue&quot; : {
            &quot;total&quot; : 0,
            &quot;readers&quot; : 0,
            &quot;writers&quot; : 0
        }
    },
    &quot;mem&quot; : {
        &quot;bits&quot; : 64,
        &quot;resident&quot; : 3131,
        &quot;virtual&quot; : 6172,
        &quot;supported&quot; : true,
        &quot;mapped&quot; : 4927
    },
    &quot;connections&quot; : {
        &quot;current&quot; : 402,
        &quot;available&quot; : 2599
    },
    &quot;extra_info&quot; : {
        &quot;note&quot; : &quot;fields vary by platform&quot;,
        &quot;heap_usage_bytes&quot; : 832531920,
        &quot;page_faults&quot; : 8757
    },
    &quot;indexCounters&quot; : {
        &quot;btree&quot; : {
            &quot;accesses&quot; : 2821726,
            &quot;hits&quot; : 2821725,
            &quot;misses&quot; : 1,
            &quot;resets&quot; : 0,
            &quot;missRatio&quot; : 3.543930204420982e-7
        }
    },
    &quot;backgroundFlushing&quot; : {
        &quot;flushes&quot; : 120133,
        &quot;total_ms&quot; : 73235923,
        &quot;average_ms&quot; : 609.6236920746173,
        &quot;last_ms&quot; : 1332,
        &quot;last_finished&quot; : &quot;Wed Oct 26 2011 22:22:23 GMT+0800 (CST)&quot;
    },
    &quot;cursors&quot; : {
        &quot;totalOpen&quot; : 0,
        &quot;clientCursors_size&quot; : 0,
        &quot;timedOut&quot; : 238392
    },
    &quot;repl&quot; : {
        &quot;ismaster&quot; : true
    },
    &quot;opcounters&quot; : {
        &quot;insert&quot; : 269351,
        &quot;query&quot; : 19331151,
        &quot;update&quot; : 14199331,
        &quot;delete&quot; : 1,
        &quot;getmore&quot; : 145575,
        &quot;command&quot; : 55982302
    },
    &quot;asserts&quot; : {
        &quot;regular&quot; : 0,
        &quot;warning&quot; : 0,
        &quot;msg&quot; : 0,
        &quot;user&quot; : 27,
        &quot;rollovers&quot; : 0
    },
    &quot;ok&quot; : 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要关心的地方：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;connections 当前连接和可用连接数，听过一个同行介绍过，mongodb最大处理到2000个连接就不行了（要根据你的机器性能和业务来设定），所以设大了没意义。设个合理值的话，到达这个值mongodb就拒绝新的连接请求，避免被太多的连接拖垮。&lt;/li&gt;
&lt;li&gt;indexCounters:btree:misses 索引的不命中数，和hits的比例高就要考虑索引是否正确建立。你看我的”missRatio” : 3.543930204420982e-7，很健康吧。所以miss率在mongostat里面也可以看&lt;/li&gt;
&lt;li&gt;其他的都能自解释，也不是查看mongo健康状况的关键，就不说明了。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;db.currentOp()&lt;/h2&gt;

&lt;p&gt;Mongodb
的命令一般很快就完成，但是在一台繁忙的机器或者有比较慢的命令时，你可以通过db.currentOp()获取当前正在执行的操作。&lt;/p&gt;

&lt;p&gt;在没有负载的机器上，该命令基本上都是返回空的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;  db.currentOp()
{ &quot;inprog&quot; : [ ] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是一个有负载的机器上得到的返回值样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ &quot;opid&quot; : &quot;shard3:466404288&quot;, &quot;active&quot; : false, &quot;waitingForLock&quot; : false, &quot;op&quot; : &quot;query&quot;, &quot;ns&quot; : &quot;sd.usersEmails&quot;, &quot;query&quot; : { }, &quot;client_s&quot; : &quot;10.121.13.8:34473&quot;, &quot;desc&quot; : &quot;conn&quot; },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字段名字都能自解释。如果你发现一个操作太长，把数据库卡死的话，可以用这个命令杀死他&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; db.killOp(&quot;shard3:466404288&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;MongoDB Monitoring Service&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/2011-10/mms.png&quot;&gt;&lt;img src=&quot;/assets/files/2011-10/mms.png&quot; title=&quot;mms&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;MongoDB Monitoring Service(MMS)是Mongodb厂商提供的监控服务，可以在网页和Android客户端上监控你的MongoDB状况。请&lt;a href=&quot;http://blog.nosqlfan.com/html/3171.html&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MongoDB构架图分享</title>
   <link href="http://beango.github.com/archives/2011/10/15/mongodb-architecture.html"/>
   <updated>2011-10-15T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2011/10/15/mongodb-architecture</id>
   <content type="html">&lt;p&gt;本文图片来自Ricky
Ho的博文&lt;a href=&quot;http://horicky.blogspot.jp/2012/04/mongodb-architecture.html&quot;&gt;MongoDB构架&lt;/a&gt;（&lt;a href=&quot;http://blog.nosqlfan.com/tags/mongodb&quot; title=&quot;查看 MongoDB 的全部文章&quot;&gt;MongoDB&lt;/a&gt;
Architecture），这是个一听就感觉很宽泛的话题，但是作者在文章中确实对MongoDB由内至外的&lt;a href=&quot;http://blog.nosqlfan.com/tags/%e6%9e%b6%e6%9e%84&quot; title=&quot;查看 架构 的全部文章&quot;&gt;架构&lt;/a&gt;进行了剖析。本文截取了其文章中的几张重点架构示意图片进行简单描述。希望对大家有用。&lt;/p&gt;

&lt;h3&gt;MongoDB数据文件内部结构&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-10/O6EzR.png&quot; alt=&quot;MongoDB构架图&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;MongoDB在数据存储上按命名空间来划分，一个collection是一个命名空间，一个索引也是一个命名空间&lt;/li&gt;
&lt;li&gt;同一个命名空间的数据被分成很多个Extent，Extent之间使用双向链表连接&lt;/li&gt;
&lt;li&gt;在每一个Extent中，保存了具体每一行的数据，这些数据也是通过双向链接连接的&lt;/li&gt;
&lt;li&gt;每一行数据存储空间不仅包括数据占用空间，还可能包含一部分附加空间，这使得在数据update变大后可以不移动位置&lt;/li&gt;
&lt;li&gt;索引以BTree结构实现&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;相关阅读：《&lt;a href=&quot;http://blog.nosqlfan.com/html/3515.html&quot;&gt;MongoDB数据文件内部结构&lt;/a&gt;》&lt;/p&gt;

&lt;h3&gt;在MongoDB中实现事务&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-10/qklTw.png&quot; alt=&quot;MongoDB构架图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;众所周知，MongoDB只支持对单行记录的原子性修改，并不支持对多行数据的原子操作。但是通过上图中的变态操作，实际你也可以自己实现事务。其步骤如图所未：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第1步：先记录一条事务记录，将要修改的多行记录的修改值写到里面，并设置其状态为init（如果这时候操作中断，那么在重新启动时，会判断到他处于init状态，从而将其保存的多行修改操作应用到具体的行上）&lt;/li&gt;
&lt;li&gt;第2步：然后更新具体要修改的行，将刚才写的事务记录的标识写到它的tran字段中&lt;/li&gt;
&lt;li&gt;第3步：将事务记录的状态从init变成pending（如果在这时候操作中断，那么在重新启动时，会判断到它的状态是pending的，这时候查看其所有对应的多条要修改的记录，如果其tran有值，那么就进行第4步，如果没值，说明第4步已经执行过了，直接将其状态从pending变成commited了就行）&lt;/li&gt;
&lt;li&gt;第4步：将需要修改的多条记录的相应值修改了，并且unset掉之前的tran字段&lt;/li&gt;
&lt;li&gt;第5步：将事务记录那一条的状态从pending变成commited，事务完成&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;其实上面的步骤并不罕见，在支持事务的DBMS中，其事务原子性提交的保证大多都与上面类似。其实事务记录的tran那条记录，就类似于这些DBMS中的redolog一样。&lt;/p&gt;

&lt;h3&gt;MongoDB数据同步&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-10/8SKjb.png&quot; alt=&quot;MongoDB构架图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是MongoDB采用Replica Sets模式的同步流程&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;红色箭头表示写操作写到Primary上，然后异步同步到多个Secondary上&lt;/li&gt;
&lt;li&gt;蓝色箭头表示读操作可以从Primary或Secondary任意一个上读&lt;/li&gt;
&lt;li&gt;各个Primary与Secondary之间一直保持心跳同步检测，用于判断Replica
Sets的状态&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;分片机制&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-10/wlqvf.png&quot; alt=&quot;MongoDB构架图&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MongoDB的分片是指定一个分片key来进行，数据按范围分成不同的chunk，每个chunk的大小有限制&lt;/li&gt;
&lt;li&gt;有多个分片节点保存这些chunk，每个节点保存一部分的chunk&lt;/li&gt;
&lt;li&gt;每一个分片节点都是一个Replica Sets，这样保证数据的安全性&lt;/li&gt;
&lt;li&gt;当一个chunk超过其限制的最大体积时，会分裂成两个小的chunk&lt;/li&gt;
&lt;li&gt;当chunk在分片节点中分布不均衡时，会引发chunk迁移操作&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;服务器角色&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2012-10/RArrX.png&quot; alt=&quot;MongoDB构架图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面讲了分片的标准，下面是具体在分片时的几种节点角色&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端访问路由节点mongos来进行数据读写&lt;/li&gt;
&lt;li&gt;config服务器保存了两个映射关系，一个是key值的区间对应哪一个chunk的映射关系，另一个是chunk存在哪一个分片节点的映射关系&lt;/li&gt;
&lt;li&gt;路由节点通过config服务器获取数据信息，通过这些信息，找到真正存放数据的分片节点进行对应操作&lt;/li&gt;
&lt;li&gt;路由节点还会在写操作时判断当前chunk是否超出限定大小，如果超出，就分列成两个chunk&lt;/li&gt;
&lt;li&gt;对于按分片key进行的查询和update操作来说，路由节点会查到具体的chunk然后再进行相关的工作&lt;/li&gt;
&lt;li&gt;对于不按分片key进行的查询和update操作来说，mongos会对所有下属节点发送请求然后再对返回结果进行合并&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;更多详细内容请看原文：&lt;a href=&quot;http://horicky.blogspot.jp/2012/04/mongodb-architecture.html&quot;&gt;MongoDB Architecture&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Markdown语法说明 (简体中文版)</title>
   <link href="http://beango.github.com/archives/2011/10/09/markdown-doc.html"/>
   <updated>2011-10-09T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2011/10/09/markdown-doc</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; This is Simplelified  Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to &lt;a href=&quot;http://daringfireball.net/projects/markdown/syntax&quot;&gt;Markdown: Syntax&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;声明：&lt;/strong&gt; 这份文档派生(fork)于&lt;a href=&quot;http://markdown.tw/&quot;&gt;繁体中文版&lt;/a&gt;，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里&lt;a href=&quot;http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md&quot;&gt;查看它的源文件&lt;/a&gt;。「繁体中文版的原始文件可以&lt;a href=&quot;https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md&quot;&gt;查看这里&lt;/a&gt; 。」--By @&lt;a href=&quot;http://twitter.com/riku&quot;&gt;riku&lt;/a&gt; / 本项目托管于 &lt;a href=&quot;http://gitcafe.com/riku/Markdown-Syntax-CN&quot;&gt;GitCafe&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 本项目同时也托管于 &lt;a href=&quot;https://github.com/riku/Markdown-Syntax-CN&quot;&gt;Github&lt;/a&gt; 上，请通过 fork＋pull request 方式来帮忙改进本项目。&lt;/p&gt;

&lt;h1&gt;Markdown 语法说明 (简体中文版)&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#overview&quot;&gt;概述&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#philosophy&quot;&gt;宗旨&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#html&quot;&gt;兼容 HTML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#autoescape&quot;&gt;特殊字符自动转换&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#block&quot;&gt;区块元素&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#p&quot;&gt;段落和换行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#header&quot;&gt;标题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#blockquote&quot;&gt;区块引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#list&quot;&gt;列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#precode&quot;&gt;代码区块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#hr&quot;&gt;分隔线&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#span&quot;&gt;区段元素&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#link&quot;&gt;链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#em&quot;&gt;强调&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#code&quot;&gt;代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#img&quot;&gt;图片&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#misc&quot;&gt;其它&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#backslash&quot;&gt;反斜杠&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#autolink&quot;&gt;自动链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#acknowledgement&quot;&gt;感谢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#editor&quot;&gt;Markdown 免费编辑器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;

&lt;h2 id=&quot;overview&quot;&gt;概述&lt;/h2&gt;




&lt;h3 id=&quot;philosophy&quot;&gt;宗旨&lt;/h3&gt;


&lt;p&gt;Markdown 的目标是实现「易读易写」。&lt;/p&gt;

&lt;p&gt;可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 &lt;a href=&quot;http://docutils.sourceforge.net/mirror/setext.html&quot;&gt;Setext&lt;/a&gt;、&lt;a href=&quot;http://www.aaronsw.com/2002/atx/&quot;&gt;atx&lt;/a&gt;、&lt;a href=&quot;http://textism.com/tools/textile/&quot;&gt;Textile&lt;/a&gt;、&lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;reStructuredText&lt;/a&gt;、&lt;a href=&quot;http://www.triptico.com/software/grutatxt.html&quot;&gt;Grutatext&lt;/a&gt; 和 &lt;a href=&quot;http://ettext.taint.org/doc/&quot;&gt;EtText&lt;/a&gt;，而最大灵感来源其实是纯文本电子邮件的格式。&lt;/p&gt;

&lt;p&gt;总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。&lt;/p&gt;

&lt;h3 id=&quot;html&quot;&gt;兼容 HTML&lt;/h3&gt;


&lt;p&gt;Markdown 语法的目标是：成为一种适用于网络的&lt;em&gt;书写&lt;/em&gt;语言。&lt;/p&gt;

&lt;p&gt;Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想&lt;em&gt;不是&lt;/em&gt;要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种&lt;em&gt;发布&lt;/em&gt;的格式，Markdown 是一种&lt;em&gt;书写&lt;/em&gt;的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。&lt;/p&gt;

&lt;p&gt;不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。&lt;/p&gt;

&lt;p&gt;要制约的只有一些 HTML 区块元素――比如 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 标签。&lt;/p&gt;

&lt;p&gt;例子如下，在 Markdown 文件里加上一段 HTML 表格：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是一个普通段落。

&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;Foo&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;

这是另一个普通段落。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的&lt;code&gt;*强调*&lt;/code&gt;会没有效果。&lt;/p&gt;

&lt;p&gt;HTML 的区段（行内）标签如 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;cite&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;del&amp;gt;&lt;/code&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。&lt;/p&gt;

&lt;p&gt;和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。&lt;/p&gt;

&lt;h3 id=&quot;autoescape&quot;&gt;特殊字符自动转换&lt;/h3&gt;


&lt;p&gt;在 HTML 文件中，有两个字符需要特殊处理： &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 。 &lt;code&gt;&amp;lt;&lt;/code&gt; 符号用于起始标签，&lt;code&gt;&amp;amp;&lt;/code&gt; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &lt;code&gt;&amp;amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;amp;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; 字符尤其让网络文档编写者受折磨，如果你要打「&lt;code&gt;AT&amp;amp;T&lt;/code&gt;」 ，你必须要写成「&lt;code&gt;AT&amp;amp;amp;T&lt;/code&gt;」。而网址中的 &lt;code&gt;&amp;amp;&lt;/code&gt; 字符也要转换。比如你要链接到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://images.google.com/images?num=30&amp;amp;q=larry+bird
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你必须要把网址转换写为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://images.google.com/images?num=30&amp;amp;amp;q=larry+bird
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;才能放到链接标签的 &lt;code&gt;href&lt;/code&gt; 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。&lt;/p&gt;

&lt;p&gt;Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &lt;code&gt;&amp;amp;&lt;/code&gt; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &lt;code&gt;&amp;amp;amp&lt;/code&gt;;。&lt;/p&gt;

&lt;p&gt;所以你如果要在文档中插入一个版权符号 &lt;code&gt;©&lt;/code&gt;，你可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;copy;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Markdown 会保留它不动。而若你写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AT&amp;amp;T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Markdown 就会将它转为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AT&amp;amp;amp;T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似的状况也会发生在 &lt;code&gt;&amp;lt;&lt;/code&gt; 符号上，因为 Markdown 允许 &lt;a href=&quot;#html&quot;&gt;兼容 HTML&lt;/a&gt; ，如果你是把 &lt;code&gt;&amp;lt;&lt;/code&gt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;4 &amp;lt; 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Markdown 将会把它转换为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;4 &amp;amp;lt; 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过需要注意的是，code 范围内，不论是行内还是区块， &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 两个符号都&lt;em&gt;一定&lt;/em&gt;会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;block&quot;&gt;区块元素&lt;/h2&gt;




&lt;h3 id=&quot;p&quot;&gt;段落和换行&lt;/h3&gt;


&lt;p&gt;一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。&lt;/p&gt;

&lt;p&gt;「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; 标签。&lt;/p&gt;

&lt;p&gt;如果你&lt;em&gt;确实&lt;/em&gt;想要依赖 Markdown 来插入 &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; 标签的话，在插入处先按入两个以上的空格然后回车。&lt;/p&gt;

&lt;p&gt;的确，需要多费点事（多加空格）来产生 &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; ，但是简单地「每个换行都转换为 &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;」的方法在 Markdown 中并不适合， Markdown 中 email 式的 &lt;a href=&quot;#blockquote&quot;&gt;区块引用&lt;/a&gt; 和多段落的 &lt;a href=&quot;#list&quot;&gt;列表&lt;/a&gt; 在使用换行来排版的时候，不但更好用，还更方便阅读。&lt;/p&gt;

&lt;h3 id=&quot;header&quot;&gt;标题&lt;/h3&gt;


&lt;p&gt;Markdown 支持两种标题的语法，类 &lt;a href=&quot;http://docutils.sourceforge.net/mirror/setext.html&quot;&gt;Setext&lt;/a&gt; 和类 &lt;a href=&quot;http://www.aaronsw.com/2002/atx/&quot;&gt;atx&lt;/a&gt; 形式。&lt;/p&gt;

&lt;p&gt;类 Setext 形式是用底线的形式，利用 &lt;code&gt;=&lt;/code&gt; （最高阶标题）和 &lt;code&gt;-&lt;/code&gt; （第二阶标题），例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This is an H1
=============

This is an H2
-------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;任何数量的 &lt;code&gt;=&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; 都可以有效果。&lt;/p&gt;

&lt;p&gt;类 Atx 形式则是在行首插入 1 到 6 个 &lt;code&gt;#&lt;/code&gt; ，对应到标题 1 到 6 阶，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 这是 H1

## 这是 H2

###### 这是 H6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 &lt;code&gt;#&lt;/code&gt;，而行尾的 &lt;code&gt;#&lt;/code&gt; 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 这是 H1 #

## 这是 H2 ##

### 这是 H3 ######
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;blockquote&quot;&gt;区块引用 Blockquotes&lt;/h3&gt;


&lt;p&gt;Markdown 标记区块引用是使用类似 email 中用 &lt;code&gt;&amp;gt;&lt;/code&gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &lt;code&gt;&amp;gt;&lt;/code&gt; ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&amp;gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&amp;gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&amp;gt; 
&amp;gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&amp;gt; id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &lt;code&gt;&amp;gt;&lt;/code&gt; ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&amp;gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &lt;code&gt;&amp;gt;&lt;/code&gt; ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; This is the first level of quoting.
&amp;gt;
&amp;gt; &amp;gt; This is nested blockquote.
&amp;gt;
&amp;gt; Back to the first level.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; ## 这是一个标题。
&amp;gt; 
&amp;gt; 1.   这是第一行列表项。
&amp;gt; 2.   这是第二行列表项。
&amp;gt; 
&amp;gt; 给出一些例子代码：
&amp;gt; 
&amp;gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择&lt;em&gt;增加引用阶层&lt;/em&gt;。&lt;/p&gt;

&lt;h3 id=&quot;list&quot;&gt;列表&lt;/h3&gt;


&lt;p&gt;Markdown 支持有序列表和无序列表。&lt;/p&gt;

&lt;p&gt;无序列表使用星号、加号或是减号作为列表标记：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*   Red
*   Green
*   Blue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等同于：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+   Red
+   Green
+   Blue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也等同于：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-   Red
-   Green
-   Blue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有序列表则使用数字接着一个英文句点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.  Bird
2.  McHale
3.  Parish
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ol&amp;gt;
&amp;lt;li&amp;gt;Bird&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;McHale&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Parish&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你的列表标记写成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.  Bird
1.  McHale
1.  Parish
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或甚至是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3. Bird
1. McHale
8. Parish
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。&lt;/p&gt;

&lt;p&gt;如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。&lt;/p&gt;

&lt;p&gt;列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。&lt;/p&gt;

&lt;p&gt;要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
    viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
    Suspendisse id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果你懒，那也行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;
标签包起来，举例来说：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*   Bird
*   Magic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会被转换为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Bird&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Magic&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这个：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*   Bird

*   Magic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会被转换为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Bird&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Magic&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.  This is a list item with two paragraphs. Lorem ipsum dolor
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

2.  Suspendisse id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*   This is a list item with two paragraphs.

    This is the second paragraph in the list item. You're
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.

*   Another item in the same list.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要在列表项目内放进引用，那 &lt;code&gt;&amp;gt;&lt;/code&gt; 就需要缩进：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*   A list item with a blockquote:

    &amp;gt; This is a blockquote
    &amp;gt; inside a list item.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要放代码区块的话，该区块就需要缩进&lt;em&gt;两次&lt;/em&gt;，也就是 8 个空格或是 2 个制表符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*   一列表项包含一个列表区块：

        &amp;lt;代码写在这&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，项目列表很可能会不小心产生，像是下面这样的写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1986. What a great season.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换句话说，也就是在行首出现&lt;em&gt;数字-句点-空白&lt;/em&gt;，要避免这样的状况，你可以在句点前面加上反斜杠。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1986\. What a great season.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;precode&quot;&gt;代码区块&lt;/h3&gt;


&lt;p&gt;和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt; 标签来把代码区块包起来。&lt;/p&gt;

&lt;p&gt;要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是一个普通段落：

    这是一个代码区块。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Markdown 会转换成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;这是一个普通段落：&amp;lt;/p&amp;gt;

&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;这是一个代码区块。
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Here is an example of AppleScript:

    tell application &quot;Foo&quot;
        beep
    end tell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会被转换为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;Here is an example of AppleScript:&amp;lt;/p&amp;gt;

&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;tell application &quot;Foo&quot;
    beep
end tell
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。&lt;/p&gt;

&lt;p&gt;在代码区块里面， &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;div class=&quot;footer&quot;&amp;gt;
        &amp;amp;copy; 2004 Foo Corporation
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会被转换为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&amp;amp;lt;div class=&quot;footer&quot;&amp;amp;gt;
    &amp;amp;amp;copy; 2004 Foo Corporation
&amp;amp;lt;/div&amp;amp;gt;
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。&lt;/p&gt;

&lt;h3 id=&quot;hr&quot;&gt;分隔线&lt;/h3&gt;


&lt;p&gt;你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* * *

***

*****

- - -

---------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;span&quot;&gt;区段元素&lt;/h2&gt;




&lt;h3 id=&quot;link&quot;&gt;链接&lt;/h3&gt;


&lt;p&gt;Markdown 支持两种形式的链接语法： &lt;em&gt;行内式&lt;/em&gt;和&lt;em&gt;参考式&lt;/em&gt;两种形式。&lt;/p&gt;

&lt;p&gt;不管是哪一种，链接文字都是用 [方括号] 来标记。&lt;/p&gt;

&lt;p&gt;要建立一个&lt;em&gt;行内式&lt;/em&gt;的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This is [an example](http://example.com/ &quot;Title&quot;) inline link.

[This link](http://example.net/) has no title attribute.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会产生：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;This is &amp;lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&amp;gt;
an example&amp;lt;/a&amp;gt; inline link.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;&amp;lt;a href=&quot;http://example.net/&quot;&amp;gt;This link&amp;lt;/a&amp;gt; has no
title attribute.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你是要链接到同样主机的资源，你可以使用相对路径：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;See my [About](/about/) page for details.   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;参考式&lt;/em&gt;的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This is [an example][id] reference-style link.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以选择性地在两个方括号中间加上一个空格：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This is [an example] [id] reference-style link.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，在文件的任意处，你可以把这个标记的链接内容定义出来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[id]: http://example.com/  &quot;Optional Title Here&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;链接内容定义的形式为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字&lt;/li&gt;
&lt;li&gt;接着一个冒号&lt;/li&gt;
&lt;li&gt;接着一个以上的空格或制表符&lt;/li&gt;
&lt;li&gt;接着链接的网址&lt;/li&gt;
&lt;li&gt;选择性地接着 title 内容，可以用单引号、双引号或是括弧包着&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;下面这三种链接的定义都是相同：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[foo]: http://example.com/  &quot;Optional Title Here&quot;
[foo]: http://example.com/  'Optional Title Here'
[foo]: http://example.com/  (Optional Title Here)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;请注意：&lt;/strong&gt;有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。&lt;/p&gt;

&lt;p&gt;链接网址也可以用方括号包起来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[id]: &amp;lt;http://example.com/&amp;gt;  &quot;Optional Title Here&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[id]: http://example.com/longish/path/to/resource/here
    &quot;Optional Title Here&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。&lt;/p&gt;

&lt;p&gt;链接辨别标签可以有字母、数字、空白和标点符号，但是并&lt;em&gt;不&lt;/em&gt;区分大小写，因此下面两个链接是一样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[link text][a]
[link text][A]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;隐式链接标记&lt;/em&gt;功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 &quot;Google&quot; 链接到 google.com，你可以简化成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Google][]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后定义链接内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Google]: http://google.com/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Visit [Daring Fireball][] for more information.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后接着定义链接：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Daring Fireball]: http://daringfireball.net/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。&lt;/p&gt;

&lt;p&gt;下面是一个参考式链接的范例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;I get 10 times more traffic from [Google] [1] than from
[Yahoo] [2] or [MSN] [3].

  [1]: http://google.com/        &quot;Google&quot;
  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;
  [3]: http://search.msn.com/    &quot;MSN Search&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果改成用链接名称的方式写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;I get 10 times more traffic from [Google][] than from
[Yahoo][] or [MSN][].

  [google]: http://google.com/        &quot;Google&quot;
  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;
  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面两种写法都会产生下面的 HTML。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;I get 10 times more traffic from &amp;lt;a href=&quot;http://google.com/&quot;
title=&quot;Google&quot;&amp;gt;Google&amp;lt;/a&amp;gt; than from
&amp;lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&amp;gt;Yahoo&amp;lt;/a&amp;gt;
or &amp;lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&amp;gt;MSN&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)
than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or
[MSN](http://search.msn.com/ &quot;MSN Search&quot;).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。&lt;/p&gt;

&lt;p&gt;使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。&lt;/p&gt;

&lt;h3 id=&quot;em&quot;&gt;强调&lt;/h3&gt;


&lt;p&gt;Markdown 使用星号（&lt;code&gt;*&lt;/code&gt;）和底线（&lt;code&gt;_&lt;/code&gt;）作为标记强调字词的符号，被 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;_&lt;/code&gt; 包围的字词会被转成用 &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt; 标签包围，用两个 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;_&lt;/code&gt; 包起来的话，则会被转成 &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会转成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;em&amp;gt;single asterisks&amp;lt;/em&amp;gt;

&amp;lt;em&amp;gt;single underscores&amp;lt;/em&amp;gt;

&amp;lt;strong&amp;gt;double asterisks&amp;lt;/strong&amp;gt;

&amp;lt;strong&amp;gt;double underscores&amp;lt;/strong&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。&lt;/p&gt;

&lt;p&gt;强调也可以直接插在文字中间：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;un*frigging*believable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是&lt;strong&gt;如果你的 &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;_&lt;/code&gt; 两边都有空白的话，它们就只会被当成普通的符号&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\*this text is surrounded by literal asterisks\*
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;code&quot;&gt;代码&lt;/h3&gt;


&lt;p&gt;如果要标记一小段行内代码，你可以用反引号把它包起来（&lt;code&gt;`&lt;/code&gt;），例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Use the `printf()` function.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会产生：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;Use the &amp;lt;code&amp;gt;printf()&amp;lt;/code&amp;gt; function.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;``There is a literal backtick (`) here.``
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段语法会产生：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;There is a literal backtick (`) here.&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A single backtick in a code span: `` ` ``

A backtick-delimited string in a code span: `` `foo` ``
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会产生：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;A single backtick in a code span: &amp;lt;code&amp;gt;`&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;A backtick-delimited string in a code span: &amp;lt;code&amp;gt;`foo`&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在代码区段内，&lt;code&gt;&amp;amp;&lt;/code&gt; 和方括号&lt;strong&gt;都&lt;/strong&gt;会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Please don't use any `&amp;lt;blink&amp;gt;` tags.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;Please don't use any &amp;lt;code&amp;gt;&amp;amp;lt;blink&amp;amp;gt;&amp;lt;/code&amp;gt; tags.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`&amp;amp;#8212;` is the decimal-encoded equivalent of `&amp;amp;mdash;`.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以产生：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;&amp;amp;amp;#8212;&amp;lt;/code&amp;gt; is the decimal-encoded
equivalent of &amp;lt;code&amp;gt;&amp;amp;amp;mdash;&amp;lt;/code&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;img&quot;&gt;图片&lt;/h3&gt;


&lt;p&gt;很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。&lt;/p&gt;

&lt;p&gt;Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： &lt;em&gt;行内式&lt;/em&gt;和&lt;em&gt;参考式&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;行内式的图片语法看起来像是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg &quot;Optional title&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细叙述如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个惊叹号 &lt;code&gt;!&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;接着一个方括号，里面放上图片的替代文字&lt;/li&gt;
&lt;li&gt;接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上
选择性的 'title' 文字。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;参考式的图片语法则长得像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![Alt text][id]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[id]: url/to/image  &quot;Optional title attribute&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 标签。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;misc&quot;&gt;其它&lt;/h2&gt;




&lt;h3 id=&quot;autolink&quot;&gt;自动链接&lt;/h3&gt;


&lt;p&gt;Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;http://example.com/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Markdown 会转为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&quot;http://example.com/&quot;&amp;gt;http://example.com/&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;address@example.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Markdown 会转成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&quot;&amp;amp;#x6D;&amp;amp;#x61;i&amp;amp;#x6C;&amp;amp;#x74;&amp;amp;#x6F;:&amp;amp;#x61;&amp;amp;#x64;&amp;amp;#x64;&amp;amp;#x72;&amp;amp;#x65;
&amp;amp;#115;&amp;amp;#115;&amp;amp;#64;&amp;amp;#101;&amp;amp;#120;&amp;amp;#x61;&amp;amp;#109;&amp;amp;#x70;&amp;amp;#x6C;e&amp;amp;#x2E;&amp;amp;#99;&amp;amp;#111;
&amp;amp;#109;&quot;&amp;gt;&amp;amp;#x61;&amp;amp;#x64;&amp;amp;#x64;&amp;amp;#x72;&amp;amp;#x65;&amp;amp;#115;&amp;amp;#115;&amp;amp;#64;&amp;amp;#101;&amp;amp;#120;&amp;amp;#x61;
&amp;amp;#109;&amp;amp;#x70;&amp;amp;#x6C;e&amp;amp;#x2E;&amp;amp;#99;&amp;amp;#111;&amp;amp;#109;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在浏览器里面，这段字串（其实是 &lt;code&gt;&amp;lt;a href=&quot;mailto:address@example.com&quot;&amp;gt;address@example.com&amp;lt;/a&amp;gt;&lt;/code&gt;）会变成一个可以点击的「address@example.com」链接。&lt;/p&gt;

&lt;p&gt;（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）&lt;/p&gt;

&lt;h3 id=&quot;backslash&quot;&gt;反斜杠&lt;/h3&gt;


&lt;p&gt;Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt; 标签），你可以在星号的前面加上反斜杠：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\*literal asterisks\*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\   反斜线
`   反引号
*   星号
_   底线
{}  花括号
[]  方括号
()  括弧
#   井字号
+   加号
-   减号
.   英文句点
!   惊叹号
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;acknowledgement&quot;&gt;感谢&lt;/h2&gt;


&lt;p&gt;感谢 &lt;a href=&quot;https://twitter.com/#!/leafy7382&quot;&gt;leafy7382&lt;/a&gt; 协助翻译，&lt;a href=&quot;http://iamhlb.com/&quot;&gt;hlb&lt;/a&gt;、&lt;a href=&quot;http://twitter.com/randylien&quot;&gt;Randylien&lt;/a&gt; 帮忙润稿，&lt;a href=&quot;https://twitter.com/#!/ethantw&quot;&gt;ethantw&lt;/a&gt; 的&lt;a href=&quot;http://ethantw.net/projects/han/&quot;&gt;汉字标准格式・CSS Reset&lt;/a&gt;， &lt;a href=&quot;http://kidwm.net/&quot;&gt;WM&lt;/a&gt; 回报文字错误。&lt;/p&gt;

&lt;p&gt;感谢 &lt;a href=&quot;https://github.com/fenprace&quot;&gt;fenprace&lt;/a&gt;，&lt;a href=&quot;https://github.com/addv&quot;&gt;addv&lt;/a&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;editor&quot;&gt;Markdown 免费编辑器&lt;/h2&gt;


&lt;p&gt;Windows 平台&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://markdownpad.com/&quot;&gt;MarkdownPad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://code52.org/DownmarkerWPF/&quot;&gt;MarkPad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Linux 平台&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://sourceforge.net/p/retext/home/ReText/&quot;&gt;ReText&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Mac 平台&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://mouapp.com/&quot;&gt;Mou&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>memcached参数中文解释</title>
   <link href="http://beango.github.com/archives/2011/09/11/memcached-parameters-chinese-explain.html"/>
   <updated>2011-09-11T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2011/09/11/memcached-parameters-chinese-explain</id>
   <content type="html">

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;memcached&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.4.2&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;num&amp;gt;&lt;/span&gt;      &lt;span class=&quot;err&quot;&gt;监听的&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TCP&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;端口&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;默认&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11211&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;U&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;num&amp;gt;&lt;/span&gt;      &lt;span class=&quot;err&quot;&gt;监听的&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UDP&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;端口&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;默认&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11211&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;表示不监听&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;file&amp;gt;&lt;/span&gt;     &lt;span class=&quot;err&quot;&gt;用于监听的&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UNIX&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;套接字路径（禁用网络支持）&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;mask&amp;gt;&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;UNIX&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;套接字访问掩码，八进制数字（默认：&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;0700&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;ip_addr&amp;gt;&lt;/span&gt;  &lt;span class=&quot;err&quot;&gt;监听的&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IP&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;地址。（默认：&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INADDR_ANY&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，所有地址）&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;            &lt;span class=&quot;err&quot;&gt;作为守护进程来运行。&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;            &lt;span class=&quot;err&quot;&gt;最大核心文件限制。&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;username&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;设定进程所属用户。（只有&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;用户可以使用这个参数）&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;num&amp;gt;&lt;/span&gt;      &lt;span class=&quot;err&quot;&gt;单个数据项的最大可用内存，以&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MB&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;为单位。（默认：&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MB&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;            &lt;span class=&quot;err&quot;&gt;内存用光时报错。（不会删除数据）&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;num&amp;gt;&lt;/span&gt;      &lt;span class=&quot;err&quot;&gt;最大并发连接数。（默认：&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;            &lt;span class=&quot;err&quot;&gt;锁定所有内存页。注意你可以锁定的内存上限。&lt;/span&gt;  
              &lt;span class=&quot;err&quot;&gt;试图分配更多内存会失败的，所以留意启动守护进程时所用的用户可分配的内存上限。&lt;/span&gt;  
              &lt;span class=&quot;err&quot;&gt;（不是前面的&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;username&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;参数；在&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;下，使用命令&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;ulimit -S -l NUM_KB&amp;quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;来设置。）&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;            &lt;span class=&quot;err&quot;&gt;提示信息（在事件循环中打印错误&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;警告信息。）&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vv&lt;/span&gt;           &lt;span class=&quot;err&quot;&gt;详细信息（还打印客户端命令&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;响应）&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vvv&lt;/span&gt;          &lt;span class=&quot;err&quot;&gt;超详细信息（还打印内部状态的变化）&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;            &lt;span class=&quot;err&quot;&gt;打印这个帮助信息并退出。&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;            &lt;span class=&quot;err&quot;&gt;打印&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memcached&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;和&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libevent&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的许可。&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;file&amp;gt;&lt;/span&gt;     &lt;span class=&quot;err&quot;&gt;保存进程&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;到指定文件，只有在使用&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;选项的时候才有意义。&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;factor&amp;gt;&lt;/span&gt;   &lt;span class=&quot;err&quot;&gt;块大小增长因子。（默认：&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.25&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;bytes&amp;gt;&lt;/span&gt;    &lt;span class=&quot;err&quot;&gt;分配给&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的最小空间（默认：&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;48&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;            &lt;span class=&quot;err&quot;&gt;尝试使用大内存页（如果可用的话）。提高内存页尺寸可以减少&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;页表缓冲（TLB）&amp;quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;丢失次数，提高运行效率。&lt;/span&gt;  
              &lt;span class=&quot;err&quot;&gt;为了从操作系统获得大内存页，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memcached&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;会把全部数据项分配到一个大区块。&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;char&amp;gt;&lt;/span&gt;     &lt;span class=&quot;err&quot;&gt;使用&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;char&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;作为前缀和&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的分隔符。&lt;/span&gt;  
              &lt;span class=&quot;err&quot;&gt;这个用于按前缀获得状态报告。默认是&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;:&amp;quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（冒号）。&lt;/span&gt;  
              &lt;span class=&quot;err&quot;&gt;如果指定了这个参数，则状态收集会自动开启；如果没指定，则需要用命令&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;stats detail on&amp;quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;来开启。&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;num&amp;gt;&lt;/span&gt;      &lt;span class=&quot;err&quot;&gt;使用的线程数（默认：&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;            &lt;span class=&quot;err&quot;&gt;每个连接可处理的最大请求数。&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;            &lt;span class=&quot;err&quot;&gt;禁用&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAS&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;            &lt;span class=&quot;err&quot;&gt;设置后台日志队列的长度（默认：&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;            &lt;span class=&quot;err&quot;&gt;绑定协议&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;可能值：&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ascii&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（默认）&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;            &lt;span class=&quot;err&quot;&gt;重写每个数据页尺寸。调整数据项最大尺寸。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;memcached在线地址：&lt;a href=&quot;https://github.com/liuxd/MyTranslation/blob/master/translation/memcached-1.4.man&quot;&gt;https://github.com/liuxd/MyTranslation/blob/master/translation/memcached-1.4.man&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>nginx upstream 的几种分配方式</title>
   <link href="http://beango.github.com/archives/2011/09/08/nginx-upstream.html"/>
   <updated>2011-09-08T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2011/09/08/nginx-upstream</id>
   <content type="html">&lt;p&gt;作者：&lt;a href=&quot;http://www.dbasky.net&quot;&gt;Mike.Xu&lt;/a&gt; 发表于: December 11, 2009 12:11 PM&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://creativecommons.org/licenses/by/2.5/cn/&quot;&gt;&lt;/a&gt;转载时请务必以超链接形式标明文章&lt;a href=&quot;http://www.dbasky.net/archives/2009/12/nginx-upstream.html&quot;&gt;原始出处&lt;/a&gt;和作者信息及&lt;a href=&quot;http://www.dbasky.net/archives/2009/12/nginx-upstream.html&quot;&gt;本版权声明&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;链接：&lt;a href=&quot;http://www.dbasky.net/archives/2009/12/nginx-upstream.html&quot;&gt;http://www.dbasky.net/archives/2009/12/nginx-upstream.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; 1、轮询（默认）&lt;/p&gt;

&lt;p&gt;每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。&lt;/p&gt;

&lt;p&gt;2、weight
指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。
例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;upstream bakend {
  server 192.168.1.10 weight=10;
  server 192.168.1.11 weight=10;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、ip_hash&lt;/p&gt;

&lt;p&gt;每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。
例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;upstream resinserver{
  ip_hash;
  server 192.168.1.10:8080;
  server 192.168.1.11:8080;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4、fair（第三方）
按后端服务器的响应时间来分配请求，响应时间短的优先分配。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;upstream resinserver{
  server server1;
  server server2;
  fair;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5、url_hash（第三方）&lt;/p&gt;

&lt;p&gt;按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。&lt;/p&gt;

&lt;p&gt;例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;upstream resinserver{
  server squid1:3128;
  server squid2:3128;
  hash $request_uri;
  hash_method crc32;
}

tips:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;label&gt;&lt;/label&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;upstream resinserver{#定义负载均衡设备的Ip及设备状态
  ip_hash;
  server 127.0.0.1:8000 down;
  server 127.0.0.1:8080 weight=2;
  server 127.0.0.1:6801;
  server 127.0.0.1:6802 backup;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在需要使用负载均衡的server中增加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;proxy_pass http://resinserver/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个设备的状态设置为:
1.down 表示单前的server暂时不参与负载
2.weight 默认为1.weight越大，负载的权重就越大。
3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误
4.fail_timeout:max_fails次失败后，暂停的时间。
5.backup：其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。
nginx支持同时设置多组的负载均衡，用来给不用的server来使用。&lt;/p&gt;

&lt;p&gt;client_body_in_file_only 设置为On 可以讲client
post过来的数据记录到文件中用来做debug
client_body_temp_path 设置记录文件的目录 可以设置最多3层目录
location 对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>jQuery最佳实践</title>
   <link href="http://beango.github.com/archives/2011/08/11/jquery-best-practices.html"/>
   <updated>2011-08-11T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2011/08/11/jquery-best-practices</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;1. 使用最新版本的jQuery&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jQuery的版本更新很快，你应该总是使用最新的版本。因为新版本会改进性能，还有很多新功能。&lt;/p&gt;

&lt;p&gt;下面就来看看，不同版本的jQuery性能差异有多大。这里是三条最常见的jQuery选择语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('.elem')
$('.elem', context)
context.find('.elem')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们用1.4.2、1.4.4、1.6.2三个版本的jQuery&lt;a href=&quot;http://jsperf.com/jquery-1-4-2-vs-1-6-2-comparisons&quot;&gt;测试&lt;/a&gt;，看看浏览器在1秒内能够执行多少次。结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/bg2011080301.png&quot; alt=&quot;jQuery最佳实践&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，1.6.2版本的运行次数，远远超过两个老版本。尤其是第一条语句，性能有数倍的提高。&lt;/p&gt;

&lt;p&gt;其他语句的测试，比如&lt;a href=&quot;http://jsperf.com/attr-vs-attrhooks&quot;&gt;.attr(&quot;value&quot;)&lt;/a&gt;和&lt;a href=&quot;http://jsperf.com/valhooks-vs-val/2&quot;&gt;.val()&lt;/a&gt;，也是新版本的jQuery表现好于老版本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 用对选择器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在jQuery中，你可以用多种选择器，选择同一个网页元素。每种选择器的性能是不一样的，你应该了解它们的性能差异。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）最快的选择器：id选择器和元素标签选择器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;举例来说，下面的语句性能最佳：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('#id')
$('form')
$('input')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;遇到这些选择器的时候，jQuery内部会自动调用浏览器的原生方法（比如getElementById()），所以它们的执行速度快。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）较慢的选择器：class选择器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;$('.className')的性能，取决于不同的浏览器。&lt;/p&gt;

&lt;p&gt;Firefox、Safari、Chrome、Opera浏览器，都有原生方法getElementByClassName()，所以速度并不慢。但是，IE5-IE8都没有部署这个方法，所以这个选择器在IE中会相当慢。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）最慢的选择器：伪类选择器和属性选择器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先来看例子。找出网页中所有的隐藏元素，就要用到伪类选择器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(':hidden')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;属性选择器的例子则是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('[attribute=value]')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两种语句是最慢的，因为浏览器没有针对它们的原生方法。但是，一些浏览器的新版本，增加了querySelector()和querySelectorAll()方法，因此会使这类选择器的性能有大幅提高。&lt;/p&gt;

&lt;p&gt;最后是不同选择器的&lt;a href=&quot;http://jsperf.com/dh-jquery-1-4-vs-1-6/6&quot;&gt;性能比较图&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2013-02/bg2011080302.png&quot; alt=&quot;jQuery最佳实践&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，ID选择器遥遥领先，然后是标签选择器，第三是Class选择器，其他选择器都非常慢。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 理解子元素和父元素的关系&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面六个选择器，都是从父元素中选择子元素。你知道哪个速度最快，哪个速度最慢吗？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('.child', $parent)
$parent.find('.child')
$parent.children('.child')
$('#parent &amp;gt; .child')
$('#parent .child')
$('.child', $('#parent'))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们一句句来看。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1) $('.child', $parent)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这条语句的意思是，给定一个DOM对象，然后从中选择一个子元素。jQuery会自动把这条语句转成$.parent.find('child')，这会导致一定的性能损失。它比最快的形式慢了5%-10%。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(2) $parent.find('.child')&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这条是最快的语句。.find()方法会调用浏览器的原生方法（getElementById，getElementByName，getElementByTagName等等），所以速度较快。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(3) $parent.children('.child')&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这条语句在jQuery内部，会使用$.sibling()和javascript的nextSibling()方法，一个个遍历节点。它比最快的形式大约慢50%。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(4) $('#parent &gt; .child')&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jQuery内部使用Sizzle引擎，处理各种选择器。Sizzle引擎的选择顺序是从右到左，所以这条语句是先选.child，然后再一个个过滤出父元素#parent，这导致它比最快的形式大约慢70%。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(5) $('#parent .child')&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这条语句与上一条是同样的情况。但是，上一条只选择直接的子元素，这一条可以于选择多级子元素，所以它的速度更慢，大概比最快的形式慢了77%。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(6) $('.child', $('#parent'))&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jQuery内部会将这条语句转成$('#parent').find('.child')，比最快的形式慢了23%。&lt;/p&gt;

&lt;p&gt;所以，最佳选择是$parent.find('.child')。而且，由于$parent往往在前面的操作已经生成，jQuery会进行缓存，所以进一步加快了执行速度。&lt;/p&gt;

&lt;p&gt;具体的例子和比较结果，请看&lt;a href=&quot;http://jsperf.com/jquery-selectors-context/2&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 不要过度使用jQuery&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jQuery速度再快，也无法与原生的javascript方法相比。所以有原生方法可以使用的场合，尽量避免使用jQuery。&lt;/p&gt;

&lt;p&gt;以最简单的选择器为例，document.getElementById(&quot;foo&quot;)要比\$(&quot;#foo&quot;)&lt;a href=&quot;http://jsperf.com/id-vs-class-vs-tag-selectors/46&quot;&gt;快10多倍&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;再来看一个例子，为a元素绑定一个处理点击事件的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('a').click(function(){
　　alert($(this).attr('id'));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码的意思是，点击a元素后，弹出该元素的id属性。为了获取这个属性，必须连续两次调用jQuery，第一次是$(this)，第二次是attr('id')。&lt;/p&gt;

&lt;p&gt;事实上，这种处理完全不必要。更正确的写法是，直接采用javascript原生方法，调用this.id：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('a').click(function(){
　　alert(this.id);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据&lt;a href=&quot;http://jsperf.com/el-attr-id-vs-el-id/2&quot;&gt;测试&lt;/a&gt;，this.id的速度比$(this).attr('id')快了20多倍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 做好缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;选中某一个网页元素，是开销很大的步骤。所以，使用选择器的次数应该越少越好，并且尽可能缓存选中的结果，便于以后反复使用。&lt;/p&gt;

&lt;p&gt;比如，下面这样的写法就是糟糕的写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery('#top').find('p.classA');
jQuery('#top').find('p.classB');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更好的写法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var cached = jQuery('#top');
cached.find('p.classA');
cached.find('p.classB');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据&lt;a href=&quot;http://jsperf.com/ns-jq-cached&quot;&gt;测试&lt;/a&gt;，缓存比不缓存，快了2-3倍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. 使用链式写法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jQuery的一大特点，就是允许使用链式写法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('div').find('h3').eq(2).html('Hello');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;采用链式写法时，jQuery自动缓存每一步的结果，因此比非链式写法要快。根据&lt;a href=&quot;http://jsperf.com/jquery-chaining&quot;&gt;测试&lt;/a&gt;，链式写法比（不使用缓存的）非链式写法，大约快了25%。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7. 事件的委托处理（Event Delegation）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;javascript的事件模型，采用&quot;冒泡&quot;模式，也就是说，子元素的事件会逐级向上&quot;冒泡&quot;，成为父元素的事件。&lt;/p&gt;

&lt;p&gt;利用这一点，可以大大简化事件的绑定。比如，有一个表格（table元素），里面有100个格子（td元素），现在要求在每个格子上面绑定一个点击事件（click），请问是否需要将下面的命令执行100次？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&quot;td&quot;).on(&quot;click&quot;, function(){
　　$(this).toggleClass(&quot;click&quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回答是不需要，我们只要把这个事件绑定在table元素上面就可以了，因为td元素发生点击事件之后，这个事件会&quot;冒泡&quot;到父元素table上面，从而被监听到。&lt;/p&gt;

&lt;p&gt;因此，这个事件只需要在父元素绑定1次即可，而不需要在子元素上绑定100次，从而大大提高性能。这就叫事件的&quot;委托处理&quot;，也就是子元素&quot;委托&quot;父元素处理这个事件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&quot;table&quot;).on(&quot;click&quot;, &quot;td&quot;, function(){
　　$(this).toggleClass(&quot;click&quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更好的写法，则是把事件绑定在document对象上面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).on(&quot;click&quot;, &quot;td&quot;, function(){
    $(this).toggleClass(&quot;click&quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要取消事件的绑定，就使用off()方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).off(&quot;click&quot;, &quot;td&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;8. 少改动DOM结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（1）改动DOM结构开销很大，因此不要频繁使用.append()、.insertBefore()和.insetAfter()这样的方法。&lt;/p&gt;

&lt;p&gt;如果要插入多个元素，就先把它们合并，然后再一次性插入。根据&lt;a href=&quot;http://jsperf.com/string-concat-single-append-vs-multiple-append&quot;&gt;测试&lt;/a&gt;，合并插入比不合并插入，快了将近10倍。&lt;/p&gt;

&lt;p&gt;（2）如果你要对一个DOM元素进行大量处理，应该先用.detach()方法，把这个元素从DOM中取出来，处理完毕以后，再重新插回文档。根据&lt;a href=&quot;http://jsperf.com/to-detach-or-not-to-detach&quot;&gt;测试&lt;/a&gt;，使用.detach()方法比不使用时，快了60%。&lt;/p&gt;

&lt;p&gt;（3）如果你要在DOM元素上储存数据，不要写成下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var elem = $('#elem');
elem.data(key,value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而要写成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var elem = $('#elem');
$.data(elem[0],key,value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据&lt;a href=&quot;http://jsperf.com/jquery-data-vs-jqueryselection-data/11&quot;&gt;测试&lt;/a&gt;，后一种写法要比前一种写法，快了将近10倍。因为elem.data()方法是定义在jQuery函数的prototype对象上面的，而\$.data()方法是定义jQuery函数上面的，调用的时候不从复杂的jQuery对象上调用，所以速度快得多。（此处可以参阅下面第10点。）&lt;/p&gt;

&lt;p&gt;（4）插入html代码的时候，浏览器原生的innterHTML()方法比jQuery对象的html()&lt;a href=&quot;http://jsperf.com/jquery-dom-manipulation/4&quot;&gt;更快&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9. 正确处理循环&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;循环总是一种比较耗时的操作，如果可以使用复杂的选择器直接选中元素，就不要使用循环，去一个个辨认元素。&lt;/p&gt;

&lt;p&gt;javascript原生循环方法for和while，要比jQuery的.each()方法&lt;a href=&quot;http://jsperf.com/jquery-each-vs-for-loop/24&quot;&gt;快&lt;/a&gt;，应该优先使用原生方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10. 尽量少生成jQuery对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每当你使用一次选择器（比如$('#id')），就会生成一个jQuery对象。jQuery对象是一个很庞大的对象，带有很多属性和方法，会占用不少资源。所以，尽量少生成jQuery对象。&lt;/p&gt;

&lt;p&gt;举例来说，许多jQuery方法都有两个版本，一个是供&lt;strong&gt;jQuery对象&lt;/strong&gt;使用的版本，另一个是供&lt;strong&gt;jQuery函数&lt;/strong&gt;使用的版本。下面两个例子，都是取出一个元素的文本，使用的都是text()方法。&lt;/p&gt;

&lt;p&gt;你既可以使用针对jQuery对象的版本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var $text = $(&quot;#text&quot;);
var $ts = $text.text();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用针对jQuery函数的版本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var $text = $(&quot;#text&quot;);
var $ts = $.text($text);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于后一种针对jQuery函数的版本不通过jQuery对象操作，所以相对开销较小，速度&lt;a href=&quot;http://jsperf.com/jquery-text-vs-html/5&quot;&gt;比较快&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11. 选择作用域链最短的方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;严格地说，这一条原则对所有Javascript编程都适用，而不仅仅针对jQuery。&lt;/p&gt;

&lt;p&gt;我们知道，Javascript的变量采用链式作用域。读取变量的时候，先在当前作用域寻找该变量，如果找不到，就前往上一层的作用域寻找该变量。这样的设计，使得读取局部变量比读取全局变量快得多。&lt;/p&gt;

&lt;p&gt;请看下面两段代码，第一段代码是读取全局变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = 0;
function x(){
　　a += 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二段代码是读取局部变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function y(){
　　var a = 0;
　　a += 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二段代码读取变量a的时候，不用前往上一层作用域，所以要比第一段代码&lt;a href=&quot;http://jsperf.com/global/2&quot;&gt;快五六倍&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;同理，在调用对象方法的时候，closure模式要比prototype模式&lt;a href=&quot;http://jsperf.com/prototype-vs-closures/20&quot;&gt;更快&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;prototype模式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var X = function(name){ this.name = name; }
X.prototype.get_name = function() { return this.name; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;closure模式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Y = function(name) {
　　var y = { name: name };
  　return { 'get_name': function() { return y.name; } };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样是get_name()方法，closure模式&lt;a href=&quot;http://jsperf.com/prototype-vs-closures/20&quot;&gt;更快&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;12. 使用Pub/Sub模式管理事件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当发生某个事件后，如果要连续执行多个操作，最好不要写成下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function doSomthing{
　　doSomethingElse();
　　doOneMoreThing();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而要改用事件触发的形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function doSomething{
　　$.trigger(&quot;DO_SOMETHING_DONE&quot;);
}
$(document).on(&quot;DO_SOMETHING_DONE&quot;, function(){
　　doSomethingElse(); }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以考虑使用&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html&quot;&gt;deferred对象&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function doSomething(){
　　var dfd = new \$.Deferred();
　　//Do something async, then... 
    //dfd.resolve();
　　return dfd.promise();
}
function doSomethingElse(){
　　$.when(doSomething()).then(//The next thing);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（完）&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MongoDB安装及使用</title>
   <link href="http://beango.github.com/archives/2011/06/15/mongodb-install.html"/>
   <updated>2011-06-15T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2011/06/15/mongodb-install</id>
   <content type="html">

&lt;h3 id=&quot;blockquote&quot;&gt;一、准备工作：&lt;/h3&gt;


&lt;p&gt;运行yum命令查看MongoDB的包信息 [root@vm ~]# yum info mongo-10gen&lt;br/&gt;
提示没有相关匹配的信息，说明你的centos系统中的yum源不包含MongoDB的相关资源，所以要在使用yum命令安装MongoDB前需要增加yum源，也就是在 /etc/yum.repos.d/目录中增加 *.repo yum源配置文件，以下分别是针对centos 64位和32位不同的系统的MongoDB yum源配置内容&lt;br/&gt;
我们这里就将该文件命名为：/etc/yum.repos.d/10gen.repo&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;For 64-bit yum源配置：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;vi&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/etc/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;repos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;repo&lt;/span&gt;  

&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Repository&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;baseurl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http:&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;downloads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;distro&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mongodb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/repo/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;redhat&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/os/x&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;86_64&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;gpgcheck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;For 32-bit yum源配置：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;n&quot;&gt;vi&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/etc/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;repos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;repo&lt;/span&gt;  

&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Repository&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;baseurl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http:&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;downloads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;distro&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mongodb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/repo/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;redhat&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/os/i&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;686&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;gpgcheck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;p&gt;根据自己的系统选择相应的配置内容&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查看系统是32位还是64位的方法：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;$ uname -a&lt;/p&gt;

&lt;p&gt;含有x86_64的那说明是64位的，例如我的centos6.0 64bit系统执行这个命令后显示：&lt;/p&gt;

&lt;p&gt;Linux vm.centos6 2.6.32-71.29.1.el6.x86_64 #1 SMP Mon Jun 27 19:49:27 BST 2011 x86_64 x86_64 x86_64 GNU/Linux&lt;/p&gt;

&lt;p&gt;做好yum源的配置后，如果配置正确执行下面的命令便可以查询MongoDB相关的信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查看mongoDB的服务器包的信息&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@vm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# yum info mongo-10gen-server  &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;****&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;省略多行不重要的信息&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*********&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;Available&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Packages&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;       &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mongo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;Arch&lt;/span&gt;       &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x86_64&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;Version&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.8.2&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;Release&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mongodb_1&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;Size&lt;/span&gt;       &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.7&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;Repo&lt;/span&gt;       &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;Summary&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mongo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sharding&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;support&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scripts&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;URL&lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http:&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mongodb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;org&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;License&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AGPL&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.0&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;Description:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mongo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;huMONGOus&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;schema&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oriented&lt;/span&gt;  
           &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;database&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;  
           &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;  
           &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;This&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;provides&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mongo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;software&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mongo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sharding&lt;/span&gt;  
           &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;softwware&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;configuration&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scripts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;  
  
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@vm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;#  &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;查看客户端工具的信息&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@vm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# yum info mongo-10gen  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Loaded&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;plugins:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fastestmirror&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（省略多行不重要的信息）&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;Installed&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Packages&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;       &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mongo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;Arch&lt;/span&gt;       &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x86_64&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;Version&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.8.2&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;Release&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mongodb_1&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;Size&lt;/span&gt;       &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;55&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;Repo&lt;/span&gt;       &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;Summary&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mongo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tools&lt;/span&gt;   
&lt;span class=&quot;n&quot;&gt;URL&lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http:&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mongodb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;org&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;License&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AGPL&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.0&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;Description:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mongo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;huMONGOus&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;schema&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oriented&lt;/span&gt;  
           &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;database&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;It&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;features&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dynamic&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;profileable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;full&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;indexing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
           &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;replication&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;over&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;support&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;efficient&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;storage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;large&lt;/span&gt;  
           &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binary&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sharding&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;  
           &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;  
           &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;This&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;provides&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mongo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tools&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt;  
           &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;utilities&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;  
  
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@vm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;#  &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;




&lt;h3 id=&quot;blockquote&quot;&gt;二、安装MongoDB的服务器端和客户端工具&lt;/h3&gt;


&lt;ul&gt;
&lt;li&gt;安装服务器端：&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@vm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# yum install mongo-10gen-server  &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@vm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# ls /usr/bin/mongo（tab键）  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;mongo&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;mongod&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;mongodump&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;mongoexport&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;mongofiles&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;mongoimport&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;mongorestore&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;mongos&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;mongostat&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;这些就是MongoDB的程序文件&lt;br/&gt;
因为mongo-10gen-server包依赖于mongo-10gen，所以安装了服务器后就不需要单独安装客户端工具包mongo-10gen了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单独安装可客户端：&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@vm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# yum install mongo-10gen   &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;检查&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@vm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# /etc/init.d/mongod  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Usage:&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/etc/i&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mongod&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;restart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reload&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;force&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reload&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;condrestart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@vm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# /etc/init.d/mongod status  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;mongod&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1341&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;running&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@vm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;#  &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;说明安后服务器端已经在运行了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务器配置: /etc/mongod.conf&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@vm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# cat /etc/mongod.conf  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# mongo.conf  &lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;#where to log  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;logpath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/var/&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/mongo/mo&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ngod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt;  
  
&lt;span class=&quot;n&quot;&gt;logappend&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#以追加方式写入日志  &lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;# fork and run in background  &lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;fork&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;true&lt;/span&gt;  
  
&lt;span class=&quot;c1&quot;&gt;#port = 27017 #端口  &lt;/span&gt;
  
&lt;span class=&quot;n&quot;&gt;dbpath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/var/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mongo&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#数据库文件保存位置  &lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;# Enables periodic logging of CPU utilization and I/O wait  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#启用定期记录CPU利用率和 I/O 等待  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#cpu = true  &lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;# Turn on/off security.  Off is currently the default  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 是否以安全认证方式运行，默认是不认证的非安全方式  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#noauth = true  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#auth = true  &lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;# Verbose logging output.  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 详细记录输出  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#verbose = true  &lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;# Inspect all client data for validity on receipt (useful for  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# developing drivers)用于开发驱动程序时的检查客户端接收数据的有效性  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#objcheck = true  &lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;# Enable db quota management 启用数据库配额管理，默认每个db可以有8个文件，可以用quotaFiles参数设置  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#quota = true  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 设置oplog记录等级  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Set oplogging level where n is  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#   0=off (default)  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#   1=W  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#   2=R  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#   3=both  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#   7=W+some reads  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#oplog = 0  &lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;# Diagnostic/debugging option 动态调试项  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#nocursors = true  &lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;# Ignore query hints 忽略查询提示  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#nohints = true  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 禁用http界面，默认为localhost：28017  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Disable the HTTP interface (Defaults to localhost:27018).这个端口号写的是错的  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#nohttpinterface = true  &lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;# 关闭服务器端脚本，这将极大的限制功能  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Turns off server-side scripting.  This will result in greatly limited  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# functionality  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#noscripting = true  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 关闭扫描表，任何查询将会是扫描失败  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Turns off table scans.  Any query that would do a table scan fails.  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#notablescan = true  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 关闭数据文件预分配  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Disable data file preallocation.  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#noprealloc = true  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 为新数据库指定.ns文件的大小，单位:MB  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Specify .ns file size for new databases.  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# nssize = &amp;lt;size&amp;gt;  &lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;# Accout token for Mongo monitoring server.  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#mms-token = &amp;lt;token&amp;gt;  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# mongo监控服务器的名称  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Server name for Mongo monitoring server.  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#mms-name = &amp;lt;server-name&amp;gt;  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# mongo监控服务器的ping 间隔  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Ping interval for Mongo monitoring server.  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#mms-interval = &amp;lt;seconds&amp;gt;  &lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;# Replication Options 复制选项  &lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;# in replicated mongo databases, specify here whether this is a slave or master 在复制中，指定当前是从属关系  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#slave = true  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#source = master.example.com  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Slave only: specify a single database to replicate  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#only = master.example.com  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# or  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#master = true  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#source = slave.example.com  &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@vm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;#  &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;


&lt;p&gt;以上是默认的配置文件中的一些参数，更多参数可以用 mongod -h 命令来查看&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:toggle(this);&quot;&gt;+ 点击展开&lt;/a&gt;&lt;/p&gt;

&lt;div style=&quot;display:none;&quot;&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;perl&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@vm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# mongod -h  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Allowed&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options:&lt;/span&gt;  
  
&lt;span class=&quot;n&quot;&gt;General&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options:&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;help&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;information&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;              &lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;information&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;configuration&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;specifying&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;additional&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;指定启动配置文件路径&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;verbose&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;be&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;more&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;verbose&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiple&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;times&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;more&lt;/span&gt;  
                         &lt;span class=&quot;n&quot;&gt;verbosity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vvvvv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;quiet&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;quieter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;specify&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;端口&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bind_ip&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;comma&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;separated&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ip&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addresses&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;listen&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;  
                         &lt;span class=&quot;n&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ips&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;绑定&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ip&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，可以多个&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxConns&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;simultaneous&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connections&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;最大并发连接数&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;logpath&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;          &lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;send&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;write&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instead&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;  
                         &lt;span class=&quot;n&quot;&gt;be&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;directory&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;日志文件路径&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;logappend&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;append&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;logpath&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instead&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;over&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writing&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;日志写入方式&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pidfilepath&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;full&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pidfile&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pidfile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt;  
                         &lt;span class=&quot;n&quot;&gt;created&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;文件路径&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keyFile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cluster&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;authentication&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;only&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;  
                         &lt;span class=&quot;n&quot;&gt;replica&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;集群认证私钥，仅适用于副本集&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unixSocketPrefix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alternative&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;directory&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UNIX&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;domain&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockets&lt;/span&gt;  
                         &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defaults&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;替代目录&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;fork&lt;/span&gt;                 &lt;span class=&quot;nb&quot;&gt;fork&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;auth&lt;/span&gt;                 &lt;span class=&quot;n&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;security&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;使用认证方式运行&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpu&lt;/span&gt;                  &lt;span class=&quot;n&quot;&gt;periodically&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iowait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;utilization&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;定期显示的&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CPU&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;和&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;等待利用率&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dbpath&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;directory&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;datafiles&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;数据库文件路径&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;diaglog&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;          &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;W&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;both&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;some&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reads&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oplog&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;记录等级&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;directoryperdb&lt;/span&gt;       &lt;span class=&quot;nb&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;database&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;will&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;be&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stored&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;separate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;directory&lt;/span&gt;  
                         &lt;span class=&quot;err&quot;&gt;每个数据库存储到单独目录&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;journal&lt;/span&gt;              &lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;journaling&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;记录日志，建议开启，在异常宕机时可以恢复一些数据&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;journalOptions&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;journal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;diagnostic&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ipv6&lt;/span&gt;                 &lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IPv6&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;support&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;disabled&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jsonp&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;allow&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JSONP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;access&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;via&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;security&lt;/span&gt;  
                         &lt;span class=&quot;n&quot;&gt;implications&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;允许&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JSONP&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;通过&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;访问，该方式存在安全隐患&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;noauth&lt;/span&gt;               &lt;span class=&quot;n&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;without&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;security&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;不带安全认证的方式&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nohttpinterface&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;disable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;禁用&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;接口&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;noprealloc&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;disable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;preallocation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;will&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;often&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hurt&lt;/span&gt;  
                         &lt;span class=&quot;n&quot;&gt;performance&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;禁用数据文件的预分配，往往会损害性能&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;noscripting&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;disable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scripting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;禁用脚本引擎&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;notablescan&lt;/span&gt;          &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allow&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scans&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;不允许表扫描&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nounixsocket&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;disable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listening&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockets&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;禁止&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockets&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;监听&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nssize&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ns&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;databases&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;为新数据设置&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ns&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;文件的大小&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objcheck&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;inspect&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;validity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receipt&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;检查在收到客户端的数据的有效性&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;profile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;          &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;all&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;quota&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;limits&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;database&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;certain&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;  
                         &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;启用数据库配额管理，默认每个&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;可以有&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;个文件，可以用&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;quotaFiles&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;参数设置&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;quotaFiles&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allower&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;per&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requires&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;quota&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;                 &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;simple&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;api&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;开启&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;api&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;repair&lt;/span&gt;               &lt;span class=&quot;n&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;repair&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dbs&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;修复所有数据库&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;repairpath&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;directory&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;repair&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defaults&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dbpath&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;修复文件的根目录，默&lt;/span&gt;  
                         &lt;span class=&quot;err&quot;&gt;认为&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dbpath&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;指定的目录&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slowms&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slow&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;profile&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;console&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;smallfiles&lt;/span&gt;           &lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smaller&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syncdelay&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;between&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;disk&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;syncs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;never&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;but&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt;  
                         &lt;span class=&quot;n&quot;&gt;recommended&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;与硬盘同步数据的时间，默认&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;秒，&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;表示不同步到硬盘（不建议）&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sysinfo&lt;/span&gt;              &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;some&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;diagnostic&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;system&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;information&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;打印一些诊断系统信息&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;upgrade&lt;/span&gt;              &lt;span class=&quot;n&quot;&gt;upgrade&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;needed&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;如果必要，将数据库文件升级到新的格式&lt;/span&gt;  
                        &lt;span class=&quot;err&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;到&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;升级时所需的）&lt;/span&gt;  
  
&lt;span class=&quot;n&quot;&gt;Replication&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options:&lt;/span&gt;    &lt;span class=&quot;err&quot;&gt;复制选项&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fastsync&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;indicate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;that&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;starting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dbpath&lt;/span&gt;  
                        &lt;span class=&quot;n&quot;&gt;snapshot&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;repl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;peer&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;从一个&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dbpath&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;快照开始同步&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;autoresync&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;automatically&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resync&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slave&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stale&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;自动同步，如果从机的数据不是新的&lt;/span&gt;  
                        &lt;span class=&quot;err&quot;&gt;自动同步&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oplogSize&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oplog&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的大小&lt;/span&gt;  
  
&lt;span class=&quot;n&quot;&gt;Master&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/slave options:   主/&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;从配置选项&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;master&lt;/span&gt;              &lt;span class=&quot;n&quot;&gt;master&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;主模式&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slave&lt;/span&gt;               &lt;span class=&quot;n&quot;&gt;slave&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;  &lt;span class=&quot;err&quot;&gt;从属模式&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slave:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;specify&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;master&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;server:port&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;从属服务器上指定主服务器地址&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;only&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slave:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;specify&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;single&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;database&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;replicate&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;从属服务器上指定要复制的&lt;/span&gt;  
                        &lt;span class=&quot;err&quot;&gt;数据库&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slavedelay&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;specify&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;be&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;used&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;applying&lt;/span&gt;  
                        &lt;span class=&quot;n&quot;&gt;master&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ops&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slave&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;指定从主服务器上同步数据的时间间隔&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;单位秒&lt;/span&gt;  
  
&lt;span class=&quot;n&quot;&gt;Replica&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options:&lt;/span&gt;    &lt;span class=&quot;err&quot;&gt;副本集选项&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;replSet&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;&amp;lt;setname&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;&amp;lt;optionalseedhostlist&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  
                        &lt;span class=&quot;err&quot;&gt;参数：&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;&amp;lt;名称&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;&amp;lt;种子主机列表&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  
  
&lt;span class=&quot;n&quot;&gt;Sharding&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options:&lt;/span&gt;       &lt;span class=&quot;err&quot;&gt;分片设置选项&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;configsvr&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cluster&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;  
                        &lt;span class=&quot;mi&quot;&gt;27019&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dir&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/data/co&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nfigdb&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;声明这是一个集群的配置数据库，&lt;/span&gt;  
                        &lt;span class=&quot;err&quot;&gt;默认的端口是&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;27019&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;默认的路径是&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/data/co&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nfigdb&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shardsvr&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;declare&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shard&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cluster&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;  
                        &lt;span class=&quot;mi&quot;&gt;27018&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;声明这是集群的一个分片数据库，默认端口为&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;27018&lt;/span&gt;  
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;noMoveParanoia&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;paranoid&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;saving&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moveChunk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;  
                        &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;but&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;will&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;  
                        &lt;span class=&quot;err&quot;&gt;关闭偏着保存大块数据。现在它是默认的，但是会变换&lt;/span&gt;  
  
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;@vm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;#  &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;




&lt;h3 id=&quot;blockquote&quot;&gt;三、基本操作&lt;/h3&gt;


&lt;ul&gt;
&lt;li&gt;连接到数据库：&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@vm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;# mongo  &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;MongoDB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;connecting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;insert操作：&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;jack&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;age&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;joe&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;age&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;find操作：&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;joe&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;update操作：&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;joe&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;joe&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;age&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;remove操作：&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;joe&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#删除所有&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;索引：&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ensureIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#添加索引&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getIndexes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#查看所有索引&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dropIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#删除索引&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ensureIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;unique&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#唯一索引&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;数据备份mongodump/恢复mongorestore：&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mongodump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;数据库名&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;#将数据库备份在dump目录，-o my_mongodb_dump将数据库备份在my_mongodb_dump目录&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mongorestore&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;数据库名&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;备份路径&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/*&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;#将备份路径下的文件恢复为数据库&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;数据导出 mongoexport/导入mongoimport：&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mongoexport&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;数据库名&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;表名&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;表名&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;#将数据库中的表数据导出到dat文件&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mongoimport&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;数据库名&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;表名&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;表名&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dat&lt;/span&gt;      &lt;span class=&quot;c&quot;&gt;#将dat文件导入到数据库中的表&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;其他：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;label/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; show dbs;  
&amp;gt; use MyTest;  
&amp;gt; show collections;  
&amp;gt; db.charpter.count({$where: &quot;this.content.length&amp;gt;0&quot;})  
&amp;gt; use test;  
&amp;gt; db.dropDatabase();//删除数据库
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>一点一滴培养你的气质</title>
   <link href="http://beango.github.com/archives/2011/06/11/train-your-temperament.html"/>
   <updated>2011-06-11T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2011/06/11/train-your-temperament</id>
   <content type="html">&lt;h3&gt;一：沉稳&lt;/h3&gt;

&lt;p&gt;（1）不要随便显露你的情绪。&lt;br/&gt;
（2）不要逢人就诉说你的困难和遭遇。&lt;br/&gt;
（3）在征询别人的意见之前，自己先思考，但不要先讲。&lt;br/&gt;
（4）不要一有机会就唠叨你的不满。&lt;br/&gt;
（5）重要的决定尽量有别人商量，最好隔一天再发布。&lt;br/&gt;
（6）讲话不要有任何的慌张，走路也是。&lt;/p&gt;

&lt;h3&gt;二：细心&lt;/h3&gt;

&lt;p&gt;（1）对身边发生的事情，常思考它们的因果关系。&lt;br/&gt;
（2）对做不到位的执行问题，要发掘它们的根本症结。&lt;br/&gt;
（3）对习以为常的做事方法，要有改进或优化的建议。&lt;br/&gt;
（4）做什么事情都要养成有条不紊和井然有序的习惯。&lt;br/&gt;
（5）经常去找几个别人看不出来的毛病或弊端。&lt;br/&gt;
（6）自己要随时随地对有所不足的地方补位。&lt;/p&gt;

&lt;h3&gt;三：胆识&lt;/h3&gt;

&lt;p&gt;（1）不要常用缺乏自信的词句 &lt;br/&gt;
（2）不要常常反悔，轻易推翻已经决定的事。&lt;br/&gt;
（3）在众人争执不休时，不要没有主见。&lt;br/&gt;
（4）整体氛围低落时，你要乐观、阳光。&lt;br/&gt;
（5）做任何事情都要用心，因为有人在看着你。&lt;br/&gt;
（6）事情不顺的时候，歇口气，重新寻找突破口，就结束也要干净利落。&lt;/p&gt;

&lt;h3&gt;四：大度&lt;/h3&gt;

&lt;p&gt;（1）不要刻意把有可能是伙伴的人变成对手。&lt;br/&gt;
（2）对别人的小过失、小错误不要斤斤计较。&lt;br/&gt;
（3）在金钱上要大方，学习三施（财施、法施、无畏施）&lt;br/&gt;
（4）不要有权力的傲慢和知识的偏见。&lt;br/&gt;
（5）任何成果和成就都应和别人分享。&lt;br/&gt;
（6）必须有人牺牲或奉献的时候，自己走在前面。&lt;/p&gt;

&lt;h3&gt;五：诚信&lt;/h3&gt;

&lt;p&gt;（1）做不到的事情不要说，说了就努力做到。&lt;br/&gt;
（2）虚的口号或标语不要常挂嘴上。&lt;br/&gt;
（3）针对客户提出的“不诚信”问题，拿出改善的方法。&lt;br/&gt;
（4）停止一切“不道德”的手段。&lt;br/&gt;
（5）耍弄小聪明，要不得！&lt;br/&gt;
（6）计算一下产品或服务的诚信代价，那就是品牌成本。&lt;/p&gt;

&lt;h3&gt;六：担当&lt;/h3&gt;

&lt;p&gt;（1）检讨任何过失的时候，先从自身或自己人开始反省。&lt;br/&gt;
（2）事项结束后，先审查过错，再列述功劳。&lt;br/&gt;
（3）认错从上级开始，表功从下级启动&lt;br/&gt;
（4）着手一个计划，先将权责界定清楚，而且分配得当。&lt;br/&gt;
（5）对“怕事”的人或组织要挑明了说。&lt;br/&gt;
（6）因为勇于承担责任所造成的损失，公司应该承担。&lt;/p&gt;

&lt;p&gt;PS:好文出处不明。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>基于.NET的大型Web站点StackOverflow架构分析</title>
   <link href="http://beango.github.com/archives/2011/03/04/stack-overflow-architecture-update-now-at-95-million-page-vi.html"/>
   <updated>2011-03-04T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2011/03/04/stack-overflow-architecture-update-now-at-95-million-page-vi</id>
   <content type="html">&lt;p&gt;原文链接：&lt;a href=&quot;http://highscalability.com/blog/2011/3/3/stack-overflow-architecture-update-now-at-95-million-page-vi.html&quot;&gt;Stack Overflow Architecture Update - Now At 95 Million Page
Views A
Month&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;编译/博客园&lt;/p&gt;

&lt;p&gt;Stack
Overflow网址：&lt;a href=&quot;http://stackoverflow.com/&quot;&gt;http://stackoverflow.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当前访问量：&lt;/strong&gt;每月9500PV（每天300多万PV）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当前Alexa排名：&lt;/strong&gt;149&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所用.NET技术：&lt;/strong&gt;C#、Visual Studio 2010 Team Suite、ASP.NET 4、ASP.NET
MVC 3、Razor、LINQ to SQL+raw SQL&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下面是英文原文：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A lot has happened since my first article on the &lt;a href=&quot;http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html&quot;&gt;Stack Overflow
Architecture&lt;/a&gt;(2009-8-5).
Contrary to the theme of that last article, which lavished attention on
Stack Overflow's dedication to a scale-up strategy, Stack Overflow has
both grown up and out in the last few years.&lt;/p&gt;

&lt;p&gt;自从2009年8月发布了第一篇关于“Stack Overflow 架构”方面的文章，Stack
Overflow已经发生了很大的变化。那篇文章更多关注的是Stack
Overflow如何解决网站的扩展性(scale-up)问题，而经过几年的发展，Stack
Overflow已经长大成人，成长为了大型网站。&lt;/p&gt;

&lt;p&gt;Stack Overflow has grown up by more then doubling in size to over 16
million users and multiplying its number of page views nearly 6 times to
95 million page views a month.  &lt;/p&gt;

&lt;p&gt;现在与2009年相比，Stack
Overflow每月独立访问用户翻了一倍，超过1600万；每月PV翻了近6倍，达到9500万。&lt;/p&gt;

&lt;p&gt;Stack Overflow has grown out by expanding into the &lt;a href=&quot;http://stackexchange.com/&quot;&gt;Stack Exchange
Network&lt;/a&gt;, which includes Stack Overflow,
Server Fault, and Super User for a grand total of 43 different sites.
That's a lot of fruitful multiplying going on.&lt;/p&gt;

&lt;p&gt;Stack Overflow新增了很多站点，比如Server Fault, Super
User等，共有43个不同站点组成了Stack Exchange
Network，可谓硕果累累，迅猛增长。&lt;/p&gt;

&lt;p&gt;What hasn't changed is Stack Overflow's openness about what they are
doing. And that's what prompted this update. A recent series of posts
talks a lot about how they've been handling their growth: &lt;a href=&quot;http://blog.serverfault.com/post/stack-exchanges-architecture-in-bullet-points/&quot;&gt;Stack
Exchange’s Architecture in Bullet
Points&lt;/a&gt;, &lt;a href=&quot;http://blog.serverfault.com/post/1432571770/&quot;&gt;Stack
Overflow’s New York Data
Center&lt;/a&gt;, &lt;a href=&quot;http://blog.serverfault.com/post/1097492931/&quot;&gt;Designing For
Scalability of Management and Fault
Tolerance&lt;/a&gt;, &lt;a href=&quot;http://blog.stackoverflow.com/2011/01/stack-overflow-search-now-81-less-crappy/&quot;&gt;Stack
Overflow Search — Now 81%
Less&lt;/a&gt;, &lt;a href=&quot;http://blog.stackoverflow.com/2010/01/stack-overflow-network-configuration/&quot;&gt;Stack
Overflow Network
Configuration&lt;/a&gt;, &lt;a href=&quot;http://meta.stackoverflow.com/questions/69164/does-stackoverflow-use-caching-and-if-so-how&quot;&gt;Does
StackOverflow use caching and if so,
how?&lt;/a&gt;, &lt;a href=&quot;http://meta.stackoverflow.com/questions/10369/which-tools-and-technologies-build-the-stack-exchange-network&quot;&gt;Which
tools and technologies build the Stack Exchange
Network?&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Stack
Overflow的变化翻天覆地，而不变的是他们开放的心态，所以才有了这篇架构分享的文章。最近，他们写了一系列文章分享他们如何应对这样的快速增长。&lt;/p&gt;

&lt;p&gt;Some of the more obvious differences across time are:&lt;br/&gt;
穿越时空，我们来看看有哪些明显的变化？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Just More&lt;/strong&gt;. More users, more page views, more datacenters, more
sites, more developers, more operating systems, more databases, more
machines. Just a lot &lt;a href=&quot;http://blog.stackoverflow.com/2011/01/state-of-the-stack-2010-a-message-from-your-ceo/&quot;&gt;more of
more&lt;/a&gt;.&lt;br/&gt;
&lt;strong&gt;更多：&lt;/strong&gt;更多的用户，更多的PV，更多的数据中心，更多的站点，更多的开发者，更多的操作系统，更多的数据库，更多的服务器...&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Linux&lt;/strong&gt;. Stack Overflow was known for their Windows stack, now
they are using a lot more Linux machines for HAProxy,
Redis, Bacula, Nagios, logs, and routers. All support functions seem
to be handled by Linux, which has required the development of
&lt;a href=&quot;http://blog.serverfault.com/post/1097492931/&quot;&gt;parallel release
processes&lt;/a&gt;. &lt;br/&gt;
&lt;strong&gt;Linux：&lt;/strong&gt;Stack
Overflow因使用Windows系统而著称，现在他们使用越来越多的Linux服务器，比如HAProxy(负载均衡),
Redis(NoSQL数据库), Bacula(数据备份系统), Nagios(远程监控软件),
日志,
路由器都运行于Linux系统，几乎所有需要并行处理的功能都是由Linux处理(这句话的翻译可能不准确)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fault Tolerance&lt;/strong&gt;. Stack Overflow is now &lt;a href=&quot;http://blog.stackoverflow.com/2010/01/stack-overflow-network-configuration/&quot;&gt;being served by two
different&lt;/a&gt;
switches on two different internet connections, they've added
redundant machines, and some functions have moved to a second
datacenter.&lt;br/&gt;
&lt;strong&gt;容错：&lt;/strong&gt;Stack
Overflow使用了两条不同的互联网线路，增加了更多的冗余服务器，将一些网站服务运行于第二个数据中心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NoSQL&lt;/strong&gt;. Redis is now used as a &lt;a href=&quot;http://meta.stackoverflow.com/questions/69164/does-stackoverflow-use-caching-and-if-so-how&quot;&gt;caching
layer&lt;/a&gt;
for the entire network. There wasn't a separate caching tier before
so this a big change, as is using a NoSQL database on Linux.&lt;br/&gt;
&lt;strong&gt;NoSQL：&lt;/strong&gt;Redis作为整个网站的缓存层。这是一个巨大的改变，以前并没有将缓存作为一个独立的层分离出来。Redis运行于Linux。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Unfortunately, I couldn't find any coverage on some of the open
questions I had last time, like how they were going to deal with
multi-tenancy across so many diffrent properties, but there's still
plenty to learn from. Here's a roll up a few different sources:&lt;/p&gt;

&lt;p&gt;遗憾的是，一些我关注的问题并没有从中找到答案，比如面对这么多不同的系统，如何解决多租户的问题（Multi-tenancy
是一种软件体系结构，在这种体系结构中软件运行在 software as a service
服务商的服务器上，服务于多个客户组织即
tenant）。但是，从中我们依然可以学到很多。下面是收集的一些数据列表：&lt;/p&gt;

&lt;h3&gt;The Stats&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;95 Million Page Views a Month&lt;/li&gt;
&lt;li&gt;800 HTTP requests a second&lt;/li&gt;
&lt;li&gt;180 DNS requests a second&lt;/li&gt;
&lt;li&gt;55 Megabits per second&lt;/li&gt;
&lt;li&gt;16 Million Users  - Traffic to Stack Overflow grew 131% in 2010, to
16.6 million global monthly uniques. &lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Data Centers&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1 Rack with Peak Internet in OR (Hosts our chat and Data Explorer)&lt;/li&gt;
&lt;li&gt;2 Racks with Peer 1 in NY (Hosts the rest of the Stack Exchange
Network)&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Hardware&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;10 Dell R610 IIS web servers (3 dedicated to Stack Overflow):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1x Intel Xeon Processor E5640 @ 2.66 GHz Quad Core with 8
threads&lt;/li&gt;
&lt;li&gt;16 GB RAM&lt;/li&gt;
&lt;li&gt;Windows Server 2008 R2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2 Dell R710 database servers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2x Intel Xeon Processor X5680 @ 3.33 GHz&lt;/li&gt;
&lt;li&gt;64 GB RAM&lt;/li&gt;
&lt;li&gt;8 spindles&lt;/li&gt;
&lt;li&gt;SQL Server 2008 R2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2 Dell R610 HAProxy servers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1x Intel Xeon Processor E5640 @ 2.66 GHz&lt;/li&gt;
&lt;li&gt;4 GB RAM&lt;/li&gt;
&lt;li&gt;Ubuntu Server&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2 Dell R610 Redis servers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2x Intel Xeon Processor E5640 @ 2.66 GHz&lt;/li&gt;
&lt;li&gt;16 GB RAM&lt;/li&gt;
&lt;li&gt;CentOS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1 Dell R610 Linux backup server running Bacula:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1x Intel Xeon Processor E5640 @ 2.66 GHz&lt;/li&gt;
&lt;li&gt;32 GB RAM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1 Dell R610 Linux management server for Nagios and logs:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1x Intel Xeon Processor E5640 @ 2.66 GHz&lt;/li&gt;
&lt;li&gt;32 GB RAM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2 Dell R610 VMWare ESXi domain controllers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1x Intel Xeon Processor E5640 @ 2.66 GHz&lt;/li&gt;
&lt;li&gt;16 GB RAM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2 Linux routers&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;5 Dell Power Connect switches&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Dev Tools&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C#&lt;/strong&gt;: Language&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Visual Studio 2010 Team Suite&lt;/strong&gt;: IDE&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Microsoft ASP.NET (version 4.0)&lt;/strong&gt;: Framework&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ASP.NET MVC 3&lt;/strong&gt;: Web Framework&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Razor&lt;/strong&gt;: View Engine&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;jQuery 1.4.2&lt;/strong&gt;: Browser Framework:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LINQ to SQL, some raw SQL&lt;/strong&gt;: Data Access Layer&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://mercurial.selenic.com/&quot;&gt;Mercurial&lt;/a&gt; and
&lt;a href=&quot;http://www.fogcreek.com/kiln/&quot;&gt;Kiln&lt;/a&gt;&lt;/strong&gt;: Source
Control（分布式版本控制系统）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.scootersoftware.com/&quot;&gt;&lt;strong&gt;Beyond Compare 3&lt;/strong&gt;&lt;/a&gt;: Compare
Tool（文件比较工具）&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Software and Technologies Used&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Stack Overflow uses a
&lt;a href=&quot;http://stackoverflow.com/questions/177901/what-does-wisc-stack-mean&quot;&gt;WISC&lt;/a&gt;
stack via
&lt;a href=&quot;http://blog.stackoverflow.com/2009/03/stack-overflow-and-bizspark/&quot;&gt;BizSpark&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Windows Server 2008 R2 x64&lt;/strong&gt;: Operating System&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SQL Server 2008 R2&lt;/strong&gt; running&lt;strong&gt;Microsoft Windows Server 2008
Enterprise Edition x64&lt;/strong&gt;: Database&lt;/li&gt;
&lt;li&gt;Ubuntu Server&lt;/li&gt;
&lt;li&gt;CentOS&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IIS 7.0&lt;/strong&gt;: Web Server&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://haproxy.1wt.eu/&quot;&gt;&lt;strong&gt;HAProxy&lt;/strong&gt;&lt;/a&gt;: for load
balancing（高性能的负载TCP/HTTP均衡器）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Redis&lt;/strong&gt;: used as the distributed caching
layer.（作为分布式缓存层的NoSQL数据库）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CruiseControl.NET&lt;/strong&gt;: for builds and automated
deployment（.NET平台的持续集成工具）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lucene.NET&lt;/strong&gt;:  for search&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.bacula.org/en/&quot;&gt;&lt;strong&gt;Bacula&lt;/strong&gt;&lt;/a&gt;: for
backups（开源的数据备份系统）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.nagios.org/&quot;&gt;&lt;strong&gt;Nagios&lt;/strong&gt;&lt;/a&gt;: (with
&lt;a href=&quot;http://n2rrd.diglinks.com/cgi-bin/trac.fcgi&quot;&gt;n2rrd&lt;/a&gt; and drraw
plugins) for monitoring（监视系统运行状态和网络信息的远程监控软件）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.splunk.com/&quot;&gt;Splunk&lt;/a&gt;:&lt;/strong&gt; for logs（日志分析工具）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.red-gate.com/products/dba/sql-monitor/&quot;&gt;SQL
Monitor&lt;/a&gt;:&lt;/strong&gt; from
Red Gate - for SQL Server monitoring&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bind&lt;/strong&gt;: for DNS&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wowwee.com/en/products/tech/telepresence/rovio/rovio&quot;&gt;Rovio&lt;/a&gt;&lt;/strong&gt;:  a
little robot (a real robot) allowing remote developers to visit the
office “virtually.”&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.pingdom.com/&quot;&gt;&lt;strong&gt;Pingdom&lt;/strong&gt;&lt;/a&gt;:  an external monitor and
alert service.（网站监控服务及网站速度测试工具）&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;External Bits&lt;/h3&gt;

&lt;p&gt;Code that is not included as part of the development tools:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.google.com/recaptcha&quot;&gt;reCAPTCHA&lt;/a&gt;（用于验证码验证，已被Google收购）&lt;/li&gt;
&lt;li&gt;DotNetOpenId（.NET 平台上的 OpenID 实现方案）&lt;/li&gt;
&lt;li&gt;WMD - Now developed as open source. See &lt;a href=&quot;https://github.com/cky/wmd&quot;&gt;github network
graph&lt;/a&gt; （轻量级所见即所得编辑器）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://code.google.com/p/google-code-prettify/&quot;&gt;Prettify&lt;/a&gt;（代码高亮显示）&lt;/li&gt;
&lt;li&gt;Google Analytics&lt;/li&gt;
&lt;li&gt;Cruise Control .NET&lt;/li&gt;
&lt;li&gt;HAProxy（负载均衡）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cacti.net/&quot;&gt;Cacti&lt;/a&gt;（网络流量监测图形分析工具）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://code.google.com/p/markdownsharp/&quot;&gt;MarkdownSharp&lt;/a&gt;（Markdown文本处理器的C#实现）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://code.google.com/p/flot/&quot;&gt;Flot&lt;/a&gt;（基于JQuery的纯JavaScript实现的绘图库）&lt;/li&gt;
&lt;li&gt;Nginx（反向代理服务器）&lt;/li&gt;
&lt;li&gt;Kiln（分布式版本控制系统）&lt;/li&gt;
&lt;li&gt;CDN: none, all static content is served off the
&lt;a href=&quot;http://sstatic.net/&quot;&gt;sstatic.net&lt;/a&gt;, which is a fast, cookieless
domain intended for static content delivered to the Stack Exchange
family of websites.
（没有使用CDN，用一个专门的域名sstatic.net传递所有的静态内容）&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Developers and System Administrators&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;14 Developers&lt;/li&gt;
&lt;li&gt;2 System Administrators&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Content&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;License:&lt;/strong&gt; Creative Commons Attribution-Share Alike 2.5 Generic&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Standards:&lt;/strong&gt; OpenSearch, Atom&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Host:&lt;/strong&gt; PEAK Internet&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;More Architecture and Lessons Learned&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;HAProxy is used instead of Windows NLB because HAProxy is cheap,
easy, free, works great as a 512MB VM “device” on a network via
Hyper-V. It also works in front of the boxes so it’s completely
transparent to them, and easier to troubleshoot as a different
networking layer instead of being intermixed with all your windows
configuration.&lt;br/&gt;
用HAProxy取代了Windows
NLB，HAProxy成本更低，更易于使用，通过Hyper-V可以很好地运行于512M内存的虚拟机。它工作于服务器群的最前端，对所有的服务器都透明。相比于原来混杂在一起的Windows配置，它运行于一个独立的网络层，更易于维护与故障处理。&lt;/li&gt;
&lt;li&gt;A CDN is not used because even “cheap” CDNs like Amazon one are very
expensive relative to the bandwidth they get bundled into their
existing host’s plan. The least they could pay is $1k/month based
on Amazon’s CDN rates and their bandwidth usage.&lt;br/&gt;
没有使用CDN，即使使用像Amazon那样与主机空间捆绑在一起的看起来“便宜”的CDN，实际的费用也是很高的，至少需要1000美元/月。&lt;/li&gt;
&lt;li&gt;Backup is to disk for fast retrieval and to tape for historical
archiving.&lt;br/&gt;
备份方案有两种，一种用于快速恢复的磁盘备份，一种用于历史数据存档的磁带备份。&lt;/li&gt;
&lt;li&gt;Full Text Search in SQL Server is very badly integrated, buggy,
deeply incompetent, so they went to Lucene.&lt;br/&gt;
SQL Server的全文索引是非常差劲的，所以他们用Lucene.NET。&lt;/li&gt;
&lt;li&gt;Mostly interested in peak HTTP request figures as this is what they
need to make sure they can handle.&lt;br/&gt;
让人很感兴趣的是他们如何处理访问高峰时的HTTP请求。&lt;/li&gt;
&lt;li&gt;All properties now run on the same Stack Exchange platform. That
means Stack Overflow, Super User, Server Fault, Meta, WebApps, and
Meta Web Apps are all running on the same software.&lt;br/&gt;
所有这些都运行于Stack Exchange平台，那意味着Stack Overflow, Super
User, Server Fault, Meta, WebApps, 和Meta Web
Apps都运行于同一个软件。&lt;/li&gt;
&lt;li&gt;There are separate StackExchange sites because people have different
sets of expertise that shouldn't cross over to different topic
sites. &lt;a href=&quot;http://meta.stackoverflow.com/questions/69422/why-separate-stack-exchange-accounts&quot;&gt;You can be the greatest chef in the world, but that doesn't
qualify you for fixing a
server.&lt;/a&gt;&lt;br/&gt;
也有一些独立运行的StackExchange站点，服务于那些具有多个专业技能，又不想为了不同的话题在多个站点之间奔波的人。如果你能成为最伟大的主厨，不能因为给你安排了服务员的工作，你就安于现状。&lt;/li&gt;
&lt;li&gt;They aggressively cache everything.&lt;br/&gt;
他们疯狂地使用缓存。&lt;/li&gt;
&lt;li&gt;All pages accessed by (and subsequently served to) annonymous users
are cached via &lt;a href=&quot;http://learn.iis.net/page.aspx/154/walkthrough-iis-70-output-caching/&quot;&gt;Output
Caching&lt;/a&gt;.&lt;br/&gt;
未登录用户访问的所有页面都通过Output Caching进行缓存。&lt;/li&gt;
&lt;li&gt;Each site has 3 distinct caches: local, site, global. &lt;br/&gt;
每个站点使用三种类型的缓存：本地、站点、全局。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;local cache&lt;/strong&gt;: can only be accessed from 1 server/site pair   
本地缓存：只能被当前站点的当前服务器访问。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;To limit network latency they use a local &quot;L1&quot; cache, basically
HttpRuntime.Cache, of recently set/read values on a server. This
would reduce the cache lookup overhead to 0 bytes on the
network.&lt;br/&gt;
为了减少网络延时，通常使用HttpRuntime.Cache作为一级缓存，这样可以避免通过网络在缓存服务器上查找的开销。&lt;/li&gt;
&lt;li&gt;Contains things like user sessions, and pending view count
updates.&lt;br/&gt;
缓存内容包含用户会话，视图数的更新。&lt;/li&gt;
&lt;li&gt;This resides purely in memory, no network or DB access.&lt;br/&gt;
直接缓存在内存中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;site cache&lt;/strong&gt;:  can be accessed by any instance (on any server) of
a single site&lt;br/&gt;
&lt;strong&gt;站点级缓存：&lt;/strong&gt;能被同一个站点的所有服务器访问。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Most cached values go here, things like hot question id lists
and user acceptance rates are good examples&lt;br/&gt;
大部分的缓存都在这一级，比如热点问题ID列表，用户支持率。&lt;/li&gt;
&lt;li&gt;This resides in Redis (in a distinct DB, purely for easier
debugging)&lt;br/&gt;
缓存数据存储在Redis数据库中。&lt;/li&gt;
&lt;li&gt;Redis is so fast that the slowest part of a cache lookup is the
time spent reading and writing bytes to the network.&lt;br/&gt;
Redis速度很快，缓存查找的开销主要在网络传输上。&lt;/li&gt;
&lt;li&gt;Values are compressed before sending them to Redis. They have
plenty of CPU and most of their data are strings so they get a
great compression ratio.&lt;br/&gt;
缓存数据发送至Redis之前会被压缩。为什么要压缩呢？因为CPU资源绰绰有余，而且大部分缓存数据是字符串，压缩率会很高，何乐而不为呢。&lt;/li&gt;
&lt;li&gt;The CPU usage on their Redis machines is 0%.&lt;br/&gt;
Redis服务器上的CPU使用率是0%。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;global cache&lt;/strong&gt;: which is shared amongst all sites and servers
&lt;strong&gt;全局缓存：&lt;/strong&gt;被所有站点和服务器共享。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inboxes, API usage quotas, and a few other truly global things
live here&lt;br/&gt;
缓存内容包含收件箱，API使用限额，一些全局设置等。&lt;/li&gt;
&lt;li&gt;This resides in Redis (in DB 0, likewise for easier debugging)&lt;br/&gt;
缓存于Redis数据库中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Most items in the cache expire after a timeout period (a few minutes
usually) and are never explicitly removed. When a specific cache
invalidation is required they use &lt;a href=&quot;http://code.google.com/p/redis/wiki/PublishSubscribe&quot;&gt;Redis
messaging&lt;/a&gt; to
publish removal notices to the &quot;L1&quot; caches.&lt;br/&gt;
大部分缓存项目在超过缓存时间之后会自动过期（通常几分钟），不需要进行删除操作。当需要让一个特定的缓存失效，会通过Redis消息系统给一级缓存发送删除通知。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Joel Spolsky is not a Microsoft Loyalist, he doesn't make the
technical decisions for Stack Overflow, and considers Microsoft
licensing a rounding error. Consider yourself corrected &lt;a href=&quot;http://news.ycombinator.com/item?id=2284900&quot;&gt;Hacker News
commentor&lt;/a&gt;.&lt;br/&gt;
Joel Spolsky（Stack
Overflow的创始人）并不是微软的忠诚分子，他不负责技术决策，使用微软软件考虑的也只是性价比。Hacker
News上一些评论者的说法需要纠正。&lt;/li&gt;
&lt;li&gt;For their IO system &lt;a href=&quot;http://blog.serverfault.com/post/our-storage-decision/&quot;&gt;they
selected&lt;/a&gt; a
RAID 10 array of &lt;a href=&quot;http://www.intel.com/design/flash/nand/extreme/index.htm&quot;&gt;Intel X25 solid state
drives&lt;/a&gt; .
The RAID array eased any concerns about reliability and the SSD
drives performed really well in comparision to FusionIO at a much
cheaper price.&lt;br/&gt;
对于IO系统，他们选择的是Intel X25 solid state drives(SSD硬盘)的RAID
10磁盘阵列，这样的磁盘阵列，保证了可靠性。这个SSD硬盘用起来感觉不错，而且价格比FusionIO的便宜。&lt;/li&gt;
&lt;li&gt;The &lt;a href=&quot;http://news.ycombinator.com/item?id=2285931&quot;&gt;full boat cost&lt;/a&gt;
for their Microsoft licenses would be approximately $242K. Since
Stack Overflow is using Bizspark they are not paying near the full
sticker price, but that's the max they could pay.&lt;br/&gt;
使用的这些微软软件，如果全部购买的话，总费用大概在24.2万美元。由于Stack
Overflow参加了微软的Bizspark计划，所以不需要付这么多钱，但是要付的话，最多也就是这么多。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Related Articles&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.serverfault.com/post/stack-exchanges-architecture-in-bullet-points/&quot;&gt;Stack Exchange’s Architecture in Bullet
Points&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.serverfault.com/post/1432571770/&quot;&gt;Stack Overflow’s New York Data
Center&lt;/a&gt; - hardware of
the various machines?&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.serverfault.com/post/1097492931/&quot;&gt;Designing For Scalability of Management and Fault
Tolerance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://news.ycombinator.com/item?id=2207789&quot;&gt;HackerNews Thread&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.stackoverflow.com/&quot;&gt;Stack Overflow Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.stackoverflow.com/2011/01/stack-overflow-search-now-81-less-crappy/&quot;&gt;Stack Overflow Search — Now 81% Less
Crappy&lt;/a&gt; -
Lucene is now running on an underused cluster.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.stackoverflow.com/2011/01/state-of-the-stack-2010-a-message-from-your-ceo/&quot;&gt;State of the Stack 2010 (a message from your
CEO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.stackoverflow.com/2010/01/stack-overflow-network-configuration/&quot;&gt;Stack Overflow Network
Configuration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://meta.stackoverflow.com/questions/69164/does-stackoverflow-use-caching-and-if-so-how&quot;&gt;Does StackOverflow use caching and if so,
how?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://meta.stackoverflow.com/&quot;&gt;Meta StackOverflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://meta.stackoverflow.com/questions/6435/how-does-stackoverflow-handle-cache-invalidation&quot;&gt;How does StackOverflow handle cache
invalidation?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://meta.stackoverflow.com/questions/10369/which-tools-and-technologies-build-the-stack-exchange-network&quot;&gt;Which tools and technologies build the Stack Exchange
Network?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://meta.stackoverflow.com/questions/2765/how-does-stack-overflow-handle-spam&quot;&gt;How does Stack Overflow handle
spam?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.serverfault.com/post/our-storage-decision/&quot;&gt;Our Storage
Decision&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://meta.stackoverflow.com/questions/4766/how-are-hot-questions-selected&quot;&gt;How are “Hot” Questions
Selected?&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://meta.stackoverflow.com/questions/20473/how-are-related-questions-selected&quot;&gt;How are “related” questions
selected?&lt;/a&gt; -
the title, the question body, and the tags. &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.stackoverflow.com/2010/04/stack-overflow-and-dvcs/&quot;&gt;Stack Overflow and
DVCS&lt;/a&gt; -
Stack Overflow selects Mercurial for source code control.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://chat.stackexchange.com/rooms/127/the-comms-room&quot;&gt;Server Fault Chat
Room&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ServiceStack/ServiceStack.Redis&quot;&gt;C# Redis
Client&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>当你输入一个网址的时候，实际会发生什么?</title>
   <link href="http://beango.github.com/archives/2011/02/25/what-really-happens-when-you-navigate-to-a-url.html"/>
   <updated>2011-02-25T00:00:00+08:00</updated>
   <id>http://beango.github.com/archives/2011/02/25/what-really-happens-when-you-navigate-to-a-url</id>
   <content type="html">&lt;p&gt;原文:http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/ &lt;/p&gt;

&lt;p&gt;作为一个软件开发者，你一定会对网络应用如何工作有一个完整的层次化的认知，同样这里也包括这些应用所用到的技术：像浏览器，HTTP，HTML，网络服务器，需求处理等等。&lt;/p&gt;

&lt;p&gt;本文将更深入的研究当你输入一个网址的时候，后台到底发生了一件件什么样的事～&lt;/p&gt;

&lt;h3&gt;1. 首先嘛，你得在浏览器里输入要网址:&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2011-02/image4.png&quot; title=&quot;当你输入一个网址的时候，实际会发生什么?&quot; alt=&quot;当你输入一个网址的时候，实际会发生什么?&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;2. 浏览器查找域名的IP地址&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2011-02/image13.png&quot; title=&quot;当你输入一个网址的时候，实际会发生什么?&quot; alt=&quot;当你输入一个网址的时候，实际会发生什么?&quot; /&gt;&lt;/p&gt;

&lt;p&gt;导航的第一步是通过访问的域名找出其IP地址。DNS查找过程如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;浏览器缓存 –&lt;/strong&gt;浏览器会缓存DNS记录一段时间。
有趣的是，操作系统没有告诉浏览器储存DNS记录的时间，这样不同浏览器会储存个自固定的一个时间（2分钟到30分钟不等）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统缓存&lt;/strong&gt; –
如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用（windows里是gethostbyname）。这样便可获得系统缓存中的记录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路由器缓存&lt;/strong&gt; –
接着，前面的查询请求发向路由器，它一般会有自己的DNS缓存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ISP DNS 缓存&lt;/strong&gt; –
接下来要check的就是ISP缓存DNS的服务器。在这一般都能找到相应的缓存记录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;递归搜索&lt;/strong&gt; –
你的ISP的DNS服务器从跟域名服务器开始进行递归搜索，从.com顶级域名服务器到Facebook的域名服务器。一般DNS服务器的缓存中会有.com域名服务器中的域名，所以到顶级服务器的匹配过程不是那么必要了。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;DNS递归查找如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2011-02/500pxAn_example_of_theoretical_DNS_recursion_svg.png&quot; title=&quot;500px-An_example_of_theoretical_DNS_recursion_svg&quot; alt=&quot;500px-An_example_of_theoretical_DNS_recursion_svg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DNS有一点令人担忧，这就是像wikipedia.org 或者facebook.com这样的整个域名看上去只是对应一个单独的IP地址。还好，有几种方法可以消除这个瓶颈：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baike.baidu.com/view/1527368.html&quot;&gt;&lt;strong&gt;循环 DNS&lt;/strong&gt;&lt;/a&gt;
是DNS查找时返回多个IP时的解决方案。举例来说，Facebook.com实际上就对应了四个IP地址。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baike.baidu.com/view/486970.htm&quot;&gt;&lt;strong&gt;负载平衡器&lt;/strong&gt;&lt;/a&gt;
是以一个特定IP地址进行侦听并将网络请求转发到集群服务器上的硬件设备。
一些大型的站点一般都会使用这种昂贵的高性能负载平衡器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;地理
DNS&lt;/strong&gt;根据用户所处的地理位置，通过把域名映射到多个不同的IP地址提高可扩展性。这样不同的服务器不能够更新同步状态，但映射静态内容的话非常好。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baike.baidu.com/view/1398775.htm&quot;&gt;&lt;strong&gt;Anycast&lt;/strong&gt;&lt;/a&gt;是一个IP地址映射多个物理主机的路由技术。
美中不足，Anycast与TCP协议适应的不是很好，所以很少应用在那些方案中。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;大多数DNS服务器使用Anycast来获得高效低延迟的DNS查找。&lt;/p&gt;

&lt;h3&gt;3. 浏览器给web服务器发送一个HTTP请求&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2011-02/image22.png&quot; title=&quot;当你输入一个网址的时候，实际会发生什么?&quot; alt=&quot;当你输入一个网址的时候，实际会发生什么?&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为像Facebook主页这样的动态页面，打开后在浏览器缓存中很快甚至马上就会过期，毫无疑问他们不能从中读取。&lt;/p&gt;

&lt;p&gt;所以，浏览器将把一下请求发送到Facebook所在的服务器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET http://facebook.com/ HTTP/1.1 Accept: application/x-ms-application, image/jpeg, application/xaml+xml, [...] User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; [...] Accept-Encoding: gzip, deflate Connection: Keep-Alive Host: facebook.com Cookie: datr=1265876274-[...]; locale=en_US; lsd=WW[...]; c_user=2101[...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GET 这个请求定义了要读取的&lt;strong&gt;URL&lt;/strong&gt;： “http://facebook.com/”。浏览器自身定义 (&lt;strong&gt;User-Agent&lt;/strong&gt; 头)， 和它希望接受什么类型的相应(&lt;strong&gt;Accept&lt;/strong&gt; and &lt;strong&gt;Accept-Encoding&lt;/strong&gt; 头).&lt;strong&gt;Connection&lt;/strong&gt;头要求服务器为了后边的请求不要关闭TCP连接。&lt;/p&gt;

&lt;p&gt;请求中也包含浏览器存储的该域名的&lt;strong&gt;cookies&lt;/strong&gt;。可能你已经知道，在不同页面请求当中，cookies是与跟踪一个网站状态相匹配的键值。这样cookies会存储登录用户名，服务器分配的密码和一些用户设置等。Cookies会以文本文档形式存储在客户机里，每次请求时发送给服务器。&lt;/p&gt;

&lt;p&gt;用来看原始HTTP请求及其相应的工具很多。作者比较喜欢使用fiddler，当然也有像FireBug这样其他的工具。这些软件在网站优化时会帮上很大忙。&lt;/p&gt;

&lt;p&gt;除了获取请求，还有一种是发送请求，它常在提交表单用到。发送请求通过URL传递其参数(e.g.:http://robozzle.com/puzzle.aspx?id=85)。发送请求在请求正文头之后发送其参数。&lt;/p&gt;

&lt;p&gt;像“http://facebook.com/”中的斜杠是至关重要的。这种情况下，浏览器能安全的添加斜杠。而像“http://example.com/folderOrFile”这样的地址，因为浏览器不清楚folderOrFile到底是文件夹还是文件，所以不能自动添加斜杠。这时，浏览器就不加斜杠直接访问地址，服务器会响应一个重定向，结果造成一次不必要的握手。&lt;/p&gt;

&lt;h3&gt;4. facebook服务的永久重定向响应&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2011-02/image8.png&quot; title=&quot;当你输入一个网址的时候，实际会发生什么?&quot; alt=&quot;当你输入一个网址的时候，实际会发生什么?&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中所示为Facebook服务器发回给浏览器的响应：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 301 Moved Permanently Cache-Control: private, no-store, no-cache, must-revalidate, post-check=0, pre-check=0 Expires: Sat, 01 Jan 2000 00:00:00 GMT Location: http://www.facebook.com/ P3P: CP=&quot;DSP LAW&quot; Pragma: no-cache Set-Cookie: made_write_conn=deleted; expires=Thu, 12-Feb-2009 05:09:50 GMT; path=/; domain=.facebook.com; httponly Content-Type: text/html; charset=utf-8 X-Cnection: close Date: Fri, 12 Feb 2010 05:09:51 GMT Content-Length: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问“http://www.facebook.com/”而非“http://facebook.com/”。&lt;/p&gt;

&lt;p&gt;为什么服务器一定要重定向而不是直接发会用户想看的网页内容呢？这个问题有好多有意思的答案。&lt;/p&gt;

&lt;p&gt;其中一个原因跟&lt;strong&gt;搜索引擎排名&lt;/strong&gt;有关。你看，如果一个页面有两个地址，就像http://www.igoro.com/和http://igoro.com/，搜索引擎会认为它们是两个网站，结果造成每一个的搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。&lt;/p&gt;

&lt;p&gt;还有一个是用不同的地址会造成&lt;strong&gt;缓存友好性&lt;/strong&gt;变差。当一个页面有好几个名字时，它可能会在缓存里出现好几次。&lt;/p&gt;

&lt;h3&gt;5. 浏览器跟踪重定向地址&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2011-02/image23.png&quot; title=&quot;当你输入一个网址的时候，实际会发生什么?&quot; alt=&quot;当你输入一个网址的时候，实际会发生什么?&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，浏览器知道了“http://www.facebook.com/”才是要访问的正确地址，所以它会发送另一个获取请求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET http://www.facebook.com/ HTTP/1.1 Accept: application/x-ms-application, image/jpeg, application/xaml+xml, [...] Accept-Language: en-US User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; [...] Accept-Encoding: gzip, deflate Connection: Keep-Alive Cookie: lsd=XW[...]; c_user=21[...]; x-referer=[...] Host: www.facebook.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;头信息以之前请求中的意义相同。&lt;/p&gt;

&lt;h3&gt;6. 服务器“处理”请求&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2011-02/image9.png&quot; title=&quot;当你输入一个网址的时候，实际会发生什么?&quot; alt=&quot;当你输入一个网址的时候，实际会发生什么?&quot; /&gt;&lt;/p&gt;

&lt;p&gt;服务器接收到获取请求，然后处理并返回一个响应。&lt;/p&gt;

&lt;p&gt;这表面上看起来是一个顺向的任务，但其实这中间发生了很多有意思的东西-就像作者博客这样简单的网站，何况像facebook那样访问量大的网站呢！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Web 服务器软件
&lt;/strong&gt;web服务器软件（像IIS和阿帕奇）接收到HTTP请求，然后确定执行什么请求处理来处理它。请求处理就是一个能够读懂请求并且能生成HTML来进行响应的程序（像ASP.NET,PHP,RUBY...）。&lt;/p&gt;

&lt;p&gt;举个最简单的例子，需求处理可以以映射网站地址结构的文件层次存储。像http://example.com/folder1/page1.aspx这个地址会映射httpdocs/folder1/page1.aspx这个文件。web服务器软件可以设置成为地址人工的对应请求处理，这样page1.aspx的发布地址就可以是http://example.com/folder1/page1。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;请求处理
&lt;/strong&gt;请求处理阅读请求及它的参数和cookies。它会读取也可能更新一些数据，并讲数据存储在服务器上。然后，需求处理会生成一个HTML响应。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;所 有动态网站都面临一个有意思的难点
-如何存储数据。小网站一半都会有一个SQL数据库来存储数据，存储大量数据和/或访问量大的网站不得不找一些办法把数据库分配到多台机器上。解决方案
有：sharding
（基于主键值讲数据表分散到多个数据库中），复制，利用弱语义一致性的简化数据库。&lt;/p&gt;

&lt;p&gt;委托工作给批处理是一个廉价保持数据更新的技术。举例来讲，Fackbook得及时更新新闻feed，但数据支持下的“你可能认识的人”功能只需要每晚更新（作者猜测是这样的，改功能如何完善不得而知）。批处理作业更新会导致一些不太重要的数据陈旧，但能使数据更新耕作更快更简洁。&lt;/p&gt;

&lt;h3&gt;7. 服务器发回一个HTML响应&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2011-02/image10.png&quot; title=&quot;当你输入一个网址的时候，实际会发生什么?&quot; alt=&quot;当你输入一个网址的时候，实际会发生什么?&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中为服务器生成并返回的响应：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK Cache-Control: private, no-store, no-cache, must-revalidate, post-check=0, pre-check=0 Expires: Sat, 01 Jan 2000 00:00:00 GMT P3P: CP=&quot;DSP LAW&quot; Pragma: no-cache Content-Encoding: gzip Content-Type: text/html; charset=utf-8 X-Cnection: close Transfer-Encoding: chunked Date: Fri, 12 Feb 2010 09:05:55 GMT  2b3Tn@[...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个响应大小为35kB，其中大部分在整理后以blob类型传输。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内容编码&lt;/strong&gt;头告诉浏览器整个响应体用gzip算法进行压缩。解压blob块后，你可以看到如下期望的HTML：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;     &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&amp;gt; &amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot; id=&quot;facebook&quot; class=&quot; no_js&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&amp;gt; &amp;lt;meta http-equiv=&quot;Content-language&quot; content=&quot;en&quot; /&amp;gt; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于压缩，头信息说明了是否缓存这个页面，如果缓存的话如何去做，有什么cookies要去设置（前面这个响应里没有这点）和隐私信息等等。&lt;/p&gt;

&lt;p&gt;请注意报头中把&lt;strong&gt;Content-type&lt;/strong&gt;设置为“&lt;strong&gt;text/html&lt;/strong&gt;”。报头让浏览器将该响应内容以HTML形式呈现，而不是以文件形式下载它。浏览器会根据报头信息决定如何解释该响应，不过同时也会考虑像URL扩展内容等其他因素。&lt;/p&gt;

&lt;h3&gt;8. 浏览器开始显示HTML&lt;/h3&gt;

&lt;p&gt;在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2011-02/image6.png&quot; title=&quot;当你输入一个网址的时候，实际会发生什么?&quot; alt=&quot;当你输入一个网址的时候，实际会发生什么?&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;9. 浏览器发送获取嵌入在HTML中的对象&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2011-02/image11.png&quot; title=&quot;当你输入一个网址的时候，实际会发生什么?&quot; alt=&quot;当你输入一个网址的时候，实际会发生什么?&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。&lt;/p&gt;

&lt;p&gt;下面是几个我们访问facebook.com时需要重获取的几个URL：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;图片&lt;br/&gt;
&lt;/strong&gt;http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif&lt;br/&gt;
  http://static.ak.fbcdn.net/rsrc.php/zBS5C/hash/7hwy7at6.gif&lt;br/&gt;
 …&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CSS 式样表&lt;br/&gt;
&lt;/strong&gt;http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css&lt;br/&gt;
  http://static.ak.fbcdn.net/rsrc.php/zANE1/hash/cvtutcee.css&lt;br/&gt;
 …&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JavaScript 文件&lt;/strong&gt;&lt;br/&gt;
 http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js&lt;br/&gt;
 http://static.ak.fbcdn.net/rsrc.php/z6R9L/hash/cq2lgbs8.js&lt;br/&gt;
 …&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等...&lt;/p&gt;

&lt;p&gt;但不像动态页面那样，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取。服务器的响应中包含了静态文件保存的期限
信息，所以浏览器知道要把它们缓存多长时间。还有，每个响应都可能包含像版本号一样工作的ETag头（被请求变量的实体值），如果浏览器观察到文件的版本
ETag信息已经存在，就马上停止这个文件的传输。&lt;/p&gt;

&lt;p&gt;试着猜猜看“&lt;strong&gt;fbcdn.net&lt;/strong&gt;”在地址中代表什么？聪明的答案是&quot;Facebook内容分发网络&quot;。Facebook利用内容分发网络（CDN）分发像图片，CSS表和JavaScript文件这些静态文件。所以，这些文件会在全球很多CDN的数据中心中留下备份。&lt;/p&gt;

&lt;p&gt;静态内容往往代表站点的带宽大小，也能通过CDN轻松的复制。通常网站会使用第三方的CDN。例如，Facebook的静态文件由最大的CDN提供商Akamai来托管。&lt;/p&gt;

&lt;p&gt;举例来讲，当你试着ping static.ak.fbcdn.net的时候，可能会从某个akamai.net服务器上获得响应。有意思的是，当你同样再ping一次的时候，响应的服务器可能就不一样，这说明幕后的负载平衡开始起作用了。&lt;/p&gt;

&lt;h3&gt;10. 浏览器发送异步（AJAX）请求&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/files/2011-02/image12.png&quot; title=&quot;当你输入一个网址的时候，实际会发生什么?&quot; alt=&quot;当你输入一个网址的时候，实际会发生什么?&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在Web 2.0伟大精神的指引下，页面显示完成后客户端仍与服务器端保持着联系。&lt;/p&gt;

&lt;p&gt;以Facebook聊天功能为例，它会持续与服务器保持联系来及时更新你那些亮亮灰灰的好友状态。为了更新这些头像亮着的好友状态，在浏览器中执行的JavaScript代码会给服务器发送异步请求。这个异步请求发送给特定的地址，它是一个按照程式构造的获取或发送请求。还是在Facebook这个例子中，客户端发送给http://www.facebook.com/ajax/chat/buddy_list.php一个发布请求来获取你好友里哪个
在线的状态信息。&lt;/p&gt;

&lt;p&gt;提起这个模式，就必须要讲讲&quot;AJAX&quot;-- “异步JavaScript 和 XML”，虽然服务器为什么用XML格式来进行响应也没有个一清二白的原因。再举个例子吧，对于异步请求，Facebook会返回一些JavaScript的代码片段。&lt;/p&gt;

&lt;p&gt;除了其他，fiddler这个工具能够让你看到浏览器发送的异步请求。事实上，你不仅可以被动的做为这些请求的看客，还能主动出击修改和重新发送它们。AJAX请求这么容易被蒙，可着实让那些计分的在线游戏开发者们郁闷的了。（当然，可别那样骗人家~）&lt;/p&gt;

&lt;p&gt;Facebook聊天功能提供了关于AJAX一个有意思的问题案例：把数据从服务器端推送到客户端。因为HTTP是一个请求-响应协议，所以聊天服务器不能把新消息发给客户。取而代之的是客户端不得不隔几秒就轮询下服务器端看自己有没有新消息。&lt;/p&gt;

&lt;p&gt;这些情况发生时长轮询是个减轻服务器负载挺有趣的技术。如果当被轮询时服务器没有新消息，它就不理这个客户端。而当尚未超时的情况下收到了该客户的新消息，服务器就会找到未完成的请求，把新消息做为响应返回给客户端。&lt;/p&gt;

&lt;h3&gt;总结一下&lt;/h3&gt;

&lt;p&gt;希望看了本文，你能明白不同的网络模块是如何协同工作的&lt;/p&gt;
</content>
 </entry>
 
 
</feed>